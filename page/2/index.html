<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="imily&#39;s notes">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="imily&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="imily&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> imily's notes </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">imily's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/【学习笔记】LCT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/27/【学习笔记】LCT/" itemprop="url">
                  【学习笔记】LCT
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-27T17:47:40+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前学的。以 备 重 修 qwq</p>
<p>把树剖成许多链，每条链用 $splay$ 维护，中序遍历深度递增。</p>
<h3 id="access-x"><a href="#access-x" class="headerlink" title="$access(x)$"></a>$access(x)$</h3><ul>
<li><p>打通 $x$ 到根的通路。过程是先把 $x$ 转到 $x$ 所在 $splay$ 的根，然后让 $x$ 带着 $x$ 的左子树并到 $fa[x]$ 所在 $splay$ 中充作 $fa[x]$ 右儿子</p>
</li>
<li><p>这个过程 $x$ 和 $fa[x]$ 都和它们原本的右儿子断开了，但右儿子依然保留“父亲是谁”的信息）</p>
</li>
</ul>
<h3 id="makeroot-x"><a href="#makeroot-x" class="headerlink" title="$makeroot(x)$"></a>$makeroot(x)$</h3><ul>
<li>先 $access$，此时 $x$ 成了和根在同一 $splay$ 中深度最大、中序遍历最末的点</li>
<li>再 $splay$，此时 $x$ 成了所在 $splay$ 的根，但仍是深度最大。为了让 $x$ 成为根、变得深度最小，我们翻转 $x$ 的左右子树。<strong>注意：此操作不影响其他 $splay$ 的深度顺序。</strong></li>
</ul>
<h3 id="findroot-x"><a href="#findroot-x" class="headerlink" title="$findroot(x)$"></a>$findroot(x)$</h3><ul>
<li>不断跳左儿子</li>
<li><h2 id="珍爱生命，远离-findroot-。。。-cut-里判能否-cut-的部分还是这样吧："><a href="#珍爱生命，远离-findroot-。。。-cut-里判能否-cut-的部分还是这样吧：" class="headerlink" title="珍爱生命，远离 $findroot$。。。$cut()$ 里判能否 $cut$ 的部分还是这样吧："></a>珍爱生命，远离 $findroot$。。。$cut()$ 里判能否 $cut$ 的部分还是这样吧：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch[y][<span class="number">0</span>] == x &amp;&amp; !ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">    cut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。"><a href="#LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。" class="headerlink" title="$LCT$ 好像没法同时保证两个节点的子树信息都是对的。。无奈。。"></a>$LCT$ 好像没法同时保证两个节点的子树信息都是对的。。无奈。。</h2><p>（模拟赛大爆炸</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/【学习笔记】最长反链和它全家（详细揭秘）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/27/【学习笔记】最长反链和它全家（详细揭秘）/" itemprop="url">
                  【学习笔记】最长反链和它全家（详细揭秘）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-27T17:47:40+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同志，扫盲了！</span><br></pre></td></tr></table></figure>
<ul>
<li><p>链：偏序关系中，链是形如 $a \leq b$ 的许多关系；$DAG$ 上，链是一个点集，其中任意两个点 $x$, $y$ 都能从 $x$ 到 $y$ 或从 $y$ 到 $x$。</p>
</li>
<li><p>反链：反链也是点集，不过其中任意两个点都不能走到彼此。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最长反链 = 最小链覆盖（Dilworth 定理：最长反链 = 最小链精确（即不可重）覆盖，通过传递闭包可以转为最小链可重覆盖，然而实现时都用网络流）</span><br><span class="line">最长链 = 最小反链覆盖</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最大匹配：$DAG$ 的最大匹配概念同二分图的。</p>
</li>
<li><p>最小链覆盖：也叫最小路径覆盖，作用如其名，分为可重和不可重。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小链覆盖 = 顶点数 - 最大匹配（刚开始没有匹配，显然成立；接下来每匹配一对点，匹配数 +1，路径数 -1。匹配数 = 每条路径点数边数和。）</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最小不可重链覆盖：拆点，用匈牙利算法或者网络流求解，连 $(x_{out}, y_{in})$</p>
</li>
<li><p>最小可重链覆盖：先传递闭包，再在形成的偏序集上做最小不可重链覆盖，跳过的点被当作重复经过，然而实现时一般用网络流建 $(x’, x, \infty)$ 这样的反边表示某些点被当作中间点做了传递闭包。</p>
</li>
<li><p>最大独立集：选出最多的点，其中两两无边相连。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大团 = 补图最大独立集</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最小点覆盖：选择最少的点覆盖所有边。</p>
</li>
<li><p>最小边覆盖：选择最少的边覆盖所有点。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大匹配 = 最小点覆盖</span><br><span class="line">    每条边一定连着一个匹配点，否则连两个未匹配点匹配数应该 +1。</span><br><span class="line">二分图 最大独立集 = 顶点数 - 最小点覆盖</span><br><span class="line">    把最小点覆盖剔除，剩下的点就没有边相连了。</span><br><span class="line">二分图 最小边覆盖 = 顶点数 - 最大匹配</span><br><span class="line">    显然。同时也告诉我们最小边覆盖就是在最大匹配的基础上加边，变成完美匹配。</span><br><span class="line">二分图 最小割 = 最小点权覆盖集 = 点权和 - 最大点权独立集</span><br></pre></td></tr></table></figure>
<p>感觉类似题目（不 sb 的那种）都是用👆上面这套理论搞来搞去，比如 <a href="https://www.luogu.com.cn/problem/P4298" target="_blank" rel="noopener">$CTSC2008-祭祀$</a>：难点在构造方案。</p>
<p>第二问好想，每个点删除后做一遍最长反链看是否只减小了 $1$。</p>
<p>第一问，先说结论：选出新图所有 $x_{out}$ 和 $x_{in}$ 都在最大独立集里的点，就是原图最长反链。</p>
<p>证明：<br>有最大独立集合 $I$ = 顶点数 $2n$ - 最大匹配 $m$，设最长反链集合为 $A$，$I - A$ 为「$x_{out}$ 或 $x_{in}$ 在最大独立集里」的点集，$|I| - |A| \leq n$, $|A| \geq |I| - n = n - m$, 而 $|A| \leq n - m$，所以 $|A| = n - m =$ 原图最长反链。</p>
<p>所以匈牙利或者 $dinic$ 找最大匹配，再 dfs 找最小点覆盖，最大独立集 = 最小点覆盖补集。注意这题可重。</p>
<p><em>彩蛋：$dinic$ 在二分图上是 $O(n\sqrt{n})$ 的哦</em></p>
<p>upd: $96$ 分我太疑惑了？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/【学习笔记】最大权闭合子图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/26/【学习笔记】最大权闭合子图/" itemprop="url">
                  【学习笔记】最大权闭合子图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-26T09:47:40+08:00">
                2020-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><hr>
<p>看到一篇很好的博客，终于会了这玩意儿！qwq 咱不来虚的哈，直接上正题</p>
<ul>
<li><p>什么是最大权闭合子图：</p>
<p>  每个点有点权，点权和最大的闭合子图即为最大权闭合子图</p>
</li>
<li><p>如何求解</p>
<p>  先说结论：$S$ 向正权点连，边权为权值，$T$ 向负权点连，边权为权值绝对值。<strong>最大权闭合子图权值即为正权和 - 最大流。</strong></p>
<p>  证明（半感性）：<strong>$S -&gt; T$ 的流量就是损失。</strong> 尽量选正权点为起点，所以 $S$ 向正权点连。一个正权点选会导致后续选一些负权点，但我们不知道选当前正权点是否优，就先选上，顶多后面被负权点损失掉为 $0$，不会亏。</p>
</li>
</ul>
<p>习题：</p>
<h3 id="Salty-Fish"><a href="#Salty-Fish" class="headerlink" title="$Salty\ Fish$"></a><a href="https://vjudge.net/problem/HDU-6634" target="_blank" rel="noopener">$Salty\ Fish$</a></h3><p>显然的最大权闭合子图模型。本质却是贪心——一个摄像头尽可能的清理掉子树里剩下的苹果中，深度大的。</p>
<p>与深度有关就长链剖分，开一个 $map$，$mp[x, d]$ 维护 $x$ 子树中深度为 $d$ 的苹果个数。每个苹果只在所在长链的根处被合并一次，$O((n + m)logn)$</p>
<p>然而这题要直接继承重儿子的 $map$，不然就 $MLE$。。以后写代码也注意一点。</p>
<p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=34972168" target="_blank" rel="noopener">$Code$</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/[THUWC2017]-大葱的神力/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/22/[THUWC2017]-大葱的神力/" itemprop="url">
                  [THUWC2017]-大葱的神力
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-22T12:50:40+08:00">
                2020-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>玩玩提答！qwq。看到一句话：提答的本质是模拟退火和找规律。哦这样吗！那我去学模拟退火（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模拟退火算法流程（贺）：</span><br><span class="line">随机变化坐标，幅度为 T</span><br><span class="line">计算新解与当前解的差 delta。</span><br><span class="line">以最大化答案为例，若 delta &gt; 0 则用新解替换当前解；否则以 exp(-delta / T) 的概率用新解替换当前解。</span><br><span class="line">温度乘上一个小于 1 的系数，即降温。</span><br><span class="line">随着温度不断降低，变化幅度也不断减小，接受一个更劣解的概率也越来越小。</span><br></pre></td></tr></table></figure>
<p>调参看脸。有人说可以观察答案的变化率什么的，总之是个完全玄学的东西。</p>
<p>好，上正文！（其实是想存代码，好有成就感的说 qwq</p>
<p>每个 case 都有特性，需要观察找规律。</p>
<h3 id="Case-1-amp-2"><a href="#Case-1-amp-2" class="headerlink" title="Case 1 &amp; 2"></a>Case 1 &amp; 2</h3><p>暴搜 + （我的垃圾）剪枝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>], b[<span class="number">30</span>], mp[<span class="number">30</span>][<span class="number">30</span>], sum, to[<span class="number">30</span>], ans, pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>], mx[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + mx[x] &lt; ans) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; ans) &#123;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                pos[i] = to[i];</span><br><span class="line">            &#125; ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x + <span class="number">1</span>);</span><br><span class="line">    rep(y, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[y] + a[x] &lt;= b[y]) &#123;</span><br><span class="line">            sum += mp[x][y];</span><br><span class="line">            to[x] = y;</span><br><span class="line">            used[y] += a[x];</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            sum -= mp[x][y];</span><br><span class="line">            used[y] -= a[x];</span><br><span class="line">            to[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("drawer2.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("drawer2.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            mx[i] = max(mx[i], mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) mx[i] += mx[i + <span class="number">1</span>];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pos[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h3><p>抽屉唯一，跑背包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>, M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[M], w[M], f[M][N], lst[M][N], ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y ^ lst[x][y]) ans[x] = <span class="number">1</span>;</span><br><span class="line">    work(x - <span class="number">1</span>, lst[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">memset</span>(f, ~<span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">10000</span>) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j], lst[i][j] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= a[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &lt; f[i - <span class="number">1</span>][j - a[i]] + w[i]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - a[i]] + w[i];</span><br><span class="line">                    lst[i][j] = j - a[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">10000</span>) <span class="keyword">if</span> (f[n][i] &gt; f[n][id]) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    work(n, id);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-4-amp-5-amp-6"><a href="#Case-4-amp-5-amp-6" class="headerlink" title="Case 4 &amp; 5 &amp; 6"></a>Case 4 &amp; 5 &amp; 6</h3><p>大葱体积唯一且抽屉体积是大葱体积倍数——裸的费用流。</p>
<p>值得一提的是有个 Case 大葱体积都在 <del>19260817</del>19900000 左右，可视为微小的扰动，不会影响最终答案，取最大值作为体积就好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(rest, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(rest));</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        v = max(v, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        add(i + n, T, b[i] / v, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mcmf();</span><br><span class="line">    rep(x, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-7"><a href="#Case-7" class="headerlink" title="Case 7"></a>Case 7</h3><p>只有第一个大葱体积不同，枚举它放在哪，跑多次费用流。跑了一分多钟，反正是提答 ~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m, Cost, V;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    rep(i, S, T) &#123;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">        pre[i] = <span class="number">0</span>;</span><br><span class="line">        inq[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    V = a[<span class="number">2</span>];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">48</span>] -= a[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        add(i + n, T, b[i] / V, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(j ,<span class="number">1</span>, m) &#123;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cost = Mcmf() - mp[<span class="number">1</span>][<span class="number">48</span>];</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">48</span>;</span><br><span class="line">    rep(x, <span class="number">2</span>, n) &#123;</span><br><span class="line">        ans[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(x, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-8-amp-9-amp-10"><a href="#Case-8-amp-9-amp-10" class="headerlink" title="Case 8 &amp; 9 &amp; 10"></a>Case 8 &amp; 9 &amp; 10</h3><p>没有任何规律。于是就上模拟退火（学以致用</p>
<p>我是 rand 排列，随便调参，最优解只有 51 万左右，然而其他人都是 60 万左右，心慌慌</p>
<p>交一发竟然也是 4 + 2 + 1，开心。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> db down = <span class="number">0.986</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][M], to[N], idb[N], ida[N];</span><br><span class="line"><span class="keyword">int</span> used[N], tmp[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    db T = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">1e-15</span>) &#123;</span><br><span class="line">        random_shuffle(ida + <span class="number">1</span>, ida + n + <span class="number">1</span>);</span><br><span class="line">        random_shuffle(idb + <span class="number">1</span>, idb + m + <span class="number">1</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) tmp[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) used[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[idb[cur]] + a[ida[i]] &lt;= b[idb[cur]]) &#123;</span><br><span class="line">                used[idb[cur]] += a[ida[i]];</span><br><span class="line">                tmp[ida[i]] = idb[cur];</span><br><span class="line">                sum += mp[ida[i]][idb[cur]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cur; --i;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll del = sum - ans;</span><br><span class="line">        <span class="keyword">if</span> (del &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span>(-del / T) * RAND_MAX &gt; rand()) &#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">                rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T *= down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(o, <span class="number">1</span>, <span class="number">5</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) ida[i] = idb[i] = i;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>) * clock() % <span class="number">114514</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld :\n"</span>, ans);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://loj.ac/s/1017355" target="_blank" rel="noopener">评测记录</a></p>
<p>$10 * 7 + 4 + 2 + 1 = 77$，海星</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/13/【学习笔记】常系数齐次线性递推/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/13/【学习笔记】常系数齐次线性递推/" itemprop="url">
                  【学习笔记】常系数齐次线性递推
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-13T18:49:40+08:00">
                2020-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>是照着 <a href="https://www.cnblogs.com/zhouzhendong/p/Cayley-Hamilton.html" target="_blank" rel="noopener">zhouzhendong</a> 和 <a href="https://www.cnblogs.com/Winniechen/p/10246295.html" target="_blank" rel="noopener">Winniechen</a> 的博客学习的。也可以参考 <a href="https://oi-wiki.org/math/linear-recurrence/" target="_blank" rel="noopener">OI-wiki</a>，是两种解释，没有那么多线代前置芝士。</p>
<p>其实我讲不清楚，建议点 OI-wiki，它特别清楚。</p>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="$问题引入$"></a>$问题引入$</h2><p>给定一个数列，满足:</p>
<ul>
<li>$n \leq k$ 时，$f_n = a_n$</li>
<li>$n &gt; k$ 时，$f_n = \sum\limits_{i = 1}^k f_{n - i} * a_i$</li>
</ul>
<p>众所周知矩阵生来就做这事儿的，$O(k^3\ log\ n)$. 当 $n$ 比较大的时候就没前途。</p>
<p>于是就出现了——特征多项式优化矩阵快速幂。求第 $n$ 项复杂度为 $O(k^2 log n)$</p>
<h2 id="前置数学芝士"><a href="#前置数学芝士" class="headerlink" title="$前置数学芝士$"></a>$前置数学芝士$</h2><ol>
<li><p>矩阵的特征值和特征向量</p>
<ul>
<li><p>若对于 $n$ 阶矩阵 $A$，有常数 $\lambda$、非零列向量 $\vec{v}$ 满足 $\lambda \vec{v} = A \vec{v}$，则称 $\lambda$ 为矩阵 $A$ 的<strong>特征值</strong>，$\vec{v}$ 为矩阵 $A$ 的<strong>特征向量</strong>。</p>
</li>
<li><p>上柿可以写作 $(\lambda I - A)\vec{v} = 0$, 左边括号里那玩意是矩阵的行列式，记做 $f(\lambda)$，即为矩阵 $A$ 的<strong>特征多项式</strong>，则对于某个矩阵的特征值 $\lambda_0$, 有 $f(\lambda_0) = 0$。</p>
</li>
<li><p>（注意：行列式和矩阵乘以一个数 $k$ 时是不同的，行列式是某行或某列乘 $k$，矩阵是所有数乘 $k$。别问为啥，这就是定义。）</p>
</li>
</ul>
</li>
<li><p>矩阵特征多项式和一个著名定理</p>
<ul>
<li><p>凯莱-哈密顿定理：$f(A) = 0$.</p>
</li>
<li><p>求解：$f(\lambda) = |\lambda I - A| = \lambda^m - \sum\limits_{i = 0}^{k - 1} a_{k - i} \lambda^i$</p>
</li>
</ul>
</li>
</ol>
<p>由上面那个柿子得到 $f(A) = A^k - b_1A^{k - 1} - c_2A^{k - 2}  … - c_k = 0$, 即 $A^k = c_1A^{k - 1} + … + c_k$，这告诉我们 $A_k$ 可以被 $A^0$ ~ $A^{k - 1}$ 的矩阵线性表出！（哇，有线代内味了</p>
<p>$A^{x + y} = A^x * A^y$,</p>
<p>$A^x = \sum b_i A^i$, $A^y = \sum c_i A^i$</p>
<p>因为有 $f(A) = 0$，所以 $A^{x + y} = \sum\limits_{k = 0}^{2K - 2} (\sum\limits_{i = 0}^{K - 1} b_ic_{k - i})A^k\ mod\ f(A)$，这个取模达到了降次的效果。用快速幂就是 $O(K^2 logn)$ 的。</p>
<p>zhouzhendong 大佬博客里有<del>非人</del>神仙 $O(klogklogn)$ 多项式操作，然而常人都写不动吧 QAQ？（就先不学了</p>
<p>$Template$：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bzoj_4161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">4e3</span> + <span class="number">5</span>;</span><br><span class="line">ll n, K, a[N], b[N], len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(ll x[], ll y[])</span> </span>&#123;</span><br><span class="line">    ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    rep(i, <span class="number">0</span>, len)</span><br><span class="line">        rep(j, <span class="number">0</span>, len)</span><br><span class="line">            add(tmp[i + j], x[i] * y[j] % mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * len; i &gt; len; i--) &#123;  <span class="comment">// 在取模</span></span><br><span class="line">        <span class="keyword">if</span> (!tmp[i]) <span class="keyword">continue</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, len + <span class="number">1</span>)</span><br><span class="line">            add(tmp[i - j], a[j] * tmp[i] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, len)</span><br><span class="line">        x[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll c[N];  <span class="comment">// 系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fpow</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    c[<span class="number">0</span>] = tmp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) Mul(c, tmp);</span><br><span class="line">        Mul(tmp, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    len = K - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, K) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fpow(n);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, len)</span><br><span class="line">        add(ans, b[i] * c[i] % mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://loj.ac/p/2981" target="_blank" rel="noopener">$THUSCH2017-如果奇迹有颜色$</a></p>
<p>这题比洛谷上的模板题多了个相邻 m 项颜色不能全不同的限制。</p>
<p>$|X/G| = \frac{1}{|G|} \sum_g m^{c(g)} = \frac{1}{|G|} \sum_k \phi(n / k) * f(k)$</p>
<p>现在要算 $f(gcd = k)$ 的染色方案数。可以状压计算，状态数是 $m^{m}$，直接跑矩阵快速幂能拿到 $55$ 分的好成绩，然后我就不会了</p>
<p>题解告诉我要去学常系数齐次线性递推，我就滚去学了。厚厚，新知识！（于是就有了这篇拼凑起来的笔记</p>
<p>猜测递推式长度小于 $m^{m}$，借助超能力（打表）发现 $m = 7$ 就 $409$.</p>
<p><a href="https://loj.ac/s/1012066" target="_blank" rel="noopener">$Code$</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/11/[ZJOI2019]-开关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/11/[ZJOI2019]-开关/" itemprop="url">
                  [ZJOI2019]-开关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-11T14:53:05+08:00">
                2020-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法一-生成函数"><a href="#方法一-生成函数" class="headerlink" title="$方法一:生成函数$"></a>$方法一:生成函数$</h2><p>“神仙题！”（平庸的 xml 发出惊叹）</p>
<p>生成函数怎么想到的啊？/yiw 但的确很符合，因为按键是有顺序的，而每个键按多少次概率也不同，适合用形式幂级数表示。</p>
<p>设 $P = \sum p$.</p>
<p>分开考虑每个键。考虑 $[x^k]F_i(x)$ 表示第 $i$ 个位置按了 $k$ 次的概率贡献。当然是 EGF 啦因为是有顺序的按。<br>$$F_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == s_i] \frac{ ( \frac{p_i}{P} ) ^n}{n!} x^n$$<br>$$F(x) = \prod F_i(x)$$<br>写成 OGF $$f(x) = \sum_k (k! <em> [x^k]F(x)) </em> x^k$$</p>
<p>$[x^k]G_i(x)$ 表示第 $i$ 个位置按了 $k$ 次，状态不变的概率。</p>
<p>然而只有 $F$ 能干啥呢？我们要求的是<strong>第一次</strong>到达目标状态，所以需要容斥。具体来说，设 $g(x)$ 表示 $k$ 次状态不变的 OGF，可按上述方法求出；设 $h(x)$ 为答案 OGF，则 $f(x) = g(x) \cdot h(x)$, 则 $h(x) = \frac{f(x)}{g(x)}$.</p>
<p>根据期望的定义，答案形如 $\sum_i if(i)$ 。啊这不就是 $h(1)$ 的导数嘛！$h’(1)$ 就是最终答案。</p>
<p>$$G_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == 0] \frac{( \frac{p_i}{P} )^n}{n!} x^n$$<br>$$G(x) = \prod G_i(x)$$<br>写成 OGF $$g(x) = \sum_k (k! <em> [x^k]G(x)) </em> x^k$$</p>
<p>写成封闭形式<br>$$F_i(x) = \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}$$<br>$$F(x) = \prod \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}$$<br>$$G_i(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}$$<br>$$G(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}$$<br>将 $F(x)$ 写成 $\sum c_i e^{\frac{i}{P}x}$ 的形式，则有</p>
<p>$$f(x) = \sum_k \left( k![x^k]F(x) \right) x^k$$</p>
<p>$$= \sum_k k<img src="\sum_i c_i ( \sum_j \frac{(\frac{i}{P}x" alt="x^k">^j}{j!} ) )x^k$$</p>
<p>$$= \sum_k ( k! \sum_i c_i \frac{(\frac{i}{P})^k}{k!} ) x^k = \sum_k  (\sum_i c_i (\frac{i}{P})^k) x^k $$</p>
<p>$$= \sum_i c_i \sum_k (\frac{i}{P})^k x^k = \sum_i \frac{c_i}{1 - \frac{i}{P}x} $$</p>
<p>同理有 $g(x) = \sum_i \frac{d_i}{1 - \frac{i}{P}x}$。$c_i$, $d_i$ 可以简单 $O(nP)$ 背包得出！</p>
<p>补充求导加减乘除法法则：</p>
<p>$$(f(x) + g(x))’ = f’(x) + g’(x)$$</p>
<p>$$(f(x) - g(x))’ = f’(x) - g’(x)$$</p>
<p>$$(f(x) \cdot g(x))’ = f’(x)g(x) + f(x)g’(x)$$</p>
<p>$$(\frac{f(x)}{g(x)})’ = \frac{f’(x)g(x) - f(x)g’(x)}{g(x)^2}$$</p>
<p>所以要求 $h’(x)$，只要计算出 $f(1)$, $f’(1)$, $g(1)$, $g’(1)$.</p>
<p><strong>然后又是常识问题：无知如我就想直接带 1 进去了，但这不行！！！因为 $i = P$ 项的存在，函数不收敛！！！</strong></p>
<p>怎么办？乘上 $1 - x$</p>
<p>$$f(x) = c_P + \sum\limits_{i \neq P} \frac{c_i(1 - x)}{1 - \frac{i}{P}x}$$</p>
<p>$$f(1) = c_P$$</p>
<p>$$f’(x) = \sum\limits_i \frac{ -c_i(1 - \frac{i}{P}x) - (c_i - c_ix)(-\frac{i}{P}) }{(1 - \frac{i}{P}x)^2} = \sum\limits_i \frac{ (\frac{i}{P} - 1)c_i }{ (\frac{i}{P}x - 1)^2 } $$</p>
<p>$$f’(1) = \sum\limits_{i \neq P} \frac{c_i}{\frac{i}{P} - 1}$$</p>
<p>同理 $g(1) = d_P$, $g’(1) = \sum\limits_{i \neq P} \frac{d_i}{\frac{i}{P} - 1}$</p>
<p>$$h’(1) = \sum\limits_{i \neq P} \frac{c_id_P - c_Pd_i}{(i - 1)d_P^2}$$</p>
<p>神奇！</p>
<p><a href="https://loj.ac/s/1010266" target="_blank" rel="noopener">$Code$</a></p>
<p>从中获得的启示：</p>
<ul>
<li>多考虑实际意义，例如本题中期望 -&gt; 导数。</li>
<li>推柿子：面对多项式束手无策，不如把它变成封闭形式搞事情，多项式的加减乘除和数的加减乘除类似的，还可以求导、ln、exp，多好啊！</li>
<li>推柿子：把 $\prod_{i = l}^{r}$ 变成一个 $r - l + 1$ 次的多项式，就可以 $\sum$ 啦！$\sum$ 就能搞事情啦！</li>
</ul>
<h2 id="方法二：异或卷积"><a href="#方法二：异或卷积" class="headerlink" title="$方法二：异或卷积$"></a>$方法二：异或卷积$</h2><p>咕咕？<del>（生成函数搞累了</del></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/【计划】十二月学习计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/07/【计划】十二月学习计划/" itemprop="url">
                  十二月学习计划
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-07T07:36:40+08:00">
                2020-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><del>我就是喜欢挖深坑!</del></p>
<p>长文给我的感觉特别安心啦其实是。然后一些题目的题解也要整理整理，学习计划也要安排给自己看。</p>
<p>$1.16$ 前的学习计划就, 刷</p>
<ul>
<li>$CodePlus$（选）</li>
<li>$NOI$（12 ~ 20）</li>
<li>$JOI$（选）☑️</li>
<li>清华集训（14 ~ ?）</li>
</ul>
<p>多学数学知识:</p>
<ul>
<li>群论☑️</li>
<li>生成函数☑️</li>
<li>单位根反演</li>
<li>斯特林相关</li>
</ul>
<p>upd：完成度感人。</p>
<hr>
<h2 id="mathcal-12-7"><a href="#mathcal-12-7" class="headerlink" title="$\mathcal{12.7}$"></a>$\mathcal{12.7}$</h2><hr>
<p>写了 $Polya$ 板题，多项式 $exp$ 板题，然后现在巨想写不板的题（</p>
<h3 id="洛谷4980-Polya-板题"><a href="#洛谷4980-Polya-板题" class="headerlink" title="$洛谷4980-Polya 板题$"></a><a href="https://www.luogu.com.cn/problem/P4980" target="_blank" rel="noopener">$洛谷4980-Polya 板题$</a></h3><p>$Polya$ 定理：<br>$|X/G| = \frac{1}{|G|} \sum\limits_{g \in G} |M|^{c(g)}$</p>
<p>其中</p>
<ul>
<li>$X$ 是不考虑本质不同的染色方案集合</li>
<li>$G$ 是各种翻转啊旋转啊等操作构成的置换群</li>
<li>$X/G$ 是本质不同的染色方案集合</li>
<li>$M$ 是颜色数</li>
<li>$c(g)$ 是置换 $g$ 的不相交循环置换个数</li>
</ul>
<p>然后这题我们直接套公式就可以做！<br>$ans = \frac{1}{n} \sum\limits_{g \in G} n^{c(g)}$</p>
<p>枚举 $c(g)$，设 $g$ 旋转了 $i$，则 $c(g) = gcd(n, i)$，因为某个点在置换 $g$ 的重复作用下经过 $lcm(n, i)$ 次操作回到自身，所以 $c(g) = \frac{n * i}{lcm(n, i)} = gcd(n, i)$</p>
<p>$\phi(n / i)$ 为其系数，为啥？</p>
<p>$\sum\limits_{k = 1}^{n} [gcd(n, k) == i]= \sum\limits_{k = 1}^{n / i} [gcd(n, k * i) == i]$</p>
<p>$= \sum\limits_{k = 1}^{n / i} [gcd(n / i, k) == 1] = \phi(n / i)$</p>
<p>所以有 $ans = \frac{1}{n} \sum\limits_{i | n} \phi(n / i) * n^i$, $O(\sqrt{n})$</p>
<h3 id="洛谷5574-任务分配问题"><a href="#洛谷5574-任务分配问题" class="headerlink" title="$洛谷5574-任务分配问题$"></a><a href="https://www.luogu.com.cn/problem/P5574" target="_blank" rel="noopener">$洛谷5574-任务分配问题$</a></h3><p>为了顺口我们求逆序对最少（翻转一下 $a[i]$ 就好）</p>
<p>$calc(l, r)$ 为 $[l, r]$ 的逆序对个数。看起来像斜率优化但它不能。。我相信一定可以优化！</p>
<p>发现有决策单调性：$calc(l - 1, r + 1) + calc(l, r) \geq calc(l - 1, r) + calc(l, r + 1)$<br>易证。<br>于是可以经典决策单调分治 + 树状数组推区间。<br>$O(Knlog^2n)$</p>
<h2 id="mathcal-12-8"><a href="#mathcal-12-8" class="headerlink" title="$\mathcal{12.8}$"></a>$\mathcal{12.8}$</h2><hr>
<h3 id="洛谷4128-有色图"><a href="#洛谷4128-有色图" class="headerlink" title="$洛谷4128-有色图$"></a><a href="https://www.luogu.com.cn/problem/P4128" target="_blank" rel="noopener">$洛谷4128-有色图$</a></h3><p>染色的是边，转的是点。考虑对于某种转点方案，其等价类个数。那边就要分<em>连接同个循环的点</em>和<em>连接不同循环的点</em>讨论。</p>
<p>同个循环：设长度为 $b_i$，有 $b_i / 2$ 种等价类</p>
<p>不同循环：等价类大小为 $lcm(b_i, b_j)$，等价类个数为 $b_i * b_j / lcm(b_i, b_j) = gcd(b_i, b_j)$</p>
<p>现在知道了具体 $b_i$ 就能算答案了。<br>考虑 $n$ 的分拆，$n$ 只有 $53$，十分稳（实际上要 $7e7$）（问题不大）</p>
<p>我们枚举 $b$ 的多重集，系数也挺正常的：$\frac{n!}{\prod b_i!} <em> \prod (b_i - 1)! </em> \frac{1}{c_i!}$</p>
<p>其中第一项是把点分配到多重集里，第二项是每个集合排顺序（是置换嘛），第三项是除掉大小相同的集合算重的方案。</p>
<p>有双倍经验题：HNOI2009-图的同构计数。第一反应是无标号连通图计数 + 背包——不对劲，我只会有标号的。再一想，边的有无不正对应着此题中染成黑或白色吗？于是看题解，果真就是有色图的卡常版——把 gcd 在中途计算掉就能 AC 此题。</p>
<h2 id="mathcal-12-9"><a href="#mathcal-12-9" class="headerlink" title="$\mathcal{12.9}$"></a>$\mathcal{12.9}$</h2><hr>
<h2 id="mathcal-12-10"><a href="#mathcal-12-10" class="headerlink" title="$\mathcal{12.10}$"></a>$\mathcal{12.10}$</h2><hr>
<h3 id="ZJOI2019-开关"><a href="#ZJOI2019-开关" class="headerlink" title="$ZJOI2019-开关$"></a><a href="https://www.luogu.com.cn/problem/P5326" target="_blank" rel="noopener">$ZJOI2019-开关$</a></h3><p>单独写博客了</p>
<h2 id="mathcal-12-11"><a href="#mathcal-12-11" class="headerlink" title="$\mathcal{12.11}$"></a>$\mathcal{12.11}$</h2><hr>
<h3 id="BZOJ4221-Kangaroo"><a href="#BZOJ4221-Kangaroo" class="headerlink" title="$BZOJ4221-Kangaroo$"></a><a href="https://darkbzoj.tk/problem/4221" target="_blank" rel="noopener">$BZOJ4221-Kangaroo$</a></h3><p>我们发现袋鼠和袋子可拆。不妨分别升序排列，看起来很可以 dp。我们要做到的就是没匹配的 $min(a) \geq max(b)$。</p>
<p>枚举从左往右第一个没有被塞到袋子里的袋鼠 $s$，对于这个 $s$ 找到它能匹配的最小的袋子 $t$。由于 $s$ 是第一个没匹配的袋鼠，$s$ 左边的袋鼠和 $t$ 及其右边的袋子都被匹配了。怎么统计方案数？枚举跨越 $(s, t)$ 的对数，即小于 $s$ 的袋鼠同大于 $t$ 的袋子匹配。除去这些，剩下的匹配对就是小于 $s$ 和小于 $t$，大于 $s$ 和大于 $t$。左右分别 $n^2$ dp。</p>
<p><a href="https://darkbzoj.tk/submission/99567" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-12"><a href="#mathcal-12-12" class="headerlink" title="$\mathcal{12.12}$"></a>$\mathcal{12.12}$</h2><hr>
<p>下午的 THUPC2020，享受比赛，好好打吧！</p>
<h2 id="mathcal-12-13"><a href="#mathcal-12-13" class="headerlink" title="$\mathcal{12.13}$"></a>$\mathcal{12.13}$</h2><hr>
<p>为了做「如果奇迹有颜色」，学习了半个常系数齐次线性递推。非常颓废，肝了 15 页生物。</p>
<h2 id="mathcal-12-14"><a href="#mathcal-12-14" class="headerlink" title="$\mathcal{12.14}$"></a>$\mathcal{12.14}$</h2><hr>
<p>AC 了「如果奇迹有颜色」。题解在「【学习笔记】常系数齐次线性递推」里。现在想去数数。</p>
<p>做了「烷基计数」，题解在「【学习笔记】生成函数」</p>
<h3 id="comet2280-另一道树题"><a href="#comet2280-另一道树题" class="headerlink" title="$comet2280-另一道树题$"></a><a href="https://cometoj.com/contest/48/problem/D?problem_id=2280" target="_blank" rel="noopener">$comet2280-另一道树题$</a></h3><p>计数转期望，期望用整数概率公式拆分。这样就化“恰好”为“至少”了，现在我们要统计走 $i - 1$ 步不会走到一块的方案数。只要并查集把走到一块的并起来，方案数就是 $(\prod (siz + 1)) - n$，最后还要减去 $n$。</p>
<h3 id="PKUWC2018-Slay-the-Spire"><a href="#PKUWC2018-Slay-the-Spire" class="headerlink" title="[$PKUWC2018-Slay the Spire$]"></a>[$PKUWC2018-Slay the Spire$]</h3><p>这是一道求和题。<br>假设选了 $i$ 张强化牌和 $m - i$ 张攻击牌</p>
<ol>
<li>$i &lt; K$，$i$ 张强化牌，$K - i$ 张最大的攻击牌</li>
<li>$i \geq K$，$K - 1$ 张最大的强化牌，一张最大的攻击牌。</li>
</ol>
<p>正确性易证。所以只要 $dp$ 就好了？$f[i, j]$ 表示前 $i$ 张强化牌摸了 $j$ 张的倍数和，$g[i, j]$ 表示前 $i$ 张攻击牌摸了 $j$ 张的和。注意 $dp$ 的时候如果攻击牌数 $j \leq m - (K - 1)$，那只能取一张牌，为了方便 $dp$ 我们把攻击牌升序排序，这样取的牌就是当前这张。第一维可以倒序搞掉。</p>
<h2 id="mathcal-12-15"><a href="#mathcal-12-15" class="headerlink" title="$\mathcal{12.15}$"></a>$\mathcal{12.15}$</h2><hr>
<p>做了「烷烃计数」，题解在「【学习笔记】生成函数</p>
<h3 id="找树"><a href="#找树" class="headerlink" title="$找树$"></a><a href="https://loj.ac/p/6622" target="_blank" rel="noopener">$找树$</a></h3><p>要理解透。解法是矩阵树的变形应用：众所周知矩阵树只能求生成树个数和生成树边积和。考虑全是异或怎么做，就是加一维 $a[x, y, z]$ 表示矩阵 $[x, y]$ 位置值为 $[z]$ 的个数，那么求行列式的时候乘法变成 $FWT$ 就行了。</p>
<p>但你怎么定义 $FWT$ 的逆元？太 $naive$ 了还是！</p>
<p>先 $FWT$，对于每个 $[z]$ 求出行列式放在答案数组里，再把答案数组 $IFWT$ 回去就好了。复杂度 $O(n^32^w + n^2w2^w)$，$1e9$，在求行列式那里特判一下如果出现 $0$ 就直接返回 $0$，就 $AC$ 了。这是怎么一回事呢，小编也很惊讶。</p>
<h3 id="希望"><a href="#希望" class="headerlink" title="$希望$"></a><a href="https://loj.ac/p/3053" target="_blank" rel="noopener">$希望$</a></h3><p>之前做的，记录一下。</p>
<p>别被高大上的题目唬住了！思路就是算一个救援队的答案，然后 $k$ 次方。点 $x$ 子树里和子树外的要分开算。考虑直接算会算重——一个连通块会被算多次，应用经典“点减边”思想——连通块中点数 = 边数 + 1，就用点的答案减去边的答案。</p>
<p>$f[x, i]$ 表示子树里深度不超过 $i$ 的连通块方案数，$g[x, i]$ 表示不包括子树里（但包括 $x$）的深度不超过 $i$ 的连通块方案数，两个一乘岂不美哉？</p>
<p>转移方程超好写：</p>
<ul>
<li>$f[x, i] = (\prod f[y, i - 1]) + 1$</li>
<li>$g[x, i] = (g[fa[x], i - 1] \prod f[son[fa[x]], i - 2]) + 1$</li>
</ul>
<p>$n$ $1e6$, $dp$ 又与深度有关，于是想到长剖优化。本题的思路到此为止，接下来 都 是 细 节</p>
<p>$f$ 可以直接算，但是 $g$ 里面那个 $\prod$ 不好搞。</p>
<p>用回退栈可以维护，做 $f$ 的时候从长到短遍历子树，做 $g$ 的时候从短到长遍历子树。</p>
<h2 id="mathcal-12-16"><a href="#mathcal-12-16" class="headerlink" title="$\mathcal{12.16}$"></a>$\mathcal{12.16}$</h2><hr>
<p>渐渐，对于安逸享乐的人它是一条长长的下坡路，通向深渊；对于上进的人它是一条长长的阶梯，通向天堂。</p>
<p>为了不滑进深渊我只有拼尽全力。<strong>我要终止看题解的不良习惯——再这样下去，xml，你会光速退役的。</strong></p>
<p>comet第六场 E，uoj311，uoj370，uoj316，loj2570, vp 一场 cf（哼，痴人说梦）</p>
<h3 id="LOJ6356-四色灯"><a href="#LOJ6356-四色灯" class="headerlink" title="$LOJ6356-四色灯$"></a><a href="https://loj.ac/p/6356" target="_blank" rel="noopener">$LOJ6356-四色灯$</a></h3><p>$O(nm)$ 是非常好做的啊，算出每个位置被经过的次数 $cnt$，贡献就是 $\sum_k C(cnt, 4k) * 2^{m - cnt}$</p>
<p>考虑 $cnt \in [0, 20]$，我们枚举选了哪些 $x_i$。设该集合为 $s$，那么被 $lcm(x \in S)$ 经过的点应当有贡献。但是对于 $s \subset s’$，$s’$ 经过的点 $s$ 也经过了，所以需要容斥出被 $s$ 经过且不被任何 $s$ 的超集经过的点个数，表示为 $g[s]$。</p>
<p>直接枚举超集 $O(3^m)$，TLE；考虑进一步优化。写出柿子：$\sum_s g[s] \sum_k C(|S|, 4k) * 2^{m - |S|}$，发现 $|S|$ 相同的可以拢到一起。设 $G[i] = \sum\limits_{|S| = i} g[s]$，$G$ 很容易容斥得到，比如 $j &gt; i$，考虑 $G[j]$ 对 $G[i]$ 的容斥贡献，只是把原先分项并到了一起，乘组合数 $C(j, i)$ 就好。</p>
<p><a href="https://loj.ac/s/1013566" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-17"><a href="#mathcal-12-17" class="headerlink" title="$\mathcal{12.17}$"></a>$\mathcal{12.17}$</h2><hr>
<p>感觉做事像有阻力一样。这阻力来自哪里？过于注重形式，便颓废了。这阻力也是犹豫不决，是自我怀疑，虽然已经比前几个月的我症状轻多了。双脚往前抵着怎么会走的快、走得轻松呢？</p>
<p>看题解这个事情，本质是急于求成，但只是一时之利，于长远则是退役的加速器。思考的充分一点，一道题做几个小时也是不亏的。<strong>务必从现在开始加强独立思考！！！</strong></p>
<p>机房的大环境与我是两个世界，带上耳塞，沉浸在自己的探究中。入神时便不受大环境影响了。</p>
<p>做题量要采取策略来保证，一天一套 CF。我是说，在学数学的同时也别忘了 CF，你看 zjy、kqh CF 都切的很多。做好题，不要做网红题，要按照自己的弱点来选题。最近的省选模拟赛，打满时间感觉不现实，但每道题都要思考透。</p>
<p>写题，思考透再开码。</p>
<p>每天坚持着充实着，有付出有收获，一切都会变好的！！！（最近就是效率低下，感到空虚了。</p>
<p>劳谦君子，有终吉。</p>
<h3 id="XJOI1626-T3"><a href="#XJOI1626-T3" class="headerlink" title="$XJOI1626 T3$"></a>$XJOI1626 T3$</h3><p>$n = 50$ 是 $TC$ 原题。但明显可以优化嘛。发现瓶颈在于容斥时并查集的操作。想到每一位建虚点。连通块数由两部分组成：被选的虚点和与它相连的点们，没被选的点们。大概可以高维前缀和。（高维前缀和这个东西就是 FMT 啦。</p>
<h3 id="XJOI1627"><a href="#XJOI1627" class="headerlink" title="$XJOI1627$"></a>$XJOI1627$</h3><h4 id="T1"><a href="#T1" class="headerlink" title="$T1$"></a>$T1$</h4><p>经典套路，树上路径问题考虑边分治或者点分治 + 堆。我原来写的边分，也可以吧，但是点分多香啊，不用三度化。</p>
<p>为什么不能对每个重心将子树大小排序算答案？每个重心丢 $K$ 个距离到答案堆里，堆不得炸掉。。复杂度也不对嘛。——那就别急着算出当前最优啊，不如把所有重心全部跑完再算最优。这就是超级钢琴的套路了。</p>
<p>对每个重心，它的子树中点的连边情况是一个区间。丢区间进堆，$st$ 表维护 $\max$。每次取区间，统计答案，裂成两半。</p>
<p>点分治的优点在哪儿呢？点和点的距离可以直接相加得出。$O(nlog^2n + mlogn)$，AC 不了就很难受。</p>
<p>upd：这题重点在超级钢琴啊，前面的有一百种做法，只要保证距离可以直接相加得出就好。简单的 dfs 序上跑也可以额。或者线段树维护直径集合。</p>
<h4 id="T2"><a href="#T2" class="headerlink" title="$T2$"></a>$T2$</h4><p><a href="https://www.cnblogs.com/chdy/p/13114664.html" target="_blank" rel="noopener">题解</a></p>
<p>我想了个 $O(\frac{n^4}{32})$ 的 bitset 假做法，被大捆绑杀了</p>
<p>看到这个矩阵里排列的形式容易想到行列式的定义，利用指数化加为乘，得到一个项数为 $nk$ 的多项式，我们只关心 $k$ 的倍数项系数是否有不为 $0$ 的。但是直接照着算行列式是不对的，因为行列式柿子里有个 $(-1)^{逆序对数}$ 的玩意，很容易抵消。</p>
<p>直接乘一个 $rand$ 就可以啦！</p>
<p>然后也不用真的拉格朗日插值，可以用单位根的神奇性质优化。往里带 $mod - 1$ 的 $K$ 次单位根 $wn$，其中 $mod = vk + 1$，带 $k$ 次。正确性见大佬博客，orz！</p>
<p>交了 $114514$ 次才过的。大捆绑我吐！</p>
<h4 id="T3"><a href="#T3" class="headerlink" title="$T3$"></a>$T3$</h4><p>一个循环节 $2$ 的串会被 $4$ 的时候再统计一次，考虑反演出来：$f[i, j]$ 表示以 $i$ 为结尾的串，循环节恰好为 $j$ 的个数，$g[i, j]$ 表示以 $i$ 为节点的串，循环节是 $j$ 的因数的个数。那么显然有 $g[i, j] = \sum\limits_{d | j} f[i, d]$, $f[i, j] = \sum\limits_{d | j} g[i, d] * \mu(\frac{j}{d})$。答案是 $C(n + 1, 2) - \sum{f[i, j]}$，现在考虑怎么算 $g$.</p>
<p>枚举 $d$，把整个串划分为长度为 $d$ 的块，块与块之间的位置我们称为关键点，算出相邻关键点向左的最长公共后缀和向右的最长公共前缀。要相加 $\geq d$ 才行，维护到当前块的最长合法块位置就好了，是 $O(nlogn)$ 的！$hehezhou$ $nb$！！！</p>
<p>还有一种做法就是发现某个答案串必然包含了 $Lyndon\ root$，然后跑 $Runs$。（虽然没听懂但还是要记下来</p>
<h3 id="ZJOI2020-传统艺能"><a href="#ZJOI2020-传统艺能" class="headerlink" title="$ZJOI2020-传统艺能$"></a><a href="https://loj.ac/p/3312" target="_blank" rel="noopener">$ZJOI2020-传统艺能$</a></h3><p>和 19 年的一样讨论啊。。$K$ 如此之大，列出 $dp$ 方程后容易想到矩阵快速幂吧。算是 2.0 版本吧，依旧觉得维护这五个量——访问祖先/自己/子树/兄弟/不交，挺巧妙的。$O(n3^3logK)$</p>
<p><a href="https://loj.ac/s/1014629" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-18"><a href="#mathcal-12-18" class="headerlink" title="$\mathcal{12.18}$"></a>$\mathcal{12.18}$</h2><hr>
<p>刚刚去听了职业规划的计算机专场。高薪、创新 大概是一些关键词吧。理科要好。职业的活动性很大（我在说什么啊）可能性很多。主要是做大数据，网络之类的。说实话目前真没什么兴趣。单论兴趣的话最现实的应该是小提琴吧（你追的上人家专业生嘛）还没想好，总之先走着吧，“如果没有坑，就先让自己成为萝卜”。</p>
<h3 id="UOJ549-序列妙妙值"><a href="#UOJ549-序列妙妙值" class="headerlink" title="[$UOJ549-序列妙妙值$]"></a>[$UOJ549-序列妙妙值$]</h3><p>分 subtask dp 有 60 分。正解怎么做？看到 $2^8$ 和 $2^{16}$，容易想到值域分块，高低八位分块做（——说起来还是在今年初赛第一次碰见的这种套路= = 果然太闭塞了）$f[i, j, s1, s2]$ 表示前 $i$ 位，分 $j$ 段，高八位前缀异或值是 $s1$，预计下一个转移的数低八位为 $s2$。本质还是均摊复杂度。</p>
<h2 id="mathcal-12-20"><a href="#mathcal-12-20" class="headerlink" title="$\mathcal{12.20}$"></a>$\mathcal{12.20}$</h2><hr>
<h3 id="XJOI1629"><a href="#XJOI1629" class="headerlink" title="$XJOI1629$"></a>$XJOI1629$</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="$T1$"></a>$T1$</h4><p>骗了 20 分。。= = 感性理解下最优解一定是 $max$ 里的 $\sum$ 相等的情况（正解告诉你就是一堆一次函数的交点），直接 $n^3$ 高斯消元解方程就能获得 $60$ 分的好成绩。</p>
<p>关于正解——分治（$height$ 上建笛卡尔树）是神，从 $height$ 最小处划成两半，分 $k$ 就先分给一边 $1$，多了可以做完后乘比例，这个也超妙。分配的比例越大，$max$ 越大，比例与 $max$ 成正比，这还是显然的。</p>
<p>左右合并，答案是 $max( lans <em> x + (1 - x) </em> h, rans <em> (1 - x) + x </em> h )$，是两个一次函数，必然存在一个交点，即两者相等，就是最小值，解方程算 $x$。</p>
<p>也可以用 $SAM$ 的 $parent$ 树，树形 $dp$，合并两个子树的时候跟上面一样分配比例。</p>
<h4 id="T2-1"><a href="#T2-1" class="headerlink" title="$T2$"></a>$T2$</h4><p>hhz 讲了从矩阵快速幂切入的方法，不断优优优化。</p>
<p>首先考虑本质不同子序列怎么 $dp$：$dp[i]$ 表示以 $i$ 结尾的本质不同子序列个数，$dp[i] = 1 + \sum\limits_{j = 1}^n dp[lst_j]$</p>
<p>乘法是一个列向量乘一个转移矩阵的形式，列向量里记录的是 $dp[lst_1]$, $dp[lst_2]$, … $dp[lst_m]$, $1$。转移矩阵有一行全是 $1$，这样长的特殊的矩阵很稀疏，只有 $O(n)$ 个位置为 $1$，乘法复杂度就变线性了。询问离线做即可。</p>
<h4 id="T3-1"><a href="#T3-1" class="headerlink" title="$T3$"></a>$T3$</h4><p>加一维时间。那每个操作就是一个面上的一个矩形，每次询问穿过一些矩形。考虑对于一条线，穿过的有矩形覆盖的点 $(p, q)$，无矩形覆盖的 $(1, 0)$，就线段树维护。</p>
<p>移动是 $O(log)$ 的，莫队可以做到 $O(n\sqrt(n)logn)$，$kd-tree$ 可以做到 $O(n\sqrt(n))$（一时口胡一时爽</p>
<h3 id="THUSC2016-成绩单"><a href="#THUSC2016-成绩单" class="headerlink" title="$THUSC2016-成绩单$"></a><a href="https://loj.ac/p/2292" target="_blank" rel="noopener">$THUSC2016-成绩单$</a></h3><p>神仙题？</p>
<p>首先肯定是区间 dp。最后删除的是一个颜色区间的物品，根据这个删除的规律来设计方案。</p>
<p>$f[i, j, l, r]$ 表示 $[i, j]$ 只剩下 $[l, r]$ 颜色区间的物品没删的最小代价, $g[i, j]$ 表示 $[i, j]$ 区间消完了的最小代价。转移 $f$，有两种：一是 $j$ 和之前的并一起；二是枚举断裂点。<br>第二种情况要分类讨论 $[l, r]$ 颜色区间的物品分散在断裂点的哪一边：1. 只有左 2. 只有右 3. 两边都有</p>
<h2 id="mathcal-12-21"><a href="#mathcal-12-21" class="headerlink" title="$\mathcal{12.21}$"></a>$\mathcal{12.21}$</h2><hr>
<h3 id="XJOI1630"><a href="#XJOI1630" class="headerlink" title="$XJOI1630$"></a>$XJOI1630$</h3><h4 id="T1-2"><a href="#T1-2" class="headerlink" title="$T1$"></a>$T1$</h4><p>我明明写的就是倍增嘛(;´༎ຶД༎ຶ`) 惨死了，暴力都 WA 飞了。倍增就一步一步跳，不要学 xml 急于求成一次跳一块导致全是错的。</p>
<h4 id="T2-2"><a href="#T2-2" class="headerlink" title="$T2$"></a>$T2$</h4><p>写了 $40$ 分，$XJ$ 又yòu双shuāng叒ruò叕zhuó没有 $SPJ$！（upd：补了。感动。）</p>
<p>正解是最小圆覆盖，半径的上界必然是看作同个平面上时覆盖了所有点的最小圆半径，枚举高度，半径的减小量随着高度的增加而减小。众所周知最小圆覆盖复杂度 $O(n)$，因为一个点贡献到圆上的期望是 $\frac{3}{i}$。</p>
<h4 id="T3-2"><a href="#T3-2" class="headerlink" title="$T3$"></a>$T3$</h4><p>$40$ 分 $Tarjan$ 缩边双。记得判进来的边啊！正解是 LCT，链赋值。</p>
<p><a href="https://www.luogu.com.cn/problem/P5489" target="_blank" rel="noopener">指路</a></p>
<h3 id="LOJ6611-摧毁时间线"><a href="#LOJ6611-摧毁时间线" class="headerlink" title="$LOJ6611-摧毁时间线$"></a><a href="https://loj.ac/p/6611" target="_blank" rel="noopener">$LOJ6611-摧毁时间线$</a></h3><p>有 sb $18$ 分做法——状压。不要傻掉了啊！如果没有 $i + 1$ 和 $i + 2$ 的要求，显然可以区间 $dp$ 啊，$f[i, j]$ 表示 $[i, j]$ 比 $i - 1$ 和 $j + 1$ 先消。<br>考虑 $i + 1$ 和 $i + 2$，信息多了，多记录几维就行:<br>$f[i, j, t, u]$ 表示 $[i, j]$ 早于 $i - 1$ 和 $j + 1$ 被删，$i + 2$ 是 $t$，$[i, u)$ 都要早于 $u$ 被删。其中 $[i, j]$ 的断裂点 $k \in [u, j]$. $O(n^6)$</p>
<p><a href="https://loj.ac/s/1016858" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="UOJ165-Flea"><a href="#UOJ165-Flea" class="headerlink" title="$UOJ165-Flea$"></a><a href="https://uoj.ac/problem/165" target="_blank" rel="noopener">$UOJ165-Flea$</a></h3><p>好妙【痴傻】复杂度肯定是去和 $n$ 扯关系的。</p>
<p>我们一个一个函数加入。这是个分段二次函数。一个很重要的事情：函数只有 $n$ 段。对每段单独做——显然我们只关注端点。<br>二分端点位置 $x$ 然后更新 $x$ 的答案。</p>
<p>询问很珍贵，选哪个点询问呢？假设当前在问第 $i$ 个函数（不要求按顺序来），选前 $i - 1$ 次跳得最高的跳蚤；若获得的函数与之前相同那该跳蚤高度就是答案（因为其他跳蚤高度只会变小），否则就加入新的函数。$O(n^2)$</p>
<p><a href="https://uoj.ac/submission/443496" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="大葱的神力"><a href="#大葱的神力" class="headerlink" title="$大葱的神力$"></a><a href="https://loj.ac/p/2288" target="_blank" rel="noopener">$大葱的神力$</a></h3><p>单独写博客了。</p>
<h2 id="mathcal-12-22"><a href="#mathcal-12-22" class="headerlink" title="$\mathcal{12.22}$"></a>$\mathcal{12.22}$</h2><hr>
<h3 id="XJOI1631"><a href="#XJOI1631" class="headerlink" title="$XJOI1631$"></a>$XJOI1631$</h3><p>今天数学场，题目有些许毒瘤，我有些许自闭。</p>
<h4 id="T1-3"><a href="#T1-3" class="headerlink" title="$T1$"></a>$T1$</h4><p>咕咕，鸽鸽</p>
<h4 id="T2-3"><a href="#T2-3" class="headerlink" title="$T2$"></a>$T2$</h4><p>基环树本质不同染色数。先树哈希判环上树同构，并算出每个树等价类的染色数。做 $burnside$ 的时候，不能像以前一样枚举 $gcd$ 了，因为每种旋转方案的等价类染色数都不同。由于 $n$ 很小，仅枚举因数即可，因为不是因数的跳出来也是距离相等的因数形态（表达不太清楚，意会一下</p>
<p>找到最小的合法旋转距离 $d$。实际上 $d$ 就是所有可行步长的 $gcd$。把相邻 $d$ 个看作一块再做 $burnside$。</p>
<h4 id="T3-3"><a href="#T3-3" class="headerlink" title="$T3$"></a>$T3$</h4><p>好妙啊。就有这么个 $trick$：小于某个 $limit$ 的操作都被执行，就可以从小往大执行操作。</p>
<p>注意到一个操作只有在 $gap \leq T$ 的时候才会被执行，就按 $gap$ 从小往大加入操作，线段树维护每个操作区间能走到的区间。</p>
<h3 id="十二省联考2019-字符串问题"><a href="#十二省联考2019-字符串问题" class="headerlink" title="$十二省联考2019-字符串问题$"></a><a href="https://loj.ac/p/3049" target="_blank" rel="noopener">$十二省联考2019-字符串问题$</a></h3><p>很自然<del>套路</del>的题，容易想到建边用图做，也就是一个 $A$ 向它支配的 $B$ 连边，这个 $B$ 再向以它为前缀的 $A$ 连边，暴力连 $O(n^2)$，考虑优化。</p>
<p>老套路，考虑图/树优化建边，这里对反串建 $SAM$，把 $A$ 串和 $B$ 串挂在对应的后缀树节点下，同个节点挂着的串相邻连边就避免了一个 $A$ 向一堆 $A$ 连的情况。</p>
<p><a href="https://loj.ac/s/1017579" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="十二省联考-皮配"><a href="#十二省联考-皮配" class="headerlink" title="$十二省联考-皮配$"></a><a href="https://loj.ac/p/3051?keyword=3051" target="_blank" rel="noopener">$十二省联考-皮配$</a></h3><p>这题不讲唔得，它用繁多的变量来搞你心态！<del>大意了啊没有闪</del></p>
<p>撇开这点，题并不难（但有点考逻辑</p>
<p>首先发现派系和阵营是交错的，不管城市选什么阵营，里面的学校都可以任意选派系，城市的决定和学校的决定共同决定了导师。<strong>也就是说城市和学校独立。</strong></p>
<p>先考虑 $k = 0$ 的情况，分别 $dp$ 算出 $f[i, j]$ 表示前 $i$ 个城市，$j$ 个人在蓝阵营的方案数；<br>$g[i, j]$ 表示前 $i$ 个城市，$j$ 个人在鸭派系的方案数。合法的相乘。</p>
<p>按照选课的套路，$k = 0$ 的情况，没有限制的城市和学校同上做；<br>$k \neq 0$，有限制的城市需要选同个阵营，同城市的学校就必须捆绑考虑了：$f[i, j, k]$ 表示前 $i$ 个城市蓝阵营人数为 $j$，鸭派系人数为 $k$ 的方案数。</p>
<p>然后滚掉一维就能 AC 辣!</p>
<p><a href="https://loj.ac/s/1017744" target="_blank" rel="noopener">$Code$</a></p>
<p><del>至此十二省联考只差一道骗分过样例了（这道打算咕掉）</del></p>
<h2 id="mathcal-12-23"><a href="#mathcal-12-23" class="headerlink" title="$\mathcal{12.23}$"></a>$\mathcal{12.23}$</h2><hr>
<h3 id="XJOI1632"><a href="#XJOI1632" class="headerlink" title="$XJOI1632$"></a>$XJOI1632$</h3><p>XJ 现在题好像不那么旧了？点赞！我都要订！</p>
<h4 id="T1-4"><a href="#T1-4" class="headerlink" title="$T1$"></a>$T1$</h4><p>求本质不同子串的本质不同子串，</p>
<p>咕咕，鸽鸽（区间本质不同子串做法？LCT + SAM？有空再补</p>
<h4 id="T2-4"><a href="#T2-4" class="headerlink" title="$T2$"></a>$T2$</h4><p>原题 $HNOI2016-序列$。容易发现就是要维护所有子区间最大值之和。</p>
<p>处理区间的套路：固定一维先算，再求和。（比赛时就这个妹想到！）</p>
<p>$f[i]$ 表示以 $i$ 为右端点的区间答案和。设 $pre[i]$ 表示 $i$ 前面最近的小于 $a[i]$ 的位置，则 $f[i] = f[pre[i]] + a[i] * (i - pre[i])$。对 $f$ 求前缀和设为 $g$。</p>
<p>怎么回答一个 $[l, r]$ 的询问？设 $pos$ 表示 $[l, r]$ 中最小的位置，问题就在于怎么计算 $(pos, r]$ 的子区间答案。答案就是 $g[r] - g[pos] - f[pos] * (r - pos)$，挺好理解。$[l, pos)$ 一个道理。</p>
<h4 id="T3-4"><a href="#T3-4" class="headerlink" title="$T3$"></a>$T3$</h4><p>考察考生熟练换维 $dp$ 的能力。</p>
<p>$bitset$ 好想，$30$ 分暴力拿到。接着思路想下去，考虑优化。</p>
<p>$f[i, j]$ 表示前 $i$ 种物品，选了 $j$ 种，能选的体积，第三维用 $bitset$ 表示。</p>
<p>换二三维。</p>
<p>$$f[i, j] = f[i - 1, j]\ |\ OR_{k = 1}^{c[i]} (f[i - 1, j - k * v[i]] &lt;&lt; 1)$$</p>
<p>换一二维。</p>
<p>$$f[j] = f[j]\ |\ OR_{k = 1}^{c[i]} (f[j - k * v[i]] &lt;&lt; 1)$$</p>
<p>发现对 $j$ 以 $mod\ v[i]$ 值分类，每类互不干扰，于是可以分别拎出来算，那就明显了：求区间或。</p>
<p><del>那不直接 st 表嘛</del>清醒点，平白多个 $log$（据说可以用 $\pm1\ rmq$ 实现，用人话就是分块 $st$ 表）</p>
<p><del>那不直接前后缀嘛</del>清醒点，不可逆</p>
<p>于是巧妙分块，以 $c[i]$ 为块大小，每块维护前后缀或就可以了。然后要加一些指标集优化不然会 T 成 40。</p>
<p>学习了最小圆覆盖。</p>
<h3 id="JOI2017-春季合宿"><a href="#JOI2017-春季合宿" class="headerlink" title="$JOI2017-春季合宿$"></a><a href="https://uoj.ac/problem/355" target="_blank" rel="noopener">$JOI2017-春季合宿$</a></h3><p><strong>发现纵向长度和横向长度固定了，每个种子都贡献一块形状大小相同的矩形，所以顺序无关。</strong></p>
<p>固定一维处理另一维的思路。枚举纵向长度，发现有两种情况纵向长度会影响横向长度：$1$. 纵向两个种子到了边界 $2$. 两个种子碰到彼此了。所以共有 $O(n^2)$ 种。</p>
<p>再计算最小横向长度，设最左边的种子到左边界为 $a$，最右边的种子到右边界距离为 $b$，种子横坐标差最大为 $c$，那么最小横向长度就是 $\max(a + b, c)$。</p>
<p>边界很恶心，于是贺了代码，可耻 ಥ_ಥ</p>
<p><a href="https://loj.ac/s/1019368" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-24"><a href="#mathcal-12-24" class="headerlink" title="$\mathcal{12.24}$"></a>$\mathcal{12.24}$</h2><hr>
<h3 id="XJOI1633"><a href="#XJOI1633" class="headerlink" title="$XJOI1633$"></a>$XJOI1633$</h3><h4 id="T1-5"><a href="#T1-5" class="headerlink" title="$T1$"></a>$T1$</h4><p>数论题！容易发现是反演，需要一个关键柿子（我不会所以就 gg）（xml 你真得捡数论了）：$\sum\limits_{i = 1}^n \cos\frac{2\pi i}{n} = [n = 1]$，证明可以考虑复数平面上的单位根：$\sum\limits_{i = 1}^n \omega_n^i = [n = 1]$</p>
<p>答案做差分得: $f(r + 1) - f(l)$，考虑 $f(n) = \sum\limits_{d = 1}^n \mu(\frac{n}{d})g(d)$，显然可以整数分块 + 杜教筛求 $\mu$; $g(n) = C(n, 2) + 1 - n$，后面这个东西是 $(\sum\limits_{i = 1}^n \sum\limits_{j = 1}^i cos\frac{2\pi j}{i}) - (\sum\limits_{i = 1}^n cos\frac{2\pi i}{i})$</p>
<h4 id="T2-5"><a href="#T2-5" class="headerlink" title="$T2$"></a>$T2$</h4><p>「有色图」三倍经验题，没切不应该——我脑抽觉得 $C_{i, j, k}$ 只最多在两个置换中。好可惜啊啊啊啊啊啊！！！就差跨越三个置换的情况我就 AC 了（吐血）祭奠我考场上铁头的两小时 (;´༎ຶД༎ຶ`)</p>
<p><del>也许以后功成名就来出题，可以出四倍经验题，来一个 $D_{i, j, k, l}$（你这出题人不讲唔得！）</del></p>
<h4 id="T3-5"><a href="#T3-5" class="headerlink" title="$T3$"></a>$T3$</h4><p>老题？牛客网上见过没切我爪巴。做法有一千种，根号、$2$/$3$ 只 $log$ 等等。</p>
<p>考虑点分治，离线询问，每次处理过分治重心的询问，对于 $S -&gt; lca$ 就维护和以及最后的那个最小值（可以倍增找位置），对于 $lca -&gt; T$ 就维护第一个小于 $S -&gt; lca$ 最小值的位置（可以二分）</p>
<p>思路很清楚，然后就是大力堆代码。有个地方没写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (mark[x]) continue;</span><br></pre></td></tr></table></figure></p>
<p>T 飞了 = =</p>
<p>hhz：不用二分，对于 $S -&gt; lca$ 最小值从小到大排序依次做，把比当前最小值便宜的点加进图里，并查集维护根就可以啦不过是 $O(nlogn\alpha)$ 的，可以 $O(1)$ 树上并查集去掉 $\alpha$。（是我不会的科技）</p>
<h3 id="歌唱王国"><a href="#歌唱王国" class="headerlink" title="$歌唱王国$"></a><a href="https://www.luogu.com.cn/problem/P4548" target="_blank" rel="noopener">$歌唱王国$</a></h3><p>妙诶。。掷骰子类型题的概率生成函数：$F(x)$ 表示扔 $i$ 次成功的概率，$G(x)$ 表示扔 $i$ 次不成功的概率。然后根据扔骰子的后继可能能列出俩柿子：</p>
<ol>
<li>$xG(x) + 1 = F(x) + G(x)$</li>
<li>$G(x) \cdot (\frac{1}{n})^m = \sum\limits_{i = 1}^m [name_{1\ to\ i}\ is\ a\ border] F(x) (\frac{1}{n})^{m - i}$</li>
</ol>
<p>求的是期望也就是 $F’(1)$，对上两柿化得：</p>
<ol>
<li><p>$xG’(x) + G(x) = F’(x) + G’(x) \Rightarrow F’(x) = (x - 1)G’(x) + G(x) \Rightarrow F’(1) = G(1)$</p>
</li>
<li><p>$G(x) = \sum\limits_{i = 1}^m [name_{1\ to\ i}\ is\ a\ border] F(x) (\frac{1}{n})^{i} \Rightarrow G(1) = \sum\limits_{i = 1}^m [name_{1\ to\ i}\ is\ a\ border] F(1) (\frac{1}{n})^{i} = \sum\limits_{i = 1}^m [name_{1\ to\ i}\ is\ a\ border] (\frac{1}{n})^{i}$</p>
</li>
</ol>
<p>联立两柿得 $F’(1)$。简单 $kmp$ 就好了 hoho！</p>
<h2 id="mathcal-12-25"><a href="#mathcal-12-25" class="headerlink" title="$\mathcal{12.25}$"></a>$\mathcal{12.25}$</h2><hr>
<p>圣诞节！！！🎄🎅🎁🍰 我们都是延熄人、补课人、吃饺子人，我妈说她是做饺子人 qwq</p>
<h3 id="XJOI1634"><a href="#XJOI1634" class="headerlink" title="$XJOI1634$"></a>$XJOI1634$</h3><h4 id="T1-6"><a href="#T1-6" class="headerlink" title="$T1$"></a>$T1$</h4><p>$O(n2^{n/2})$ 状压，想到了但是要 $EXCRT$ 合并 /肋木</p>
<h4 id="T2-6"><a href="#T2-6" class="headerlink" title="$T2$"></a>$T2$</h4><p>原题 $BZOJ3838$.</p>
<p>hhz 一语道破天机：模拟费用流模拟的是最短路增广的过程——换用数据结构维护流。这类题一般鬼畜，但容易建出费用流模型，发现模型一般很简单，就可以考虑它增广到底在干啥了。推荐做题：<a href="https://loj.ac/p/6405" target="_blank" rel="noopener">$Conquer the World$</a></p>
<p>建出模型：’(‘ 向源点连边，’)’ 向汇点连边，$K / 2$ 次增广跑费用流。模型非常简单，考虑模拟费用流！</p>
<p>这费用流在干啥？每次取一对括号, 位置分别为 $l$ 和 $r$, 如果取的是 ‘()’ 则对 $[l, r)$ 区间 $+1$；如果取的是 ‘)(‘ 则对 $[r, l)$ 区间 $-1$，同时要非负。</p>
<p>就可以线段树维护取的过程，维护一堆量：</p>
<ul>
<li>$tag$</li>
<li>$min$（假定区间最小值为 $0$，以最小值为参照考虑某个 $a$ 或 $b$ 能否取）</li>
<li>$min_a$, $min_b$（区间最小 $a$/$b$）</li>
<li>$lmin_a$, $rmin_b$（为了不跨越最小值，区间被分成许多段，显然我们合并时只用到最左段最小 $a$ 和最右段最小 $b$）</li>
</ul>
<p>还有一种做法——带悔贪心，从左往右插入 ‘(‘ 和 ‘)’，’)’ 的时候可以选新的 ‘(‘ 也可以选一个以前匹配掉的 ‘(‘。所以匹配上还要丢一个 $-a[]$ 以备反悔。但是这样还是错的，因为没有每次个数增加 $1$ 的阶段性。有神仙曰：$wqs$ 二分，<strong>就可以丢掉个数的限制了！</strong> 二分斜率 $k$，匹配上要丢的东西就变成 $-a[] - k$ 了。</p>
<h4 id="T3-6"><a href="#T3-6" class="headerlink" title="$T3$"></a>$T3$</h4><p>这题不难，想到正解了。</p>
<p>最终是很多个断开的连续段，考虑某个区间是否可以作为连续段，只要维护每个位置向左最远位置（$mn$）和向右最远位置（$mx$），树状数组 $O(nlogn)$。</p>
<p>$dp$，$dp[i]$ 表示 $i$ 为最后一个连续段右端点的 $dp$ 值，显然当 $p$ 为左端点时贡献是 $sum[p - 2]$，$sum$ 是 $dp$ 数组前缀和。</p>
<p>枚举右端点 $r$，我们只要维护左端点在 $[mn[r], r]$ 中且向右最远位置 $\geq r$ 的连续段贡献就好，发现这样连续段左端点随着右端点单调，于是可以树状数组做。</p>
<p>发现自己想到解法，说出来或者写出来会清楚很多。没啥好说的，暴力都写挂了！！！（后来发现 bug 在预处理最远位置 = =</p>
<h3 id="珍珠"><a href="#珍珠" class="headerlink" title="$珍珠$"></a><a href="https://loj.ac/p/3120" target="_blank" rel="noopener">$珍珠$</a></h3><p>写在「生成函数」里了。</p>
<p><a href="https://loj.ac/s/1019774" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="ICPC-World-Final-2018-Conquer-the-World"><a href="#ICPC-World-Final-2018-Conquer-the-World" class="headerlink" title="$ICPC\ World\ Final\ 2018\ Conquer\ the\ World$"></a><a href="https://loj.ac/p/6405" target="_blank" rel="noopener">$ICPC\ World\ Final\ 2018\ Conquer\ the\ World$</a></h3><p>拆距离为 $dist = dep_x + dep_y - 2 * dep_{lca}$。注意因为强制洞全部满，洞的 $dep$ 可以减去 $\infty$ 最后再加回来。</p>
<p>在每个 $x$ 作为 $LCA$ 时操作掉子树里所有匹配起来贡献 $&lt; 0$ 的对，然后为了在祖先处可以反悔，还要分别丢进堆 $dist - dep_x$ 和 $dist - dep_y$。不会出现路径重合的对因为那肯定不优。</p>
<h2 id="mathcal-12-26"><a href="#mathcal-12-26" class="headerlink" title="$\mathcal{12.26}$"></a>$\mathcal{12.26}$</h2><hr>
<p>学习了最大权闭合子图。</p>
<h3 id="Salty-Fish"><a href="#Salty-Fish" class="headerlink" title="$Salty\ Fish$"></a><a href="https://vjudge.net/problem/HDU-6634" target="_blank" rel="noopener">$Salty\ Fish$</a></h3><p>写在「最大权闭合子图」学习笔记里了。</p>
<h3 id="CF280D-k-Maximum-Subsequence-Sum"><a href="#CF280D-k-Maximum-Subsequence-Sum" class="headerlink" title="$CF280D-k-Maximum Subsequence Sum$"></a><a href="https://www.luogu.com.cn/problem/CF280D" target="_blank" rel="noopener">$CF280D-k-Maximum Subsequence Sum$</a></h3><p>容易建出费用流模型。发现一次增广后沿途的费用被取负，线段树模拟维护流即可。</p>
<p><a href="https://codeforces.com/contest/280/submission/102359458" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="BZOJ4977-跳伞求生"><a href="#BZOJ4977-跳伞求生" class="headerlink" title="[$BZOJ4977-跳伞求生$]"></a>[$BZOJ4977-跳伞求生$]</h3><p>带悔贪心，好像不太可以从模拟费用流的角度解释？按血量升序排序，每个老鼠必须匹配，每个洞不一定要匹配，于是老鼠找已在的未匹配的洞，或者已在的已匹配的洞。这里涉及的反悔操作很简单——消除老鼠的贡献就好。</p>
<h3 id="LOJ6289-花朵"><a href="#LOJ6289-花朵" class="headerlink" title="$LOJ6289-花朵$"></a><a href="https://loj.ac/problem/6289" target="_blank" rel="noopener">$LOJ6289-花朵$</a></h3><p>单独写博客了。</p>
<h3 id="CF995F"><a href="#CF995F" class="headerlink" title="$CF995F$"></a><a href="https://www.luogu.com.cn/problem/CF995F" target="_blank" rel="noopener">$CF995F$</a></h3><p>（感觉这玩意以前在 h2 做到过）</p>
<p>暴力 $dp$, $f[x, c]$ 表示 $x$ 权值为 $c$ 的方案数，则 $f[x, c] = \prod s[y, c]$ 其中 $s$ 是 $f$ 的前缀和</p>
<p>$D$ 太大了，但考虑到只会出现 $n$ 种权值，可以以离散化的思想求出 $f[x, c]$ 表示 $x$ 的权值在当前有的权值中排名第 $c$ 小。但组合数就不能直接求了——出现的权值种类不知道。</p>
<p>考虑 $f[1, i]$ 是啥，就是用了 $\leq i$ 种权值且一定用了第 $i$ 种权值的方案数，那容斥不就好了么？</p>
<p>$$F[i] = f[1, i] - \sum\limits_{j = 1}^{i - 1} C(i - 1, j - 1) * F[j]$$</p>
<p><a href="http://codeforces.com/contest/995/submission/102377434" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-27"><a href="#mathcal-12-27" class="headerlink" title="$\mathcal{12.27}$"></a>$\mathcal{12.27}$</h2><hr>
<h3 id="XJOI1628"><a href="#XJOI1628" class="headerlink" title="XJOI1628"></a>XJOI1628</h3><h4 id="T3-7"><a href="#T3-7" class="headerlink" title="T3"></a>T3</h4><p>构造一个排列使得权值最大——用费用流求解。只有三种连边，线段树优化建图即可。</p>
<h4 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h4><p>一眼广义 SAM 但是根本不会（那是不是不叫“一眼”？</p>
<h3 id="区间本质不同子串个数"><a href="#区间本质不同子串个数" class="headerlink" title="$区间本质不同子串个数$"></a><a href="https://www.luogu.com.cn/problem/P6292" target="_blank" rel="noopener">$区间本质不同子串个数$</a></h3><p>写在「SAM」学习笔记里了。</p>
<h2 id="mathcal-12-28"><a href="#mathcal-12-28" class="headerlink" title="$\mathcal{12.28}$"></a>$\mathcal{12.28}$</h2><hr>
<h3 id="XJOI1634-1"><a href="#XJOI1634-1" class="headerlink" title="$XJOI1634$"></a>$XJOI1634$</h3><h4 id="T1-7"><a href="#T1-7" class="headerlink" title="$T1$"></a>$T1$</h4><p>剖链，每条链做，把小火车拆成 $O(logn)$ 段，一些斜率为 $1$ 和 $-1$ 的线段，求交点。斜率相同要么重合要么同起点，变成一维问题，经典点减边求出相交对数；斜率不同旋转 $45$ 度扫描线，不用点减边。</p>
<h4 id="T2-7"><a href="#T2-7" class="headerlink" title="$T2$"></a>$T2$</h4><p>$T2$ 没做出来太不应该了。反思一下到底是哪儿出了问题？也许我脑袋中有过一闪而过的“枚举最值”的想法。</p>
<p>这题要做个转化——权值 $\geq$ 最小值的边权值不变，权值 $&lt;$ 最小值的边权值为 $0$. 考虑到边只有 $3e3$ 条，依次枚举 + 最短路即可。</p>
<h4 id="T3-8"><a href="#T3-8" class="headerlink" title="$T3$"></a>$T3$</h4><p>二维线段树显然</p>
<h2 id="mathcal-12-29"><a href="#mathcal-12-29" class="headerlink" title="$\mathcal{12.29}$"></a>$\mathcal{12.29}$</h2><hr>
<p>今天放了一堆 $ACM$ 题。抱灵辣</p>
<h4 id="T1-8"><a href="#T1-8" class="headerlink" title="$T1$"></a>$T1$</h4><p>一直在考虑一段的进位。。我是 sb，看哪位直接把那位之前的拎出来记作 $b[i]$, $b[i] + b[j] \geq 10^p$ 就是进位，显然排序 + 双指针算对数就好了。</p>
<h4 id="T2-8"><a href="#T2-8" class="headerlink" title="$T2$"></a>$T2$</h4><p>容易想到笛卡尔树之类的，每个数有一个管辖范围，并且组成新序列的数字顺序不变 $unique$ 后是原数列的一个子序列, $dp[i, j, k]$ 表示到原序列第 $i$ 个，组成新序列前 $j$ 个，（最小）次数为 $k$ 的方案数。</p>
<p>cly 说也可以笛卡尔树上 $dp$，$dp[i, j, k]$ 表示 $i$ 节点前/后缀为 $j$，次数 $= k$ 的方案数，转移要高维前缀和。</p>
<h4 id="T3-9"><a href="#T3-9" class="headerlink" title="$T3$"></a>$T3$</h4><p>利用类似 $Hash$ 的线性探测法即可 $AC$。</p>
<h4 id="T4-1"><a href="#T4-1" class="headerlink" title="$T4$"></a>$T4$</h4><p>在 $\sqrt{S}$ 附近暴搜即可。（$T3$ &amp; $T4$ 都好暴力啊！</p>
<h4 id="T5"><a href="#T5" class="headerlink" title="$T5$"></a>$T5$</h4><p>题目看错 $* n$。首发的 $A$ 和 $B$ 会选两个不同行不同列的，剩下 $6$ 个跟之前选的同行同列的格子，和 $1$ 个不同行不同列的格子，必败状态是 $6$ 个全为 $1$，$1$ 个为 $0$，$sg\ 值\ =\ XOR(\ a[i, j]\ 同行同列\ ?\ a[i, j] - 1\ :\ a[i, j]\ )$</p>
<h4 id="T6"><a href="#T6" class="headerlink" title="$T6$"></a>$T6$</h4><ul>
<li><p>竞赛图即是有向完全图。</p>
</li>
<li><p>$kosaraju$ 是啥？咕一个</p>
</li>
</ul>
<p>听说是 北大集训$2020$ 某题的弱化版。先找一个哈密顿回路（$Graph\ Theory$：竞赛图一定存在哈密顿通路），回路外的边修改都不影响强连通性，而翻转回路上的边会形成链，原本不在回路上的边现在覆盖了一些区间，然后分类讨论，缩点啊什么的。</p>
<h4 id="T7"><a href="#T7" class="headerlink" title="$T7$"></a>$T7$</h4><p>我看到那个 $3$ 操作啊我就大意了！我以为是 $splay$，根本不用的啊！就看作环形移位就好了啊！更改起点就好了啊！被偷袭了啊！</p>
<p><strong>$FLAG$：今明两天搞完 $SAM$，得立刻回去搞 $AGC$ 和集训队作业和 $TC$ 好题了啊，落后于当代 $OI$ 了啊啊。。人傻没救了啊啊。。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OI is full of Theories...</span><br></pre></td></tr></table></figure>
<h2 id="mathcal-12-30"><a href="#mathcal-12-30" class="headerlink" title="$\mathcal{12.30}$"></a>$\mathcal{12.30}$</h2><hr>
<p>时光飞逝，日月如梭，光阴荏苒…（咳咳）xml 还是这么菜！$2021\ is\ coming$！再冲两天就快快乐乐跨年咯 ~</p>
<h3 id="BJWC2018-Border-的四种求法"><a href="#BJWC2018-Border-的四种求法" class="headerlink" title="$BJWC2018-Border 的四种求法$"></a><a href="https://www.luogu.com.cn/problem/P4482" target="_blank" rel="noopener">$BJWC2018-Border 的四种求法$</a></h3><p>写在「SAM」里了。</p>
<h3 id="CF1326F2"><a href="#CF1326F2" class="headerlink" title="$CF1326F2$"></a><a href="https://codeforces.com/contest/1326/problem/F2" target="_blank" rel="noopener">$CF1326F2$</a></h3><p>$nb$ 题。容易想到 $dp$ 出集合 $s$ 里的点形成链的方案数再拼起来，但这不对因为连接处点不一定没边。</p>
<p>考虑子集反演。设答案数组为 $f$，则设 $g[S] = \sum\limits_{S \subseteq T} f[T]$，从意义上理解 $g$ 就是任选一些链，不管连接处，拼起来的方案数。只要求出 $g$ 就好了。</p>
<p>对于链长度集合相同的方案只是交换顺序，方案数相同，我们仅考虑枚举 $n$ 的分拆。</p>
<p>直接 $dp$（$dp’[s] = \sum dp[s - t] <em> g[t]$）要做 $n$ 的拆分数次子集卷积，复杂度大约是 $P(n) </em> n * 2^n$, 吃不消。</p>
<p>有神仙用容斥优化：对 $dp$ 进行容斥，捕捉容斥切口：令 $g[s]$ 表示使用 $s$ 集合里的点构成的某些长度的链方案数，$dp$ 若重复用点则必然会漏掉一些点不用，就可以容斥了。快在哪儿呢？原先中途边枚举拆分边卷，现在只要枚举完卷一次再容斥一次，复杂度是 $P(n) * 2^n$ ——稳了！</p>
<p><a href="https://codeforces.com/contest/1326/submission/102753163" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="mathcal-12-31"><a href="#mathcal-12-31" class="headerlink" title="$\mathcal{12.31}$"></a>$\mathcal{12.31}$</h2><hr>
<p>跨大年辣！！！！！<del>这篇博客也完结了QWQ</del></p>
<h3 id="XJOI1639"><a href="#XJOI1639" class="headerlink" title="$XJOI1639$"></a>$XJOI1639$</h3><h4 id="T1-9"><a href="#T1-9" class="headerlink" title="$T1$"></a>$T1$</h4><p>hhz: 这么输入只有两种目的：1. 加快读入 2. 数据随机。这题明显是随机。</p>
<p>这是道误差分析题，任何数除以 999… 都是循环节，想到把 $\lfloor \frac{x}{111…} \rfloor$ 变成 $\lfloor \frac{9x}{10^i - 1} \rfloor$。整数位先加，再加小数位。</p>
<p>然后咕咕了，实在变态啊。。</p>
<h4 id="T2-9"><a href="#T2-9" class="headerlink" title="$T2$"></a>$T2$</h4><p>好题。容易想到 $n^2$ dp: $f[i, j]$ 表示到第 $i$ 位，两支队伍结尾分别是当前最高高度位置（这是固定的）和 $j$ 的最小不满度。这大概是没有前途的思路。</p>
<p>考虑另一种暴力: 设 $Max$ 为当前出现的最大高度，$max$ 为当前出现的次大高度，$f[i, max]$ 表示到第 $i$ 位，次高高度为 $max$ 的最小不满度，则新加一个 $h$ 进来有两种转移—— $max$ 变与不变。就像最短路一样转移。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">h &gt; Max:</span><br><span class="line">    i  i+1</span><br><span class="line"> 低  ○   ○</span><br><span class="line">     ○ ↘ ○ 边权 0</span><br><span class="line"> 高  ○   ○</span><br><span class="line"></span><br><span class="line">h &lt; Max:</span><br><span class="line">    ○ → ○ 边权 max - h</span><br><span class="line">    ○   ○</span><br><span class="line">    ○   ○</span><br><span class="line"></span><br><span class="line">    ○ → ○ 边权 a</span><br><span class="line">    ○ → ○ 边权 a + 1</span><br><span class="line">    ○ → ○ 边权 a + 2</span><br><span class="line">    。。。</span><br><span class="line">    就是加等差数列啦。</span><br></pre></td></tr></table></figure></p>
<p>两种做法，正做反做。</p>
<p>正做需要区间加等差数列和维护前缀 $min$，采取差分思想，等差数列变成区间加常数，离散化下标，利用平衡树维护。</p>
<p>反做就比较巧妙了，相当于反跑最短路，每一列点一定上小下大，为啥？分段证，$h &lt; max$ 时上小下大序列 + 上小下大等差数列，单调性显然；$h &gt; max$ 时只会平移和上移取 $min$，单调性显然。</p>
<p>有了单调性就不用维护前缀 $min$ 了，线段树维护区间加常数、区间取 $min$、区间加等差数列。采取差分思想，变成单点加、区间取 $min$、区间加常数。</p>
<p>PS：这类题其实之前模拟赛遇到过，也是第一种暴力没前途、第二种暴力可以用 $Trie$ 树优化。</p>
<h4 id="T3-10"><a href="#T3-10" class="headerlink" title="$T3$"></a>$T3$</h4><p>设 $f[i, j]$ 表示已经考虑了连续的 $i$ 个，选了里面 $j$ 个人，讨论新加一个人到开头/结尾，有：</p>
<ul>
<li>$f[i, j] = f[i - 1, j] <em> p^j + f[i - 1, j - 1] </em> q^{i - j}$</li>
<li>$f[i, j] = f[i - 1, j] <em> q^j + f[i - 1, j - 1] </em> p^{i - j}$</li>
</ul>
<p>联立解得 $f[i - 1, j]$ 关于 $f[i - 1, j - 1]$ 的递推式，直接推就完事了！！！$f[i - 1, j] = \frac{ p^{i - j} - (1 - p)^{i - j} }{ p^j - (1 - p)^j } f[i - 1, j - 1]$，注意判 $p = \frac{1}{2}$ 的情况。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/【学习笔记】生成函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/06/【学习笔记】生成函数/" itemprop="url">
                  【学习笔记】生成函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-06T23:14:05+08:00">
                2020-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>运气好的话也许不用重修？感觉挺好理解呀！</p>
<h2 id="无趣的-基本概念和技术"><a href="#无趣的-基本概念和技术" class="headerlink" title="无趣的$基本概念和技术$"></a><del>无趣的</del>$基本概念和技术$</h2><hr>
<ul>
<li>约定：$f’(x)$ 表示对 $f(x)$ 求导</li>
</ul>
<p>生成函数的系数从具体的数被推广到了<strong>形式幂级数</strong>。</p>
<p>大小函数：好难说清楚？就是比如某个生成函数第 $n$ 项的大小函数 $= n$。不同的情境下大小函数被赋予不同的实际意义。</p>
<p>普通生成函数：OGF</p>
<ul>
<li>无标号xx计数</li>
</ul>
<p>指数生成函数：EGF</p>
<ul>
<li>有标号xx计数，是泰勒级数的形式。合并的时候会 $C(n + m, n)$ 重新分配标号：$[x^n]f(x) = a_n\frac{x^n}{n!}$, $[x^m]g(x) = b_m\frac{x^m}{m!}$, 合并起来就对 $[x^{n + m}]$ 有贡献：$a_nb_m\frac{x^{n + m}}{n!m!}$。</li>
</ul>
<p>泰勒级数：</p>
<ul>
<li><p>$e^x = \sum\limits_{k \geq 0} \frac{x^k}{k!}$</p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/7681487?fr=aladdin" target="_blank" rel="noopener">泰勒展开</a></p>
</li>
</ul>
<p>求导：$x^n = nx^{n - 1}$，与生成函数的左移位相对应。</p>
<p>求积分：$\int x^n dx = \frac{1}{n + 1} x^{n + 1}$，与生成函数的右移位相对应。</p>
<p>乘法逆元：</p>
<ul>
<li><p>$A(x)B(x) \equiv 1 \pmod {x^n}$</p>
</li>
<li><p>$A(x)$ 有乘法逆元的充要条件是 $A(x)$ 的常数项有乘法逆元。必要性：$[x^0] A(x) [x^0] B(x) = 1$</p>
</li>
<li><p>有<a href="https://www.luogu.com.cn/paste/2x7n21r1" target="_blank" rel="noopener">求法</a>,（注：这里的 $B’$ 不是求导，就是单纯表示另一个生成函数）每次算出 $2B’ - AB’^2$ 赋给 $B$，每次规模减小一半，$T(n) = T(n/2)+O(nlogn) = O(nlogn)$（是不是很像牛顿迭代？）</p>
</li>
</ul>
<p>复合逆：若对于俩函数 $f(x)$ 和 $g(x)$ 而言有 $g(f(x)) = x$，则可以看作 $x$ 在 $g \cdot f$ 的作用下保持不变，称 $g$ 为 $f$ 的复合逆。<strong>对 $f$ 和 $g$ 有要求：常数项为 0 且一次项系数不为 0</strong>。</p>
<ul>
<li><p>有结论：若 $g(f(x)) = x$ 则 $f(g(x)) = x$，$f$ 与 $g$ 互为复合逆。</p>
</li>
<li><p>有求导方式：$f(g(x))’ = f’(g(x))g’(x)$</p>
</li>
<li><p>有求法：👇</p>
</li>
</ul>
<p>求法就是拉格朗日反演：</p>
<ul>
<li><p>已知 $f(x)$ 求 $g(x)$，$[x^n] g(x) = \frac{1}{n} [w^{n - 1}] (\frac{w}{f(w)})^n$</p>
</li>
<li><p>推广形式：$[x^n]h(g(x)) = \frac{1}{n} [w^{n - 1}] h’(w) (\frac{w}{f(w)})^n$</p>
</li>
</ul>
<p>对数函数：$ln$</p>
<ul>
<li><p>$ln(A(x)) = \sum\limits_{i \geq 1} \frac{A(x)^i}{i}$</p>
</li>
<li><p>有结论：$ln’(x) = \frac{1}{x}$</p>
</li>
<li><p>有求法：$ln(A(x)) = \int (ln A(x))’ = \int \frac{A’(x)}{A(x)}$，所以对 $A(x)$ 求导作为 $a$，求逆作为 $b$，$a * b$ 再积分就得到了 $ln$。</p>
</li>
</ul>
<p>指数函数：$exp$</p>
<ul>
<li><p>$exp(A(x)) = \sum\limits_{i \geq 0} \frac{A(x)^i}{i!}$</p>
</li>
<li><p>有求法：👇</p>
</li>
</ul>
<p>求法就是牛顿迭代：</p>
<ul>
<li>设 $f(x) = e^{A(x)}$, 则得到方程 $g(f(x)) = ln(f(x)) - A(x) = 0$. 设已求得 $f$ 前 $n$ 项 $f_0(x)$，即 $f(x) \equiv f_0(x) \pmod {x^n}$. 对 $g(f(x))$ 作泰勒展开，整理可得 $f(x) \equiv f_0(x) - \frac{g(f_0(x))}{g’(f_0(x))} \pmod {x^{2n}}$, 带入 $g(f(x))$ 定义可得 $f(x) = f_0(x)(1 - ln(f_0(x)) + A(x))$，按此迭代，$T(n) = T(n/2)+O(nlogn) = O(nlogn)$</li>
</ul>
<p>对数函数和指数函数的性质在这里仍然成立。</p>
<p>多项式快速幂：求 $A(x)^k$</p>
<ul>
<li>直接快速幂是 $O(n\ logn\ logk)$ 的</li>
<li>有 $O(nlogn)$ 求法：$A(x)^k = exp(k\ ln\ A(x))$</li>
</ul>
<h2 id="有趣的表示！"><a href="#有趣的表示！" class="headerlink" title="$有趣的表示！$"></a>$有趣的表示！$</h2><hr>
<p>有标号简单无向图的 EGF：$G(x) = \sum\limits_{n \geq 0} 2^{\binom{n}{2}} \frac{x^n}{n!}$</p>
<p>有标号无向连通图的 EGF：$C(x) = ln(G(x))$</p>
<p>无标号环的 OGF：$-\sum\limits_{d \geq 1} \frac{\phi(d)}{d} ln(1 - A(x^d))$, $ln(1 - A(x^d))$ 中只有 $n/d$ 项是有用的</p>
<h2 id="有趣的题目！"><a href="#有趣的题目！" class="headerlink" title="$有趣的题目！$"></a>$有趣的题目！$</h2><hr>
<h3 id="城市规划"><a href="#城市规划" class="headerlink" title="$城市规划$"></a><a href="https://www.luogu.com.cn/problem/P4841" target="_blank" rel="noopener">$城市规划$</a></h3><p>$G(x) = e^{C(x)} = \sum\limits_{n \geq 0} 2^{\binom{n}{2}} \frac{x^n}{n!}$，直接求 $ln(G(x))$ 即可</p>
<h3 id="The-Child-and-Binary-Tree"><a href="#The-Child-and-Binary-Tree" class="headerlink" title="$The\ Child\ and\ Binary\ Tree$"></a><a href="https://www.luogu.com.cn/problem/CF438E" target="_blank" rel="noopener">$The\ Child\ and\ Binary\ Tree$</a></h3><h3 id="ZJOI2019-开关"><a href="#ZJOI2019-开关" class="headerlink" title="$ZJOI2019-开关$"></a><a href="https://www.luogu.com.cn/problem/P5326" target="_blank" rel="noopener">$ZJOI2019-开关$</a></h3><p>单写博客了</p>
<h3 id="LOJ6538-烷基计数"><a href="#LOJ6538-烷基计数" class="headerlink" title="$LOJ6538-烷基计数$"></a><a href="https://loj.ac/p/6538" target="_blank" rel="noopener">$LOJ6538-烷基计数$</a></h3><p>慕名而来！</p>
<p>哦，所以无标号计数一般会用到群论那套理论是吗？妈妈我 $burnside$ 学值了！</p>
<p>设烷基生成函数为 $A(x)$。$A(x) = 1 + xA(x)^3$ 显然不行。考虑 $burnside$，一个点只有三个儿子共 $3! = 6$ 种置换：</p>
<ul>
<li>$(1, 2, 3): A(x)^3$</li>
<li>$(1, 3, 2)(3, 2, 1)(2, 1, 3): 3A(x)A(x^2)$</li>
<li>$(2, 3, 1)(3, 1, 2): 2A(x^3)$</li>
</ul>
<p>所以 $A(x) = 1 + \frac{x}{6}(A(x)^3 + 3A(x)A(x^2) + 2A(x^3))$</p>
<p>分治 NTT $O(nlog^2n)$, 牛顿迭代 $O(nlogn)$</p>
<p>我只会分治 NTT。。卷啊卷卷啊卷 就可以了。具体来说卷的方法分别如下：</p>
<ul>
<li>$A(x)^3$: $[l, mid]$ 三次</li>
<li>$3A(x)A(x^2)$: $[l, mid]$ 一次，$[mid + 1, r]$ 一次</li>
<li>$2A(x^3)$: $l \neq 0$ 的时候 $2l &gt; r$，所以 $[l, mid]$ 一次，$[0, r - l]$ 两次；$l = 0$ 的时候 $[l, mid]$ 三次。</li>
</ul>
<p><a href="https://loj.ac/s/1012212" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="LOJ6512-烷烃计数"><a href="#LOJ6512-烷烃计数" class="headerlink" title="$LOJ6512-烷烃计数$"></a><a href="https://loj.ac/p/6512" target="_blank" rel="noopener">$LOJ6512-烷烃计数$</a></h3><p>与上一题的区别也是此题的难点，是<strong>无根树</strong>。不难想到树的重心，甚至 $4$ 个儿子的 $burnside$ 引理你都想好了但还是不知道怎么切入。</p>
<p>设烷烃生成函数为 $B(x)$。</p>
<blockquote>
<p>有结论：$c - d + e = 1$</p>
<p>$c$ 为点等价类个数。两个点在一个等价类中，当且仅当分别以两个点为根的有根树同构。</p>
<p>$d$ 为边等价类个数。两条边在一个等价类中，当且仅当分别删去两条边得到的有根树同构。</p>
<p>$e$ 为是否存在一条边使得断掉后两边以断边端点为根的子树同构。</p>
<p>证明：</p>
<ol>
<li>$e = 0$，根为重心，自成一个等价类；对于剩下的点，它们的父边在同一个边等价类中，当且仅当它们在同一个点等价类中，$c - d = 1$.</li>
<li>$e = 1$，在连接两个重心的边上加入一个点变成有根树，转为情况 1.</li>
</ol>
</blockquote>
<p>推到生成函数形式，$C(x) - D(x) + E(x) = B(x)$</p>
<p>$C(x)$ 可以看作所有不同构的无标号无根树的 $c$ 之和，即所有不同构的无标号有根树个数，$C(x) = \frac{x}{24} ( A(x)^4 + 6A(x)^2A(x^2) + 3A^2(x^2) + 8A(x)A(x^3) + 6A(x^4) )$</p>
<p>$D(x)$ 可以看作在边上加一个点能构成多少个不同的有根树，$D(x) = \frac{(A(x) - 1)^2 + (A(x^2) - 1)}{2}$</p>
<p>$E(x)$ 可以看作同构有根树个数，$E(x) = A(x^2)$</p>
<p><a href="https://loj.ac/s/1012789" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="珍珠"><a href="#珍珠" class="headerlink" title="$珍珠$"></a><a href="https://loj.ac/p/3120" target="_blank" rel="noopener">$珍珠$</a></h3><p>概率生成函数相关。</p>
<p>【白云白兔可爱！喜欢题面】.jpg</p>
<p>巧妙生成函数！$\sum\limits_{i = 1}^D \lfloor \frac{cnt_i}{2} \rfloor \geq m \Rightarrow \sum\limits_{i = 1}^D cnt_i \% 2 \leq n - 2m$，特判不合法情况。</p>
<p>枚举 $cnt_i \% 2 = 1$ 即奇数的个数，设 $odd_i$ 表示有 $i$ 个奇数的方案数，则 $ans = \sum\limits_{i = 1}^{n - 2m}$</p>
<p>$odd$ 是恰好，不好算，二项式反演一波：设 $f$ 表示至少, 接下来就算 $f$</p>
<p>$$odd_i = \sum\limits_{j = i}^D (-1)^{j - i} C(j, i) f_j$$</p>
<p>$$= \sum\limits_j (-1)^{j - i} \frac{j!}{i!(j - i)!} f_j$$</p>
<p>$$= \frac{1}{i!} \sum_j \frac{(-1)^{j - i}}{(j - i)!} j!f_j$$</p>
<p>显然的卷积形式。</p>
<p>会想起数列 ${0, 1, 0, 1, \cdots}$ 的 $EGF$ 为 $\frac{e^x - e^{-x}}{2}$，有：</p>
<p>$$f_k = C(D, k) n! [x^n] ( (\frac{e^x - e^{-x}}{2})^k (e^x)^{D - k} )$$</p>
<p>$$= C(D, k) \frac{n!}{2^k}\sum\limits_{j = 0}^k C(k, j) (-1)^{k - j} e^{(D + 2(j - k))x}$$</p>
<p>$$= \frac{C(D, k)}{2^k} \sum\limits_{j = 0}^k \frac{k!}{j!(k - j)!} (-1)^j (D - 2j)^n$$</p>
<p>$$= \frac{D!}{2^k(D - k)!} \sum\limits_{j = 0}^k \frac{(-1)^j (D - 2j)^n}{j!} \frac{1}{(k - j)!}$$</p>
<p>卷积！完事了。</p>
<h3 id="CF755G-Poland-Ball-and-many-other-Balls"><a href="#CF755G-Poland-Ball-and-many-other-Balls" class="headerlink" title="CF755G-Poland Ball and many other Balls"></a><a href="https://www.luogu.com.cn/problem/CF755G" target="_blank" rel="noopener">CF755G-Poland Ball and many other Balls</a></h3><p>思路简单，适合练习处理生成函数的 Trick。</p>
<p>容易写出 $dp$ 柿子：$f_{n, k} = f_{n - 1, k} + f_{n - 1, k - 1} + f_{n - 2, k - 1}$</p>
<h3 id="1-特征方程"><a href="#1-特征方程" class="headerlink" title="$1. 特征方程$"></a>$1. 特征方程$</h3><p>有递推关系—— $K$ 由 $K$ 和 $K - 1$ 推得，于是设 $F(x)$ 表示 $\sum_k f_{n, k}x^k$, 列出生成函数：$F_n(x) = F_{n - 1}(x) + xF_{n - 1}(x) + xF_{n - 2}(x)$，即 $F_n(x) = (1 + x)F_{n - 1}(x) + xF_{n - 2}(x)$</p>
<p>这玩意长得一脸特征方程，于是引入新的元 $z$，解出 $z = \frac{ 1 + x \pm \sqrt{ 1 + 6x + x^2 } }{2}$</p>
<p>算出递推式的 $c_1$ 和 $c_2$ 以后多项式全家桶就完事了。然而蒟蒻并不会算？</p>
<h3 id="2-倍增"><a href="#2-倍增" class="headerlink" title="$2. 倍增$"></a>$2. 倍增$</h3><p>还是上面那个柿子，不一样的角度看到的是加大步长转移—— 根据中间是否割开一个相邻的块分类讨论，$F_{n + m}(x) = F_n(x)F_m(x) + xF_{n - 1}(x)F_{m - 1}(x)$</p>
<p>$F_{2n}(x) = F_n^2(x) + xF_{n - 1}^2(x)$</p>
<p>$F_{2n - 1}(x) = F_n(x)F_{n - 1}(x) + xF_{n - 1}(x)F_{n - 2}(x)$</p>
<p>$F_{2n - 2}(x) = F_{n - 1}^2(x) + xF_{n - 2}^2(x)$</p>
<p>于是就可以由 $F_n(x)$, $F_{n - 1}(x)$, $F_{n - 2}(x)$ 得到 $F_{2n}(x)$, $F_{2n - 1}(x)$, $F_{2n - 2}(x)$ 啦</p>
<h3 id="3-组合容斥"><a href="#3-组合容斥" class="headerlink" title="$3. 组合容斥$"></a>$3. 组合容斥$</h3><p>这个比较有意思（雾），蒟蒻想写这个方法。不能一上来就说“满脸”/“一眼”之类的话啊，你根本都还没看出门道呢。</p>
<p>枚举两球组的个数，$f(k) = \sum_i \binom{n - i}{k} \binom{k}{i}$。然后就不会了，这玩意咋整啊？</p>
<p>题解有神仙办法，需要你足够灵活：组合意义，先从前 $K$ 个里选任意个，再从剩下的里选 $K$ 个。</p>
<p>这有个蛋用？</p>
<p>隐藏关系：<em>不重复</em>。重复这玩意就可以容斥，设 $F(k)$ 表示恰好重复 $k$ 个，$G(k)$ 表示至少重复 $k$ 个。</p>
<p>$$G(i) = \binom{k}{i} \binom{n - i}{k - i} 2^{k - i}$$</p>
<p>$$F(0) = \sum\limits_{i = 0}^k (-1)^i G(i)$$</p>
<p>$$= \frac{k!}{(n - k)!} \sum\limits_{i = 0}^k \frac{(-1)^i(n - i)!}{i!} \cdot \frac{2^{k - i}}{((k - i)!^2)}$$</p>
<p>$n$ 过大，怎么办？化下降幂。。这其实是一个自然的事情，可能我还没适应罢。</p>
<p>$$= \frac{k!n!}{(n - k)!} \sum\limits_{i = 0}^k \frac{(-1)^i(n - i)!}{i!n!} \cdot \frac{2^{k - i}}{((k - i)!^2)}$$</p>
<p>$$= k!n^{\underline{k}} \sum\limits_{i = 0}^k \frac{(-1)^i}{i!n^{\underline{i}}} \cdot \frac{2^{k - i}}{((k - i)!^2)}$$</p>
<p><a href="https://codeforces.com/problemset/submission/755/102687760" target="_blank" rel="noopener">$Code$</a></p>
<p>注意空间要开足。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/05/【计划】NOIP2020赛前训练小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/05/【计划】NOIP2020赛前训练小结/" itemprop="url">
                  NOIP2020赛前训练小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-05T23:59:59+08:00">
                2020-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开一篇博客，助力 $NOIP2020$</p>
<p>少浪费时间在无意义的自我怀疑中，$you\ do\ have\ a\ lot\ to\ learn$，保持稳定而欣喜的心态 奔跑吧！</p>
<p><em>眼高手低通过练习手会慢慢变高，眼低手低练到死都是菜。</em></p>
<p><em>抱怨身处黑暗，不如提灯前行。愿 11.7 出考场的我不留遗憾！</em></p>
<p><em>不骄，不躁，不惧，不悔。</em></p>
<hr>
<h3 id="9-5"><a href="#9-5" class="headerlink" title="9.5"></a>9.5</h3><p>noi2019D1T1（斜率优化），apio2020T2（kruskal重构树）, 一道线段树优化建图，春节十二响（堆和贪心）</p>
<h3 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h3><p>uoj455（可撤销贪心模拟费用流），luogu4260（计数 + 莫队算组合数前缀和）</p>
<h3 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h3><p>cf558e（线段树区间排序，实质是区间赋值），cf1194f（期望计数 + 复杂度分析），cf round 664 div1 A ~ C</p>
<h3 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h3><p>luogu2542（有点点套路的树剖题），cf1327f（限制dp），uoj209（思维），uoj210（2-sat）</p>
<h3 id="9-9"><a href="#9-9" class="headerlink" title="9.9"></a>9.9</h3><p>loj3158（贪心 + 堆，模拟费用流），uoj58</p>
<h3 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h3><p>9.10 的训练记录被吞了</p>
<h3 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h3><p>cf986c（简单二进制题），loj3303（线段树合并 01 trie），uoj137（巧妙加维 dp），uoj134（图的连通性），牛客练习赛69（ABCE），总结就是切了一天水题</p>
<hr>
<p>我来填坑，初赛 90.5 稳稳飞过，希望复赛也能稳稳的呀 ~ 前段时间太忙了，但是觉得训练小结很重要，希望对自己的程度有清晰的认知。</p>
<h3 id="10-17"><a href="#10-17" class="headerlink" title="10.17"></a>10.17</h3><p>模拟赛简单数论（偏 at 风）+ 背包分治（套路风然而还是不会。。）+ 计数推柿子，感觉自己计数的水平有长进但还不够。<strong>dp 多练！</strong></p>
<h3 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h3><p>cf div2 手速场 4 道。wxw 26 min AC 2E 好强呀！cf 现场真的跟 vp 不一样。结论：<strong>多打 cf！</strong>（有时间 vp 就不错了= =</p>
<p>AT 两道，一是神奇的异或转 % 2 意义下加法，用多项式 gcd 做；二是不难但小巧清新的同余最短路。</p>
<h3 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h3><p>被吞了（忘记记录了</p>
<h3 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h3><p>效率低的一天…qaq 写了 LCT 板子，还有一堆简单题</p>
<h3 id="10-21"><a href="#10-21" class="headerlink" title="10.21"></a>10.21</h3><p>今天也没有模拟赛。。开心 但是有点慌，感觉自己复赛水平十分不稳</p>
<h3 id="10-22"><a href="#10-22" class="headerlink" title="10.22"></a>10.22</h3><p>XJ 模拟赛偏水了，vp cf 远古场（掉信心）吧！还写了两道 at</p>
<h3 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h3><p>今天效率不高。不过开始听课啦！加油加油加加油！！！！</p>
<p>简单题加上对拍都能保证写出了，现在就是长代码的调写和思维要加重训练。</p>
<hr>
<p>CSP 没有考好，前期的训练还是挺浮躁的，心态也没养好。不骄不躁，不惧不悔，坚定的沉静的走自己的计划。继续开坑。</p>
<h3 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h3><p>学了斯坦纳树。做了 THUSCH-巧克力。vp 并订正了 CF185(Div1) BCD。做了 loj2277, loj6033。看到有趣的题会加进题单里的。</p>
<p>ps：我真的好喜欢 LOJ 呀 ~</p>
<h3 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h3><p>To do list：uer 4 和 6 的 T3, 大前天 T3，推柿子</p>
<p>vp 并订正了 CF#FF(Div1) 的 BCD。做了 loj2118。自己推了一个平平无奇的柿子（</p>
<h3 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h3><ul>
<li>今天模拟赛没有 fst！300！（有生之年系列 (<em>◑∇◑)爻(◐∇◐</em>)（虽然大家今天分都很高（但是我和 LMOliver 神仙同分诶（不要乐极生悲= = 平静一点（你的内心戏已经溢出屏幕了^-^</li>
</ul>
<p>To do list: 订正 monisai，uer 4 和 6 的 T3，大大前天 T3</p>
<p>订正了 monisai，做了 uer 4 的 T3</p>
<h3 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h3><p>To do list: uer 6 的 T3，uoj274, 大大大前天 T3，订正 vp, litble * 1</p>
<p>做了 uer 6 的 T3，订正了 vp 的 CF1163C2、E、F</p>
<h3 id="11-23"><a href="#11-23" class="headerlink" title="11.23"></a>11.23</h3><p>To do list: 订正模拟赛、vp，切树游戏, 国王饮水记，时空旅行，loj3057</p>
<p>订正了模拟赛，vp CF516 BCDE，切树游戏</p>
<h3 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h3><p>⚠️ 今天的模拟赛💥了（找借口：比赛的时候穿的太多了</p>
<p>实际上是，跟 T2 刚了比较久，自以为写了正确的做法就丢了，又写了 T3 的 40 分暴力就心满意足以为其他人也不过 40 分，因为我以为 T3 是神仙斜率优化，事实证明我完全想难了！把 w_i 拆开就是个 sb 贪心！所以就炸的很彻底了。人均 300 的场子我 182，得深刻反思了。</p>
<p>不骄不躁，不能因为前两天打得还行就飘了，noip 才是定胜负的一局。不过也别紧张了，毕竟只是人生漫漫长路的一幕而已</p>
<p>还有就是，固定思维是最可怕的，不能因为前两天斜率优化做多了就看啥都是斜率优化，它来个贪心你就猝不及防。前几天打得不错也是因为敢不断去尝试新的角度。（诶，这题这么做好像有高分暴力拿/好像可以艹标）最近题又简单，真的，傻逼题不会做太可怕了（回想起 csp 面对 T3 的无助和赛后的痛心疾首了吗？）</p>
<p><strong>把问题想复杂，本质就是没有仔细分析问题性质！</strong> 果然还是浮躁了吗。</p>
<p><strong>听着 xml！接下来的两周，要避免一切可能会让心躁起来的事情。虽然听着好笑，但的确是这么回事。</strong></p>
<p>To do list: 订正 T4，国王饮水记，vp，bzoj3636，loj3057，洛谷3553、3558</p>
<p>T4 是道没意思的大数据结构，LCT 什么的…?（我不精通 LCT 啊 qaq）本质是个 easy 的阶梯 nim，我竟然一直在想合并咋地咋地。。。都说是阶梯 nim 了！！！果然还是学艺不精吗！！！</p>
<p>胡了国王饮水记（不想写）（只会斜率优化不会贪心），vp CF461 BCDE，bzj3636</p>
<h3 id="11-25"><a href="#11-25" class="headerlink" title="11.25"></a>11.25</h3><p>今天放了以前哥哥给我做过的 mjy 的一套题，T2 不平等博弈我写 sg。。。光荣爆 5pts。另外 T3 假了好几种做法；想到了分治，觉得十分有前途，但是手玩小样例把自己叉了，后来事实证明这是道不可做题，题解写的吧啦长，最小割 dp 是什么神仙玩意啊 (›´ω`‹ )（但是莫名觉得分治有些搭边？</p>
<p>To do list：订正模拟赛 T3，cf468d，loj3057, sp3734，游戏</p>
<p>做了 loj3057, cf468d, sp3734，游戏</p>
<h3 id="11-26"><a href="#11-26" class="headerlink" title="11.26"></a>11.26</h3><p>今天也遭遇了低素质出题人的狂轰滥炸。T3 polya 板题不会，T4 它 n、m、p 的最大值都不在同一档分害我 RE 挂了 80？？？（这年头什么沙雕都有</p>
<p>To do list：订正 vp，学习polya（选），Druzyny，uoj390, 序列, AGC011F</p>
<ul>
<li><p>因为多人讲课（tyy &amp; kqh）所以计划咕了一大半</p>
</li>
<li><p>发现 kqh 讲课非常形象，各种算法都能随便画示意图，大概这样会帮助加深理解。我也试试？！</p>
</li>
</ul>
<p>做了 CF578 的 CDE, Druzyny</p>
<h3 id="11-27"><a href="#11-27" class="headerlink" title="11.27"></a>11.27</h3><p>今天也遭遇了 sb 的自己。第三次在排序前求前缀和了 我是 sb！！！</p>
<p>To do list：订正昨天 F，uoj390，AGC011F，loj3276, 学习 polya &amp; 订正昨天 T3，vp</p>
<p>没错，做不完前面的今天你 xml 就别想 vp。</p>
<p>做了 昨天 F，uoj390，疫情控制，半道 AGC011F，半道 loj3276</p>
<h3 id="11-28"><a href="#11-28" class="headerlink" title="11.28"></a>11.28</h3><p>今天是 Fuyuki 出的多校联考题。没打挂！hoho！280！（其实是数据水，多给我 30（然后打出了 100 80 60 40 这样漂亮的等差数列分</p>
<p>你看人家 万老爷，同样 280，人家 T1 fst 成 0，本来吊打我 100 分呢！不骄不躁，仍要向下扎根，向上结果。我们每一个人都要砥砺前行。</p>
<p>区间向区间连边，如果有序就可以考虑倍增并查集或者线段树优化建图什么的…</p>
<p>To do list: loj3276, 3277, 3278, 学习 polya 订正 T3，AGC011F</p>
<p>做了 loj3276. 所以今天是得意忘形的颓废的一天，超级差评，xml 你清醒一点？？？</p>
<h3 id="11-29"><a href="#11-29" class="headerlink" title="11.29"></a>11.29</h3><p>打了图灵杯，zzq 出的题真的一言难尽。。。</p>
<p>知道有一种快速阶乘算法：<a href="https://www.cnblogs.com/gryzy/p/6015485.html" target="_blank" rel="noopener">https://www.cnblogs.com/gryzy/p/6015485.html</a></p>
<p>To do list：loj3277，loj3278，vp cf，AGC011F，哥哥的 SRM</p>
<p>做了 loj3277，loj3278，vp CF657 AB</p>
<h3 id="11-30"><a href="#11-30" class="headerlink" title="11.30"></a>11.30</h3><p>最近联考题，质量比 XJ 自己的模拟赛好多了！！！（感觉像饿久了的孩子吃到肉的心情</p>
<p>带悔贪心真的喵喵!! ,,ԾㅂԾ,,</p>
<p>To do list: 订正 CF657 CDE，AGC011F，订正模拟赛，loj3275, loj3271, loj3281，哥哥的 SRM</p>
<p>订正 CF657 CDE、模拟赛，做了 AGC011F, loj3271</p>
<ul>
<li>写反悔贪心的总结？今天 T4 + 雪灾与外卖（模拟费用流也安排上）</li>
</ul>
<h3 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h3><p>今天几乎 AK 了。。题还不错吧我觉得（？）T4 纯粹是写法问题啦。。在线线段树就是跑不过离线树状数组嘛，无论从空间还是时间上看。</p>
<p>To do list：订正 T4，loj3275, vp，哥哥的 SRM，bzoj3864</p>
<p>订正 T4，vp CF673 EF，loj3275</p>
<h3 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h3><p>csp T2 题目漏掉一句话，写了离散化被卡了 35 分。。。<strong>xml 你不要再读错题了啊！</strong></p>
<p>为了不读错题，第一遍就要很认真很仔细。我觉得最好的办法就是开考通读所有题，这时候因为还没开调，心态是比较稳健的。关于数据范围、段末段中的细节之处，各种奇怪的“保证”，切莫忽视了！而且第一遍如果读错，后面就极容易陷入惯性思维，就无意中犯下了比赛大忌。</p>
<p>关于今天的模拟赛，搬了 LOJ 首页 COCI2020 四道原题。。。T2 本该想出来的，树的重心也没错，但同一个子树里也可以选两个小子树啊。。T3 树形 dp 没写出来，细节贼多。。T4 口胡应该是对的，笛卡尔树 + 线段树维护凸包（或维护单调栈，应该差不离），但好难写的感觉 = = 有些许自闭。。。</p>
<p>「我会变成一个更好的人吗 / 相比自己 相比昨天 / “你会啊”」</p>
<p>To do list: 订正 T2、T3、T4，订正昨天 vp 的 F，loj3280，bzoj3864, 哥哥的 SRM，麻将</p>
<p>订正了 T2，T3，T4，昨天 F，bzoj3864, loj3272</p>
<h3 id="12-3"><a href="#12-3" class="headerlink" title="12.3"></a>12.3</h3><p>今天 T2 暴力没挂！rush 了 T2 两只 log 做法结果 wa 得渣都不剩 😊💢 T1 人类智慧题我认输（虽然不难），T3 其实不难想！考场上就以为只有 LCT 能做，实际上把操作放到树形结构上看就可以用清真的并查集维护。</p>
<p>感觉自己最近懂得东西多一些了，就老把题往难了想（还是菜的一种体现），许多题都有清真的精妙做法啊。</p>
<p>To do list: 订正模拟赛 T2、T3，loj3280，vp，游园会，麻将，哥哥的 SRM，xza 场</p>
<ul>
<li>套路：简单 dp 展开，如 f[i] = min(f[i - 1] + 1, a[i]) 可展开成 f[r] = min(f[l - 1] + 1, a[l], a[l + 1], … a[r]) 然后就能上数据结构了。</li>
</ul>
<p>订正了 T3、T2，vp 了 CF806 D（E 口胡，F 挖坑。。）loj3280（口胡）, 游园会（我爱 dp 套 dp！）</p>
<h3 id="12-4"><a href="#12-4" class="headerlink" title="12.4"></a>12.4</h3><p>考前最后一天！奥利给！！！</p>
<p>To do list：订正 vp，麻将，哥哥的 SRM，xza 场，loj3280，loj6302，一些回顾。</p>
<ul>
<li>看<a href="https://www.cnblogs.com/owenyu/p/7815234.html" target="_blank" rel="noopener">这个</a></li>
</ul>
<p>没完没了的自闭，xml 你烦不烦啊你！</p>
<p>今天模拟赛，信心赛，却接连读错两道题。要是在明天的 NOIP 考场上因为读题失分那真是追悔莫及了啊！不要让未来为了自己的傻逼买单。因为明天就要比赛，今天的心态不平和。要是这样到明天的赛场上岂不是重蹈 CSP 的覆辙？沉稳下来，专注于题目，有时间一定要对拍。</p>
<p>是挑战，也是机遇。Hope it can bring out the best in me.</p>
<p>做了 麻将！loj6302，loj3280, 订正了 vp 的 D</p>
<p>定一下明天的考试策略：开场读题，认真仔细，pdf 荧光笔划出坑点，考虑每道题的时间布局；打题仔细严谨，注意空间和模数不为 0 等坑点，很久都调试不出来不如先弃掉去写其他题的暴力；最后检查一遍思路和代码实现有无手误，最后五分钟编译一次，删除调试语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace NOIP &#123;</span><br><span class="line">    struct OIer &#123;</span><br><span class="line">        int rp = inf;</span><br><span class="line">    &#125; xml;</span><br><span class="line">&#125; NOIP2020;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while(1) NOIP2020::xml.rp++!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h3><p>垃圾构造毁我青春。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/05/【计划】NOIP2020 前的做题记录整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/05/【计划】NOIP2020 前的做题记录整理/" itemprop="url">
                  NOIP2020 前的做题记录整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-05T23:58:59+08:00">
                2020-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NOIP 前也做了不少好题！但是依然考的那么差。。。QAQ 每道题都很好！但太难了都没做太深入的思考 QAQ。。。所以接下来到 NOIP2021 的 300 多天要尽可能争取完整的做出题。</p>
<h1 id="立下-Flag（希望它永远不倒）：每天都自己独立做出一道有质量的题"><a href="#立下-Flag（希望它永远不倒）：每天都自己独立做出一道有质量的题" class="headerlink" title="立下 Flag（希望它永远不倒）：每天都自己独立做出一道有质量的题"></a>立下 Flag（希望它永远不倒）：每天都自己独立做出一道有质量的题</h1><h3 id="ZJOI2019-麻将"><a href="#ZJOI2019-麻将" class="headerlink" title="$ZJOI2019-麻将$"></a><a href="https://loj.ac/p/3042" target="_blank" rel="noopener">$ZJOI2019-麻将$</a></h3><hr>
<p>$dp$ 套 $dp$ 就是状态间的转移也有 $dp$ 关系，$f[i]$ 转移到 $f[j]$, $i$ 和 $j$ 有 dp 关系。所以要 $dp$ 预处理状态和状态的转移边。（这不就是自动机嘛？）</p>
<p>我们需要对子数和面子数来表示摸出的牌的状态。</p>
<p>刻子用到的是同种牌，所以可以转移时枚举个数，不用表示到状态里因为对后续无影响。</p>
<p>对后续有影响的就是顺子。<br>$f[i, 0/1, j, k]$ 表示考虑到第 $i$ 种牌，是否有过对子，我决定分出的 $(i - 1, i, i + 1)$ 型的顺子个数为 $j$，我决定分出的 $(i, i + 1, i + 2)$ 型的顺子个数为 $k$，此时已经凑出的最大面子数。<br>于是转移到 $i + 1$ 的时候 $j + k$ 张和之前的组顺子（此时有 $j$ 个面子诞生了）<br>$j$, $k$ 必然不会大于 2 否则就是三张刻子（数量相等的情况下优先凑刻子）<br>发现用 $cnt$（对子个数）和 $f[0/1, j, k]$ 就可以表示状态。</p>
<p>因为你发现这就是个在状态间不断转移的跳 $n$ 步的东西，所以可以命名为“麻将自动机” 2333！<br>自动机上的节点表示的状态就是把 $cnt$ 和 $[0/1, j, k]$ 压在一块<br>参照在 $AC$ 自动机上 $dp$ 的套路，我们敲定最终 $dp$ 状态：$f[i, j, k]$ 表示考虑到第 $i$ 种牌，在自动机上第 $j$ 个节点，共摸了 $k$ 张牌的方案数</p>
<p>根据期望的线性性和整数概率公式，我们可以把答案拆分为 $P$ 的权值的每个 $1$ 对答案的贡献，即每个时刻没胡牌的方案数 $*$ 概率。<br>那个方案数直接取自动机上的就好，因为能待在自动机上的就一定没胡。</p>
<p>仔细想想好像之前写的两道 $dp$ 套 $dp$ 也很自动机啊。</p>
<p><a href="https://loj.ac/s/1005925" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="LOJ3280-首都城市"><a href="#LOJ3280-首都城市" class="headerlink" title="$LOJ3280-首都城市$"></a><a href="https://loj.ac/p/3280" target="_blank" rel="noopener">$LOJ3280-首都城市$</a></h3><hr>
<p>考虑选颜色 a 会让颜色 b 也必选，不妨 a -&gt; b 连边。但是颜色 -&gt; 颜色连边不容易，考虑让点作为中转站，颜色 -&gt; 点 (可以通过树上倍增优化建图) 再 点 -&gt; 颜色。</p>
<p><a href="https://loj.ac/s/1006784" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="CF673F-Bearish-Fanpages"><a href="#CF673F-Bearish-Fanpages" class="headerlink" title="$CF673F-Bearish Fanpages$"></a><a href="https://www.luogu.com.cn/problem/CF643D" target="_blank" rel="noopener">$CF673F-Bearish Fanpages$</a></h3><hr>
<p><del>嘟嘟</del>读懂题意你就会发现这是道模拟题。因为根据老套路，修改只要改对父亲的，父亲对儿子的查询时加上。（所以它为什么黑了啊？</p>
<p>这题巨烦奥！一个点的度数影响它的儿子，它的父亲，它自己</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; f -&gt; ff -&gt; fff</span><br><span class="line">    son   son   son</span><br><span class="line">    val   val</span><br><span class="line">    deg</span><br><span class="line">（下面是影响的东西）</span><br></pre></td></tr></table></figure>
<p>但是怎么处理父亲度数变了，儿子在全局 set 里的变化呢？我们对每个点开一个 set，维护其儿子集合的最大最小权值。所以全局 set 其实装的就是每个 set 的最大最小权值。</p>
<p><a href="http://codeforces.com/contest/643/submission/100179942" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="CF806D-Perishable-Roads"><a href="#CF806D-Perishable-Roads" class="headerlink" title="$CF806D-Perishable Roads$"></a><a href="https://www.luogu.com.cn/problem/CF773D" target="_blank" rel="noopener">$CF806D-Perishable Roads$</a></h3><hr>
<p>首先会想到贪心的把点都挂到最短边的一端，像个扫帚。但这是有问题的：如果最短边与根不直接相连，有些点就处于根到最短边的路径上，没法挂过去。</p>
<p>将除了最短边外的所有边权值减去最短边权值，跑根到最短边的最短路就好。</p>
<h3 id="LOJ3385-Svjetlo"><a href="#LOJ3385-Svjetlo" class="headerlink" title="$LOJ3385-Svjetlo$"></a><a href="https://loj.ac/p/3385" target="_blank" rel="noopener">$LOJ3385-Svjetlo$</a></h3><hr>
<p>被出到模拟赛里了。考场上我的 dp 状态是 $f[x, 0/1, 0/1]$ 表示 $x$ 回不回来，$x$ 当前的颜色。然而巨难写！（而且还是错的。正解 $f[x, 0/1/2, 0/1]$ 表示 x 子树内的路径接口状态和 x 当前的颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f 的定义是 包括起始点，也包括终点。</span><br><span class="line">0: ⬇️⬆️  1: ⬆️或⬇️  2: ⬆️⬇️</span><br></pre></td></tr></table></figure></p>
<p>这种状态设计是怎么想到的呢？<br>一条路径，由：⬆️ / ⬇️⬆️ / ⬇️ 三部分组成，其中一和三都最多只有一个；为了方便讨论，我们规定单个点也可以看作 ⬆️ 或 ⬇️。dp 就可以像背包一样做了。</p>
<p><a href="https://loj.ac/s/1003823" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="LOJ3370-Histogram"><a href="#LOJ3370-Histogram" class="headerlink" title="$LOJ3370-Histogram$"></a><a href="https://loj.ac/p/3370" target="_blank" rel="noopener">$LOJ3370-Histogram$</a></h3><hr>
<p>还是模拟赛题 QAQ（口胡差点正确！耶！</p>
<p>我口胡的是按 $a$ 降序分治（就是笛卡尔树），每个块用两个线段树维护两个单调栈然后上线段树合并，但那样好像有亿点蛋疼（因为笛卡尔树分治 $n$ 次，单次查询 &amp; 合并只能是 $log$ 级别的</p>
<p>正解就是简单粗暴，每次把区间划两半的分治，计算跨中点的区间贡献。</p>
<p>讨论 $a$ 和 $b$ 最小值同在一边和不在一边两种情况。同在一边是有单调性的，直接双指针。不在一边的话就要麻烦一些：考虑 $b$ 最小值在左边，现在要在右边找一个 $a$ 最小值。</p>
<p>设 $r_1$ 比 $r_2$ 优，则 $a[r_1] <em> b </em> (r_1 - l + 1) \geq a[r_2] <em> b </em> (r_2 - l + 1)$<br>化成斜率优化的柿子就是 $(a[r_2] <em> (r_2 + 1) - a[r_1] </em> (r_1 + 1)) / (a[r_2] - a[r_1]) \geq l$，而 $l$ 单调递减。</p>
<p>线段树维护凸包就可以支持区间查询啦！$O(n log^2 n)$ 因为有 $logn$ 个区间，每个区间要 $logn$ 凸包查询</p>
<p><a href="https://loj.ac/s/1004609" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-汉堡肉"><a href="#JOI2020-汉堡肉" class="headerlink" title="$JOI2020-汉堡肉$"></a><a href="https://loj.ac/p/3272" target="_blank" rel="noopener">$JOI2020-汉堡肉$</a></h3><hr>
<p>很妙啊！（$K \geq 4$ 就是人类智慧题</p>
<p>首先四个签只会出现在四条线上：$max(L)$, $min(R)$, $max(D)$, $min(U)$。</p>
<p>证明：</p>
<ol>
<li>$max(L) \leq min(R)$, $max(D) \leq min(U)$，只要往围成的矩形里插一根签</li>
<li>$max(L) &gt; min(R)$, $max(D) \leq min(U)$，$max(L)$ 右边必然有签，$min(R)$ 左边必然有签，并且两边的签通过平移都可以移动到两条线上。另一种相反情况也如此。</li>
<li>$max(L) &gt; min(R)$, $max(D) &gt; min(U)$，道理同上。</li>
</ol>
<p>证毕。</p>
<p>$max$ 和 $min$ 非常好，为什么？以 $max(L)$ 为例分析，首先它右边必定要有签，在有签的情况下这签尽量左又是最优的，而竖直方向对它无影响因为已经是 $max$ 了。</p>
<p>$K \leq 3$ 根据抽屉原理就一定有签出现在交点上了。有签在交点上的情况可以直接暴搜出解（每次选交点，删掉覆盖到的矩形，剩下的继续递归选交点）。剩下就是签都在线段上的情况。</p>
<p>首先某块汉堡肉如果相邻三边都是以上那四种线段之一（即包含了一整条边），它必定插签，可以不用考虑；否则离散化（不用真的离散化）矩形边坐标，对每条边可以单独做前后缀连边的 $2-SAT$。</p>
<p>严谨地说，要判无解，但是本题保证有解 qwq</p>
<p>然后这题随机化也能艹过去，好像是什么分 $K$ 类，每类算矩形并，让矩形并最大</p>
<p><a href="https://loj.ac/s/1002813" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-建筑装饰4"><a href="#JOI2020-建筑装饰4" class="headerlink" title="$JOI2020-建筑装饰4$"></a><a href="https://loj.ac/p/3271" target="_blank" rel="noopener">$JOI2020-建筑装饰4$</a></h3><hr>
<p>$n^2$ dp 还是很好想的。$dp[i, 0/1, j]$ 表示到 $i$，第 $i$ 位是否为 $A$，选了 $j$ 个 $A$ 的值，只为 $1$ 或 $0$。有一种做法是（猜）结论：$dp[i, 0/1]$ 值为 $1$ 的是一段区间。归纳可证？但是这就没意思了啊 qwq</p>
<p>考虑其他做法。不妨交换状态与值：$dp[i, 0/1, 0/1]$ 表示到 $i$，第 $i$ 位是否为 $A$，$A$/$B$ 的最多个数能是多少。容易记录路径。输出方案时从后往前。</p>
<p><a href="https://loj.ac/s/1001454" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-有趣的-Joitter-交友"><a href="#JOI2020-有趣的-Joitter-交友" class="headerlink" title="$JOI2020-有趣的 Joitter 交友$"></a><a href="https://loj.ac/p/3275" target="_blank" rel="noopener">$JOI2020-有趣的 Joitter 交友$</a></h3><hr>
<p>最大值是唬你的，就是能关注则关注。考虑一个关注事件会有什么“副产品”：所有和 $B$ 用户互相关注的 $C$ 都会被 $A$ 关注。这互相关注的关系具有传递性，关注关一团，启发我们把有双向边的点对缩点。发现答案等于 $\sum_S sz(S)(sz(S) - 1) + sz(S)in_deg(S)$</p>
<p>现在要合并两个团，要维护 $sz(sz - 1)$ 和 $sz * in_deg$ 的变化，还要合并 $in$ 和 $out$ 的点对。用启发式合并 + set 存入边出边 + 并查集（合并的时候把信息都拢到根上，并查集帮助找根）可以做到 $O(nlog^2n)$！</p>
<p>还有一个细节，合并可能造成连锁反应，那么对于新的要合并的点对递归处理就好。</p>
<p><a href="https://loj.ac/s/1002124" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-遗迹"><a href="#JOI2020-遗迹" class="headerlink" title="$JOI2020-遗迹$"></a><a href="https://loj.ac/p/3276" target="_blank" rel="noopener">$JOI2020-遗迹$</a></h3><hr>
<p><a href="https://blog.csdn.net/qq_39972971/article/details/105074251" target="_blank" rel="noopener">CCCOrz</a></p>
<p><a href="https://blog.csdn.net/jokerwyt/article/details/105116540" target="_blank" rel="noopener">CCCOrz</a></p>
<p>很妙的题！没有思路，一定先剖析这个操作的原理：怎么找长度为 $2N$ 的序列的结果序列。</p>
<p>发现其中一种方法是从后往前，对于每个 $a[i]$ 如果 $\leq a[i]$ 有空着的位置就选 $i$ 并且填上空位。发现这种方法很利于 $dp$。有个 $simple$ 的想法是 $O(n2^n)$ 的状压，$dp[i, S]$ 表示 $i$ ~ $2N$ 选的位填的集合是 $S$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不选：系数为 j - [已填的位置数]</span><br><span class="line">要选：f[i, j] = f[i + 1, j]</span><br><span class="line">     f[i, j + k] = f[i + 1, j] * C([i ~ 2N 要选的位置数] - j, k - 1) * (k + 1) * g[k - 1, k - 1] * fac[k - 1]</span><br><span class="line">     （不与 1 相连的 贡献可以之后算 —— 这步实在太妙了，避免了记录状态）</span><br><span class="line">    其中 g[i, j] 表示 j 个关键位填了 &lt;= i 的数，dp 预处理的时候要满足 [1, i] 内的个数 &lt;= i</span><br></pre></td></tr></table></figure></p>
<p>最后除以 $2^n$，因为我们在一开始就决定为了方便，把两个相同的数也看作有标号的。</p>
<p>这题的某个难点在于“虚实结合”，实际填的数在最后对应的是另一个数</p>
<p><a href="https://loj.ac/s/999539" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-星座-3"><a href="#JOI2020-星座-3" class="headerlink" title="$JOI2020-星座 3$"></a><a href="https://loj.ac/p/3277" target="_blank" rel="noopener">$JOI2020-星座 3$</a></h3><hr>
<p>大声喊出来：网 格 图 的 套 路 是 什 么？——笛——卡——尔——树</p>
<p>（大雾</p>
<p>每次从最大的位置 $x$ pia 开，星空被分成三部分：左，$x$ 头顶的，右</p>
<p>$dp[x, i]$ 表示笛卡尔树第 $x$ 个节点最大的位置头上最高的星星高度为 $i$。合并的时候三部分只能有最多一颗星星比最大位置高。用 $pair$（最高星星高度 + $dp$ 值）+ $set$ 可以轻松实现，启发式合并 $O(n log^2 n)$</p>
<p><a href="https://loj.ac/s/1000065" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="JOI2020-收获"><a href="#JOI2020-收获" class="headerlink" title="$JOI2020-收获$"></a><a href="https://loj.ac/p/3278" target="_blank" rel="noopener">$JOI2020-收获$</a></h3><hr>
<p>恶心 &amp; 有意思的题。</p>
<p>员工是不定的，而苹果成熟的时间都相同，因为询问的是人，考虑人不动，苹果动，也许会有一些绝妙的发现。从苹果向第一个采摘它的员工 1 连边，再从员工 1 向第二个采摘它的员工 2 连边… 每个员工都有一个出边，形成了基环内向树森林。分别对每棵基环内向树统计答案。把询问离线下来放在节点上。</p>
<p>一个苹果的贡献怎么算？先断环成链，有两种情况：</p>
<ol>
<li>苹果到该点没有经过断边</li>
<li>经过了断边</li>
</ol>
<p>第一种情况就动态开点线段树（下标为时间），第二种可以化成下取整柿子然后维护余数。一个子树的贡献可以进去和出去时做差得到。</p>
<p><a href="https://loj.ac/s/1000206" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="CF436E"><a href="#CF436E" class="headerlink" title="$CF436E$"></a><a href="https://www.luogu.com.cn/problem/CF436E" target="_blank" rel="noopener">$CF436E$</a></h3><hr>
<p>出到模拟赛里，比赛时就知道肯定是反悔贪心了，但我就是不会。。</p>
<p>反悔贪心先固定一种顺序，一般是个数每次加一，然后每步要么选择，要么反悔。一般用堆来维护决策集合。（为什么用堆就不用说了吧？！）</p>
<p>本题共有四种决策：</p>
<ul>
<li>选择<ol>
<li>选一个新的 $i$, $a_i$</li>
<li>从选了一个的 $i$ 里再选一个, $b_i - a_i$</li>
</ol>
</li>
<li>反悔<ol>
<li>去掉只选了一个的 $i$，再选两个 $j$，$b_j - a_i$</li>
<li>去掉选了两个的 $i$ 的第二个，再选两个 $j$，$b_j - (b_i - a_i)$<br>用四个堆分别维护这四种决策。</li>
</ol>
</li>
</ul>
<p>这题有好多种乱搞做法。<br>比如 $dst$ 的：<br>按照 $a_i$ 和 $b_i - a_i$ 的大小关系分类<br>$a_i \leq b_i - a_i$ 没有依赖关系，可以单独考虑；<br>但是 $a_i &gt; b_i - a_i$ 的就要捆绑了<br>最后可能会有剩一个空的情况，那么枚举 + 分讨就好了？</p>
<h3 id="WC2008-游览计划"><a href="#WC2008-游览计划" class="headerlink" title="$WC2008-游览计划$"></a><a href="https://www.luogu.com.cn/problem/P4294" target="_blank" rel="noopener">$WC2008-游览计划$</a></h3><hr>
<p>一眼最小生成树。但是上方格图了？？？</p>
<p>斯坦纳树，一种 奇 形 怪 状 的状压最小生成树算法。</p>
<p>$dp[i, S]$ 表示串起了 $S$ 集合的点，根为 $i$。两种转移：</p>
<ol>
<li>每次就把一个集合往根上并就好: $dp[i, S | S’] = min{ dp[i, S] + dp[i, S’] - val[i] }$</li>
<li>换根就一步一步往身边的节点换: $dp[i, S] = min{ dp[j, S] + val[i], (i, j) \in E }$</li>
</ol>
<p>发现第一个转移按秩，第二个转移无明显顺序，干脆套个 $spfa$，就做完了。以 $s$ 为划分阶段。</p>
<p>这是斯坦纳树的常规套路。</p>
<h3 id="THUSCH2017-巧克力"><a href="#THUSCH2017-巧克力" class="headerlink" title="$THUSCH2017-巧克力$"></a><a href="https://loj.ac/p/2977" target="_blank" rel="noopener">$THUSCH2017-巧克力$</a></h3><p>很好的 <del>随 机 化</del> 斯坦纳树题。首先如果 $C$ 很小的话怎么做？我们可以二分中位数（变权值为 $0$/$1$） + 状压跑斯坦纳树。但是我们首要的是选的块数尽量少，次要的是选的 $0$ 尽量多，怎么 $dp$？<strong>这里有个超好的 Trick：把 $0$ 赋为 $inf - 1$，把 $1$ 赋为 $inf + 1$，块数就是 $\lfloor \frac{val + 300}{1000} \rfloor$</strong></p>
<p>但是 $C$ 大而 $K$ 小。于是想到把 $C$ 种颜色随机分为 $K$ 类跑状压。正确率是 $\frac{k!}{k^k}$，约等于 $0.0384$, 跑个几百次就没问题了。</p>
<p><a href="https://loj.ac/s/991228" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="HNOI2013-与或非"><a href="#HNOI2013-与或非" class="headerlink" title="$HNOI2013-与或非$"></a><a href="https://www.luogu.com.cn/problem/P3220" target="_blank" rel="noopener">$HNOI2013-与或非$</a></h3><hr>
<p>（原来与非（$nand$）是真的存在啊，，不是为题而编出来的，，）</p>
<p>这是个很强大的运算，$and$、$or$、$xor$、$not$ 均可用 $nand$ 来表示。$not\ A = A\ nand\ A$, $A\ and\ B = not\ (A\ nand\ B)$, $A\ or\ B = (not\ A)\ nand\ (not\ B)$，而 $xor$ 显然可以由另外三种表出。</p>
<p>所以题目等价于可以将 $n$ 个数任意位运算起来！吼吼</p>
<p>变中找不变。若存在两个位置 $i$ 和 $j$ 使得 $n$ 个数的 $i$ 和 $j$ 位都相同，显然最终搞出的数 $i$ 和 $j$ 位也是相同的。因此数位 $dp$ 的时候从高位到低位考虑，确定当前位后必须将和它相同的位标记一下。</p>
<p>剩余没有互相限制的位置可以任意取 $0$ 或 $1$。为什么？？考虑用线性基的思想构造解（假设当前要取第 $x$ 位为 $1$）：通过一些操作把 $n$ 个数消成上三角；对于第 $x$ 位为 $0$ 的 $a_i$ 把 $a_i$ 取反，否则不动。把 $a$ 全部 &amp; 起来，$x$ 位上必然是 $1$；同时由于 $x$ 没有互相限制的位置，没有其他位上为 $1$。</p>
<h3 id="重返现世"><a href="#重返现世" class="headerlink" title="$重返现世$"></a><a href="https://www.luogu.com.cn/problem/P4707" target="_blank" rel="noopener">$重返现世$</a></h3><hr>
<p>好像第一次做 $k-th\ \min-\max$ 容斥的题。。可能只是板子题，但是 $dp$ 容斥系数的方法挺重要，碰到好几次了记录一下。</p>
<p>$\min_k$ 和 $\max_k$ 可以转化。<br>$$E(\max_k(S)) = \sum\limits_{T \subset S} (-1)^{|T| - k} C(|T| - 1, k - 1) * E(\min(T))$$<br>$$E(\min(T)) = \frac{m}{\sum\limits_{t \in T} p_t}$$<br>容斥这东西的系数显然可以 $dp$，老套路了。</p>
<p>考虑状态怎么设计，我们可以把 $k$ 和 $E(\min(T))$ 给表示到状态里：$f[i, j, k]$ 表示, 当前到第 $i$ 种原料，$\sum p_t = j$, 柿子中的 $k = k$ 时, $\sum\limits_{T \subset S} (-1)^{|T| - k} C(|T| - 1, k - 1)$ 的和。转移：</p>
<p>$f[i, j, k] = f[i - 1, j, k]$ (不选 $i$)</p>
<p>$+ f[i - 1, j - p_i, k - 1] - f[i - 1, j - p_i, k]$（选 $i$）</p>
<p>这是因为 $|T|$ 增加 $1$ 时, $C(|T| - 1, k - 1) = C(|T| - 2, k - 1) + C(|T| - 2, k - 2)$（根据组合数的定义）然后 $-1$ 的指数也改变了，负负得正。</p>
<p>边界：$f[0, 0, k] = 0$,<br>$f[i, p_i, k] = f[i - 1, p_i, k] + (-1)^{1 - k}C(0, k - 1)$，后面这坨等价于 $[k == 1]$</p>
<h3 id="转盘"><a href="#转盘" class="headerlink" title="$转盘$"></a><a href="http://loj.ac/p/2495" target="_blank" rel="noopener">$转盘$</a></h3><hr>
<p>我们发现如果时间被某个点限制住，就没必要在走到那个点的路上走走停停，直接在出发前一次停个够。</p>
<p>破环成链，在起始点停满时间。枚举起始点，假设从 $st$ 开始，$ans = \min\limits_{st}( \max\limits_i( T_i - dist(i, st) ) ) + n - 1$</p>
<p>暴力计算是 $O(n^2)$ 的，考虑数据结构维护</p>
<p>拆一波 $dist$（去掉环的影响）：<br>$ans = \min\limits_{ 1 \leq i \leq n }( \max\limits_{ 0 \leq j \le n }(T_{i + j} - j) ) + n - 1$</p>
<p>设 $a_i = T_i - i$，$ans = \min\limits_{ 1 \leq i \leq n }( \max\limits_{ i \leq j \le i + n - 1 }{a_j} + i ) + n - 1$，发现是一个后缀 $\max$ 的 $\min$，$\min$ 直接线段树，<br>后缀 $\max$ 怎么搞？单调队列 $O(n)$，线段树维护 $a$ 的单调增的队列就好了！</p>
<p>用 <a href="https://www.luogu.com.cn/problem/P4198" target="_blank" rel="noopener">这题</a> 的做法，分治的合并，非常强。</p>
<p>接下来证明我们可以统计窗口大小 $= n$ 的答案。因为 $a_i = T_i - i, a_{i + n} = T_i - i - n$, 所以窗口大小 <strong>$\leq n$</strong>;<br>又因为窗口大小 $\geq \frac{1}{2}$ 区间长度，对于最大的区间 $[1, 2n]$ 而言 <strong>$\geq n$</strong>。</p>
<p><a href="https://loj.ac/s/985524" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="ZJOI2019-线段树"><a href="#ZJOI2019-线段树" class="headerlink" title="$ZJOI2019-线段树$"></a><a href="https://uoj.ac/problem/467" target="_blank" rel="noopener">$ZJOI2019-线段树$</a></h3><hr>
<p>现在看看，一眼期望嘛。。老套路了：用期望做计数题</p>
<p>比较巧妙的是状态设计，除了维护本点为 $1$ 的概率外，还维护祖先为 $1$ 的概率。设其分别为 $f$ 和 $g$。</p>
<p>下面分五种情况：</p>
<ol>
<li>全覆盖的点: $g_i = \frac{1}{2} g_i + \frac{1}{2}$</li>
<li>本点: $f_i = \frac{1}{2}f_i + \frac{1}{2}$, $g_i = \frac{1}{2}g_i + \frac{1}{2}$</li>
<li>到根经过的路径上点: $f_i = \frac{1}{2}f_i$, $g_i = \frac{1}{2}g_i$</li>
<li>靠近路径但全不覆盖的点: $f_i = \frac{1}{2}f_i + \frac{1}{2}g_i$, $g_i = g_i$</li>
<li>毫无影响的点: $f_i = f_i$, $g_i = g_i$</li>
</ol>
<p>$2$, $3$ 和 $4$ 都是 $modify$ 的时候会 $psd$ 的，所以直接操作就好。唯独要给 $1$ 打 $tag$：我们让这个 $tag$ 打在系数和常数上，发现若打了 $k$ 个 $\frac{1}{2}$，系数就是 $(\frac{1}{2})^k$, 常数是 $1 - (\frac{1}{2})^k$</p>
<p><a href="https://uoj.ac/submission/438768" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="三角形"><a href="#三角形" class="headerlink" title="$三角形$"></a><a href="https://uoj.ac/problem/418" target="_blank" rel="noopener">$三角形$</a></h3><hr>
<p>正着做，每个点受到它所有儿子的限制，无法避免这个限制，没法做。技巧：得失转换题考虑倒一下顺序，<strong>每个点就只受父亲影响了</strong></p>
<p>每次操作可以用二元组 $((\sum w_{son}) - w_i$, $\sum w_{son})$来表示，分别是最终影响和操作过程中达到的最大值</p>
<p>优先级好算，堆维护，取队首和父亲绑一块，老套路了。</p>
<p><strong>操作优先级怎么算？</strong>将二元组看作 $(x, y)$，比较 $(x, y)$ 和 $(x’, y’)$。我们比较的宗旨是让第二维最小，即如果 $\max(y, x + y’) &lt; \max(y’, x’ + y)$ 那先一后二，否则先二后一。</p>
<p>最恶心的来了——<strong>这样写会 T！</strong><br>所以老实分类讨论吧。注意拆掉 $x + y’ &lt; \max(x’ + y, y’)$ 右边的 $\max$ 时 $x$ 必须 $\geq 0$，所以 $x$、$x’ &lt; 0$ 的时候要特殊讨论。</p>
<p>绑的时候合并操作，影响相加，最大值更新。这样就算出了全局最优解。</p>
<p>而根据操作序列反推出每个子树答案的方法也很巧妙：考虑每个子树的操作序列是全局的一个子序列，我们用线段树合并求解所有子树的答案就可以了。线段树上以时间为下标。</p>
<p><a href="https://uoj.ac/submission/438673" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="UOJ211-逃跑"><a href="#UOJ211-逃跑" class="headerlink" title="$UOJ211-逃跑$"></a><a href="https://uoj.ac/problem/211" target="_blank" rel="noopener">$UOJ211-逃跑$</a></h3><p>求方差就是求每种情况经过位置个数和，以及经过位置个数平方和。个数和可以 $dp$: $f[i, x, y]$ 表示走了 $i$ 步第一次到达 $(x, y)$ 的概率，$g[i, x, y]$ 表示走了 $i$ 步到达 $(x, y)$ 的概率，显然 $f$ 可以由 $f$ 和 $g$ 容斥得到。</p>
<p>平方和老套路，把 $x^2$ 拆成 $C(x, 2) + x$，考虑其实际意义就是到达了两个地点的概率——这怎么搞？$h[i, x, y]$ 表示走了 $i$ 步在到达 $(a, b)$ 前到达过 $(a - x, b - y)$ 的概率和，要减去在到达 $(a - x, b - y)$ 前到达过 $(a, b)$ 的概率和。</p>
<p><a href="https://uoj.ac/submission/440153" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="UOJ141-量子态的棋盘"><a href="#UOJ141-量子态的棋盘" class="headerlink" title="$UOJ141-量子态的棋盘$"></a><a href="https://uoj.ac/problem/141" target="_blank" rel="noopener">$UOJ141-量子态的棋盘$</a></h3><hr>
<p>首先那么多球是唬你的：假设有 $a$ 个球流到 $(x, y)$ 上，那么会分为两个支流，分别为 $a / 2$ 和 $(a + 1) / 2$，就看 $(x, y)$ 初始状态决定那个支流到那个方向。$n$、$m$ 那么小，直接 $80$ 进制状压，总状态数只有几十万，$hashmap$ 冲一发就好。</p>
<p><a href="https://uoj.ac/submission/440103" target="_blank" rel="noopener">$Code$</a></p>
<h3 id="CF1163E"><a href="#CF1163E" class="headerlink" title="$CF1163E$"></a><a href="https://www.luogu.com.cn/problem/CF1163E" target="_blank" rel="noopener">$CF1163E$</a></h3><hr>
<p><a href="https://www.cnblogs.com/p-b-p-b/p/11741238.html" target="_blank" rel="noopener">题解</a></p>
<p>这题好妙！感觉线性基的题目想跟我讲道理都不行= = 意识流赛高。。</p>
<p>大概是只能用 $&lt; 2^x$ 的数；同时构成大小为 $k$ 的线性无关组（线性基），这个线性基能异或出 $2^x - 1$ 个数，构造就随性一点，每次 pia 两半，左右因为中间有个数（基里的数，什么数都行，本代码中与深度有关），必然是不同的。<br>太妙了，把线性无关运用的淋漓尽致。</p>
<h3 id="CF1163F"><a href="#CF1163F" class="headerlink" title="$CF1163F$"></a><a href="https://www.luogu.com.cn/problem/CF1163F" target="_blank" rel="noopener">$CF1163F$</a></h3><hr>
<p>读完题我想：如果能维护不经过某条边的最短路就好了。。</p>
<p>正解很硬核，直接最短路树 + 分讨</p>
<ol>
<li>$(u, v)$ 不在最短路上，变小，新值与初始答案取个 $\min$</li>
<li>$(u, v)$ 不在最短路上，变大，无影响</li>
<li>$(u, v)$ 在最短路上，变小，答案减小对应的值；</li>
<li>$(u, v)$ 在最短路上，变大，这个比较麻烦。<br>回答上面那个问题！线段树！</li>
</ol>
<p>懂了吗？线段树只要维护原始最短路的断边情况。$[L, R]$ 表示不用区间 $[L, R]$ 的边的最短路</p>
<p>经典套路：<strong>批量</strong>维护删除某个点或边的可以尝试分治</p>
<p>某条边 $(u, v)$ 所在的最短路，对删除<em>连接 $u$ 的、在 $u$ 之前，在最短路上的最后点</em> ~ <em>连接 $v$ 的、在 $v$ 之后，在最短路上的最前点</em>之间的边有贡献</p>
<h3 id="CF516E"><a href="#CF516E" class="headerlink" title="$CF516E$"></a><a href="https://www.luogu.com.cn/problem/CF516E" target="_blank" rel="noopener">$CF516E$</a></h3><p>我即数学黑洞！</p>
<p>设 $x = i % n$, $y = i % m$</p>
<p>$i = k1 <em> n + x = k2 </em> m + y$</p>
<p>$x \equiv y \pmod {gcd(n, m)}$</p>
<p>设 $d = gcd(n, m)$, 于是就可以把男女生关于 $d$ 归为 $0 ~ d - 1$ 类，不同类间互不影响，于是变成了 $d$ 个子问题。一个子问题的贡献是这一类的所有男女生变开心的时间。（接下来的 $n$ 和 $m$ 是除以 $d$ 后的，互质）</p>
<p>如果 $i % n$ 男生让 $i % m$ 女生变开心了，那 $(i + n) % m$ 女生在 $n$ 时间后也会变开心，<br>所以连边：$i -&gt; (i + n) % m$, $n$</p>
<p>再对于所有初始就开心的 $i$ 连边：$S -&gt; i$, $i$</p>
<p>然后跑最短路。但是图太大了。</p>
<p>考虑第一种边，因为 $n$ 和 $m$ 互质，所以会连成一个大环，我们把与 $S$ 相连的点称为关键点，把所有关键点拎出来，对最大时间有贡献的必然是相邻两点之间最靠右的非关键点（画图就明白了）</p>
<p>那怎么给拎出来的关键点重标号（排序）呢？$exgcd$ 算起点到它们的距离，就做完了。</p>
<p>后记：xml 因为贺了一整题所以非常难受。</p>
<h3 id="BZOJ3636-教义问答手册"><a href="#BZOJ3636-教义问答手册" class="headerlink" title="$BZOJ3636-教义问答手册$"></a><a href="https://darkbzoj.tk/problem/3636" target="_blank" rel="noopener">$BZOJ3636-教义问答手册$</a></h3><p>不能重叠，而且是若干条。</p>
<p>首先有显然的 $n^2$ $dp$：<br>$f[l, r]$ 表示区间 $[l, r]$ 的答案，那么<br>$f[l, r] = max(f[l, r - 1], f[l, r - L] + s[r] - s[r - L])$</p>
<p>当然也可以反向：<br>$f[l, r] = max(f[l + 1, r], f[l + L, r] + s[l + L - 1] - s[l - 1])$</p>
<p>所以我们知道了某个端点就可以 $O(n)$ 计算我们想要的东西</p>
<p>神 litble：不能 $AC$ 但很妙的分块（正解无关）：对于每个块的左端点 $l$，预处理所有点作为 $r$ 的 $f$。</p>
<p>正解：对于每个中点处理过中点的询问。<br>要么不取跨中点的区间，要么取，$O(L)$ 枚举跨中点区间的左端点再 $O(n)$ 计算未被包括在跨中点区间里的区间答案（用上面的 $dp$）</p>
<p>所以是 $O(nL log n)$</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="imily" />
          <p class="site-author-name" itemprop="name">imily</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">312</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index-1.html">
                <span class="site-state-item-count">110</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imily</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

</body>
</html>
