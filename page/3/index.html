<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="imily&#39;s notes">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="imily&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="imily&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> imily's notes </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">imily's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/18/CSP2020 总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/11/18/CSP2020 总结/" itemprop="url">
                  CSP2020 总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-18T12:00:00+08:00">
                2020-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>被 T1 搞得心态爆炸导致 T3 彻底降智，最后一小时浑浑噩噩一分都没捞着，大失败！</p>
<h2 id="T1-儒略日"><a href="#T1-儒略日" class="headerlink" title="$T1. 儒略日$"></a>$T1. 儒略日$</h2><hr>
<p>打了一个半小时左右，真的是。。。本场崩的罪魁祸首，关键是年份还算错了一处（取模），只拿到了暴力分。。。。</p>
<p><del>啊！！！！气死我了！！！！</del></p>
<p>T1 的使命就是来耗时间的，考察选手代码能力。即选择较优的写法，以缩短时间。。。比如说二分和小范围的预处理就很好。狂码 200 行的选手如我，不崩谁崩？</p>
<p><a href="https://loj.ac/submission/990046" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="T2-动物园"><a href="#T2-动物园" class="headerlink" title="$T2. 动物园$"></a>$T2. 动物园$</h2><hr>
<p>呵，最后 5 min 发现数据范围 $0 \leq k \leq 64$… 再见，这美丽的世界。</p>
<p>于是比去年更烦了一重：要判 = 64 和 65 的，65 就是先减后加。</p>
<p><a href="https://loj.ac/submission/990047" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="T3-函数调用"><a href="#T3-函数调用" class="headerlink" title="$T3. 函数调用$"></a>$T3. 函数调用$</h2><hr>
<p>被 T1 烦到了，思路完全乱掉，归根结底还是心理素质太差了！</p>
<p>这题只是简单的加法乘法原理题，只要注意到贡献都是以加为根本，以乘为辅，大概就能想出来。最终答案的原先面目都是一些加操作啊。</p>
<p>于是考虑维护乘操作对加操作的影响，记一个后缀乘积就好了，拓扑看似难写实则好写。。。</p>
<p><a href="https://loj.ac/submission/990045" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="T4-贪吃蛇"><a href="#T4-贪吃蛇" class="headerlink" title="$T4. 贪吃蛇$"></a>$T4. 贪吃蛇$</h2><hr>
<p>这题看似简单 实则不愧对其第四题的地位。。。思维严密，挺有意思的。</p>
<p>重要性质（与 16 年的蚯蚓十分相似）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进食的蛇丢进另一个队列里，发现当前丢的一定是进食过的蛇里最弱的</span><br></pre></td></tr></table></figure></p>
<p>猜想：如果当前 $max$ 吃了 $min$，不会变成 $min$，就一定会吃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：之后吃了的 max 会比当前吃完的 max 更小。</span><br></pre></td></tr></table></figure></p>
<p>所以分为两个阶段：</p>
<ol>
<li>当前 $max$ 吃了 $min$，不会变成 $min$，就一直吃</li>
<li>当前 $max$ 吃了 $min$，会变成 $min$，会一直进行下去直到某条蛇吃了不会变成 $min$ 或总数 $= 2$，这时最后吃的那条会反悔，倒数第二条吃的一定会吃，倒数第三条会反悔。。。发现和递归层数的奇偶性有关。感觉十分nb。<br>$set$ 维护 $max$ &amp; $min$，$O(Tnlogn)$，$70$ 分。</li>
</ol>
<p>考虑优化，那必须 $O(n)$ 了</p>
<p>考虑双端队列</p>
<p>划一下题目中容易遗漏的条件：保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。</p>
<p>——不用 $sort$ 了！</p>
<p>$q1$ 维护没吃过和没被吃过的，$q2$ 维护吃过的。显然都是有序的。</p>
<p>就是在暴力的基础上改一改</p>
<p>对于我这种没有🧠的选手来说，先写暴力才有可能优化成正解。。。而且暴力也更稳，考场上要尽力的打高分啊！</p>
<p><a href="https://loj.ac/submission/989975" target="_blank" rel="noopener">$Code$(暴力)</a></p>
<p><a href="https://loj.ac/submission/990038" target="_blank" rel="noopener">$Code$(正解)</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="$总结$"></a>$总结$</h2><hr>
<p>不要哀求，学会争取。感觉思维还是太慢了，细节又推不干净，接下来要训练思维的敏捷性，也要注重模拟赛的训练。</p>
<p>考场情况多，稳住。僵住的状态可以去窗口深呼吸，回来继续拼抢。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/10/【计划】NOIP2020复习计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/11/10/【计划】NOIP2020复习计划/" itemprop="url">
                  NOIP2020复习计划
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-10T23:58:59+08:00">
                2020-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>相关题目特征</li>
<li>算法内容</li>
<li>复杂度</li>
<li>习题</li>
</ul>
<hr>
<h1 id="TRICK"><a href="#TRICK" class="headerlink" title="TRICK"></a><em>TRICK</em></h1><ul>
<li>中位数相关可考虑二分，将小于二分值的标为 -1，大于二分值的标为 1</li>
<li>看见乘积考虑取 log，这样开方就变成除法，乘就变成加法了，有很多优秀的性质</li>
<li><a href="https://www.cnblogs.com/gryzy/p/6015485.html" target="_blank" rel="noopener">快速阶乘算法</a></li>
<li>网格图套路一览：C = V - E + F; 分治最短路；二分图染色；笛卡尔树（待补）</li>
</ul>
<hr>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><em>贪心</em></h1><ul>
<li>区间取点</li>
</ul>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a><em>DP</em></h1><h2 id="01背包-amp-完全背包-amp-多重背包"><a href="#01背包-amp-完全背包-amp-多重背包" class="headerlink" title="01背包 &amp; 完全背包 &amp; 多重背包"></a>01背包 &amp; 完全背包 &amp; 多重背包</h2><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h2 id="树型dp"><a href="#树型dp" class="headerlink" title="树型dp"></a>树型dp</h2><h2 id="概率dp"><a href="#概率dp" class="headerlink" title="概率dp"></a>概率dp</h2><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h2 id="插头dp"><a href="#插头dp" class="headerlink" title="插头dp"></a>插头dp</h2><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><h2 id="决策单调性-amp-四边形不等式"><a href="#决策单调性-amp-四边形不等式" class="headerlink" title="决策单调性 &amp; 四边形不等式"></a>决策单调性 &amp; 四边形不等式</h2><h2 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h2><h2 id="矩阵乘法优化"><a href="#矩阵乘法优化" class="headerlink" title="矩阵乘法优化"></a>矩阵乘法优化</h2><ul>
<li>变形：+ 和 max</li>
</ul>
<h2 id="wqs-二分"><a href="#wqs-二分" class="headerlink" title="wqs 二分"></a>wqs 二分</h2><hr>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a><em>图论</em></h1><h2 id="A-amp-IDA"><a href="#A-amp-IDA" class="headerlink" title="$A^{}$ &amp; $IDA^{}$"></a>$A^{<em>}$ &amp; $IDA^{</em>}$</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>dfs &amp; 欧拉序 &amp; 括号序列。配合数据结构食用。</li>
<li>树的重心 &amp; 直径</li>
<li>LCA</li>
<li>树链剖分 &amp; 长链剖分</li>
</ul>
<h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><h2 id="Prufer序列及Cayley定理"><a href="#Prufer序列及Cayley定理" class="headerlink" title="Prufer序列及Cayley定理"></a>Prufer序列及Cayley定理</h2><ul>
<li>prufer 序列是<strong>无根树</strong>的数列，一棵 $n$ 个点的无根树，prufer 序列长度为 $n - 2$。</li>
<li>无根树转数列：找到编号最小的叶子结点，在树上删除它并将它与它相连的点加入 prufer 序列。重复操作直到只剩 2 个点。</li>
<li>数列转无根树：每次将 prufer 序列最前面的元素和 当前在树上的且没在 prufer 序列里出现的最小节点 连边。</li>
<li>Cayley定理：$n$ 个点的<strong>无向完全图</strong>的生成树个数：$n^{n - 2}$</li>
<li>$n$ 个节点，第 $i$ 个点度为 $d_i$ 的生成树个数：$\frac{(n - 2)!}{\prod\limits_i (d_i - 1)!}$</li>
<li>$n$ 个节点，$k$ 个连通块，第 $i$ 个块大小是 $a_i$，第 $i$ 个块的度数为 $d_i$，在块之间连 $k - 1$ 条边使得连通的方案数：$n^{k - 2} \times \prod a_i$ <a href="https://oi-wiki.org/graph/prufer/#_3" target="_blank" rel="noopener">证明</a></li>
<li><a href="https://www.luogu.com.cn/paste/jbsz4em1" target="_blank" rel="noopener">51nod1601</a> <a href="https://www.luogu.com.cn/paste/8pjpuesx" target="_blank" rel="noopener">CF917D</a></li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h2 id="kruskal重构树"><a href="#kruskal重构树" class="headerlink" title="kruskal重构树"></a>kruskal重构树</h2><ul>
<li><a href="">[NOI2018]-归程</a> <a href="">[APIO2020]-交换城市</a></li>
</ul>
<h2 id="tarjan强联通分量"><a href="#tarjan强联通分量" class="headerlink" title="tarjan强联通分量"></a>tarjan强联通分量</h2><ul>
<li>有向图里的。定义是任何两个点都能互相到达。</li>
<li>强连通分量的基图是边双连通分量，即存在一种给边双分量中的边定向的方案使得其强连通。易证！XD</li>
</ul>
<h2 id="tarjan双联通分量"><a href="#tarjan双联通分量" class="headerlink" title="tarjan双联通分量"></a>tarjan双联通分量</h2><h2 id="割点和桥"><a href="#割点和桥" class="headerlink" title="割点和桥"></a>割点和桥</h2><h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><ul>
<li>分别对树和环处理。</li>
<li><p>扣环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlop</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fr)</span> </span>&#123;  <span class="comment">// 这里是扣两个点的环，记录的不是 fa 而是来的那条边</span></span><br><span class="line">    <span class="keyword">if</span> (vis[x]) &#123; rt = x; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span>) == fr) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">int</span> t = getlop(y, i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">                lop[++num] = x, dis[num] = val[i], inl[x] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (x != rt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P4381" target="_blank" rel="noopener">IOI2008-Island</a>, 小清新基环树题，求每棵树的直径之和</p>
</li>
<li><a href="https://www.luogu.com.cn/paste/uc2gqdkt" target="_blank" rel="noopener">ARC079D-Namori Grundy</a></li>
</ul>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><h2 id="2-sat"><a href="#2-sat" class="headerlink" title="2-sat"></a>2-sat</h2><ul>
<li>有诸多限制，非此即彼的逻辑关系，且是二元关系。</li>
<li>拆点做。<strong>考虑要全面</strong>。拓扑序是反的，所以输出答案就是选两者中强连通分量编号较小的，因为在拓扑序上它比较靠后。复杂度和 tarjan 相同，有 $n$ 个点 $m$ 条限制（即边）就是 $O(n + m)$</li>
<li><a href="https://www.luogu.com.cn/paste/142viofa" target="_blank" rel="noopener">UOJ210</a></li>
</ul>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><ul>
<li>spfa &amp; bellman-ford:</li>
<li>Dijkstra:</li>
<li>Floyd:</li>
<li>差分约束:</li>
<li>k短路:</li>
</ul>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><ul>
<li>最大流 = 最小割</li>
<li>费用流</li>
<li>有上下界的网络流</li>
<li>二分图（最大匹配，最大独立集，最大点全覆盖集，最小路径覆盖的一些性质）（匈牙利算法） </li>
</ul>
<h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><ul>
<li>套圈法</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><hr>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a><em>数论</em></h1><h2 id="埃氏筛-amp-线性筛"><a href="#埃氏筛-amp-线性筛" class="headerlink" title="埃氏筛 &amp; 线性筛"></a>埃氏筛 &amp; 线性筛</h2><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><h2 id="gcd-amp-exgcd"><a href="#gcd-amp-exgcd" class="headerlink" title="gcd &amp; exgcd"></a>gcd &amp; exgcd</h2><h2 id="CRT-amp-exCRT"><a href="#CRT-amp-exCRT" class="headerlink" title="CRT &amp; exCRT"></a>CRT &amp; exCRT</h2><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h2 id="概率与期望"><a href="#概率与期望" class="headerlink" title="概率与期望"></a>概率与期望</h2><h2 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h2><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><h2 id="群论-amp-Burnside-amp-Polya"><a href="#群论-amp-Burnside-amp-Polya" class="headerlink" title="群论 &amp; Burnside &amp; Polya"></a>群论 &amp; Burnside &amp; Polya</h2><h2 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h2><h2 id="lucas定理"><a href="#lucas定理" class="headerlink" title="lucas定理"></a>lucas定理</h2><h2 id="分拆数"><a href="#分拆数" class="headerlink" title="分拆数"></a>分拆数</h2><hr>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a><em>博弈论</em></h1><p>虽然这个东西在 noip 里几乎不考，但也是很常见（而且我几乎一无所知）的知识点。来系统地整理一下吧。</p>
<p>必胜态转移会到至少一个必败态，必败态一定会到必胜态。终止状态一定是必败态，因此可以考虑分析终止状态的性质。</p>
<h2 id="bash博弈"><a href="#bash博弈" class="headerlink" title="bash博弈"></a>bash博弈</h2><ul>
<li>一堆石子有 n 个，每次最少取 1 个，最多取 m 个。(m + 1) | n 时先手必败，否则先手必胜。</li>
</ul>
<h2 id="nim博弈"><a href="#nim博弈" class="headerlink" title="nim博弈"></a>nim博弈</h2><ul>
<li>n 堆石子，每堆有 a_i 个，每次选择一堆选若干个。XOR(a_i) = 0 则先手必败，否则先手必胜。</li>
<li>证明：设 k = XOR(a_i), a_i 为包含 k 最高位的一堆个数，考虑取 $a_i - (a_i\ xor\  k)$ 个使得 a_i 变为 a_i\ xor\ k，这样总的异或和又变为 0。这跟 bash 博弈有异曲同工之妙的就是维持一个稳定态（后手必败态）。</li>
</ul>
<h2 id="Wythoff博弈"><a href="#Wythoff博弈" class="headerlink" title="Wythoff博弈"></a>Wythoff博弈</h2><ul>
<li>两堆石子，两人轮流从任意一堆中取至少一个或同时从两堆中取同样多的物品，取不到者败。</li>
<li>咕咕</li>
</ul>
<h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><ol>
<li>bash + nim。就是在模意义下的 nim 游戏啦，每堆 % 上 (m + 1) 再做 nim。</li>
<li>nim-k，每次可以从最多 k 堆石子里拿任意个。结论是把每个位置上的石子数表示成二进制，若每一位上 1 的个数 % (k + 1) 都等于 0 那么先手必败，否则必胜。结论难想但证明还是好胡的。</li>
<li>阶梯博弈，每次可以将一个石子移到它所在阶梯的下一阶梯，位于 0 的石子不能动（石子可以叠起来）。结论是直接做奇数级阶梯的 nim。证明：对手移动奇数位置，就按照 nim 的移法去移；对手移动偶数位置，就顺势把这个石子移到下一个偶数位置。这样就可以视“奇数位置的石子被移动”为“那颗石子没了”，就是普通 nim 了。当然题目不会这么裸，要做转化，比如 <a href="https://loj.ac/submission/929939" target="_blank" rel="noopener">[SDOI2019]-移动金币</a></li>
</ol>
<h2 id="SG"><a href="#SG" class="headerlink" title="SG"></a>SG</h2><ul>
<li>万能的存在= =。对于一个游戏，$SG(x) = mex_{y = x.nxt}{SG(y)}$；所有游戏的 SG 异或为 0 时先手必败，否则必胜。</li>
</ul>
<h2 id="min-max博弈（搜索）-amp-alpha-beta剪枝"><a href="#min-max博弈（搜索）-amp-alpha-beta剪枝" class="headerlink" title="min-max博弈（搜索） &amp; alpha-beta剪枝"></a>min-max博弈（搜索） &amp; alpha-beta剪枝</h2><hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><em>数据结构</em></h1><h2 id="栈-amp-单调栈-amp-队列-amp-单调队列"><a href="#栈-amp-单调栈-amp-队列-amp-单调队列" class="headerlink" title="栈 &amp; 单调栈 &amp; 队列 &amp; 单调队列"></a>栈 &amp; 单调栈 &amp; 队列 &amp; 单调队列</h2><ul>
<li>和区间问题配合食用，可以求出一些范围</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>路径压缩</li>
<li>带权并查集</li>
<li>拆点</li>
</ul>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><ul>
<li>根号数据结构嘛。。1e5 内都可做。另外相邻状态能 $O(1)$ 转移。$O(log)$ 要看过不过得去了。。？</li>
<li>不带修莫队：记录 $(l, r)$，按$l$ 第一关键字，$r$ 第二关键字排序。换块 $O(n)$，同一个块中 $O(\sqrt{n})$，所以总共 $O(n\sqrt{n})$</li>
<li>带修莫队：记录 $(l, r, t)$，$t$ 表示第几次修改，按$l$ 第一关键字，$r$ 第二关键字，$t$ 第三关键字排序，每次若当前修改数比 $t$ 少就将没修改的修改，否则回退。注意如果修改 $(l, r)$ 里的信息要更新答案。复杂度不会分析，视作 $n = m$ 的话，块大小取 $n^{\frac{2}{3}}$ 时有最小值 $n^{\frac{5}{3}}$，所以大约是 $O(n^{\frac{5}{3}} + n\ log\ n)$</li>
<li>树上莫队：还是序列问题，将树转化成欧拉序。注意特判 LCA。复杂度分析视作序列问题，带修和不带修复杂度同上⬆</li>
<li><a href="http://uoj.ac/submission/430504" target="_blank" rel="noopener">[UOJ58]-糖果公园</a>，一道朴实无华的带修树上莫队（这里采用的是直接跳 LCA + 直接分块，也可以欧拉序）</li>
</ul>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul>
<li>lazy-tag<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2></li>
<li>经常结合树上问题食用，限制就是插入的信息一定得是 O(n) 级别的复杂度才不会错。。来证明一下它 O(nlogn) 的复杂度吧：发现合并两棵线段树的复杂度是它们重合的点数，合并两个点的复杂度是 O(logn)，共合并 n - 1 次所以是 O(nlogn)。</li>
<li>除了权值啊下标线段树合并的，还能做 01 trie 合并哦。</li>
<li><p><a href="https://loj.ac/submission/932042" target="_blank" rel="noopener">LOJ3303(01 trie 合并)</a></p>
</li>
<li><p>动态开点</p>
</li>
<li>zkw？</li>
<li>主席树</li>
</ul>
<h2 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h2><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><hr>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a><em>计算几何</em></h1><p>觉得不会考所以只复习凸包（</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><em>字符串</em></h1><p>这块真是一窍不通 :(</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><ul>
<li>01 Trie 是 xor 问题的杀手之一。可持久化后可以查询某个区间的异或值。</li>
<li><a href="https://loj.ac/submission/935085" target="_blank" rel="noopener">十二省联考2019-异或粽子</a></li>
</ul>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><h2 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h2><ul>
<li>大多是用 $height$ 数组搞事情。（$height[i]$ 表示排名 $i$ 的后缀和排名 $i - 1$ 的后缀的最长公共前缀。）</li>
<li>倍增 + 桶排不多说，复杂度 $O(n\ log\ n)$。重点是 $height$ 数组，有结论：$height[rk[i]] &gt;= height[rk[i - 1]] - 1$，近似单调，因此可以 $O(n)$ 求。</li>
<li><a href="https://loj.ac/submission/929295" target="_blank" rel="noopener">[NOI2016]-优秀的拆分</a></li>
</ul>
<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><h2 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h2><hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="分治-amp-二分-amp-三分"><a href="#分治-amp-二分-amp-三分" class="headerlink" title="分治 &amp; 二分 &amp; 三分"></a>分治 &amp; 二分 &amp; 三分</h2><ul>
<li>二分：有单调性的可以二分。<a href="https://www.luogu.com.cn/paste/oakm4jh5" target="_blank" rel="noopener">不存在的 BZOJ3580-冒泡排序</a></li>
<li>01 分数规划：二分比值，注意不等号方向以及取不取的到 ‘=’。<a href="https://loj.ac/submission/931538" target="_blank" rel="noopener">[BJOI2019]-奥术神杖</a></li>
<li>平面分治（平面最近点对）</li>
<li>cdq 分治</li>
<li>整体二分</li>
</ul>
<h2 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h2><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h2 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h2><h2 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h2><h2 id="DLX"><a href="#DLX" class="headerlink" title="DLX"></a>DLX</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/Comet OJ Contest 75/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/25/Comet OJ Contest 75/" itemprop="url">
                  CodeJam2019-R1c
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-25T23:27:40+08:00">
                2020-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://cometoj.com/contest/75/problems" target="_blank" rel="noopener">传送门</a></p>
<p>sooke 这套真是高质量好题 /dz</p>
<h2 id="A-绝境"><a href="#A-绝境" class="headerlink" title="$A. 绝境$"></a>$A. 绝境$</h2><hr>
<p>考虑容斥，答案就是每种 $n - 1$ 个操作的交集减去 $n$ 个操作的交集。求矩形交的前后缀和！</p>
<p><a href="https://cometoj.com/status/ykj87mpwfh7me0lbi15ciah6vj67ryd4" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="B-命运"><a href="#B-命运" class="headerlink" title="$B. 命运$"></a>$B. 命运$</h2><hr>
<p>注意，边不相交这是个很有用而且很强的条件！这样限定了 $i$ 位置取的 $in_i$ 个点只能是上方的底部和下方的顶端一些点。</p>
<p>特殊性质一是很有启发意义的一档。发现每个点引出的边方向确定了！为什么？若 $p_{i - 1} + 1 = p_i$ 则向右，若 $p_{i - 1} - 1 = p_i$ 则向左。然后可以愉快的dp，$f[i, j]$ 表示到第 $i$ 点处理完后，上方有 $j$ 条边（下方有 $p_i - j$ 条边）</p>
<p>推广一下发现，每个点的入度和出度都定了！为啥啊</p>
<ul>
<li>$in_i + out_i = d_i$</li>
<li>$p_{i - 1} - in_i + out_i = p_i$</li>
</ul>
<p>然后继续用刚才思路做，枚举上方几条入边和出边：$f[i, j] = \sum_x \sum_y f[i - 1, j - x + y]$</p>
<p>转移是 $n^2$ 的。。。优化：$g[i, j] = \sum\limits_{x = 0}^{in_i} f[i - 1, j + x]$    $f[i, j] = \sum\limits_{y = 0}^{out_i} g[i, j - y]$ 发现都是前缀和形式，前缀和优化。</p>
<p><a href="https://cometoj.com/status/fxs5bt46b7u243sfjl627cmk3nze4yxb" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="C-终焉"><a href="#C-终焉" class="headerlink" title="$C. 终焉$"></a>$C. 终焉$</h2><hr>
<p>答案显然是断边数 + 1。</p>
<p>技巧/经典套路1：修改是改变一个点和它周围一圈点时，考虑它的<strong>树上结构</strong>，只要修改父亲节点处就好了！</p>
<p>集合幂级数？FWT、FMT？？好像都只能做部分分</p>
<p>$f[x, s]$ 表示节点 $x$ 儿子中状态为 $s$ 的数量，发现这样修改和查询一个是 $O(2^m)$，一个是 $O(1)$，这太不均匀了！</p>
<p>经典套路2：分两段，比如说修改 $x$ 值为 $s$，那么 $f[fa, t]++$，其中前半段 $t$ 和 $s$ 相同，后半段 $s$ 是 $t$ 的子集；<br>查询的话就先 $s = ~s$，$ans += f[fa, t]$，其中后半段 $t$ 和 $s$ 相同，前半段 $t$ 是 $s$ 的子集。但这样时间是 $O(n2^{m / 2})$ 了，空间还是 $O(n2^m)$</p>
<p>经典套路3：度数分块</p>
<p>考虑 $bound$，当度数 $&lt; bound$ 时暴力修改/询问，$&gt; bound$ 时用上面的数组做，发现这样空间复杂度是 $O(n / d * 2^{m / 2})$；发现 $d = 2^{m / 2}$ 时最优！</p>
<p>就做完啦。</p>
<p><a href="https://cometoj.com/status/n8s13h50ao6gc6fvte6gb5opzqpcanel" target="_blank" rel="noopener">$Code$</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/14/【学习笔记】平面图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/14/【学习笔记】平面图/" itemprop="url">
                  【学习笔记】平面图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-14T23:14:05+08:00">
                2020-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是平面图？除了节点外边没有交点的图。对于一个区域，我们称其为<strong>面</strong>；包围这个区域的边称其为<strong>边界</strong>；边界的长度称为这个面的<strong>度</strong>。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. |E| &lt;= 3|V| - 6</span><br></pre></td></tr></table></figure>
<p>这告诉我们 <strong>平面图里 m 与 n 同阶</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. V - E + F = K + 1</span><br><span class="line"></span><br><span class="line">任何一个凸多面体（或连通平面图）满足上式，其中 F 为面数，K 为连通块数。</span><br></pre></td></tr></table></figure>
<p>欧拉定理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 平面图的判定：（以 [HNOI2010]-planar 为例）（其实是只会存在哈密顿回路的）哈密顿回路会连成一个环，每条边就是环上的一条弦，两条边 i 和 j 若 xi &lt; xj &lt; yi &lt; yj 则相交，只能一条放环里、一条放环外——这是个二分图嘛！二分图有无合法染色等价于有无解啦。</span><br></pre></td></tr></table></figure>
<p>接下来是平面图转对偶图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 对于一个 s-t 平面图（有源点和汇点的平面图），其对偶图中的一个环对应着原图中的一个割。</span><br><span class="line">将平面图最小割或最大流转化成对偶图最短路，效果绝佳。（但我没写过qvq）</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3209" target="_blank" rel="noopener">HNOI2011-平面图判定</a></p>
<p>利用哈密顿路径上的编号先后 判断边是否交，转二分图判定就好啦，并查集和 $2-sat$ 都可以</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/14/NOIP2020 总结 & 题解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/14/NOIP2020 总结 & 题解/" itemprop="url">
                  NOIP2020 总结 & 题解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-14T23:14:05+08:00">
                2020-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在-NOIP2020-之后"><a href="#写在-NOIP2020-之后" class="headerlink" title="写在 NOIP2020 之后"></a>写在 NOIP2020 之后</h2><hr>
<p>T3 构造我直接傻眼，搞了俩小时一分没得（这构造本质是模拟）。最近大赛考非正常题越来越多了，对码力的要求也逐步上升，这俩我都不擅长。对而且我还不擅长思维题。我擅长啥呢？套路题（有手就行的 sb 题）。</p>
<p>想要多写 LOJ 的神题、套路题、非正常题，想学生成函数。在役的时间，有一天便看一天的风景，dp 套 dp、生成函数这些人类智慧不看会后悔的吧 qvq？ 向前跋涉吧！<strong>“永远不要用行为上的努力来掩盖思维上的懒惰。”</strong></p>
<h2 id="成绩出了"><a href="#成绩出了" class="headerlink" title="成绩出了"></a>成绩出了</h2><hr>
<p>丧气话删了。“世上一切不幸都是由于当事者能力不足”</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>先 乘 后 除 /吐血 痛失 30 分，<strong>痛失高一赛季！</strong></p>
<p>正解就维护指数</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>好吧。。这题就是复杂度优化题。后面东西用树状数组我做到了，前面那个用倍增我真想不到啊。。</p>
<p>肯定要枚举 AB，然后发现确定了 AB 的长度，C 的奇数个数只有 2 种值，就很简单了。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>据说我写的是 $70$ 分，就每次挑两个柱子，当前柱有 $x$ 个黑，$y$ 个白（显然颜色不重要，我们就看作黑白），然后把两个柱子准备一下，即一个留 $x$ 个空位，一个留 $y$ 个空位，但我调了很久，还写挂了，痛失 $70$ 分。赛后看题解知道自己只想到了几个关键细节中的一个。</p>
<p>我们钦定总有一个柱子是空的，即每次操作完，有 $n$ 个柱子都是满的，这样可以简化很多。（第二个细节）</p>
<p>先看 $n = 2$ 的情况。发现可以在不改变其他柱子状态的情况下整理一个柱子，即白的在下，黑的在上。（第三个细节）</p>
<p>然后可以将柱子整理成同色的，具体就是，通过空柱子，我们可以 $reverse$ 一个柱子；两个柱子选一种颜色的球，<strong>需要保证两个柱子上此颜色的球数之和 $\leq m$</strong>，给丢到空柱子上，用一个柱子上的球填满另一个柱子再将塞到空柱子上的球拿回放在这个柱子上。（第四个细节）</p>
<p>$n &gt; 2$ 的情况分治就好了，复杂度 $O(5nmlogn)$，极限数据只跑了 $500000$。</p>
<p>需要注意的是，可能存在一个柱子颜色全是黑或全是白，merge 的时候可能会 $&gt; m$，需要特判。</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>暴 力 写 挂 我是屑</p>
<p>又是构造又是多项式的，爽啦。</p>
<p>对于暴力和正解都很重要的一个思想：每维是独立的。</p>
<p>如果模拟两轮没走完，发现每轮合法位置的变化量是线性的，即对于第 $i$ 维，第一轮走了 $a_i$，第二轮走了 $b_i$，那么再走 $x$ 轮减少的就是 $b_i - (a_i - b_i) * x$</p>
<p>枚举 $i$，现在计算的是第 $x + 2$ 轮做完第 $i$ 步的答案，合法的位置数是每维的合法位置乘起来。</p>
<p>将 $x$ 看作自变量，枚举 $i$，第 $x$ 轮走了 $i$ 步的答案是 $f(x) = \prod_j (tot_{j, i} - (a_j - b_j) * x)$，$tot_{j, i}$ 表示第 $j$ 维走了 $i$ 步的合法位置数</p>
<p>$\prod$ 写作 $\sum$, $f(x) = \sum_i c_i x^i$，最终答案即为 $\sum_i c_i (\sum\limits_{i = 1}^{mx} x_i)$（$mx$ 是走的轮数上限。</p>
<p>后面这玩意是个自然数幂和，$k \leq 3$ 时有通项公式，$k &gt; 3$ 时可以预处理因为题目保证 $max_{w_i} \leq 1e6$.</p>
<p>$O(nk^2)$，乘法是 $k^2$, 听说因为 $F$ 变化量小，通过什么拉格朗日插值可以做到 $O(nk)$（蒟蒻不会内个</p>
<h1 id="「不要在脑海里激情澎湃一会儿就当努力过了。」"><a href="#「不要在脑海里激情澎湃一会儿就当努力过了。」" class="headerlink" title="「不要在脑海里激情澎湃一会儿就当努力过了。」"></a><em>「不要在脑海里激情澎湃一会儿就当努力过了。」</em></h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/以 CF1327F 为代表的一类限制计数问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/08/以 CF1327F 为代表的一类限制计数问题/" itemprop="url">
                  以 CF1327F 为代表的一类限制计数问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T18:07:40+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这类有限制的计数问题，套路在状态设计上。一般是区间上的问题，切入点是发现 dp 的要点有当前位置和满足限制的位置以及满足了哪些限制；转移就是 对于同一种限制同一个右端点找到最大的左端点，这之间必须有一个满足要求的位置。</p>
<h2 id="CF1327F"><a href="#CF1327F" class="headerlink" title="$CF1327F$"></a>$CF1327F$</h2><hr>
<p>按位处理，可以算出每一位的答案然后乘起来。子问题的解决必须是 $O(n)$ 的！！</p>
<p>限制为 1 很好处理，全部强制为 1 就可以了；为 0 就比较难搞，要求至少有一个位置是 0。</p>
<p>先只考虑为 0 的限制。对于一个位置 $i$ 找到所有右端点 $\leq i$ 的限制的最大左端点，设其为 $l_i$。$f[i, j]$ 表示填完了前 $i$ 个位置，满足了右端点 $\leq i$ 的所有限制，最后一个 0 的位置在 $j$，其中 $l_i \leq j \leq i$ 的方案数</p>
<p>那么 $f[i, j] = f[i - 1, j]$ $(j &lt; i)$，$f[i, i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[i - 1, k]$</p>
<p>想优化空间。发现 $i \neq j$ 的 $f[i, j]$ 好像没什么用，干脆令 $f[i]$ 表示原来的 $f[i, i]$，$f[i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[k]$。发现求了一个后缀和，又发现 $l_i$ 单调递增，所以 dp 是 $O(n)$ 的。</p>
<p>那加上 1 的限制怎么办？把那些已经强制为 1 的点拎走，剩下的做 dp。</p>
<p><a href="https://codeforces.com/problemset/submission/1327/92203899" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="清华集训2017-某个歌姬的故事"><a href="#清华集训2017-某个歌姬的故事" class="headerlink" title="$[清华集训2017]-某个歌姬的故事$"></a>$[清华集训2017]-某个歌姬的故事$</h2><hr>
<p>离散化（u1s1这题离散化是大毒瘤。）</p>
<p>预处理出每个位置的上限 $up_i$，这样就把 $up_i$ 相同的相邻位置缩成了一个点。</p>
<p>对于限制 $[l_j, r_j, m_j]$ 显然只有 $l_j \leq i \leq r_j$ 中 $up_i = m_j$ 的点能贡献。<br>于是对于每个 $m_j$ 将所有 $up_i = m_j$ 的点拿出来做 dp。</p>
<p>怎么d？显然是满足每个限制区间内有一个点达到上限即可。<br>令 $f[i, j]$ 表示满足所有 右端点在 $1$ ~ $i$ 的限制，选的最后一个点是 $j$ 的方案数。</p>
<p>不同的 $m_j$ 是独立的，分别 dp 后把答案乘起来。</p>
<p><a href="https://loj.ac/submission/927800" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="NOI2020-D1T2-命运"><a href="#NOI2020-D1T2-命运" class="headerlink" title="$[NOI2020 D1T2]-命运$"></a>$[NOI2020 D1T2]-命运$</h2><hr>
<p>区 间 上 树（</p>
<p>这个比赛时连 dp 方程都想不到。。。就写了最暴力的指数级容斥。。<strong>但实际上跟前两题的 dp 设计思路是很相似的！</strong></p>
<p>$dp[i, j]$ 表示 $i$ 的子树内状态已经确定，没有满足的链顶点的最大深度为 $j$ 的方案数（记录最深是因为深的满足了，浅的也满足了），边界就是链都满足了，$j = 0$</p>
<p>$$dp[x, i] = (\sum\limits_{j = 0}^{dep_x} dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^i dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^{i - 1} dp[x, j] \times dp[y, i])$$</p>
<p>前两部分分别是 $(x, y)$ 这条边为 1 和为 0 的方案数。</p>
<p>二维dp，前缀和形式。。噫，这个东西和 pkuwc2018-minimax 好像啊！没错，就是整体dp，上线段树合并。</p>
<p>跟 minimax 一样的，碰到叶子结点就返回，其他节点由儿子节点 upd 上来。</p>
<p><a href="https://loj.ac/submission/927792" target="_blank" rel="noopener">$Code$</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/[COCI2010]-ZUMA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/08/[COCI2010]-ZUMA/" itemprop="url">
                  [COCI2010]-ZUMA
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T14:46:40+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次碰到不会做的区间 dp。。这题的难点在于设计 dp 状态。。</p>
<p>发现普通的思路 $f[i, j]$ 没有办法做</p>
<p>$f[i, j, k]$ 表示在区间 $[i, j]$ 前放了 $k$ 个与 $c[i]$ 同色的球，连带着新加的球全部消掉的最小球数。</p>
<p>$f[i, j, k] =$</p>
<ol>
<li>$f[i, j, k + 1] + 1$（在前面加一个球）</li>
<li>$f[i + 1, j, k + 1]$ $(c[i] = c[i + 1])$</li>
<li>$f[i + 1, p - 1, 0] + f[p, j, k + 1]$ $(c[i] = c[p])$</li>
</ol>
<p>边界：$f[i, i, j] = K - 1 - j$</p>
<p>$f[i, j, K - 1] =$</p>
<ol>
<li>$f[i + 1, j, 0]$</li>
<li>$f[i + 1, j, K - 1]$ $(c[i] = c[i + 1])$（因为要求 $\geq K$ 个连续的球）</li>
<li>$f[i + 1, p - 1, 0] + f[p, j, K - 1]$（理由同 2）</li>
</ol>
<p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, KK = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, c[N], f[N][N][KK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = min(x, y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        rep(j, <span class="number">0</span>, K - <span class="number">1</span>) f[i][i][j] = K - <span class="number">1</span> - j;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - len + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][K - <span class="number">1</span>]);</span><br><span class="line">            rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                    chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][K - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = K - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                chkmin(f[i][j][k], f[i][j][k + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                    chkmin(f[i][j][k], f[i + <span class="number">1</span>][j][k + <span class="number">1</span>]);</span><br><span class="line">                rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                    <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                        chkmin(f[i][j][k], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/Codeforces Round 664 Div1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/08/Codeforces Round 664 Div1/" itemprop="url">
                  Codeforces Round 664 Div1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-08T13:37:40+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>China-Round 好神仙 &gt; &lt;</p>
<p>xry 都参与出题啦，我们这届也开始征战四方了！加油，无限可能。</p>
<h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><hr>
<p>小贪心，先分成两个集合，枚举大的集合取几个。</p>
<p><a href="https://codeforces.com/contest/1394/submission/92126211" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><hr>
<p>趣题！要求的是<strong>任何</strong>点都能走回到自己，$k$ 这么小显然指数级枚举啦，问题在于怎么快速判断</p>
<p>考虑 $n$ 条边这个条件，也就是说有 $n$ 个入度，而每个点都能走回到自己，每个点都有一个入度，这意味着 $n$ 条边的终点遍布 $n$ 个点</p>
<p>那么预处理一些东西，只要能实现集合并就好了。$bitset$ 过不去，怎么办？$hash$！$O(1)$ 合并</p>
<p>注意写双$hash$！学习一波新写法 :)</p>
<p><a href="https://codeforces.com/contest/1394/submission/92131053" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><hr>
<p>好题！</p>
<p>最大值最小，考虑二分（判定性问题就可做很多啦！</p>
<p>发现两个串相似的条件是 B 和 N 的个数相等，操作其实是加或减 $B$、$N$、$BN$</p>
<p>那么问题转化为判定是否存在一个 $t$ 使得对于任何 $i$，$dis(s_i, t) \leq mid$</p>
<p>来细化一下：在平面上，设 $s_i$ 对应的点为 $(a, b)$, $t$ 对应的点为 $(c, d)$, $dis(s_i, t) =$</p>
<ol>
<li>$(a - c)(b - d) &gt; 0$: $max{|a - c|, |b - d|}$</li>
<li>$(a - c)(b - d) &lt; 0$: $|a - c| + |b - d|$</li>
</ol>
<p>显然满足异号限制的点必然满足同号限制，即可以看做同号限制对所有 $s_i$ 都适用</p>
<p>化开来 $|x - x_i| \leq mid$, $|y - y_i| \leq mid$，即 $x \in [x_i - mid, x_i + mid]$, $y \in [y_i - mid, y_i + mid]$</p>
<p>对于异号限制，想想怎么把它化作“对所有都适用且刚好限制到异号点”</p>
<p><strong>这里有个经典trick：$|x| + |y| = |x - y|$，对于同号没有影响，而对于异号是等价的</strong></p>
<p>所以 $|(x - y) - (x_i - y_i)| \leq mid$，即 $(x - y) \in [x_i - y_i - mid, x_i - y_i + mid]$</p>
<p>至此我们得到了 $x$, $y$, $x - y$ 的限制，枚举一维就能得到另一维的范围，判断有无交就可以了。</p>
<p><a href="https://codeforces.com/contest/1394/submission/92186512" target="_blank" rel="noopener">$Code$</a></p>
<h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><hr>
<p><a href="https://blog.aor.sd.cn/archives/1246/" target="_blank" rel="noopener">咕咕，记一下大佬博客</a></p>
<h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><hr>
<p>咕咕</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/06/[LG4260]-博弈论与概率统计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/06/[LG4260]-博弈论与概率统计/" itemprop="url">
                  [LG4260]-博弈论与概率统计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-06T20:58:40+08:00">
                2020-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>赢的场数都确定了，$p$ 一点用都没有，我们要算出得分之和以后除以 $C(n + m, n)$。所以这是道计数题？</p>
<p>不能小于 0，想到了啥，卡特兰数！考虑平面上向右向上走问题</p>
<p>假设 $n \geq m$, 从 $(0, 0)$ 走到 $(n, m)$ 贡献是 $n - m$，方案数是 $C(n + m, n) - C(n + m, n + 1)$，就是用总数 - 碰到了边界线的方案数</p>
<p>从 $(0, 0)$ 走到 $(n, m - 1)$ 贡献是 $n - m + 1$，方案数是 $C(n + m, n + 1) - C(n + m, n + 2)$</p>
<p>…</p>
<p>所以总贡献是 $\sum \limits_{i = 0}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = (n - m)C(n + m, n) + \sum\limits_{i = 0}^{m - 1}C(n + m, i)$</p>
<p>$n &lt; m$ 会怎么样，$\sum \limits_{i = m - n}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = \sum\limits_{i = 0}^{n - 1}C(n + m, i)$</p>
<p>这样就结束啦（</p>
<p>哦不 多组询问。。</p>
<p>发现形如 $f(n, k) = \sum\limits_{i = 0}^k C(n, i)$ 的东西很难求</p>
<p>发现 $f(n, k) = \sum\limits_{i = 0}^k C(n - 1, i - 1) + C(n - 1, i) = 2f(n - 1, k) - C(n - 1, k)$</p>
<p>发现知道了 $f(n, k)$ 就可以在 $O(1)$ 时间内推出 $f(n \pm 1, k)$ 和 $f(n, k \pm 1)$！</p>
<p>莫队求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll T, p, unit = <span class="number">500</span>, tot;</span><br><span class="line">ll ans[N], fac[N], inv[N], divv[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> ll n, k, id; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = inv[i] * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.n / unit == b.n / unit ? a.k &lt; b.k : a.n / unit &lt; b.n / unit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; p;</span><br><span class="line">    pre(<span class="number">500000</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= m) &#123;</span><br><span class="line">            ans[i] = (n - m) * C(n + m, n) % mod;</span><br><span class="line">            q[i].k = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].k = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        q[i].n = n + m;</span><br><span class="line">        divv[i] = fac[n] * fac[m] % mod * inv[n + m] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + T + <span class="number">1</span>, cmp);</span><br><span class="line">    q[<span class="number">0</span>].n = <span class="number">-1e9</span>;</span><br><span class="line">    ll nn = <span class="number">0</span>, kk = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].k &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[i - <span class="number">1</span>].k &lt; <span class="number">0</span> || q[i - <span class="number">1</span>].n / unit &lt; q[i].n / unit) &#123;</span><br><span class="line">            nn = q[i].n, kk = q[i].k;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">0</span>, kk) (tot += C(nn, j)) %= mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nn &lt; q[i].n) tot = (tot * <span class="number">2</span> % mod - C(nn, kk) + mod) % mod, ++nn;</span><br><span class="line">            <span class="keyword">while</span> (nn &gt; q[i].n) --nn, tot = (tot + C(nn, kk)) % mod * inv[<span class="number">2</span>] % mod;</span><br><span class="line">            <span class="keyword">while</span> (kk &lt; q[i].k) ++kk, (tot += C(nn, kk)) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        (ans[q[i].id] += tot + mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i] * divv[i] % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/[LnOI2019]-加特林轮盘赌/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/05/[LnOI2019]-加特林轮盘赌/" itemprop="url">
                  [LnOI2019]-加特林轮盘赌
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T15:16:40+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有意思的题（我不会概率所以它超有意思（</p>
<p>比较妙的通过“环”的性质，化无限为递推。设 $f[n, k]$ 表示长度为 $n$ 的环中第 $k$ 个人唯一幸存的概率，那么有 $f[n, k] = p0 \times f[n - 1, k - 1] + (1 - p0) \times f[n, k - 1]$, 特别的 $f[n, 1] = (1 - p0) \times f[n, n]$</p>
<p>这玩意作为 dp 有后效性，想到消元。暴力消元炸没了，但我们发现假设前 $i - 1$ 行都算出来了，第 $i$ 行所有 $f[i, j]$ 只与 $f[i, 1]$ 有关，于是想到经典套路：表示成 $a \times f[i, 1] + b$ 的形式，$\sum\limits_{j = 1}^i f[i, j] = 1$，解出 $f[i, 1]$。</p>
<p>$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> p0, f[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, K, cur = <span class="number">1</span>, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p0 &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (!p0) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(n == <span class="number">1</span> ? <span class="string">"1"</span> : <span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        lst = cur; cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span>, A = <span class="number">0</span>, b = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">2</span>, i) &#123;</span><br><span class="line">            a *= (<span class="number">1</span> - p0);</span><br><span class="line">            A += a;</span><br><span class="line">            b = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * b;</span><br><span class="line">            B += b;</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">1</span>] = (<span class="number">1</span> - B) / (A + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">2</span>, i)</span><br><span class="line">            f[cur][j] = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * f[cur][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, f[cur][K]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法利用等比数列求和公式。设当前轮 $f[i]$ 表示 $i$ 唯一存活的概率，$g[i]$ 表示 $i$ 被打死的概率，$g[i] = (1 - p0)^{i - 1} p (\sum\limits_{j = 0}^{\infty} ((1 - p)^n)^i) = \frac{(1 - p)^{i - 1}}{1 - ((1 - p)^n)^i}$，然后每打死一个人就得到一个新的局面。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="imily" />
          <p class="site-author-name" itemprop="name">imily</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">312</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index-1.html">
                <span class="site-state-item-count">110</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imily</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

</body>
</html>
