<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【置顶】嘴巴</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%98%B4%E5%B7%B4/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%98%B4%E5%B7%B4/</url>
      
        <content type="html"><![CDATA[<p>要锻炼思维就不能每道都写。（然而这并不意味你写就草草写！xml 的赛场调试水平之差有目共睹 qaq…）因 此 开 了 「㗅」坑。</p><p>嘴巴题不会放在「学习计划」里。</p><p>因为是嘴巴题所以低配，一律 details。</p><p>加星号的是打算有时间写写的。</p><h3 id="LOJ6669"><a href="#LOJ6669" class="headerlink" title="$LOJ6669$"></a><a href="https://loj.ac/p/6669" target="_blank" rel="noopener">$LOJ6669$</a></h3><details>询问 n 次得出每个点深度，同时也得出了重链。按深度 bfs，对于当前点 x，从以根为链顶的重链开始，询问 x 和该重链底的距离，得出 LCA 的深度，若刚好为 dep_x + 1 则父亲找到，否则因为是二叉树，跳到该重链顶点唯一的轻儿子开始新的重链询问。O(nlogn)</details><h3 id="CF741D"><a href="#CF741D" class="headerlink" title="$CF741D$"></a><a href="https://www.luogu.com.cn/problem/CF741D" target="_blank" rel="noopener">$CF741D$</a></h3><details>「重排」这个条件非常强：所有字符只能有最多一种出现奇数次。奇偶性考虑异或。对于一种 01 路径维护最长的那条。启发式合并每个子树的路径。O(nlogn)</details><h3 id="BZOJ4771-七彩树"><a href="#BZOJ4771-七彩树" class="headerlink" title="$BZOJ4771-$七彩树"></a>$BZOJ4771-$七彩树</h3><details>多次询问子树 x 里深度为 [dep_x, dep_x + d] 有多少种不同的颜色。无脑线段树合并复杂度肯定错了嘛。不考虑深度限制，初始时某颜色 c 的两个点 a、b 各自贡献是 1，到了 lca(a, b) 就要除去 1 个贡献。最后答案是子树和。考虑深度限制：预处理距离每个 x <= 1 d 的答案。[dep_x, dep_x + d] 在 dfs 序上是连续的。 假设我们已经有 <="d" - 的答案，那就把深度为 的答案加进来，按 序插在主席树里就好。（好㗅 details><h3 id="AGC051D"><a href="#AGC051D" class="headerlink" title="$AGC051D$"></a><a href="https://atcoder.jp/contests/agc051/tasks/agc051_d" target="_blank" rel="noopener">$AGC051D$</a></h3><details>巧妙处理。路径的分类标准是什么？我模糊感觉到不同的类别之间应该要有关联。怎么用合适的分类去把 abcd 关联起来呢？官方题解：分三类。1. 过 $T$ 型。$S \rightarrow T \rightarrow U$, $U \rightarrow T \rightarrow S$2. 过 $V$ 型。$S \rightarrow V \rightarrow U$, $U \rightarrow V \rightarrow S$3. 回型。$S \rightarrow T \rightarrow S$, $S \rightarrow V \rightarrow S$, $U \rightarrow T \rightarrow U$, $U \rightarrow V \rightarrow U$枚举过 $T$ 型和过 $V$ 型的数量，列出一个好多组合数的柿子，然后变成阶乘再 FFT。。大概就完了，主要是分类比较神。</details><h3 id="WC2018-即时战略"><a href="#WC2018-即时战略" class="headerlink" title="WC2018-即时战略"></a><a href="https://uoj.ac/problem/349" target="_blank" rel="noopener">WC2018-即时战略</a></h3><details>好像没什么特别妙的= =……？数据范围一眼 log。要一棵树支持：1. 加点 2. 快速跳到一个点方法一：二分！LCT，在实链上不断二分，然后跳到下一个实链。方法二：点分树 + 替罪羊重构。维护已知树的点分树，设 explore(x, y) = z，从 z 开始向上跳 logn 次找到 z 在 x 的哪个点分子树里，跳过去。这样的上跳要点分树深度次即 logn 次，于是是 O(nlog^2n) 的。</details></=></details>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】Ideas &amp; Tricks</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91Ideas%20&amp;%20Tricks/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91Ideas%20&amp;%20Tricks/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】暂时胜利</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%9A%82%E6%97%B6%E8%83%9C%E5%88%A9/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%9A%82%E6%97%B6%E8%83%9C%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】耻辱柱</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E8%80%BB%E8%BE%B1%E6%9F%B1/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E8%80%BB%E8%BE%B1%E6%9F%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="多测清空：特别是建图，cnt清否？lnk清否？deg清否？"><a href="#多测清空：特别是建图，cnt清否？lnk清否？deg清否？" class="headerlink" title="多测清空：特别是建图，cnt清否？lnk清否？deg清否？"></a>多测清空：特别是建图，cnt清否？lnk清否？deg清否？</h2><h2 id="set：不能在-it-的-for-循环中-erase-it"><a href="#set：不能在-it-的-for-循环中-erase-it" class="headerlink" title="set：不能在 it 的 for 循环中 erase(it)"></a>set：不能在 it 的 for 循环中 erase(it)</h2><h2 id="dp-要注意如果有-f-i-min-f-i-j-g-j-，注意判-f-i-j-g-j-会不会炸-long-long（初始值是-1e18-的话会炸！！！）"><a href="#dp-要注意如果有-f-i-min-f-i-j-g-j-，注意判-f-i-j-g-j-会不会炸-long-long（初始值是-1e18-的话会炸！！！）" class="headerlink" title="dp 要注意如果有 f[i] = min(f[i - j] + g[j])，注意判 f[i - j] + g[j] 会不会炸 long long（初始值是 1e18 的话会炸！！！）"></a>dp 要注意如果有 f[i] = min(f[i - j] + g[j])，注意判 f[i - j] + g[j] 会不会炸 long long（初始值是 1e18 的话会炸！！！）</h2><p>——wc2020 场外赛 25 pts$</p><h2 id="分母是否为-0？nan！"><a href="#分母是否为-0？nan！" class="headerlink" title="分母是否为 0？nan！"></a>分母是否为 0？nan！</h2><p>——模拟赛 100 -&gt; 0</p><h2 id="取模模-0-了吗？RE！"><a href="#取模模-0-了吗？RE！" class="headerlink" title="取模模 0 了吗？RE！"></a>取模模 0 了吗？RE！</h2><p>——做题，wa 了 inf 次</p><h2 id="取模取对了吗？正负对了吗？最好输出前-ans-mod-mod！"><a href="#取模取对了吗？正负对了吗？最好输出前-ans-mod-mod！" class="headerlink" title="取模取对了吗？正负对了吗？最好输出前 (ans += mod) %= mod！"></a>取模取对了吗？正负对了吗？最好输出前 (ans += mod) %= mod！</h2><p>——noi2020同步赛 D1T2 ？分</p><h2 id="字母打错了吗？"><a href="#字母打错了吗？" class="headerlink" title="字母打错了吗？"></a>字母打错了吗？</h2><p>——noi2020同步赛 D1T3 24 分，r1、r2 打成 c1、c2</p><h2 id="空间开大了吗？哪怕卡着都不行！"><a href="#空间开大了吗？哪怕卡着都不行！" class="headerlink" title="空间开大了吗？哪怕卡着都不行！"></a>空间开大了吗？哪怕卡着都不行！</h2><p>——模拟赛 80 -&gt; 0</p><h2 id="空间开小了吗？2e5-开了-1e5？"><a href="#空间开小了吗？2e5-开了-1e5？" class="headerlink" title="空间开小了吗？2e5 开了 1e5？"></a>空间开小了吗？2e5 开了 1e5？</h2><p>——模拟赛 80 -&gt; 50</p><h2 id="floor-x-是小于等于-x-的最大整数，ceil-x-是大于-x-的最小整数"><a href="#floor-x-是小于等于-x-的最大整数，ceil-x-是大于-x-的最小整数" class="headerlink" title="floor(x) 是小于等于 x 的最大整数，ceil(x) 是大于 x 的最小整数"></a>floor(x) 是小于等于 x 的最大整数，ceil(x) 是<strong>大于</strong> x 的最小整数</h2><p>——模拟赛 fst 了一定分</p><h2 id="C-n-m-里写-if-n-lt-m-return-0-了吗？"><a href="#C-n-m-里写-if-n-lt-m-return-0-了吗？" class="headerlink" title="C(n, m) 里写 if (n &lt; m) return 0; 了吗？"></a>C(n, m) 里写 if (n &lt; m) return 0; 了吗？</h2><h2 id="builtin-popcount-不适宜计算-long-long-类型的答案（不知道为啥）"><a href="#builtin-popcount-不适宜计算-long-long-类型的答案（不知道为啥）" class="headerlink" title="__builtin_popcount() 不适宜计算 long long 类型的答案（不知道为啥）"></a>__builtin_popcount() 不适宜计算 long long 类型的答案（不知道为啥）</h2><p>真要用的话可以用 __builtin_popcountll()</p><h2 id="double-题用-int-计算斜率-坐标了吗？"><a href="#double-题用-int-计算斜率-坐标了吗？" class="headerlink" title="double 题用 int 计算斜率/坐标了吗？"></a>double 题用 int 计算斜率/坐标了吗？</h2><h2 id="输出-0-的输出-1-了吗？输出-1-的输出-0-了吗？"><a href="#输出-0-的输出-1-了吗？输出-1-的输出-0-了吗？" class="headerlink" title="输出 0 的输出 -1 了吗？输出 -1 的输出 0 了吗？"></a>输出 0 的输出 -1 了吗？输出 -1 的输出 0 了吗？</h2><p>——模拟赛 100 -&gt; 60</p><h2 id="变量重名了吗？外面-i-里面也是-i"><a href="#变量重名了吗？外面-i-里面也是-i" class="headerlink" title="变量重名了吗？外面 i 里面也是 i"></a>变量重名了吗？外面 i 里面也是 i</h2><h2 id="SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。"><a href="#SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。" class="headerlink" title="SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。"></a>SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。</h2><h2 id="递归函数里的变量（比如数组的项首）别开在全局"><a href="#递归函数里的变量（比如数组的项首）别开在全局" class="headerlink" title="递归函数里的变量（比如数组的项首）别开在全局"></a>递归函数里的变量（比如数组的项首）别开在全局</h2><p>——bzoj3636 调半天</p><h2 id="注意-n、m-等主要变量的最大范围是否出现在同一档分里"><a href="#注意-n、m-等主要变量的最大范围是否出现在同一档分里" class="headerlink" title="注意 n、m 等主要变量的最大范围是否出现在同一档分里"></a>注意 n、m 等主要变量的最大范围是否出现在同一档分里</h2><p>——模拟赛的惨痛遭遇 挂 80pts</p><h2 id="不要再不排序求前缀和了！！！💢💢💢"><a href="#不要再不排序求前缀和了！！！💢💢💢" class="headerlink" title="不要再不排序求前缀和了！！！💢💢💢"></a>不要再不排序求前缀和了！！！💢💢💢</h2><p>——模拟赛 100 -&gt; 0</p><h2 id="线段树要记得-pushdown-和-update。。。"><a href="#线段树要记得-pushdown-和-update。。。" class="headerlink" title="线段树要记得 pushdown 和 update。。。"></a>线段树要记得 pushdown 和 update。。。</h2><h2 id="Tarjan-边双要记录入边"><a href="#Tarjan-边双要记录入边" class="headerlink" title="Tarjan 边双要记录入边"></a>Tarjan 边双要记录入边</h2><h2 id="数组-5e5-开成-1e5"><a href="#数组-5e5-开成-1e5" class="headerlink" title="数组 5e5 开成 1e5"></a>数组 5e5 开成 1e5</h2><p>——模拟赛 100 -&gt; 60</p><h2 id="线段树-if-lx-gt-rx-return"><a href="#线段树-if-lx-gt-rx-return" class="headerlink" title="线段树 if (lx &gt; rx) return;"></a>线段树 <code>if (lx &gt; rx) return;</code></h2><p>——模拟赛 100 -&gt; 30</p><h2 id="链式前向星-i-nxt-i-老是写错。"><a href="#链式前向星-i-nxt-i-老是写错。" class="headerlink" title="链式前向星 i = nxt[i] 老是写错。"></a>链式前向星 <code>i = nxt[i]</code> 老是写错。</h2><p>——虫逢 T 成 sb</p><h2 id="vector-insert-O-n"><a href="#vector-insert-O-n" class="headerlink" title="vector .insert() O(n)"></a>vector .insert() O(n)</h2><h2 id="printf-“-lld”-0"><a href="#printf-“-lld”-0" class="headerlink" title="printf(“%lld”, 0)"></a>printf(“%lld”, 0)</h2><p>——BOOM！</p><h2 id="mul-int-类型写成-void"><a href="#mul-int-类型写成-void" class="headerlink" title="mul() int 类型写成 void"></a>mul() int 类型写成 void</h2><p>——40 分 has gone！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】卡常小记</title>
      <link href="2099/11/29/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%A1%E5%B8%B8%E5%B0%8F%E8%AE%B0/"/>
      <url>2099/11/29/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%A1%E5%B8%B8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+jnzR8XjUMMJeU5WiIOg8L2yS2PiK2JEszrS42YySP82R5ojatzS4hli7SqPnf/hLCg0oyDSVPA0PL1+5NMHwx2hoAtc+CrgRpwOcdPZu4BwqHtpqaF/8li3f1dy6if7/9I69AKxFCx5bNDN9XAxV/01DOyrIBje7qW6dsHCqFqAkpJSHLqMvoDmGEi3OSogS53yqebR53b7W4VsNkdj1acomqPvWBzI4pZ6KAOaBj36eerWyNSj2+jV6ESDc0+VWkSedAtYixX1LMmnWJ2T9CgGvlRx/83AplQ64m9P9ckORGNav68gBAOEbaUxVJD0Iac5nkcSq3dgX+Xo1SyvWd6TEB5ZMHSPf8/m1VGOS4FQVQx2+FwV0D9h8ZxjESorRGcEJ3V8QUzLa9wZB0lZ43fSDmy4+6oJqTultjcig7yP9ZWpbJMtU0L2R1CmjSYyW++ttsq/wDBbVZGXImkKeCuKUWwkTnedunyHIc194J45x2Lh31BosN8T+h4MlQcg2xK6OCkqJXfnT2JlB4FiLgKaCxk7oRBRKT2vYMeGf54V32nmKmY5FvIKS4wP3LW7XFkXdE/a0Np2UDeeaUsPFZhOOmpjwlFhQE4+DuAiIKnEJWl0k+9lJF7Jc7gQfi7bFcuSFz+vfkwCuMopxE44Z41yGStnjGuI4PJm/jBh7xSVnj5Tmr436SSVXPZcn6U93h0gu7zQ7AsbcALfTxZcQjoR/iRf+Fs5T1NYvkaonjDzCrSBQqLN81zILUY47219XRV5aWWWR2p8a2ZZf1RTO/eNwKwAAwobnMlrV+Z+eLb1PDB8JI4guT4m90cPQyi57Vi1RaBKrImx1bwMPZowXGt3Y/r9alrLjvGXvCPS4uqR8bSzpajJjODi4ZkjR6s+tDZew4VdcfSKqqX7ERp+Ghmj3PFZj1okM1n2ZIlPBSmUAexHhHmmMlfy//Az/3aZ/qzypeMC+DNI/PTZLClJ2bbLJerdwfydYyBd4DJHBpxKVIPP9YgUI+o5LztqjFNcd3gaqHV/IhnhQ0ak7rVQdotEZTAftJ0ppnQgC/geR01dqdAqtNipWO2mmh2jPOU4IzVHw3zUbDtdWRGz9AiWRqqaqXUas+ZjyO+9Put6DCWuF6Ancf2SqVJUEbdLlqQTERpQqA2svI2Q==</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】摘抄本</title>
      <link href="2099/11/28/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%91%98%E6%8A%84%E6%9C%AC/"/>
      <url>2099/11/28/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%91%98%E6%8A%84%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX19fPruwmqR1XtiayA/5kQp8bev7ya2pgu3CCvcyeHvpY0xL0Zs6IWd55jEAfkMU/+B8kxhq2lLcMTVNePJTYugF2Y9IzJsyeRh1k1d2a2WKn8qjc4I1oxurDdetR7MuiF6rcWLt8CckRSS8KVBx6XyoDiCrNRHMlI6SmAWkG+0Ka5Anvnob0yC+iSnHNX/3pgJkO1kMBew961MzGYRlKdTvAzA94xCmecNWVjAsRSSHsEdGwjGMbvxnor93nPLHeO8CozXT5ERm1bG0+7X4Zuc7Bbk9H/kIXp+UosMcCaFINrIB26VVLsuOzeakXo6l81f6Tv8Uv20QXM4IMr2Ioo4QmzaoYrPumzK7/t5sBFauH0So/f2vJScna6ZbGUpvICBKnhOQ3NZ0msC84HryY7onVW5ZZlONwkrbvts2AQ8yiW0KubXLioEgX6xfgZNJ3dUBSBfjUOIRlqssOk7PuosT5H/9yawZxl7iS2X2FzOyzcp99HF1r8nEbWcLyBjjHTRHXx52lijSCTYDnoWWKIGK6DO5BxTSFVRCrpUiecPBYh0Ax9ZGDStT0GnzmNJEpJZE9yXnXPcJvG3l8Jh4APldrohJd9wFygkAaIRGodauaKlFPqErQ94aZwc4IZTikudhU7iCGeTO1/JtIY9MR1IP86h5i4hv6KltA5Kv4mQyM96QCLccTFqUVhQTqQ7ixLj9c+OSMmvxjnpza2jnUTeOoWnqpt/oMAr7IP/iWRxVEmcGNSfjfvpmMa0SZ3eui2NR5PHVHYKGfxExrg21Ak8GMhqfJ/+ZGCalwsZ1/Xu9rC4Pr6h2rpl4svSQ74AJcdXMwIKr0CwsNJ7T/iaw3I2Uk0n7QOUC5NbJ56eKl4sBrjJXAJgcPAtNfr+rFR3maRrv128EHdgOvySq2moOSNK5r2xtqzVhin09DMvT/EASl+Hn3CO5Vr609i0Apf+yChQDk5A3ByNdUKZu8mZYr+xDuTAAo/AptWSeVpmLT8feHUOCZ4bNDZNCZ+8AG9WfXsnwktrdM8J93wnMV7JfILse72qON6W4EVWdkNzxUt5sNX88liM8xbMnV52Kg+fUwr1qRokG04nbhJV4rSjc1PeWkK3TxXUYkaiZJP+xKEgFrQpJODY7APKRgbdVlnUlZLHspedA0PLNXQ==</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21Mar 训练日志</title>
      <link href="2021/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Mar%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Mar%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】拟阵</title>
      <link href="2021/03/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8B%9F%E9%98%B5/"/>
      <url>2021/03/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8B%9F%E9%98%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 拟阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】保序回归</title>
      <link href="2021/03/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BF%9D%E5%BA%8F%E5%9B%9E%E5%BD%92/"/>
      <url>2021/03/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BF%9D%E5%BA%8F%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p><del>因 题 开 坑，传 统 艺 能</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 保序回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2020 乱写</title>
      <link href="2021/03/08/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892020%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/03/08/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892020%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E8%81%94%E5%90%88%E7%9C%81%E9%80%89" target="_blank" rel="noopener">link</a></p><h3 id="冰火战士"><a href="#冰火战士" class="headerlink" title="冰火战士"></a>冰火战士</h3><p>就是求一个 $lim$ 使得 $\min( \sum\limits_{b_i \leq lim} a_i, \sum\limits_{d_i \geq lim} c_i )$ 最大。$X$ 型函数求交点问题，考虑二分，但线段树上二分太慢了……</p><p>卡常神器：BIT + 倍增。二分找到第一个冰系前缀和不小于火系后缀和的位置，稍微移项得「两种前缀和之和不小于火系全和」。</p><p><a href="https://loj.ac/s/1085474" target="_blank" rel="noopener">$Code$</a></p><h3 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h3><p>Trick：$\binom{n}{k} k^{\underline{m}} = \binom{n - m}{k - m} n^{\underline{m}}$（易证）</p><p>把 $f(k)$ 变成下降幂形式 $\sum\limits_{i = 0}^m b_i k^{\underline{i}}$，再把 $\binom{n}{k} k^{\underline{i}}$ 变成 $\binom{n - i}{k - i} n^{\underline{i}}$，变换求和符号，上二项式定理就做完了。</p><p><a href="https://loj.ac/s/1088152" target="_blank" rel="noopener">$Code$</a>  <del>模数非质啊啊啊</del></p><h3 id="信号传递"><a href="#信号传递" class="headerlink" title="信号传递"></a>信号传递</h3><p>状压 dp, $f_S = \min_x( f_{S - x} + |S| * ( \sum\limits_{y \in S - x} (K * c_{x, y} + c_{y, x}) + \sum\limits_{y \notin S - x} (K * c_{y, x} - c_{x, y}) ) )$。复杂度 $O(2^m m^2)$，空间 $O(2^m m)$，都不行。</p><p>考虑把 $|S| *$ 后面那坨括号设为 $g_{S, x}$，后面那个计算 $y \notin S - x$ 的用容斥，即最开始先算好全集，到时候抠掉 $y \in S - x$ 的错误贡献就好了。则 $g_{S, x} = g_{S - x, x} + (K * c_{x, y} + c_{y, x} ) - ( K * c_{y, x} - c_{x, y} )$，$y$ 取 $lowbit(S - x)$ 这样转移就是 $O(1)$ 的了。</p><p>空间怎么搞呢？注意到每个 $g_{S - x}$ 在给 $g_{S}$ 转移完后就失去价值了，考虑回收。具体用 queue 实现。</p><p><a href="https://loj.ac/s/1087320" target="_blank" rel="noopener">$Code$</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>逆建 01 Trie（从低位到高位插入），维护 $v_{a_i} + d(x, a_i)$ 的集合，这样每次 $+ 1$ 就是 $0$ 变 $1$ 并返回，或者 $1$ 变 $0$ 并继续递归。直接交换儿子并递归到改后的 $0$ 子树里去继续修改就好了。记录每位 $1$ 的奇偶。单次 $logV$，总的就是 $nlogV$。</p><p><a href="https://loj.ac/s/932042" target="_blank" rel="noopener">$Code$</a></p><hr><p>还剩两道毒瘤题。。。/kk</p><hr><h3 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h3><p>反演一波，根据 $n = \sum\limits_{d \mid n}$ 可得 $ans = \sum\limits_{d = 1}^{V} \varphi(d) \sum\limits_{d \mid w_{e_i}} ( \sum\limits_{i = 1}^{n - 1} w_{e_i} )$</p><p>trick: 矩阵树求边权和，边权为 $1 + w_i x$，答案为行列式的一次项系数。所以行列式只需在模 $x^2$ 意义下计算，维护 $x^0$ 和 $x^1$ 项即可。<del>拉插就算了吧</del></p><p>复杂度 $O(Vn^3)$，会 T。玄学优化：边少于 $n - 1$ 就跳过。于是非常跑不满。</p><p>行列式除法：$(ax + b)^{-1} \equiv -\frac{a}{b^2} + \frac{1}{b} \pmod{x^2}$；寻找当前位置非零行，若存在常数项非零则直接选那个，否则常数项都为零，选一次项系数非零的。代码超好写。</p><p><a href="https://loj.ac/s/1088258" target="_blank" rel="noopener">$Code$</a></p><h3 id="魔法商店"><a href="#魔法商店" class="headerlink" title="魔法商店"></a>魔法商店</h3><p><del>终于……要开始贺了么……</del></p><p>超级大毒瘤题。拟阵？保序回归？蒟蒻全都不会哒！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】LGV 引理</title>
      <link href="2021/03/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LGV%20%E5%BC%95%E7%90%86/"/>
      <url>2021/03/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LGV%20%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><p>LGV 引理，用来处理<strong>有向无环图</strong>上的不相交路径计数问题。</p><ul><li>$w(Path)$ 表示 $Path$ 这条路径上的边权积，也可以是生成函数，这样就能搞很多事情</li><li>$e(u, v)$ 表示 $u$ 到 $v$ 所有路径的 $w(Path)$ 之和</li><li>$N(\sigma)$ 表示 $\sigma$ 这个排列的逆序对数</li><li>有矩阵 $M$ 和点集 $A$、$B$，$M_{i, j} = e(A_i, B_j)$</li></ul><script type="math/tex; mode=display">ans = det(M) = \sum\limits_{S : A \rightarrow B} (-1)^{N(\sigma(S))} \prod\limits_{i = 1}^n w(S_i)</script><p>其中 $S$ 这个映射是在枚举 $A$ 到 $B$ 的每个路径组。</p><p>感性理解挺容易的，所有相交的路径从排列角度都可以看作在相交的那一刻互换灵魂，会形成逆序对；只要逆序对数 $&gt; 0$，经过类行列式的容斥，这个路径组贡献就是 $0$。</p><hr><h3 id="Gym102978-A"><a href="#Gym102978-A" class="headerlink" title="$Gym102978-A$"></a><a href="https://codeforces.com/gym/102978/problem/A" target="_blank" rel="noopener">$Gym102978-A$</a></h3><p>先不考虑 $a_{R, C} = V$。划一条折线 $i$ 表示分割了 $val_i$ 和 $val_{i + 1}$，共有 $k - 1$ 条线，将每条线向右向下平移一个单位后转化成不相交路径计数，上 LGV。</p><p>考虑 $a_{R, C} = V$。诶——也就是说恰好 $V - 1$ 条折线跨过了 $(R, C)$ 西北方向的直线！怎么用 LGV 呢？边积 + 生成函数！把 $(R, C)$ 西北方向的所有路径的 $w()$ 赋为 $z$，答案就是行列式求出的生成函数第 $V - 1$ 项。然而行列式套卷积什么的显然boom，考虑见过的套路——随便什么带进去，最后插回来得到系数。</p><p><a href="https://vjudge.net/solution/29880391" target="_blank" rel="noopener">$Code$</a></p><hr><p><del>好诶 又水了一篇</del> 碰到有趣的题目会回来写的啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21Feb 训练日志</title>
      <link href="2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】类欧几里得</title>
      <link href="2021/02/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>2021/02/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>最原始的类欧几里得长这样：</p><ul><li>$f(a, b, c, n) = \sum\limits_{i = 0}^n \lfloor \frac{ai + b}{c} \rfloor$</li></ul><p>其推广形式有</p><ul><li>$g(a, b, c, n) = \sum\limits_{i = 0}^n i\lfloor \frac{ai + b}{c} \rfloor$</li><li>$h(a, b, c, n) = \sum\limits_{i = 0}^n \lfloor \frac{ai + b}{c} \rfloor ^2$</li></ul><p><del>网上证明一大堆，这里只讲结论</del></p><p>设 $m = \lfloor \frac{an + b}{c} \rfloor$</p><h2 id="求-f"><a href="#求-f" class="headerlink" title="求 $f$"></a>求 $f$</h2><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $f(a, b, c, n) = f(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \frac{n(n + 1)}{2} + \lfloor \frac{b}{c} \rfloor (n + 1)$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $f(a, b, c, n) = nm - f(c, c - b - 1, a, m - 1)$</p></li></ul><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">euclid</span><span class="params">(ll n, ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> (b / c) * (n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= c || b &gt;= c) <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span> * (a / c) + (n + <span class="number">1</span>) * (b / c) + euclid(n, a % c, b % c, c);</span><br><span class="line">    ll m = (a * n + b) / c;</span><br><span class="line">    <span class="keyword">return</span> n * m - euclid(m - <span class="number">1</span>, c, c - b - <span class="number">1</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="求-g"><a href="#求-g" class="headerlink" title="求 $g$"></a>求 $g$</h2><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $g(a, b, c, n) = g(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \frac{n(n + 1)(2n + 1)}{6} + \lfloor \frac{b}{c} \rfloor \frac{n(n + 1)}{2}$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $g(a, b, c, n) = \frac{1}{2}( n(n + 1) m - g(c, c - b - 1, a, m - 1) - h(c, c - b - 1, a, m - 1) )$</p></li></ul><h2 id="求-h"><a href="#求-h" class="headerlink" title="求 $h$"></a>求 $h$</h2><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $h(a, b, c, n) = h(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor ^2 \frac{n(n + 1)(2n + 1)}{6} + (n + 1) \lfloor \frac{b}{c} \rfloor ^2 + 2 \lfloor \frac{b}{c} \rfloor f(a \% c, b \% c, c, n) + 2 \lfloor \frac{a}{c} \rfloor g(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor n(n + 1)$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $h(a, b, c, n) = m (m + 1)n + 2g(c, c - b - 1, a, m - 1) - 2f(c, c - b - 1, a, m - 1) - f(a, b, c, n)$</p></li></ul><p>带有下取整的都可以试试类欧几里得。分两种情况：分离后递归，变换后递归。</p><p>类欧几里得的最大优势是其几何意义：比如说原始型可理解为一条直线下的整点个数。下面这道在分离那种情况里的几何意义是梯形整点个数。</p><p>变换一般也很套路，结合几何意义在坐标轴上旋转/对称/反转… 即可再次转化为可分离的情况。</p><p>复杂度 $O(logn)$。</p><h3 id="Sum"><a href="#Sum" class="headerlink" title="$Sum$"></a><a href="https://uoj.ac/problem/42" target="_blank" rel="noopener">$Sum$</a></h3><p>那个根号在指数上太猖狂了，得想办法把它拿下来。$(-1)^a = 1 - 2 * (a \% 2) = 1 - 2a + 4 \lfloor \frac{a}{2} \rfloor$</p><p>我们要求的形如下：$\sum\limits_{d = 1}^n \lfloor d \frac{a \sqrt{r} + b}{c} \rfloor$。</p><p>利用类欧几里得的思想，中间那个分数 $\geq 1$ 的时候求的是较短底边长为 $\lfloor \frac{a \sqrt{r} + b}{c} \rfloor$ 的梯形内整点个数，分离并递归；$&lt; 1$ 的时候是个斜边斜率 $&lt; 1$ 的 $Rt△$，把它关于直线 $y = x$ 对称就变成了斜边斜率 $&gt; 1$ 的 $Rt△$。<a href="https://blog.csdn.net/hzj1054689699/article/details/79552941" target="_blank" rel="noopener">图看其他人的</a></p><p>复杂度考虑每次缩小一半求解区域面积，$O(logn)$。</p><p>坑点：long double，gcd 减小分子分母</p><p><a href="https://uoj.ac/submission/456838" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 类欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】网络流</title>
      <link href="2021/02/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>2021/02/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027E、ARC110E 等一类删除计数问题</title>
      <link href="2021/02/08/AGC027E%E3%80%81ARC110E%20%E7%AD%89%E4%B8%80%E7%B1%BB%E5%88%A0%E9%99%A4%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/08/AGC027E%E3%80%81ARC110E%20%E7%AD%89%E4%B8%80%E7%B1%BB%E5%88%A0%E9%99%A4%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Atcoder 好喜欢出诸如此类的题：你有一个由 ‘$a$’ ~ ‘$?$’ 构成的字符串，每次可以按某种规则删去一些再加上一些，问最终能形成多少种本质不同的字符串。</p><p>偏偏是我的克星。完全没得思路啊摔。仅有的两道 套路倒是相同的 qwq</p><h3 id="AGC027E"><a href="#AGC027E" class="headerlink" title="$AGC027E$"></a>$AGC027E$</h3><p>规则：只有 $ab$，每次删 ‘$aa$’ 为 ‘$b$’ 或删 ‘$bb$’ 为 ‘$a$’。</p><p>如果我们将 $a$ 看作 $1$，将 $b$ 看作 $2$，在模 $3$ 意义下字符串不变。令 $p(s)$ 表示 $s$ 字符之和模 $3$。</p><p>一个字符串 $s$ 能规约到字符 $a$，当且仅当 $p(s) = p(a)$ 且 $s$ 中存在两个相邻的相同字符。（归纳证明：$|s| = 1$ 或 $2$ 时显然成立，否则你可以不断操作第一对相邻的相同字符。）</p><p>$t$ 能否被 $s$ 到达？容易贪心的想到「把 $s$ 分段后让 $t$ 的每个字符与对应段匹配」，且让分的段尽量靠前。于是就可以倒着 dp：$f_i$ 表示以 $[i, |s|]$ 为后缀有多少种分段方案数。</p><p>注意：最后可能剩下一段 $abababab$ 这样无法规约的段，但是它总能被前面部分通过调整规约顺序给化为最终串中的空串。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nxt[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    nxt[n + <span class="number">1</span>][<span class="number">0</span>] = nxt[n + <span class="number">1</span>][<span class="number">1</span>] = nxt[n + <span class="number">2</span>][<span class="number">0</span>] = nxt[n + <span class="number">2</span>][<span class="number">1</span>] = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        (sum += s[i] == <span class="string">'a'</span> ? <span class="number">1</span> : <span class="number">2</span>) %= <span class="number">3</span>;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = s[i] == <span class="string">'a'</span> ? i + <span class="number">1</span> : (s[i + <span class="number">1</span>] == <span class="string">'b'</span> ? i + <span class="number">2</span> : nxt[i + <span class="number">2</span>][<span class="number">0</span>]);  <span class="comment">// 这一段 p = 1</span></span><br><span class="line">        nxt[i][<span class="number">1</span>] = s[i] == <span class="string">'b'</span> ? i + <span class="number">1</span> : (s[i + <span class="number">1</span>] == <span class="string">'a'</span> ? i + <span class="number">2</span> : nxt[i + <span class="number">2</span>][<span class="number">1</span>]);  <span class="comment">// p = 2</span></span><br><span class="line">        f[i] = add(f[nxt[i][<span class="number">0</span>]], f[nxt[i][<span class="number">1</span>]] + (sum == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sub(f[<span class="number">1</span>], sum == <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="ARC110E"><a href="#ARC110E" class="headerlink" title="$ARC110E$"></a>$ARC110E$</h3><p>规则：只有 $ABC$，每次把两个相邻的不同字符替换为和它俩都不同的那个字符。</p><p><em>解题过程与上面那道完全相同。</em></p><p>如果我们将 $A$ 看作 $1$，$B$ 看作 $2$，$C$ 看作 $3$，在异或意义下字符串不变。令 $p(s)$ 表示 $s$ 异或和。</p><p>一个字符串 $s$ 能规约到字符 $a$，当且仅当 $p(s) = p(a)$ 且 $s$ 中存在两个相邻的不同字符。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], lst[<span class="number">4</span>], pre[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) a[i] = s[i] - <span class="string">'A'</span> + <span class="number">1</span>, pre[i] = (pre[i - <span class="number">1</span>] ^ a[i]);</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        f[i] = (pre[n] ^ pre[i]) == <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            f[i] = add(f[i], f[lst[j ^ pre[i]]]);</span><br><span class="line">        &#125;</span><br><span class="line">        lst[pre[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">3</span>) ans = add(ans, f[lst[i]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变中找不变。<del>（苍 白 无 力）</del></p><p>找性质题有什么总结啊【暴躁】</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】线段树分裂、分治、二进制分组、李超线段树</title>
      <link href="2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84/"/>
      <url>2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><p><img src="/images/裂开.jpg" alt="我裂开"></p><p><img src="/images/合上.png" alt="我合上"></p><p>以某个键值为中点（一般是把前 $k$ 个元素分离出来，而不是把前 $k$ 个下标）将线段树分裂为两部分。就把两棵线段树重合的 $log$ 个节点新建出来，所以单次严格 $O(logn)$，实现非常直白！</p><p>应用条件比较苛刻，要有序，才能关于键值裂开。题不太有，比较经典的这道<a href="https://www.luogu.com.cn/problem/P2824" target="_blank" rel="noopener">排序</a>，容易发现每次排序的是连续区间，对于每个区间建权值线段树，新建区间时把波及到的原有区间分裂出重合部分的线段树即可。以后见到应用再回来写。</p><details>    <summary>template</summary>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_5494</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = N * <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], idx, id;</span><br><span class="line"><span class="keyword">int</span> rt[N], ls[M], rs[M];</span><br><span class="line">ll sz[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x] = sz[ls[x]] + sz[rs[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sz[x]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(ls[x], l, mid), build(rs[x], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sz[x] += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p &lt;= mid ? insert(ls[x], l, mid, p, v) : insert(rs[x], mid + <span class="number">1</span>, r, p, v);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        <span class="keyword">return</span> sz[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) ret = query(ls[x], l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) ret += query(rs[x], mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123; x |= y; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sz[x] += sz[y]; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    merge(ls[x], ls[y], l, mid);</span><br><span class="line">    merge(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        x = y, y = <span class="number">0</span>; <span class="keyword">return</span>;  <span class="comment">// 把 y 合并到空子树 x 上去，放心直接 =</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) split(ls[x], ls[y], l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) split(rs[x], rs[y], mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    upd(y);  <span class="comment">// !!!</span></span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || sz[x] &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= sz[ls[x]]) <span class="keyword">return</span> ask(ls[x], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs[x], mid + <span class="number">1</span>, r, k - sz[ls[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ++id;</span><br><span class="line">    build(rt[id], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">4</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            ++id;</span><br><span class="line">            split(rt[id], rt[x], <span class="number">1</span>, n, y, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            merge(rt[x], rt[y], <span class="number">1</span>, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            insert(rt[x], <span class="number">1</span>, n, z, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(rt[x], <span class="number">1</span>, n, y, z));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask(rt[x], <span class="number">1</span>, n, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="线段树分治"><a href="#线段树分治" class="headerlink" title="线段树分治"></a>线段树分治</h2><p>把操作复制 $logn$ 份挂在线段树上 $logn$ 个节点下，最后统一做一遍。时间线段树就是这个。</p><h2 id="二进制分组"><a href="#二进制分组" class="headerlink" title="二进制分组"></a>二进制分组</h2><p><a href="https://imilyx.github.io/2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E7%8E%84%E5%AD%A6" target="_blank" rel="noopener">玄学</a></p><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>维护的是坐标系，支持两个操作：</p><ol><li>加入一条直线</li><li>查询所有加入直线与 $x = x_0$ 的最高交点。</li></ol><p>线段树维护覆盖每个区间没被覆盖面积最多的那条线。如果当前区间中，加入的线段和目前面积最多的线段相交，只需看斜率和中点谁高就能判断谁在这个区间占的面积更大，输的那条往下递归。</p><p>这里运用了标记永久化的思想，查询就把沿途线段贡献取 max。</p><p>如果插入的是线段，需要先找到可插入的区间，再分别加，是两只 log 的。</p><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_4254</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, idx;</span><br><span class="line"><span class="keyword">int</span> tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">db b[N], k[N];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">w</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> b[i] + k[i] * (x - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w(id, l) &gt; w(tr[x], l) &amp;&amp; w(id, r) &gt; w(tr[x], r)) &#123;  <span class="comment">// 完胜</span></span><br><span class="line">        tr[x] = id; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w(id, l) &lt;= w(tr[x], l) &amp;&amp; w(id, r) &lt;= w(tr[x], r)) &#123;  <span class="comment">// 完败</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k[tr[x]] &lt; k[id]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w(id, mid) &gt; w(tr[x], mid))</span><br><span class="line">            modify(x &lt;&lt; <span class="number">1</span>, l, mid, tr[x]), tr[x] = id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w(id, mid) &gt; w(tr[x], mid))</span><br><span class="line">            modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tr[x]), tr[x] = id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modify(x &lt;&lt; <span class="number">1</span>, l, mid, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> w(tr[x], t);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(w(tr[x], t), t &lt;= mid ? query(x &lt;&lt; <span class="number">1</span>, l, mid, t) : query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)query(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50005</span>, T) / <span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;b[idx], &amp;k[idx]);</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, <span class="number">50005</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】BSGS &amp; exBSGS</title>
      <link href="2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BSGS%20&amp;%20exBSGS/"/>
      <url>2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BSGS%20&amp;%20exBSGS/</url>
      
        <content type="html"><![CDATA[<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>$O(\sqrt{p})$ 求解关于 $x$ 的高次同余方程 $a^x \equiv n \pmod{p}$，其中 $p$ 为质数。</p><p>由 $a^{\phi(p)} \equiv 1 \pmod{p}$ 得 $x \in [0, p - 1)$。设 $x = i <em> k - j$, 则 $(a^k)^i \equiv b </em> a^j \pmod{p}$，取 $k = \sqrt{p}$，对于 $j \in [0, k)$ 把 $b * a^j \pmod{p}$ 存入 hash 表，枚举 $i \in [0, k)$，查找 hash 表中是否有当前的 $(a^k)^i \pmod{p}$。</p><h2 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h2><p>$p$ 非质的版本，$(a, p) &gt; 1$。考虑转化为 $(a, p) = 1$。</p><p>展开为 $a \cdot a^{x - 1} + p * y = b$，必须要 $(a, p) \mid b$，$a^{x - 1}$ 和 $y$ 才有整数解。</p><p>令上柿变为：$a^{x - 1} \cdot \frac{a}{(a, p)} \equiv \frac{b}{(a, p)} \pmod{\frac{p}{(a, p)}}$。</p><p>此时如果 $(a^{x - 1}, \frac{p}{(a, p)}) = 1$，就直接用 BSGS 解 $a^{x - 1} \equiv \frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}} \pmod{\frac{p}{(a, p)}}$（注意这里的模数可能非质，不能用费马小定理求逆元，只能 exgcd 啦）；否则递归分解直到 $(a’, p’) = 1$。</p><p>在递归过程中若出现 $(a’, p’) ∤ \frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}}$，直接无解。<strong>注意：有特例：若 $\frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}} \equiv 1 \pmod{\frac{p}{(a, p)}}$，表示 $a^{x - k} \equiv 1 \pmod{p}$（递归了 $k$ 层），即 $a^{x - k} <em> a^k \equiv 1 </em> b \pmod{p}$，$k$ 为解。</strong></p><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_4195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">ll n, m, p, ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % mod) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    ll d = exgcd(b, a % b, y, x); y -= a / b * x; <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll p, ll t)</span> </span>&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll k = (ll)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p), x, y;</span><br><span class="line">    exgcd(t, p, x, y), b = (b * x % p + p) % p;</span><br><span class="line">    ll tmp = b, S = qpow(a, k, p);</span><br><span class="line">    rep(i, <span class="number">0</span>, k) &#123;</span><br><span class="line">        mp[tmp] = i;</span><br><span class="line">        tmp = tmp * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = S;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[tmp]) <span class="keyword">return</span> i * k - mp[tmp];</span><br><span class="line">        tmp = tmp * S % p;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll k = <span class="number">0</span>, d = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(n, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ++k, m /= d, p /= d, t = t * (n / d) % p;</span><br><span class="line">        <span class="keyword">if</span> (t == m) <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (d = BSGS(n, m, p, t)) == <span class="number">-1</span> ? <span class="number">-1</span> : d + k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; m &amp;&amp; (n || m || p)) &#123;</span><br><span class="line">        n %= p, m %= p, ans = exBSGS();</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2018]-历史</title>
      <link href="2021/02/07/%5BZJOI2018%5D-%E5%8E%86%E5%8F%B2/"/>
      <url>2021/02/07/%5BZJOI2018%5D-%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uoj.ac/problem/374" target="_blank" rel="noopener">传送门</a></p><h3 id="mathscr-Part-1"><a href="#mathscr-Part-1" class="headerlink" title="$\mathscr{Part.1}$"></a>$\mathscr{Part.1}$</h3><p>不难发现就是最大化 access 更改的边数。考虑不带修怎么做。变换一下问题就是最大化每个点被更改的次数和——每个点都可以独立计算，一个点贡献一次当且仅当相邻两次 access 发源于其不同的子树，并且每个点都可以取到其上限（只要合理安排该点每个子树的 access 顺序就可以了，大概可归纳证明）</p><p>点 $x$ 的上限是啥呢？设 $s_x = \sum\limits_{i \in subtree(x)} a_i$, $mx_x = \max\limits_{y \in son(x)}(s_y)$, 那么就是 $\min( s_x - 1, 2 * (s_x - mx_x) )$（讨论一下发现是否存在「一个 $a_i$ 过大、其他子树安排不完」的情况都符合该柿）</p><p>考虑修改，那么就要应用链剖分啊分治啊树上科技来维护修改点到根的路径了。接下来的操作神仙极了 qaq（细节好多啊摔</p><h3 id="mathscr-Part-2"><a href="#mathscr-Part-2" class="headerlink" title="$\mathscr{Part.2}$"></a>$\mathscr{Part.2}$</h3><p>我们记录每个点 $x$ 当前的贡献类型：是 ①「$s_x - 1$」，还是 ②「$2 <em> (s_x - mx_x)$ 且 $mx_x$ 来自 $x$ 某个子树」，还是 ③「$2 </em> (s_x - mx_x)$ 且 $mx_x$ 来自 $x$ 自己」。</p><p>注意到一次修改只会加，加了可能改变某些点的贡献类型。（改完后的）① 型点增加 $w$，②③ 型点不变。我们要是能快速修改这些贡献类型，就能顺便更新答案。</p><p>我们让 ② 型点 $x$ 向 $mx_x$ 对应的儿子连一条边。通过移项，我们发现了一个更优的性质：这样的儿子最多只有一个！这就和重链剖分契合了。Orz</p><p>我们把 $x$ 向 $mx_x$ 连的边看作实边，向其他儿子连的边看作虚边，形成的实链只有链底是 ① 或者 ③，其余都是 ②。</p><p>然后就是一个类 splay access 的操作，连实边或者断实边。</p><p>关于复杂度，$x$ 到根路径上又轻又虚的边数不超过 $log \sum a$，因为显然一次至少翻一倍。单次 access 最多改 $log \sum a$ 条虚边为实边。$O(nlog\sum a)$。</p><p>用树剖 + 线段树维护虚边位置每次暴改就是对的，但是找虚边这种事怎么能忘了 LCT 本人呢！毕竟这玩意只是有条件的连实边，魔改一发就好了。</p><p>「判断实边的断与连」要用到 $s_x$。设修改点为 $x$。考虑用 lct 维护「 $x$ 到根路径上的」$s$。只改深度比 $x$ 小的所以是个区间加 + 单点查询。为了实现方便，我们利用<strong>差分思想</strong>，设 $val_x = s_x - s_{ch[x, 1]}$，就可以单点修改，并且查询只要把点转到 splay 的根然后询问右子树的 $val$ 和，就不用什么 LCT 套线段树了！伟 大 胜 利</p><p>说了这么多，代码还是挺好写的。</p><details>    <summary>code</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll ans, a[N], s[N], lst[N], val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] &amp;&amp; ch[fa[x]][dir(x)] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[x] = s[ch[x][<span class="number">0</span>]] + s[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sz = s[x] - s[ch[x][<span class="number">0</span>]];  <span class="comment">// x 的真实 s</span></span><br><span class="line">    ans -= lst[x];</span><br><span class="line">    lst[x] = min(sz - <span class="number">1</span>, <span class="number">2</span> * (sz - max(a[x], s[ch[x][<span class="number">1</span>]])));</span><br><span class="line">    ans += lst[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = dir(x), w = ch[x][k ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (nrt(y)) ch[z][dir(y)] = x;</span><br><span class="line">    ch[y][k] = w, ch[x][k ^ <span class="number">1</span>] = y;</span><br><span class="line">    <span class="keyword">if</span> (w) fa[w] = y;</span><br><span class="line">    fa[y] = x, fa[x] = z;</span><br><span class="line">    up(y), up(x);  <span class="comment">// 这里不能 upd，因为 x 还没旋到根，ch[x][1] 不是 x 所在 splay 上 x 的真实后继；旋到根以后 ch[x][1] 才是。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nrt(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">        <span class="keyword">if</span> (nrt(y)) rot((dir(x) ^ dir(y)) ? x : y);</span><br><span class="line">        rot(x);</span><br><span class="line">    &#125;</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x]) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        s[x] += w;</span><br><span class="line">        <span class="comment">// 底</span></span><br><span class="line">        <span class="keyword">if</span> (!y) a[x] += w;</span><br><span class="line">        val[x] += w;</span><br><span class="line">        </span><br><span class="line">        ll sz = s[x] - s[ch[x][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span> (s[ch[x][<span class="number">1</span>]] * <span class="number">2</span> &lt;= sz + <span class="number">1</span>) &#123;</span><br><span class="line">            val[x] += s[ch[x][<span class="number">1</span>]], ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[y] * <span class="number">2</span> &gt; sz + <span class="number">1</span>) &#123;</span><br><span class="line">            val[x] -= s[y], ch[x][<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[x] = fat;</span><br><span class="line">    ll mx = s[x] = a[x];</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fat) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        s[x] += s[y];</span><br><span class="line">        <span class="keyword">if</span> (s[y] &gt; mx)</span><br><span class="line">            mx = s[y], id = y;</span><br><span class="line">    &#125;</span><br><span class="line">    lst[x] = min(s[x] - <span class="number">1</span>, <span class="number">2</span> * (s[x] - mx));</span><br><span class="line">    ans += lst[x];</span><br><span class="line">    <span class="keyword">if</span> (id &amp;&amp; mx * <span class="number">2</span> &gt; s[x] + <span class="number">1</span>)</span><br><span class="line">        ch[x][<span class="number">1</span>] = id;</span><br><span class="line">    val[x] = s[x] - s[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        g[x].pb(y), g[y].pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, w; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;w);</span><br><span class="line">        access(x, w);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】二次离线莫队</title>
      <link href="2021/02/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E8%8E%AB%E9%98%9F/"/>
      <url>2021/02/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>最近规划的是多做锻炼思维模式的 CF、AT 题，但是这玩意既然 xtr 学长介绍了那为何不学呢？</p><p>普通莫队加入/删除一个位置的贡献是 $T(n)$，复杂度 $O(n\sqrt{n}T(n))$，$T(n)$ 很大的时候就 GG 了。。</p><p><del>于是，神说：要有二次离线莫队。</del></p><p>以<a href="https://www.luogu.com.cn/problem/P4887" target="_blank" rel="noopener">模板题</a>为例，设 $f(i, [l, r])$ 表示 $i$ 对 $[l, r]$ 所产生的贡献。一次移动只会加入 $l - 1$ 或 $r + 1$，以 $r + 1$ 为例，$f(r + 1, [l, r]) = f(r + 1, [1, r]) - f(r + 1, [1, l - 1])$，前面那项可以预处理（根据 $a xor b = c \Leftrightarrow a xor c = b$，我们可以将有 $K$ 个 $1$ 的 $c$ 的 $a xor c$ 存在桶里，到 $b$ 就直接查），后面这个就要<strong>第二次离线下来最后统一做</strong>。所以二次离线莫队这玩意实际上减小了「处理答案的变化量」的复杂度。复杂度变为 $O(nT(n) + n\sqrt{n})$。</p><p>讲一下第二次离线。你可以把 $f(x, [1, l - 1])$ 放在下标为 $l - 1$ 的 vector 里然后从前往后做，但这样空间是 $O(m\sqrt{n})$ 的。不如维护 $(L, R, q[i].l - 1, i, 1/-1)$ 表示当前统计 $x \in [L, R]$ 对 $[1, q[i].l - 1]$ 产生的贡献、来自第 $i$ 个询问时产生的答案变化量、加还是减，空间就是 $2m$ 了。</p><p>算出的答案变化量实际上对后续操作有影响，所以要做前缀和。</p><details>    <summary>code</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_4887</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cnt(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, V = <span class="number">16390</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, unit;</span><br><span class="line"><span class="keyword">int</span> a[N], bin[V];</span><br><span class="line">ll ans[N], pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ques</span> &#123;</span> <span class="keyword">int</span> l, r, id; ll ans; &#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atom</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, op;</span><br><span class="line">    atom(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Id, <span class="keyword">int</span> Op) &#123; l = L, r = R, id = Id, op = Op; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buc;</span><br><span class="line"><span class="built_in">vector</span>&lt;atom&gt; vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Ques a, Ques b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l / unit == b.l / unit ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">14</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unit = n / <span class="built_in">sqrt</span>(m);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">16383</span>)</span><br><span class="line">        <span class="keyword">if</span> (cnt(i) == K) buc.pb(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        pre[i] = bin[a[i]] + pre[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc.size(); j++) ++bin[a[i] ^ buc[j]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = q[i].l, r = q[i].r;</span><br><span class="line">        ll &amp;x = q[i].ans;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; l)</span><br><span class="line">            vec[R].pb(atom(l, L - <span class="number">1</span>, i, <span class="number">1</span>)), x -= pre[L - <span class="number">1</span>] - pre[l - <span class="number">1</span>], L = l;</span><br><span class="line">        <span class="comment">// while (L &gt; l)</span></span><br><span class="line">        <span class="comment">//     --L, x -= pre[L];</span></span><br><span class="line">        <span class="keyword">if</span> (R &lt; r)</span><br><span class="line">            vec[L - <span class="number">1</span>].pb(atom(R + <span class="number">1</span>, r, i, <span class="number">-1</span>)), x += pre[r] - pre[R], R = r;</span><br><span class="line">        <span class="comment">// while (R &lt; r)</span></span><br><span class="line">        <span class="comment">//     ++R, x += pre[R];</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; l)</span><br><span class="line">            vec[R].pb(atom(L, l - <span class="number">1</span>, i, <span class="number">-1</span>)), x += pre[l - <span class="number">1</span>] - pre[L - <span class="number">1</span>], L = l;</span><br><span class="line">        <span class="comment">// while (L &lt; l)</span></span><br><span class="line">        <span class="comment">//     x += pre[L], ++L;</span></span><br><span class="line">        <span class="keyword">if</span> (R &gt; r)</span><br><span class="line">            vec[L - <span class="number">1</span>].pb(atom(r + <span class="number">1</span>, R, i, <span class="number">1</span>)), x -= pre[R] - pre[r], R = r;</span><br><span class="line">        <span class="comment">// while (R &gt; r)</span></span><br><span class="line">        <span class="comment">//     x -= pre[R], --R;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(bin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bin));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc.size(); j++) ++bin[a[i] ^ buc[j]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].size(); j++) &#123;</span><br><span class="line">            atom t = vec[i][j];</span><br><span class="line">            rep(k, t.l, t.r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &lt;= i &amp;&amp; !K) q[t.id].ans += t.op * (bin[a[k]] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> q[t.id].ans += t.op * bin[a[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) q[i].ans += q[i - <span class="number">1</span>].ans;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) ans[q[i].id] = q[i].ans;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信奥学习建议（来自 xtr 学长）</title>
      <link href="2021/02/06/%E4%BF%A1%E5%A5%A5%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%EF%BC%88%E6%9D%A5%E8%87%AA%20xtr%20%E5%AD%A6%E9%95%BF%EF%BC%89/"/>
      <url>2021/02/06/%E4%BF%A1%E5%A5%A5%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%EF%BC%88%E6%9D%A5%E8%87%AA%20xtr%20%E5%AD%A6%E9%95%BF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>xtr 学长的经历好戳我啊。。他的 HE 大概是每个 oier 憧憬的吧。可爱勤奋的卷怪们都要有 HE 啊。xml 你也去追你的梦吧，虽然梦是什么还不明朗。也许就像 xtr 学长说的那样，为了有站在台上无比荣耀的瞬间，或是驰骋在赛场上的那种快感。</p><p>要对自己的处境和知识掌握情况有充分的了解，然后不顾一切的努力，<strong>做到完全实现自己的想法</strong>。</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>四种类型</p><ol><li>luogu 模板</li><li>UOJ、LOJ 上清华集训/集训队作业等高水平综合题</li><li>CF、AT 上 更注重思维模式的题</li><li>历年真题</li></ol><p>选择适应自身的。</p><p>可以专题，但<strong>必须适时杂题以确保比赛能力</strong></p><h2 id="学东西"><a href="#学东西" class="headerlink" title="学东西"></a>学东西</h2><ol><li>感兴趣的领域深入，以有所擅长</li><li>不感兴趣的掌握基础，以知识体系完备</li><li>冷门算法浅尝辄止</li></ol><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ol><li>尽快想出</li><li>高效调试</li><li>综合判断、策略能力</li><li>适时放弃</li><li>心态</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>瞄准水平略高的身边人。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>分长期短期，适时调整。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】反演杂烩</title>
      <link href="2021/02/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8D%E6%BC%94%E6%9D%82%E7%83%A9/"/>
      <url>2021/02/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8D%E6%BC%94%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>若有 $g_n = \sum\limits_{i = 1}^n a_{n, i} f_i$, 并且 $f_n = \sum\limits_{i = 1}^n b_{n, i} g_i$，则称 $f$ 和 $g$ 可以反演。证明带就完事了。</p><p>经典套路是 dp 容斥系数。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><p>广义容斥。</p><p>「恰好」与「至多」：</p><script type="math/tex; mode=display">f_n = \sum\limits_{i = 0}^n \binom{n}{i} g_i \Longleftrightarrow g_n = \sum\limits_{i = 0}^n (-1)^{n - i} \binom{n}{i} f_i</script><p>「恰好」与「至少」：</p><script type="math/tex; mode=display">f_k = \sum\limits_{i = k}^n \binom{i}{k} g_i \Longleftrightarrow g_k = \sum\limits_{i = k}^n (-1)^{i - k} \binom{i}{k} f_i</script><h2 id="min-max-容斥"><a href="#min-max-容斥" class="headerlink" title="$\min-\max$ 容斥"></a>$\min-\max$ 容斥</h2><script type="math/tex; mode=display">max(S) = \sum\limits_{T \subseteq S} (-1)^{|T| + 1} min(T) \Longleftrightarrow min(S) = \sum\limits_{T \subseteq S} (-1)^{|T| + 1} max(T)</script><p>证明大概考虑设 $\max(S) = x$，只有 $T = \{x\}$ 时的 $\min(T)$ 为 $x$，其余时候必然存在一个 $y$ 使得 $\min(T \cup \{y\}) = \min(T)$，就抵消了</p><p>这玩意还能应用到期望上去：套个 $E()$ 就好。</p><p>一般来说不用真的枚举集合，信息只和集合大小有关。</p><p>推广：通过求 $\min$ 来求 $kth \max$</p><script type="math/tex; mode=display">kth\ \max(S) = \sum\limits_{T \subseteq S} (-1)^{|T| - k} \binom{|T| - 1}{k - 1} \min(T)</script><p>习题：<a href="https://www.luogu.com.cn/problem/P4707" target="_blank" rel="noopener">重返现世</a> <a href="http://imilyx.github.io/2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/#%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96" target="_blank" rel="noopener">sol</a></p><p><a href="https://uoj.ac/problem/449" target="_blank" rel="noopener">喂鸽子</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E5%96%82%E9%B8%BD%E5%AD%90" target="_blank" rel="noopener">sol</a></p><h2 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h2><p>就是 FMT 和 FMI。</p><script type="math/tex; mode=display">f_S = \sum\limits_{T \subseteq S} g_T \Longleftrightarrow g_S = \sum\limits_{T \subseteq S} (-1)^{|S| - |T|} f_T</script><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>本质是质因子集合的 FMT 和 FMI。</p><script type="math/tex; mode=display">f(n) = \sum\limits_{d | n} g(d) \Longleftrightarrow g(n) = \sum\limits_{d | n} \mu(d) f(\frac{n}{d})</script><script type="math/tex; mode=display">f(n) = \sum\limits_{n | d} g(d) \Longleftrightarrow g(n) = \sum\limits_{n | d} \mu(n) f(\frac{d}{n})</script><p>最常用的：</p><script type="math/tex; mode=display">\sum\limits_{d \mid n} \mu(d) = [n == 1]</script><h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2><script type="math/tex; mode=display">f_n = \sum\limits_{i = 1}^n {n \brace i} g_i \Longleftrightarrow g_n = \sum\limits_{i = 1}^n (-1)^{n - i} {n \brack i} f_i</script><h2 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h2><script type="math/tex; mode=display">[k \mid n] = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni}</script><p>证明：若 $k \mid n$，那么：</p><script type="math/tex; mode=display">\frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni} = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} (\omega_k^n)^i = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^0 = 1</script><p>若 $k \nmid n$，那么根据等比数列求和有：</p><script type="math/tex; mode=display">\frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni} = \frac{1}{k} \frac{\omega_k^{nk} - \omega_k^0}{\omega_k^n - 1} = 0</script><p>应用于 $O(k)$ 提取多项式所有下标为 $k$ 倍数的项或系数（设第 $i$ 项系数为 $a_i$，下面是提系数）：</p><script type="math/tex; mode=display">\sum\limits_{i = 0}^{n / k} [x^{ik}] f(x)</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^n [k \mid i] [x^i] f(x)</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^n \frac{1}{k} \sum\limits_{j = 0}^{k - 1} \omega_k^{ij} [x^i] f(x)</script><script type="math/tex; mode=display">= \frac{1}{k} \sum\limits_{j = 0}^{k - 1} \sum\limits_{i = 0}^n a_i (\omega_k^j)^i</script><script type="math/tex; mode=display">= \frac{1}{k} \sum\limits_{j = 0}^{k - 1} f(\omega_{k}^j)</script><p>现推也非常方便！「提取项」一个道理，就现推一下吧，总是能把单位根搞成函数自变量的。</p><p>习题：<a href="https://uoj.ac/problem/450" target="_blank" rel="noopener">复读机</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E5%A4%8D%E8%AF%BB%E6%9C%BA" target="_blank" rel="noopener">sol</a></p><p><a href="http://loj.ac/p/6485" target="_blank" rel="noopener">LJJ 学二项式定理</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#LJJ-%E5%AD%A6%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">sol</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WC2021 游记</title>
      <link href="2021/02/05/WC2021%20%E6%B8%B8%E8%AE%B0/"/>
      <url>2021/02/05/WC2021%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>线上真·游记</p><p>T1 为什么就没找出来性质呢？CF 做太少了，思维模式太 low！T2 为什么模拟赛出现类似的还是不会呢？没弄懂！T3，T3 你推一半为什么不会了？这是真不会。。。</p><hr><p>又 出 成 绩 了，28 + 60 + 20 = 108 铜，T1 挂了 4 分，然而就算没挂分也是差 6 分银牌（写了那好麻烦的 10 分就银了 /kel</p><p><del>dsy: 赛后算分，庸人自扰</del></p><p>差距没有很大，也没有缩小呢，xml 你要继续努力！</p><hr><h2 id="改题"><a href="#改题" class="headerlink" title="改题"></a>改题</h2><p><a href="https://loj.ac/p?keyword=wc2021" target="_blank" rel="noopener">题目链接</a></p><h3 id="括号路径"><a href="#括号路径" class="headerlink" title="括号路径"></a>括号路径</h3><p>找性质的能力还是太菜了。。。<del>我再不刷 CF 和 AT 我名字倒过来写！</del> 注意到这样的路径是双向的，而且若 (x, y) 是合法对，那么任意点 w 同时与 x、y 有或无路径。</p><p><strong>即有合法路径的对形成的团中，两两互达！</strong></p><p>类似「Joitter 交友」，缩就完事了。并查集维护连通性。记录每个点的出入括号，<del>遇到同种类的就从了</del>。合并点对采用启发式合并。人懒用了 map，两只 log。</p><p><a href="https://loj.ac/s/1061222" target="_blank" rel="noopener">$Code$</a></p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>magic breeding? Ah~ 加强版。每位显然是独立的。考虑二分的思想，$\geq lim$ 的为 $1$，$&lt; lim$ 的为 $0$，那么 $\max$ 为取并，$\min$ 为取交。</p><p>括号很恶心，要建表达式树。我们选择从后往前建。叶子处是操作 id，非叶子处是 $($、$)$、$&lt;$、$&gt;$、$?$</p><p>本题要统计每个集合 $\geq$ 某种取值的方案数才能算出该取值在答案中贡献的次数。</p><p>集合只有 $2^m$ 种，取值却有 $nm$ 种。考虑 dp 预处理, 枚举集合表示这个集合里的数都 $\geq$ 那个值，$dp[x, 0/1]$ 表示在表达式树上 $x$ 节点的子树有多少种方案使得运算结果为 $0$/$1$。</p><p>表达式树是个二叉树。合并答案，记俩儿子 dp 值分别为 $(x0, x1)$, $(y0, y1)$，结果记为 $(z0, z1)$</p><ul><li>对于 $&gt;$: $z0 = x0 <em> y0$, $z1 = x0 </em> y1 + x1 <em> y0 + x1 </em> y1$</li><li>对于 $&lt;$: $z0 = x0 <em> y0 + x0 </em> y1 + x1 <em> y0$, $z1 = x1 </em> y1$</li><li>对于 $?$: 上面两种加起来。</li></ul><p>$O(2^m|E| + nm^2)$.</p><p><a href="https://loj.ac/s/1061278" target="_blank" rel="noopener">$Code$</a></p><h3 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h3><p>这道和「WC2020-猜数游戏」都先咕咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十二省联考2019 乱写</title>
      <link href="2021/02/04/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/02/04/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83" target="_blank" rel="noopener">传送门</a></p><h2 id="异或粽子"><a href="#异或粽子" class="headerlink" title="异或粽子"></a>异或粽子</h2><p>可持久化 Trie 树 + 「超级钢琴」做法。</p><p>加强版：$k \leq \frac{n(n - 1)}{2}$。<a href="https://imilyx.github.io/2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#T3-1" target="_blank" rel="noopener">题解</a></p><h2 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h2><p>很自然<del>套路</del>的题，容易想到建边用图做，也就是一个 $A$ 向它支配的 $B$ 连边，这个 $B$ 再向以它为前缀的 $A$ 连边，暴力连 $O(n^2)$，考虑优化。</p><p>老套路，考虑图/树优化建边，这里对反串建 $SAM$，把 $A$ 串和 $B$ 串挂在对应的后缀树节点下，同个节点挂着的串相邻连边就避免了一个 $A$ 向一堆 $A$ 连的情况。</p><p><a href="https://loj.ac/s/1017579" target="_blank" rel="noopener">$Code$</a></p><h2 id="骗分过样例"><a href="#骗分过样例" class="headerlink" title="骗分过样例"></a>骗分过样例</h2><p>咕咕</p><h2 id="皮配"><a href="#皮配" class="headerlink" title="皮配"></a>皮配</h2><p>这题不讲唔得，它用繁多的变量来搞你心态！<del>大意了啊没有闪</del></p><p>撇开这点，题并不难（但有点考逻辑</p><p>首先发现派系和阵营是交错的，不管城市选什么阵营，里面的学校都可以任意选派系，城市的决定和学校的决定共同决定了导师。<strong>也就是说城市和学校独立。</strong></p><p>先考虑 $k = 0$ 的情况，分别 $dp$ 算出 $f[i, j]$ 表示前 $i$ 个城市，$j$ 个人在蓝阵营的方案数；<br>$g[i, j]$ 表示前 $i$ 个城市，$j$ 个人在鸭派系的方案数。合法的相乘。</p><p>按照选课的套路，$k = 0$ 的情况，没有限制的城市和学校同上做；<br>$k \neq 0$，有限制的城市需要选同个阵营，同城市的学校就必须捆绑考虑了：$f[i, j, k]$ 表示前 $i$ 个城市蓝阵营人数为 $j$，鸭派系人数为 $k$ 的方案数。</p><p>然后滚掉一维就能 AC 辣!</p><p><a href="https://loj.ac/s/1017744" target="_blank" rel="noopener">$Code$</a></p><h2 id="春节十二响"><a href="#春节十二响" class="headerlink" title="春节十二响"></a>春节十二响</h2><p>撕烤怎么合并链，必然是贪心的大配大、小配小。拿堆维护一下，加个启发式合并就 AC 了。</p><p><a href="https://loj.ac/s/1017408" target="_blank" rel="noopener">$Code$</a></p><h2 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h2><p>别被高大上的题目唬住了！思路就是算一个救援队的答案，然后 $k$ 次方。点 $x$ 子树里和子树外的要分开算。考虑直接算会算重——一个连通块会被算多次，应用经典“点减边”思想——连通块中点数 = 边数 $+ 1$，就用点的答案减去边的答案。</p><p>$f[x, i]$ 表示子树里深度不超过 $i$ 的连通块方案数，$g[x, i]$ 表示不包括子树里（但包括 $x$）的深度不超过 $i$ 的连通块方案数，两个一乘岂不美哉？</p><p>转移方程超好写：</p><ul><li>$f[x, i] = (\prod f[y, i - 1]) + 1$</li><li>$g[x, i] = (g[fa[x], i - 1] \prod f[son[fa[x]], i - 2]) + 1$</li></ul><p>$n$ $1e6$, $dp$ 又与深度有关，于是想到长剖优化。本题的思路到此为止，接下来 都 是 细 节</p><p>$f$ 可以直接算，但是 $g$ 里面那个 $\prod$ 不好搞。</p><p>用回退栈可以维护，做 $f$ 的时候从长到短遍历子树，做 $g$ 的时候从短到长遍历子树。</p><p><a href="https://loj.ac/s/1009842" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[集训队作业2018]-围绕着我们的圆环</title>
      <link href="2021/02/03/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E5%9B%B4%E7%BB%95%E7%9D%80%E6%88%91%E4%BB%AC%E7%9A%84%E5%9C%86%E7%8E%AF/"/>
      <url>2021/02/03/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E5%9B%B4%E7%BB%95%E7%9D%80%E6%88%91%E4%BB%AC%E7%9A%84%E5%9C%86%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p/6040" target="_blank" rel="noopener">$LOJ6040$</a> 加强版。高妙的线代题，虽然只用到了秩和线性空间的概念（完全不像今天国家队爷讲课那样让人摸不着头发哼！）</p><p>（接下来都用本题中的 $p$、$q$、$s$，这样比较严谨）</p><p>回顾矩阵乘法：$A(x, y) * B(y, z) \rightarrow C(x, z)$（绕晕了就看看这个👈）</p><p>考虑无修改怎么做，毫无头绪（</p><p>观察 $A$ 和 $C$ 的关系：$C$ 的列向量一定在 $A$ 列向量组成的线性空间里。</p><p>设 $A$ 的（列）秩为 $x$，$C$ 的（列）秩为 $r$。对于 $B$ 的每一列都可以列出一个有 $x$ 个线性无关的方程的方程组，那么自由元有 $q - x$ 个，一列的方案数是 $2^{q - x}$。因此<strong>在 $A$ 和 $C$ 的秩确定时</strong>，$B$ 方案数就是 $(2^{q - x})^s$。</p><p>现在我们要统计“秩为 $x$ 且列向量的线性空间包含 $C$ 的 $A$ 方案数”。这不好算。</p><p>dp, $f_{i, j}$ 表示 $i * q$ 的矩阵，秩为 $j$ 的方案数，转移类似线性基 dp。统计“秩为 $x$ 且列向量的线性空间包含秩为 $r$ 的 $C$ 的 $A$ 方案数”，最后答案除以 $g_{p, r}$。那么 $A$ 的方案数就是 $f_{q, x}$，$C$ 的方案数就是 $g_{x, r}$，为什么？</p><p>因为<strong>行秩 = 列秩</strong>，$C$ 中对应 $A$ 的那 $x$ 行确定后剩下的行就像 $A$ 中剩下的行那样能被那 $x$ 行表出的。</p><p>答案就是 $\sum\limits_{x = r}^q f_{q, x} g_{x, r} (2^{q - x})^s$</p><p><a href="https://loj.ac/s/1056871" target="_blank" rel="noopener">$LOJ6040 Code$</a></p><p>本题要我们动态求矩阵的秩。</p><p>大概就是个线性基状物的插入和删除。删除怎么搞？<a href="https://blog.csdn.net/a_forever_dream/article/details/83654397" target="_blank" rel="noopener">大佬比较详细的解说</a> 考虑删除向量 $x$ 后我们要尽量找一个来替代 $x$。对线性基里每个向量记录它插入时异或了哪些向量。找到「受本次删除影响」的基外向量 $y$，如果不存在基外的就找基内最低的（这样在删除时就不会影响更低位的向量），把 $y$ 其它受影响的向量异或上 $y$（$y$ 自己变成 $0$，这样就能消除 $x$ 在线性基里的影响，相当于用 $y$ 替代了 $x$）；如果找的是基内的，秩数 $-1$。</p><p>用 bitset，$O(\frac{n^3}{\omega})$</p><p><a href="https://uoj.ac/submission/453202" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】带权二分</title>
      <link href="2021/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
      <url>2021/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>这玩意儿其实早几个月就学了，现在来补笔记。</p><p>带权二分又称 wqs 二分，解决的是这样一类问题：有 $n$ 个物品，需要在强制选 $K$ 个物品的前提下最大/最小化代价；设强制选 $K$ 个的代价最值为 $val(K)$，$val(K)$ 无法直接求得，但是 $val$ 函数的最值以及取到最值的位置可以求，并且 <strong>$val$ 是一个凸函数</strong>。</p><p>现在讨论求上凸函数最大值（下凸函数最小值一个道理）。令 $f(x) = val(x) + kx$，$k$ 的实际意义是「多选一个物品就要付出的代价」，在坐标系上就是将 $val$ 的导函数向上平移了 $k$。导函数与 $x$ 轴的交点对应的就是 $val$ 的最高点，且上凸函数的导函数递减，因此 <strong>$k$ 变大，最值点右移</strong>，可二分。最后让 $val(K) = f(K) - kx$。</p><p>求下凸函数最小值，<strong>$k$ 变大，最值点左移</strong></p><p><strong>调边界是真的恶心</strong>，自闭了</p><p>习题：<a href="https://loj.ac/p/2478" target="_blank" rel="noopener">林克卡特树</a> <a href="https://imilyx.github.io/2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/#%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91" target="_blank" rel="noopener">题解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 带权二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客折腾小记</title>
      <link href="2021/02/02/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/"/>
      <url>2021/02/02/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九省联考2018 乱写</title>
      <link href="2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83" target="_blank" rel="noopener">传送门</a></p><p>按题解篇幅看就知道「秘密袭击」是「切树游戏」那样的神套路题了吧。（不过「切树游戏」毒瘤多了-_-||</p><h2 id="一双木棋"><a href="#一双木棋" class="headerlink" title="$一双木棋$"></a>$一双木棋$</h2><hr><p>有「$pos_i \leq pos_{i - 1}$」的限制，直接状压轮廓状态数就是 $\binom{n + m - 1}{m - 1}$，不到 $10^5$。搜索解决 min-max 博弈。</p><p><a href="https://loj.ac/s/1054666" target="_blank" rel="noopener">$Code$</a></p><h2 id="IIIDX"><a href="#IIIDX" class="headerlink" title="$IIIDX$"></a>$IIIDX$</h2><hr><p>我太菜了！直接贪心在 $d$ 有重复的时候是错的，比如 $n = 4$, $k = 2.0$, $1$ $1$ $1$ $2$ 和 $1$ $1$ $2$ $1$。</p><p>正解挺灵活的。建树，把 $d$ 从大到小排序。对每个权值维护一个 $c_i$ 表示<strong>别的节点至多能在 $i$ 左边拿走几个</strong>。我们知道把 $i$ 填到 $x$ 点就要在 $i$ 左边预留出 $size[x]$ 个空位放到 $x$ 的子树里，但是不能确定是哪些个空位因为会影响后面的判定。这时要把 $[i, n]$ 的 $c$ 减去 $size[x]$。</p><p><strong>$c$ 实际上是用来限制同层的</strong>，所以往下走到儿子时，要把父亲给它预留的位置释放掉。</p><p><a href="https://loj.ac/s/1055202" target="_blank" rel="noopener">$Code$</a></p><h2 id="秘密袭击"><a href="#秘密袭击" class="headerlink" title="$秘密袭击$"></a>$秘密袭击$</h2><hr><p>求树的每个连通块第 $K$ 大权值之和。类似整数概率公式一样的拆分权值：</p><script type="math/tex; mode=display">Ans = \sum\limits_{S} Kth \in S = \sum\limits_{i = 1}^W i \sum\limits_S [Kth \in S == i]</script><script type="math/tex; mode=display">= \sum\limits_{i = 1}^W \sum\limits_{S} [Kth \in S \geq i] = \sum\limits_{i = 1}^W \sum\limits_S [cnt(S, i) \geq K]</script><p>其中 $cnt(S, i)$ 表示连通块 $S$ 中权值 $\geq i$ 的点数。</p><p>问题转化为：枚举权值 $v$，统计 $\geq v$ 的权值出现次数 $\geq K$ 的连通块个数。 </p><p>这似乎可以 dp？！$f_{i, j, k}$ 表示以 $i$ 为最浅点，权值 $\geq j$ 的出现次数为 $k$ 的连通块数。有：$f_{i, j, k} = \prod\limits_{v \in Son(i)} f_{v, j, k’}(\sum k’ = k - (val_i \geq j))$。答案就是 $\sum\limits_{k = K}^n \sum\limits_{i = 1}^n \sum\limits_{j = 1}^W f_{i, j, k}$。令 $g_{i, j, k} = \sum\limits_{x \in subtree(i)} f_{x, j, k}$，我们求的实际上是 $\sum\limits_{k = K}^n \sum\limits_{i = 1}^W g_{1, i, k}$</p><p>（据说 $O(n^2K)$ 能过，但来都来了是吧）</p><p>上面那个背包长得一脸生成函数，那就如它所愿：令 $F_{i, j} = \sum\limits_{k = 0}^n f_{i, j, k} <em> z^k$，$G_{i, j} = \sum\limits_{x \in subtree(i)} F_{x, j}$。有 $F_{i, j} = (val_i \geq j ? z : 1) </em> \prod (F_{son_i, j} + 1)$, $G_{i, j} = F_{i, j} + \sum G_{son_i, j}$</p><p>带 $n + 1$ 个点值 $z$ 进去，让 $F$ 和 $G$ 是点值状态，转移就是<strong>对应位相乘</strong>，最后再拉格朗日插值<a href="https://blog.csdn.net/CRZbulabula/article/details/61210514" target="_blank" rel="noopener"><strong>还原系数</strong></a>得到 $g$。</p><p>对应位相乘？那就用整体 dp 的思想在每个点上维护一棵线段树，线段树每个节点上有个形式幂级数。考虑我们要干什么，区间乘 $z$，全局 $+1$，对应位置相乘，维护全局答案。</p><ul><li>初始化，$(F, G) = (1, 0)$</li><li>如果 $val_i \geq j$ 那么 $(F, G) \rightarrow (F * z, G)$</li><li>合并，$(F, G) \rightarrow (F(1 + F_v), G + G_v)$</li><li>$(F, G) \rightarrow (F, G + F)$</li></ul><p>非常繁琐，我们用矩阵来转移。但是矩阵常数大<del>跑不过暴力</del>，考虑函数复合维护 tag（这一步过于神奇）：观察到 $F$ 只会变成 $aF + b$, $G$ 只会变成 $G + cF + d$，于是每个节点维护一个四元组 $(a, b, c, d)$ 表示 $(aF + b, cF + d + G)$。合并 tag 就是 $(a, b, c, d)$ 和 $(A, B, C, D)$ 相乘，得到 $(Aa, Ab + B, Ca + c, Cb + D + d)$。单位元是 $(1, 0, 0, 0)$。</p><p>hint：要写垃圾回收和 unsigned int。</p><p>复杂度 $O(n^2logW)$。</p><p>感想：整体 dp 好神啊！整体 dp 套生成函数好神啊！</p><p><a href="https://loj.ac/s/1055616" target="_blank" rel="noopener">$Code$</a></p><h2 id="劈配"><a href="#劈配" class="headerlink" title="$劈配$"></a>$劈配$</h2><hr><p>回忆起被「皮配」支配的恐惧 /jk 还好这道比较阳间，一道复杂度分析题</p><p>第一问写一个“扩展”的二分图最大匹配就好了，具体来说每个后期被更改匹配导师的人新匹配的导师必须是同一志愿的，$O(n^3C)$</p><p>第二问有显然的二分性，你可以二分 + 从前往后加人，但是这样是 $O(n^3Clogn)$。我们可以保留前缀不变的匹配状态，就是 $O(n^2Clogn)$ 的样子。</p><p>但是有完全更简单的做法：在做第一问要替换人的时候尽量替换靠后的，顺便记录下来就可以了。</p><p><a href="https://loj.ac/s/1056622" target="_blank" rel="noopener">$Code$</a></p><h2 id="林克卡特树"><a href="#林克卡特树" class="headerlink" title="$林克卡特树$"></a>$林克卡特树$</h2><hr><p>题意：让你选 $K + 1$ 条路径使得权值和最大。</p><p>带权二分，$f[i, 0/1/2]$ 表示点 $i$ 的度数为 $j$ 时 $i$ 子树中的最优解（要记录路径数，写个 struct 就好了），分类讨论。</p><p><a href="https://loj.ac/s/907209" target="_blank" rel="noopener">$Code$</a></p><h2 id="制胡窜"><a href="#制胡窜" class="headerlink" title="$制胡窜$"></a>$制胡窜$</h2><hr><p>大分类讨论题吗。。。有心情再写吧 /cy 被「秘密袭击」搞自闭了</p><p>upd: 我来口胡了</p><p>显然不能每个串都被那两刀切到。考虑容斥，求每个串至少被切到一次的方案数。有下面几种情况：</p><ol><li>第一刀啥都没切到，第二刀切完</li><li>第二刀啥都没切到，第一刀切完</li><li>第一刀切到但没切完，补第二刀切完</li><li>第一刀切完，第二刀随便切</li></ol><p>$1$、$2$、$3$ 不能一刀切完时答案是 $0$，否则算一下。</p><p>$4$ 麻烦一点，第二刀切的位置是一个区间，可以二分出左右端点。答案是个取 $\min$ 形式的，二分出开始取后面的时候。柿子存在平方形式，所以线段树维护区间 $0$、$1$、$2$ 次方和。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21Jan 训练日志</title>
      <link href="2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1/K0Yi0a4ORGbH3adpmQ3oja4vJvPRO4pNEvPPM+cus0sVfqOdIRzfD7R0BamTKWloRnIzTrSsxfnXsGPztpjDzZ6oCWhnR/51yhuQIKT7DBdbRUqgmh4pdEEbYfrukQorLA1VgoTXpnD8inxmHZE++TNqZBua/AF7tOcM41uIRzbYd+QbF0ioaKfmsMsV0QqGZbjJoUueHf12lgODjM4Wl4+KczTVKvyAe+ciV7WpdcO39VxTtkyx4W/QGUIucFckRSdRipdvczmojvsg6aZ13ukA/p4ILWZkh2+cVFfPFUUeP/kf/eFWXPZg5hay1czt0dRTplBsh+Tl1S2/GFM0yMlWL3+iJ7K9sY4lY+8FRvg2S0hsXf+shWMroqk3EU+T7uVw4L6OgY/+CBeeadEur0qL4hypDrsoDdIPj2Tib5nUoEGzq+dWlnz8f8SGSuTqcrUb6ql10KXLN4PWlQpAvZloa4YzFFjAzSG12i0NPimLZ1zGX1blgd4XpnoUPFxfcFL0ddIJFQs5h1C+1x9bVLcu0NnjDJZuHmxwIzCbfc8g/LIK/rJs62DQk/6J+3Sjm6F8LhUMhvOOoYOemq7EGplsnjNvbAID6EWjwrYVkB5AMhIPt8pvwKt0TlVKijySJhgFP3uIWS7JcsGkGhAtJbB6sYTPDvP+9gygsC8KMk6PCzBEsEgROX7xRn9rWCCysmWU4R4RCdB8j8xGZajAOiiwJRSrrq1r+TQNEWNt7yRDK4/w/96rhl3pp/icaOveOb4Kx2c3H1i1YI18udbVaggzW22iqztb/OmLyxu+P0fxquRDePch38IFNrg4ZWg4EvMfJW6XrlK3mu3h5Xxtqcm4SOVtA1JbVOLDVJ5IHrOKO+gmiuT+EKfGP/1ZR2ynMhkAGhny3QycRi4/VBTWB7LS8+F3AojdV8wd2rqzYd/s08MeyJoMQ0NcDueDqW2VzjJIZmMBm3yOw8l7+3yjd2K2XVUSR9hvteVsQMMSfPDyIzE3Yrav34h0QAtM9NZC5Oy83maM6SxujK7TEReEgBtp2kt4r2sB4/MEi9d3KcOCeK7CCrXX/xQiIwPD+xvK2j1vf9P3RV5tBexYVgsMWnN5c3EDAxYATVQG2JnHRURHDTW6vLft/+n8KcvKWA1hcqBHaxJahcUWZbiI2/lVeLWwedhqopmmNG3GSKnbzaX8tir1ruy6rqJP7Ve6Cnlz/ppqzo7fTIiQBxT88mWq8FrCCL1J1Mb0B0AtNW4wXCShU0u2XB58Ez7Bfh/Fqii4iPVayuO33xz1rG7N0NENP4jw+2NET3uMc/uq0CHTo9KAIldnt0b+0ity6WtqRHd3IaGhlfVCpvJdAkfYqRpzaHijmGztmHjaaiRz4IVCmPXqf6S1WLu4T+sybOf5QVBWkGmhj1ZRGgW1Cgp4bThavuzElc4yiEWbwP/FNDKgYBzu1K06Y5SX3MOnxN9TDEAMCGrdmjfg4JmGmAIFdbHYHYqchDXX/7HuP9Dc7DM86XAjG5R7pqH0nVEEVosZ7VFa73cnTstisgwCl/uJdYS+nFnbtRH9yt4bGkOWgKfeagv9jp4gjWv+PmC9COgaGXBKo7dSyNebEvMjVT9psBo4gy4BXOXT7Gpg4MVDGeg20LQD9FxJi+izzqnXwdIkt47dxsZfzClMDs3DcoJ0Oy3tUpbjPQPn7bHiT5A0wnjz66knZfJii/9O0MtprIwDo3yFmijNEGwy39qmiFipv8knme3nwOCMdx3rPSthh4QOO5qFYXUFj7j5Ddm8TpMug+z10CG16hYzdBdIyvJ/uIs2bdtYvyAO/jeo/DWi0kKgh93zG6VfjXqzYIWeLrNac7yRxnkjcDz47QtjxSOfBFx6m4CJPCxtD0edXHMTOgDIBjocaruPRbNkq2onb17swGd5X+5wFxTy52IjP5k/PHu+j8qZVBDZrVWaOkMG7hrJo9w4ghdishV7nOfmI2+fIfhe0/EZdCzd3HW03kDGKB+OQ2gESVJbu56Kaj+KEr1br/bjiIAR4birvdLjNlbDyj5x/0OBiad0QRY/zDq0SX9t7gJTcvBTx1utl+J/y73hZ6XoDBr+95AE0AAFyR0wqWRrnnpMZkx91phW7Ymtw6s09KbUQ6yRcQ5Pye3ag1+YRitVVOOLz1e1XP78onezcIQG9AKXFjnJFDpWWK5C9GoS12NN19TO1vlaZntOvo86aZcDlg/tOSN9II6xIdRoP7L6Avy4ZqKIupEriOOAxzEVz+h+1BtE+fzfRYR/ndTqaA7ghy6Yb8cTJmbJ8gX47vk+Wu7+i05OhX7KKkVgEiyGiUcCK7F/7LzBhJB6ZKl/iKeEBBJmXrwP9Z0aTYrficNWday1fg/I/w27/FEddh6DvslGxOCmdjpMvayDUhChVSe988PFxUGBoksPN3MOiixhNUIeXN2HsyJPvfa2m7kKZbqJsf+ZpMBjciZqdFQyt4Fc8+MRdBFEs5mhfV6/9IPHmQ2mIegyKHXTovZan3nr4HDq6GRP69zMvnTqMQR2WiPWY79wxwIviq0ToktavxDTcL8BiJvTYQWTZt3AS3mSP0aIqMtrTdeUN8IQ0wCFywvloAV4RjGuesgO+bH4XJvg/INs+QQdcmF/AVErMRXbHV18jQICbQHq/YwE8DxiSXwd3VqsW9bji43Ab1toUtG95y4aLh6m4mirT9OhKx5uWl7AETZoB+VKHIGPyS7bwhknZvZ+jVP3G4NjbgSDbdiEfM2GUVPYWwumoiiqZfINemFlZU6zaXKopTpE4vqHLL1hVvi6+eEVXhHuKdhk1ce1Fcxqi4f0h48utKlMjATHy4zks69LWYUiAaxjXbp6K0HXbMCOaEJHMSYBD4eaSm7wy0EftCktDjlvGG6SPj9CpE4l6MUyN7RHURMp5dAeZjj8fM86ZkKQPftP1fu6b5k4S65ad98vTJHHDh/aSfAtOWWJvlWjahSoA/G0eX+HsovZzGhpMajOg2jUdzcWL2hxzYI4itilzHR/CKOE6wAre7AsOVoYbRmaRiJ3pZuCCN3rHPC3Tp73klrMs6TRJocMvGE9XP2PjMJ7GPzSEDumozfZvOmg9Fn3RTZCHFYJACtJbQ6O73YpO2z/UHDi9icjdrlJlB0eIB1hrsZ4CstOm4OeMnELFZIeJZRJO6hyc5RgAmlFG2gnHy5qp/JZx4rod28ESl2j2qQ9NHWeE33SUmGTFzf3fYJM17qJklyjB2NNDZt27Xme1seobqbZBApujXfeuQKIO+D0r65l5gatjoLa2wvoXkybTtI82nMjOv7hYkiWXO5ECAa9bLp3AYZr6SjTaLEztXkLkK5Slz5xMDp5Pl8zOgVPnca4ni+XWOJCFAolUvs/gB08H7eHjKuQxRefSXvAOI+P8NIX3PLbtd/WmO1IGmfFsHafUBYHTUqKiRvE0DOOhjbW8Non+6y4qc894j5oD6aOhZ/St+VeWoHwLqKNg5F91PaOgXx9KXeZq0crgUPZ4rATRzhDTAkacS4mxY4UT9AKXHo3C8tQ7LJF+5FbxFEIuwH1bKnIblXAAYDUeAO3cge6YaOs4dBKFidf85dJ3yc9NVra1xmOskOnfqeaLoo0cLeVMTBmwPyPSmXSqTqrQhYAhlqf866e8TkZQ65eU8dLUZ5eRgDq9CDbpR5sYEE0RqCbedCahXYr9UMhq/LEv7Cmeh2iuKHQJKk8CGIQmlCQfAkW81Xf/zQzwSxNal8rpyVNyJ+Z2RMGGLm9jC+CXzRFLMayCZ1eABavfaGSzafeUjLKcp3G958QwcoeyV/cqbblgKZOXj5ksS6NNTLlmcIwXy8ocTfVJd9flDqOQQ+ms4IK6+QW19LRjNVLahDAYzfTSJB0ASXiCMl9WLA5oS+8UyWZfN72D/a1DkzH37CI05MtbAb+f7IvPbuUpX9LNbti3Mlj/Ya8Jfp4kzx6KXd+Y8Zq0mcsDv8aXBL0IiBro+njMDvhUZczbyuv2MfQIOLrKgkzR10R2/I6rbW0udX3Mk4gF3XQk2cazvmYoHLeEoZb4GwyRF3t/R2Q0Q4onsFIbBCSfaHpLiEDGlpJnNwtO9MNbe6t0VLRmgY4C7TcBVM+3xRSuAFwQb/dm7F6LSDEpPaVfgEg10B0BmGU+OiqEVaxLfZi8rAmYKB/fjtTjWmIKiaLPoPG1XIYiOZ/Uv75mq/Lvt3akqJ7qkPnKp4eyO+hywU+MoYJdyyEGsK0+csG7mC3tDNp6Z6Rus0pTtTMVy3YES1kpCbEE81Gguw0x9/ldmdXK9OlHtpU7M9j1dpCWzfHTXVL1IunqD8wf4T6zzey3dNlNzPqDISK2rUncte+LInW19l7dOUXAHxPaCyTILWoTQXS5XGpRKR0JwDPvOqKh8Bm4qSDNgIvwjCYkgJBBuerDitaEkTFXoX/7sWJSiGFLpt4ckGigphwcJCB5XZsQbrrkqEdV07W8LzaD//ryID+3rpL9ugcDekcKuOJq3MrrFSvMAq135y311PVJ7Qhjk5/sRafNVURKa7XWSKpH69WRw/oagt1KtI28BKSz1zbq0wbXcHwsqivM/UH3kzTNzwJZNk9w9qcI6Msja7cLyz7/Ib6Fqbsepzb6ZVqz8nhIhI7L0fWjUp7kVv9OyxZna2yon6VcxJxQ15QcP8WinPIdU6DZW0pHbB7KT9EdWEXd85J0JtoyeipTOFma2/kL9j6t+gcC6e57aIeRfiR4ioAnXcxGQ2s2Xy3C+NjaExkGTGhJX9oGUKUnrt9ldJbSb+9ii0e1gHUZmPu33TbjW/gywfI6ZxJHFjY7HLYzp57XxPOf8V8NWxfSCLcghfU5jQKXWadKJTRHGV+EILmtMWxE3TXxu50EBBqn3VYSjJ5zHNR/0rao2b629xW+WzGIBGcFtgoLM3j76t/P5+aNiHeMKkTCmOiZafR5gdnnYwb1nbWSynB5MN3no85zSb5ATDh36Zp5dR98LhRT4XieIH4/js0REfXaunfN6zu2Nmmc++nt6nIJA4L334CB8Tkq95I581NDj6Z7+V7r//ItsmUiPyYpFkyPEPevcloSc2Qf4yLRlwf/F1TfW6AWIt6UoXFqG1nEeSRx+DkBpZZcnYzZSk7WKXBGtjozWl/X/sTUiPptx2MaywvDIyvd1NYQA72amcJCB1QubO4L9AI6lke1m8i5ROsZKnJZcRl46Chl/EMKrondo/KTFyW9v+WUc9xPWa2r29WgDoeDXJ41UdfXkxoA1aHVYu5HdLog1FWXjs/xB/IN8IUgqd2iq9YiVOEXsASVbtXV7ft4YSC6ZhxDwg+okDzfKdt953dnkDK87VeIFUbGxkCzhFsuakHka8lk5uSmgJgG+XdTj3vbvN7rLKMfUrwd2gLhmQxSilCgG0FezGXHpNYFVcuXWRkDp81zMxyMDoYkjg/dgoFMdYQSgMZdv0DtiWQPh6LlfOmLuv9uivKxNpaYCKttyKqtp6oY4Mh+O3WeO+YAj6tI+Nmx6gHuY1VQaPrihtRJl8cRMcX9HJEBXsB1keWZd52jUcc1pj7CKii8r+QLgArXyLYWOmlfkgH3Co52g9lOjJUiTMbj6s98fo/gBuN59HyZB4vQN3f32YGHCAWkcYju8aSyVPRg4W5pxHdzKwqvz7oAMhWWPy8Z8DmYgFp8tomoOKGj0PtcNp07+LIodsbVGzw7BYNw8ffTlvVXDXOxTdI7Q7Rr/8XPYq+jFSUbYy7oJqC9uJYz/SmlDZtZy/JnlWAF6MppGmB96LgdW96xqdwQ0xoljekoE7r+XsBMB8hAInzFV9rEnAay0CaXzz3Z0/e3cnpP+G/XvmwoUGCowjJz1Hulgq5eCWuw3Smtm5X8/u/3QH07JQfVWi+DUY5zmNHaiG/dLpeSRbUNBaOFD3b528gA0zUWxwpinNr0b5x+oEzyW7mm28AmWGC8RASlXcnJJQS6+UA8TbjKjJQ6X5pOyhb26YgDrRx9ifd84+Aab4BMhUUWWXOGLQydayRTdqx271Wx+PyAPSuEtQkDLN+CwryBceLtGgQw0wFprLjXrjJbGVu+EQun+Kk10Oe5UlW1tLee5iI2OUtxSJ9d93Qobo6Gvi4VRwwSCnn14+Hi9j2P69L9ulWxO9q4IDXrXWFuaStRePAVJzU1AoFw0VqO6oydDXaOtoPo2UJPJRebkfP+CjRWjLL+kNmivHfH4QnJdl3UMpsPNbLg2rs7kv9sg2EGcd9/KhiUP1XTtPR4UcRTpSZbmlsOIRk1QkOC73YwMVCy/ACAD7Ro2b3SMOF7hj7BiwImIQg7b41sUOV9bNlxM6eMCNalHijvQ++/IQo6/16rBvQB9k7L+F047BQmfkaTAvXZ7UTNEk62zYkTOB3HRaHLsl9An/VmyixBZxu/nEFiGepgckRsglL5MoCu1YcnIc8rrVDbN5CIvl2SCRw5I791li1But+Xah/uau+54zlVpHt4MJYiKcqkZSh31JEZFEBx118GWqazy/PIHs4gbQmSWv3c7l38WkArActAVJXhIcoOLnRidAHKtTF3YB4A2nhsFCdmsNyMA+7gvr5sRAjepqFLvn6m6tXwIt0Aef1Wq0PonILf3q0AYkgOgqrlt8VxgNrKscu6SaHFuqA+agoTWX67NvJr6v7OXqvAYsXiqsdEzatUBE459cUDWj4pomzLvQ+OL+1CJT9MLvLPxKSk3HavTqCXimhUZWd1YoUJmEc/d+kmK68tljyuYfkRFQACJ1usDWVGRaYjK5FpNxuGy++xS1NO6q+HIGJ1+q5yCO79Uus+hv5xIsw0Oldi6gZa78C9nD6uBj+rZshs5aIQZlTU4w6bPlHb5VekhiTcayvuU7VSpiaBAeoKOMyL0HvkqSU6dNywvHNjZ5C5UmM46S5azwqYF+413NRKPgmXZgXB5bsrcq8k5zayB9LbisIkdPIbaPcx0QEaZInekFP86PtwgFBoz5VBSzhtVyVYdyg1plpAXAxEVY53WmSXhjS2YTrytkBtMrEw05Aaf8Dd8FaRFuFVhyUlvxApHMN5WTvBqOTzcmL+8ruGOmCuLIIBQdiTpO7aJxrM85eoVuvYvqBTYu5kvEvryT/bnI7A5d7c5gRr+wipE2Ean3SMdNYz/x6MMmtfO2HvqF2/4XD/NrIHEgDGdPibTx10NaeNsXChvPq5yzbqN22n+GYO1+Syac/KgzLckFts59A2iBMtp8gqGNQowJiDw+t4Bv74c1gnuKyuXX2Hm3Ym/jfjV02bQ9/DbFCnkg2EBBSLpHZAPsXMobTD1xjMVzA0CuQmskYj+UFPhLKLRmI/lMuxeB2VSyBsfH83o1bJMdeySb++8atADF90LdFaoNXIKLXNcoNN4ASThLxkqFlh7OnEktAr+LEpP3S2SmUcuPNCMjpJTea0wT2/5ZingPClwjMlZi+ANc0iZv1XaCPqF3owheWYiECN+mwgbGUOD1yxh7JdT1Y/fOeTnBc1IFcrKJeb7eYoDqeBO7EvYE20fBVgLpBbWFcaV1sLGBXArKd3LBuZqoVMHJ97g7Yf9p55nh4JihgbZ2JDDt81N1K4pKeeaI01sAJduD3Jf5E2OuXekQLH4vHdDVPh3k59zT6rcUKvpsxbSalXdlQtpMR0L0aOWPIhNk60FxYCoz/YYSWmovw3wMdcFOPTElqTgt/ppYj52ApF11a/fxwQENf32WTpOgB2ZHTmn5Xb3+IYyYLIZNuXdIWFuEazpv2UIfX5VmM2kVyTFw8GaTcyK9I9NFvQuyWehxlFyHqYp99nSqiD48JJNetBGuMQ6OkLC+G4wASAfP14KfO3QrNrShdyJG+qT8nceZzv/ER8BwmrMKOwfYG/mIW8T46nmO7FIw3xWW83wN0r4SDijKSRX4YE0u+Yh90tW/j9lF2mv2SZUezRboeIsrwRfFT9+6uF+8XvKFI8RDPusKmEZTpnSAirm8wVzSwDD3AFDYwNECC9znHZfiYQZcrSxc4qlycVnri9Ey+G3grxbjvsMe4KByrG2z6VMoqWiGMxZ42tngB/Ud1vJXem1IWQWHGb67QwEWOtgGYg1loxx0K68ZAos9GLAmBi8OrW0XcgMaf+pyozhOdRhjQ/Jp0dJdpfUonKHkFHrHoJjmC0d0PSU4uwDWzIUKS8KVcWHcLMxPPQcBpRuwCDvWHt3PMwhUHMOsrkbNM8TObR7pFagqKeWHBjmj7Kucodox0VEpVpCTAPZL0nR+DrhkSQaHADJgY6TGr6S9CpoaetRt8IhM3V6ebNVPnbL/1KwBWrC1zkUpwZsIXiaTBbGMC4pIw+XlObKYaVB6UJhHIYWFL9ss3bHgHvG6e/Vil+b3is3wR/vI8tJFDHhgX08LODNMU/yJB3nPuMS8+bZWt5R3SyHilt7/iINkwFzkNcNppR+UloxUMP1t6SRNjJtP+z8ecaANSZ5xoZULGHFLi6wBQp4tiyN63U17mcgMvMeMXIR7cUJS3EfWr8SoryN7stZfyNjIKquT3xvoIEOc2776DmyZ5sQRCm9oqUT1zT7kRwGjq1YpiEOIHKNG436lAy2ZThJsz77JoLrROE3y+4NrpAlrsNjvOgMypVEKtMTFjghCgNWtdSJV8iJiqH6v/rCJaEaki4BAmj3jTUfgDTCU7hp/MH2tNbszUF4tOsd1SiMkmb6/rJQmj9TydBheS3YM93SW0+X/ZXG7wK1mv9zxmAX52YutbnVvW+UNlES4YpMOwNLGKGGijQb35/ndZQuusRnhIlh1DHJm+Z4QGMhVY2SzRFBLe7dWrtirfFY7NHE2B3Tg9v0vDKdOeU7XPCQxN+efYETiKfnTNq7t7O+RJg4dPKAXC5zLOUk9KASYO3V2R2af5n673pznyloGaR0ODdLNf+dNeVNexpd9iuoMfYQgN8Rmtdce4vtqox/uNjf546vi8d/dChuy5PYakc6cBGIzijU5ysE7bI1JPIc8gvW1GKiZYA4W0pKvowwTlHo66wtPRTIqPm08o/Qqu7tDKXCD2NYJpjc84jAn94idhfl6hjGOvsf5qnUniLu6VYJN+rZFrWXQqqsH5PqDftE1NO3T5J2xvgic/MY6UpDpO2hrKhgxEYXQ9wgp6I11PpMqxWcv5jPTJVLuG3pMMFY4or4h+1DW6dYYLZDuS0iDXn5PpTRwYOj58A7ylS7apjd4e56xnshsKX25XTGxifBybm5pz93E+5u2iSLB3ku0UlSJknufpzVasHa8+XUlMpX7UY9jp/abNcDICCbiuq84gq61MVTlFR4bm9nx5AVceyz/QbJT5XWutElz/NiS8BEjR2r/D4YUqjr5KzkbNGOJE/kdkcN9Mc7L35/7vU87r4EopeWtXWy28K0+yw7d4tr3WH+4L5DvlRkDqKU4JhPw09+PNV9ebO3qFkUZ8k6dmaBJQnG8zn629ouo3UAzLRaLysCPY5fKLJdbj/EetyaCC4YLDD+t8GKiPAJe5kdBPlJqi38ZP4gATpCUMsUPs0+NFdId/eWzs5q8ftgQrogNpti+XX7bd9GaRNftiBMTYQ1Kb4RHU7R4TnmX9ixiFY1bJ/TksU60FH5Z7JiC50hTxM7z38i6Q1obVYxR9pI/oGDZQTBhQSW/e5jF45E/Z22QIr3jXyUNculpde2dKPX8dDF4Zv3Grsuj9MVVpT14srviY2rcLPtLrCl8x+wsIK9gIRbnLB0Bj9ouu2lg4WgleQV+A/HsKL5E048vkWX125t6VFWlLcsvVQvJa0/iL0uWYNV6WeOKlSap/n9YZyLbngCbHCGKKN2Fl/GNLUKpgJpxSShbd6deT5kS8LCMPidzmNUlXr2ePB3LfALnGguzl9BUsUwZ8Km6I1WKbRm1QsHjoi1GJ8VlMF8eE8hQQXUzalIML5mtYkq3qGBwvinY69esj6HO89k5WnPXQHaO6FvJFqUronZlsJrGMyM1w9GxnG/3ZOefGYxO+B1t5m+9YekWD+qokItYwnJ3jz35nS4LGjEg9gOJcBrjxBoeeWHOZ4j4M5tKKCVRByPfFLuwM2k4eDQV34YGCf1sxspj2YR2CU4DDV5RyUIUuyhSHMcxd3DmzCxLKwrItcpNH8F4aQYJMzdT67Sv1UNl9u15SEW+SjTp0KUNpgfwY+lo5lsrvcCyvAQCts0Ay0JA9TlvrwyclhrJdcwDUbBO0Y2VblqjR3sk1VqFxGbyTSVxQuifoNIrP/qZyj499coxsxPdpWd6jigkJfCCGdCPLOU//uR4lOFKi/P4KelIvWjJJYKOPDbHeH0Sn4B0nhQdFxwKkMHbHL+IP/erWUEwUY4QgkidakrnjR9O2j1JycW41AOL1yf/dvK5FUCHiVfQTy4ccXEx/PC3zO/kzzg7n05haAnaxkQM4olfVAVe5SFjPv5nCFsnZYPIQL2eCX9AY/4BvVVRdqrgpBcqVNhXCJPcy9ydhsQf8dRKog5sMuaQ/wHkNyxUDZV0LHV6xpX2IW6ubf2oz3BIJh2P9JQv3dqpI1eV8IdqAau35AoZ973vGZ959w5esr4pedMgxeKFGhG5EvkswUytcsLALMgPMOABQLfxA2/5PNIt6KSMDuhr1sWM1ovkWvQ/o6J9iNkI4vdxViEhEQe3cyLZrhWwBur8tuDGblMbo0PZ+GsAalKkpHiwbwiI5iAfYZW7+5PpGFW3XqyFmtNGxeHhLOYDRMMlGCYky2kiS/p7F3ogLNwcvxw4w7tv/KTEPDPwF+QtVVMjvFF9zlmW3Xzu/HIZi9zjvMyqcy6rKexbvA2Km78yJBSIBjYa2mbGrcO9uOh7JD1rP26RPO1Fe2p4QKIRLDHU/BHpLQOrOkSLyTdPBrM8RSquiB3RJngxLgJhzOaAoiPVKZjBWcmaXMFly/B/SO3yXdAoNutrb7Fr6b1pYMyNNxazDftSJfntNZDVMnNF0Cj5KTjdFGCjCQckj/p4rVM1Aa2qFxbJHYxDre/Sm2nZcWh+ytgGkCjHBrb5CqTQO6Q+c/DVp0Y7PbOrYyTcYwJOoulaP0gQwJMCbP8NU2SZrsWNPS+mb/bpdEPgkrbObGFsL8q8PA+oczRmfd2dpaX57jnBsuA0VJcXBbnNv3xfwBa/cfK7otsJJ4lm1c9nVxnpKlMqS9Iw7u1Ad4xbYCZdTwDQOdeHQNJFnSm2ZwlhFXrGGjdo59ApBbtAmJrtMtCVYd8+8W3WXouX+pMEBwzClc2M9bsMS21irzI/RMaxuQXXKKxSmnQXwD+JDaFVB6hzxtoXI031txCenrpy3+07Ubs/wAWrxIiksHNT7jAsivlXAA1u0VD9wf7nQzoCHMRWwanESpgziX4amkZSb3Kj5tCf9aeCp3qFbG78VZfBZ9PCQOffw5KW7a7P/cWD2LdWhzjXQ3gwLrO1dsKI/kR+jwXzaCYVXSB3mHaq+mWMUyX5WSzbuN/i+eUU80kHPGuNqen7xIXno+MklhDYeDYVQ7eOzZWgr5ldyQvr2uiExqthyEaERZOkJkCXCIi5x4EXcgNOGFzKnujL4gz9MSc0W2I/ExjwYdLMQ8U2qIHsgXg+bIk7WsA1qpZdCs9cZvQ4HjCwwV2KkdowEALeoDWmaPG1AiFrD/kGKxLqDb4UECMFHDAF6iJlXC3udOOLVkHttuHOCi+2JyCV1sn3/mBUb1rCMaQ28RCdBjNe7Hfp2c/8/NDtxJnszSHAM5bxC9iCCjnIl03PPwdYA5UtWWnWZkIJlczcjV9LdiJAWdY+cdB7hWfPpRpwndFvM92O+Qn+BbIVyfLDktz9J05UZLxk1Y0tO5Eac2Qc0kzi49G1pOox5Gr5JQypri1nvU++Kkt3zN0ngpqVDCugLcWfhe9BlfWFp6slPk/qfX78GEucvVAVK4I6ayiDeL1Tlj7xBGjHAj9tciuZVy0BcB1S5I9rMd3drouRmUc+eSMqjcFclu9/WAiaqwi5IiNzPdh9L0PLseuTTz/zqlAhnc2eNzkE94s3LTcx4tAZXOuBgnOR9Gr1lLnSZUcpGGUwlYRgCTZU895lY5w2izUtgsJZhp6BMaSigOG2lIm8b7dNPiMD9RSc2wZjJayYURd1EswmfiJUAtDeVCaFRg/BtnxxV5cfJ1u33JlBuLCChtYDEnk9VP79qYtqaDdehJAihTsGOwZY5N//zGpEp1r4p8dKnp59v6j0Akajtcz+rUJ9nW0juSRewEmcaCUZnHcAYbHz+ShitC23qO51H2Cc5K9MFzOWvXac44V5a70cpq5Wz8YSeObpau3Jwn/DlCdYFPSTRo+l/vIRs40EJ5bEJY5k9XJwxZ9LvvYFhJdgnEPOjlkNcub8dZmNGDrJn4I4u+detYmmZmApw3EAsI4lgqwNEid23mJQJKC3F5UxcZW3zE/6FGqN2cfDYNS58gpgVz4De66ng/qoK1j3b204FaPPLK0C43bxJokSmmhHJlNU9Ir0TGFIpcs/R47y2X7tkbz5vZRTdEPPAfO1rO3jbb4I5lQK0/VKGcRu9SfCPGK71rL5t1qVQdZdMJ2U1BU5aju4p7u4jnrW1l14P0fpvJcguQ8fOiG7hm3rHzViIBMKs7fxFVyfoWk+ZZNi9h7mFU3G2vubWjT0EHOreWtD118uHB7fLf6pK1WT0IXqJVaSOGZ4Aj9lTfXqGdjAy0m3p5hLOFyolbPLlQdr4pdl/BVuFsKH+02/KU0UhKMTc9hXz4OuVBaVPKM3P6EfIE1n6IHWvGucbP/abq3jI4AZTvoDPjC8BTtKTczeFfwHhHewYuAsAMtMu3BxeTnGxSji63MpLeKcVc8QJmCB+lSw6Sl5igZ28X1C+x+lw+0z7JM24l5alPOHpYcNq5mclh0BA6gJnwUC5qk7PcAnfclorDcmaw6BcRCPA6/25Mns8hVKWxpYJI9lUmSgo2E4vZCZFQtyqZJE2HqreTfyMVthjpXAa/2ifQjX7VQXk+LD+n8yGXsA2SOPfwBLMakQNGFb71fcBkhjdQHWjuA3/GYizPMgPBn8FcdXm6u22dqrMZBXD660zVyCten3N3OPn++om75r5Cic9NcoCc2Nl+1Zn99RU/nI4qYGRSLAzKc7CP8/VVFSYfJxAxRdcTRZjxFCwo+aTnmlfO0cV16mYoRHZHVvXDGlBEZTuhpUeosCyxhHxzhoPJ9fEQL17CfBU2gdgeNI3gRpp0ZiykxeSjzkA7wJVrfbnoElvCVdAVFCkIQVCPWjrMNRSqmUpL43NqGNQoORP5gYcS4Z+t6OmQ9ny8F5roFXej2TjHU4PBkc3kI6x2a2kO0l8X+SdjiwfxT8nVAQZXH4q/FPYJo8sTBKNBFxpHaJw/pCfAJ3g9XRjn0mXtVlGzEHxNgc5GwRP+GQmtiE7j/FEtc4Bsour/5BXJwFWxKFuuBW+iB1Bh42Anj2UNtM0MdF/iOV+q+025F1VbG6j2Xq/MhJg58YTWepfKxQa8t/ONH7LFcxPY/Ofuwp25aBJX+T0aj6dON7K4zJfBTrX75s6+i2XMBrmmVneuc4Vu5zRW8pdUo7iZfMyHkG25UGAZrUtYPEZHgPJu2AZlPBvX3kq6aOMTvfihxMYO4FwOSEtPNReAhuNTwfUpZrebR5BL+/xdYL9ZR1b2A5EMQD+KVU+6Fy4uuEitnfISfcXKi5vr9rVs1lMVQ9MhnE7yZcLME0/fDPR+0dEgOANZwuFFRGh/Gd9JcHGw8IDusiQ2A7mPmQWkJwvGL6/3BqQ6v9lhnf9e99DI4FFQ7nmdJgADaviFoSs6OSk9m8ZK4kL9v34+GEY/jksaO5PWR1L54t7jfCSnPwueGhNtGvVQuIhqI0jKiTmMmErD3R3t6X0/PwSfi/Ynw0hsKZrkaIQRhzjQtyQOwMuP2poCN1Lieqov6cSUvey0jrfFoZJ1WDoKl42YiQxVhfq6C2xs8AY0zmwbjHO7q37GR5l4bxTePxSRKAapYG4ePIXUvxAlU12womyzlPu9Bxo9EjgGJivCp78HgdmN4juVqX8Hep/Qti78RnKJu7VBPIWh7hEFOXR8VCK9sm4Sp65WPN78mZmo4rsYFfpDE8yVsHY5bwqEvF2U3kkVSLzAqDUgY3I3tTmxIm70STYPyryPgdbB4P1FTV5LWVCnPgV/vCoqBj7Rs0x/b2pVLkBpE1wIfKPRDjR1l1a9gSiZ6m+2AkqhIeYdmXGhWqdE3HONwWiKF/2aU913Cb+MMH6J+DXn8PL2mLNCU6j/sxnzy06V+RSeX8whesAwC7x4RF5Vzug9Fm+9F+K3sGiqnMBZacDgNJGq73AcKTli4z117y4EYW0ICEQt05c2wqPeti2UjXnQO13Kb64wV8zBt3mlqUA0+5DkG3IEv+QBSPGjXDduBkAjmWTNNSzWs43VeTMNYZOsuiBJwZ74in2Yb2MLmVt9Q6TCKUgx5VXC+hMLROvYptbSMXWMioKUHBj24Wi3iofs4SvUDcgeyL+Ua3Dj8BP4Rdr3+6iZw2lZP4iOfnuQw4qrP6d3qi+MqFWaKQK0XkiscApD+8edaGBjmjY28/AES9nV+SNF+06qK/39BskuSj1RU4ZSkxEolIZe+tR6pfxSji7CYMqh4JzFMySgQRA6XSkKzHbsPTiuqGaNbqhUi0m+wtyxAhVwNRVgvQ0XoMwKGrHubI/Fw8QwKj1N6jALEWNSroxsHGDetHzCz0FVFBP8h8ea4inv4+F02SgYwi0txgDmnUNrsU5qGvAOLtDW1C0oh3VVliArgQOZws7vfWA+IDjaWApS9K4xZn7zri0miShh+0lOPZitTpUrRH3xULqi5rZ4Kg11ghavp1FCyVMxNyNchb619g1uoS3AVWNd7lylgWwm1ufke1LK2EmiCvT3cQiow0OZxE/RsafIqm6JL1kTYTkurulKCYHYvhQ5WQs3SY/IdAKx1BI7vIyYO7mQzxagkjHUCTfRLlQdHhMkSbH0K9O2LgZcF4VeIyQx951vfK1eSrq3r49KE0vGB5hGySe/4SlG/k9K9cHgiT8cZghhM912XIk3k/Vnx9S/NtibguYku0RtRsh+7Oe9psNKVT6RE2t+sD5HOmlZcNe/9EFr7MwhLDzpLsGUisbj9CItPEYwaFg9RD7sz8V/w641HqUarWInCP9mLcULzUnJR6j+ITi/GY5+2WhjB3r9eDYD02k6Lfjb5h8EbtYSNyV6b7L+238j3MHKyJl6819UwxTjv1TnESbwbz2/jVeV5bQ1QF7IMkz9vnj/7fpktfloinLcPNQLgAe/yV+q06dU/ib1OEnyt1yTr74vzvP0I/K1OnLGHeKlxZQZz89PLAYUwfmUhb3qZCXIBielYKnjs6/1Nhf5AYlwOF7azNsueZxOW3TtjKobGDeQCm/1G9f12RreGWTvtppMY9WHSIuugOts5lKJKKBfpBlhbtVerEbJQV/5p3B/PHEOxduLVaAdREhCaVAh/oYGvQ6PQWLEz3V+80swr07loifG012YO+DL3eNa00BVYyK3hJJItqYibJaTeCH4+V2jX4HcfeY+ptV2w8iS+Nvg1HuXqdmFrVC+llh3Bemwtv9a3dsTKdyQX5dB9HrIlb/TM1VFJm8AzItUCYM9x6H8OH5vNrGhp+P9rwkJFjCRxPYzXWzEP2JDMlxcUE6UXFgFBPonabQ1S/SiOWvIXXxxU37wFWBh36CRY/Vg3X3TVYHRo/+eiqSOltIsLItHZnc+/DyJvShBIRxHeCcYwRmCHCyHg31BG3J1ZjbNcx99wH8qqpERrfc1PG4QiNZkhopEfI3xXmsKLih17d+Kb5wUYeEjpvyB5gCEQMZVpfgho1L4COBO7rvLfAcpXnrtXdPqdoxsj8CLnm4dKFaeweHbz/c58TGYg8YDreWo/4yTy67BBM/klIDojFLCxvctVWciEslo8v0Zp3apmDf1LP1lVgIY3CNzbc2P9/8x4cOABFAIyZdXOXZyU/DN3ODnodkfClpyJ9n8f3r7AqANrCbs7e+uphMCqlNzrb+GGANFvzG5J81tHyyYWcY+88jfOmgIxTFOdgt7I5sJI3fidbNxXmq+EGa3v5iCesOcDFtnpEBTYYbSIiNltSO629vGgJoOFsLVRIVSK4EgjRinhuUxNrqvFMsH+3H0DxqjJUVEXy/c1i4wk/wGXg+5gjA5VzmQYwqVazoW9H37D0XkksUNRE4eXMiasUSrH+oY9AqkvzP8XtjmSkz3TGTrMAp7O73yJx4EpQJroGNmZqOOuZ82lNpZVm+a3kgOaCpdzImvi1iWj43Lt2FEZbsGiXoj8Kw9AVN+K1ej+BAEGsqnE835qaxYhF/T8GfUyu3P+Prvr8iE3K+TPJE9IO30AbxbkPuBCVbLJcl8fDNU8pk9esSe4Yyiitai3btXmW2qheJx6Jet2PYj/ci3NrMd+R7aGagwrwovJNR3q1I0LMT06+9/m32HbSB9ISl+7j7PjsAuHPmJd9xEATp1JcB7FXIxsFs9WEmUDYougLxFya/Ye+SLyJl7tG5Zp8F7DKRPcevK9vXyxF5OsQBLGM+TxmfHql7e6gnxparqW3V69ugkcZNRWoDPpjXHIszhA2/74UiBQfhWh0W8VmY5YAIJrGKYDyiJyqSmlhl1XrT5yrM2O4777PV5jNco3U73rCvmlsKN9/ztihJUN5U2uaYZysUYHFj/gV3ga31HNmkFi51twOmtNFjaHXTeo2qcvPanl3KRu/H/rCWjO1eS1t7g8mbzPnCGGcUl/D7Z1oIQ7dVl532WIryplbvWVs6gX2EUR+G509UC/55QtWbuXB4KGuEuwG8dFQlfXbfXWlt0z6cGVx9y06EBps7dZGuSs3wm4OZ065dgF3bAQqT/TpyUWhqomL0qwbZaGzccFe4eAlgiTka0CEpcwJ04OGkyfXIqem4q0R/AlUULuQVAhAd5D9mHafe4/MDvaWuFRn49HEBOsj1z6HNQJpzJrOSfRwMM14EA7WcPSe9zurwHQxQ7qi0h2y9buNUBqKOyLRf3xFsE82iIAbYkV6bKuxkoAtXjOuM85m+uE6udEMA10ELfylCRl3QQ0JO8eQmGHjQqsYV006m+mJEY5NGuaFsO8mog75BqtG+sVXbZRq7P0pEa8o7owf9CRAhhsC/7Bh1T1ia/MLWdVfMOxa+G+DHS55D6VcBYV+WWq8lj+jW55UyV+AB2XPzA1CtPmH8Fwta4E2UHHYoQAtQlXp8Zl9fXoLg3VSlrtj5AkMBXOpQKgn4eHpVVzlX9MDhmRBYJdwBtrIYLKbT+7bRlrvIZ5Xe6plCoFZwpHmlMarFzhThC/P+Us5WVmxywfAd71Xruz5bZutvzZpyrHAz9ledI2TF0C90xJknuErpy0/vzr4yKEuEDbKVlE5Q6PHmD9HPxxV7RHDtFinzr9mPZPiIdhy4BsgLDQTT7v3JP7oWYNEui5nbg6nY87Z8oCBjUs+R6m9ri3j0PrzlfgamhW35OiBz0RYfG4kGbfOs4ZylzmAbFvX70WFQ3uviCaKUsHTIyFm14oO64/IQ3yTLMF7kx+/9c3K4yIijQW/FafxHzSGFzcDdpMrStFYTLzLpgRpHjC1vGzI4bwx8dz5NC/cKrEUQDEElbX6J4u3oM1SR8Y9/pEHJYvQLJJ6wla7q6EKbgqQlmuyjCz3r+lI2pTveq5dRy6Fr3n+m4uCJvU9tT5OKSYFb+xjkVoWGznsb3JBi0S0kN/YMZ2A7t5NhRmUmjAqWMf3g3YuYsRfZCgtkadN1vdQEIxiRQ2gxhe/qHYvWNZK82NwPQrcyjsTRwbT7O/ddQbYetA+9v4s5Qw15mu3ycUs2JpkImurKk0T6zyZOPDJccDwWtnBduuURDYGlI40qWl9WCTsH9BS8d2XvXVc75+9qYL3eqAsKN8jmAyWt4CvMy9MZjgzOna+86pk6f14vhtJ5PC68sx340A5+JtB/nmO/mHMOchcsnNp1c44lZVf0EbYiEsH3YHtAk0ifNrNaR2UqjbDKB8Bc4AQ/m4katK7lOI456zpzBNdRqvbSR5rS5tRX0S/8qaN8N/kTbC91T2e4DRM6wdqav74W/LspOfAZ73BFfz+u+tspVz74FUQ0lF0kn/X4mBtBErOaJL5iEkLZm5CJP+vGWpNJ3UmAMq8rnSfqkUXDjKnwLNZo4cK/n4oKH7xYHptCJh3DbQPmRiBKUwwkVuOGggeKdFn5cI6wpsBekE8IeJSeaUJacw6OtXvSnMSlCFCpK6mMHM4jCGMUFFP63XB4Ey5BhIBWlEfBMNiyk0pM/w7kmS6OkUG4W3S7dHmGSn9/1/9FoHI2QCCKADH18OuvSexJQKnrs23AatpDqH4vPMRZsqSvrydizNeDq5GJm3ua11cP6/wNTBYEs6PesdZvjJ0vYZFpu+hLTkeoHEy8wDQdV9t+2S5rFoOxdzqXdkFSszXuhmTk5OaKH2H7q7O4U6dkOYFcxQ3NNJitdW/2+yk2jRsDLMqb1FGw7zum4w5OF/oYtMIOrbFNDGORlXqkIeho8HM1ZG7ujk4NMrFmrSTTZgrcPy8vM9lOOtfnBkvlbR7hlSbSSqeeAKs9PfbEGT9jqaL02Tqr7WI82rjLBzaas4nf3crN9oBPBRbTHQeCE0208499S0Xuk142BGXo9fpd8+ZyCOa6mh+u+JrSjuAWSNtXakOiv2gBiVFhBZXdTgSrCa4Xf8GKI9jDMfWZKPikoFdc1lO7v3YVryg2QAKh4MMQc9L5JjJsLHfZv1sAFrOqsAACEzie6ShKwn34eEsR5xWmafQZIIcmhOxpsgsV20gb2VCHeurOYXu2lQ9NSpm3Sd6jwbGRB5+wby9ktcH7bYvyg5i6k6m57YrQIOoXI+pPYk+MxgwwaQN/2FwdmldxQvb2Vx3rd0Qwk4H1UR7pJG0w/uTH1AapnHojYvCnWLBEPANmnOnEmaLWG8WgW6Mt7/Zrr1sUxv8O2lhYAtp8Gw19cfQTztvMKqihCIgmKqW97VGAgcCiY0dsExtmW1MrmyjJUhf9zBUkiK8PbRRiqVplhATA4rKCnz+t1Kzbwimr6j4g305xnnrFr5MPXKcPn57UypwEfBkLd4G1AuwnjHRd/KyUmc/zvOSPkaFSos/ZKwRpcKqp1zIlZJF+Tcza515jebjUhic/srGk3SYxPBnQ6LxjEdQSMJDC1rGhV9YnCSHaPP/OQXmApVeBDhN0YdtXsuPKko2KexgKe8pG7OOXkjba5LdahByLDM1d7k4OOPtt4NXTYD/DXbWb1iiUOHnKt8kFl8PQE3WYqPSUCYcDNstCIMweFEOR6H0HjZjgELc+Mnt+SzudGMNr1+LEjRNuJAOtyoNH3N6nlfvR4zxCsGLOELAI6drYRHFRm9tkEZPvYS+PDtXfkmGKPmizPd9CxPeQ1jEiXVHAJl6RaL+74EiPlUVKpKTOMvw3m07phrOdOjTbMDR3Cany5Lpq6WIHnyDYV83UwTsXsDAFeZlU/461nI50jO0E16nDlMFcbk3yafthPmx6v3mmbtqDdlun5/ILdF8gweqSr6wNw12nfPqIH2GYs9biacBqHHyisJ8qzkgbEja/tzOJHKmgTRftz2EFktg5+5po0GwSzwso92YQU8AOEld0j62gc+8/4tZi5ATcT//qGvUVd+lAoIyIJD0SLURtYQDOvgu4ZYnSW9iSDQhH4m7KBhQhQzo8w9hODDwFvsvD1dlFzxZJ/JvCuwbTRnlUhDlcAg6gteVBF/HTVRURk1WoJ++o+2BcItQhKBxNxTB/7R5f1NNMtCGNkkn/wp0VEi/DMYhsSqqRddBn2yH/ZR4SLEeNpHVWcUFmIF4pvtfBVw9EqIgwX0vy2mbUK13yRJm7m1xxGrjYdxk9X1Mls0sqgzaquqABvqiKPwCywyyYyF+PuzM/XRiusKGJHDykFoGQzX8y0LDnj6RsGVtPdFV8yXlhn0Rx1+uB+D5Hpt92I/WhGTnh2CJbfnK34Y+5C0RFdci2m2PyRU3IaeDjKLBnA5F9dkpmflhjnXGA/M9sakWu7u9uHcOjyscchuEhLjHcN4S/TfHd/kaBBhKYYthiCtrheu38V457L655qeJG9COf55cVro71XpIrcHSYjBZpcCbQGHbFyXd1Qb3rqDXyMlZoXQI0tjQFE4Y48xkZiUuopQtRXpT+DrhBMoM43LsQH5GS5FJn7OMYLYsaImBrRcyhTejOWQ3fZRGeP41deHKtpbTKOdf6ExOUdNMExl5siVa+1RoFP5FtQUizcxuhboy8wF9oV7ZpWO4NnJizAZJ3X9A0THZCkg035XdDDTrgNUh+wYsJhFUKsots1gGLHTmIAbJWUOH5vs8IM2R6F2xd2oc15/Ew6rZjoOFdcTpyMaMfaCOKT8iIXm8b1tWglq7cDugZ49qv14E3ekijheci5z7pclr2OEANW3Q3/HWT1hhE/n/ZyFD7+9ETNKJJSKvTAJRIqJRxiZ2zI35gUolPMLZn+uTAM9kaxpv7XVpr/O/xQ8+HxAk0hme8cFRDp/Mr3YyOLGO/rouKlsUpZtBrz9k9cHREF95t61GT4USNZ8WqOVhhHsX0A6nuq3ZVXDDyqyEbcFxdRfH2tZKUfbx4EOzUyCKKQzOA8a0E4PYsbYHXPq3bYW6UGnjicQ03XvGMvuoe/gVzC5hCZRpFqLymP1Sbqo9g5M9sWDzbtHHF1mEzQ3we/osFsdaoF9EFxP1ywntmW7ZIdY9c8Daeju6YW0rACTGBfCHjX9eejCd7R0e7GTNtN5cnX9BGogDPx3tjtqy0ngpqrGJvbiod11WVz+yXAqV5iXTyp8eD5DnLjP1RVOxbkseE7lpcDKWzb6E7Ui/5HqE2v39CWKgvlma+sx4gPbi/B2Uo9RqBVgnoFv/BOh5zI0u3MRuFRmReFRLY2vp12UvyqZ5OTFTxf4FhQoiM2SKV6mOW3H1q/NgI8kLKf3Ln+HBy4Erx/90hIXhMqrZoAANv1parnRHSNMYuNERPgMXOQuYnu9CvjkicGmHcZi13kOl2Y5tB+OTLUXTgXZtjXYAAnhIz4bCDPVYzcbFbIS630I+Elb796pq/HfcFBYUuzPdBRdg+7JLTbdKOjSkYUMWvftj+saIwo56DxNgAL6CcfPUln7/BeripKpWLC8ZoUmaoXOtkZ3tNugMCTrgSFGeRj0vx2QKfCPtIwMGHPohSs6fW8cJPRBVNtfEUGf8LY8DrznNAi10jX4BPqIkSUn4l2u60OyyyQQM1GupzTPV9r6SVpOx6mGBulxTlXp3CEQD9CI9F6BhUKp0WkbV33d7SWls2aMf6B68AcQyHxSbtzZ60gKzi2CuPxaZYP6lLnigP5VVzdfkndluPWG0m1Cd3P/b6GdQ32KIXzxaHTctgVLdXbJTLxWJGs2aGQpRQvvukVSm7gcUi2tuspZl0X6ijw0z5ReweSm+6O77XKB2LSrcFSzcZLkAeSvZANVv1B3RpjpS7Zp2bO2fcy70UYiqDzFzpc+qFQJUpSOZEwA20ZKY8ndQYzXJLpn6oxc26M4YBefQFAaBVWnTga9m+cp4X92S9llUd1lyeOTyfGwHoxOMedJWS76GFx3JxCNFjGxuos4wuv7HPgsnghCAZuzlQDkYX0SdTjrU12Yu4TWPkx4sqG/xTk3AIxJl7uRBowBQqntJY8EZmeZh0SSEakOJ8E2nZwYS4H4dWh3/6fWjiHjo01m4BczFXP2R7YKJTo69l+qZ2yerEku/GiKiqTj15Zg8q4lPy1+OrM2q6rCCtc7/P81R7oTj49RvQKwU31PILpEj+ofuEKHcAWvUr4bYbvZaDAAXPD/I3Dgjo2MNODiGfWsQ6pMCFgf1oc/Ap6DwnpPDHBTabAlP+o4bLeIMWbddQKKqlWMc+94HCFM3AhzMmPEQrj0bSjvh+5yFTaXkTRL0ubVgEGvP+pcvgqvfBQQCPqMYaZfCPGyL1EhtEqyiOqPn578AmohICwYhnUoSfCuhTeYylx/vhUlOJa+abAbft2zmfS0wG2a0RE4/61VOFPfqAK8h0uvVzXVUQD/SkjBE5uYngrzwTLAXpeYGPLGBk27kvUGd+gnklXJg/1wyWVw3LPp3QBl41e9M4RNz7/7jC7WYyI0GEjzt/KxVqXStc8duQANEKgHtG1wCPokwb2uNIPFNcDUmaNicdkwkoOSAvU9BNfah63ehnNeJ2todHgHpw3JijdesftP3+60upjONs0MLxgtL1hD/D/O0VkB52GSb7wS1KR/6a76dWvqeNfVTwyGT/NR+Y4s5vJGUG/gTU6L3lcYTXXgBYg3/sPzq7yc7lQXzOjjPZoilgEi18x0rfzfZcRZlwYR/duUq/hKm3pnYnx7HLWN54d8LGe2+ozmHAKrtafRGiCAcOjc6Pb4TFqSC3k68zB9105U8T3cNAI20olqtQOQeVq0QxfHg+4doW5YZm7pcWQMZYy9VEH6vqaTlj1lklnlTXKh/9muxGvHksKME1fT9ryFTVjIAKb7d4SatzQuw2SBMgh5tmmM2eq38n79rWc2V7KA6a2t2NiCMyKMn/EGpEMn29uh1Mry5xs4AcDaI+t6ELzAGq0gDiWAntVPuuRHmGgIuFk2olnq+w5Eiku3qTjaNz44fg3pq1YaBOygD/8YaTUNbJegI+cfH0n6uBL0SCBBM9cfxJHdwVPBcY3mwyoCTE3MK2nIdc1QZ1CUcJYYemSJ+CtudrNYdnjHUUcgoYI8L/Gib4axdxKBhcJzs7MKqwRruZKyDbxV+uizhghKMJJJzs9KsX5nJklqI0Y0H2qvcMhENi6F3uBd3ERgpMO+wHrvsPQybF70hqxUd5a0faF428sXH6Qa+07fj5uy9WUe9jMsZNiaJb4xaerK7kLpkz3C2jrLJfuccxKEqV/qtlUTYDdHU/WgErpbn43VS/G1jJHBOoegCs2p838Ml6V5Xu3eq4QRtk+ZfdRQu8zxvYYaDsZLu2O5Oj/djRZopqLJw7pzuOx4tzvOLozWAxSk9GEVuc3VUQYey6bL899Rsf8IbetFgAa+nYzVx6GiphpT2a/PwlunAJyu/67vYDWsLKqIORdFbxu1AWBdOYpXwI0g8H5gHEFxBStiuZWBSmutf9srmk1A1rvTGXUn7PMJtnxmQt2zwwiF3cjfU7HnErGicMDawWYUR1LJok3PPZjHZCoyv0hhYoCi5nEZyCqfmUBeXzaoy+ziGtBUgL3TPOVKQMCNiRURfjAdNBLasm+a9op9U8VU+p2/rR219qV9ZTxeeWs/F8ebznm6trZ4eT+gL7vwO9vtHdxwJSbIgWhp/a48+SQDJnvLbgqnw0Qu6YwhV1GMaIF5+wD1YABHHdODVlKRGhOvViORT+PfbfgGu4JYs1IbbEKd5stzEjjIuPWOwflZJCrXjVnNqiGPXy/YFQepVm/AJC3ZE/fnbg4wfTfcvg495zDK6hsWaUzCoDqtRCLrs7IL3Xw/la/V//+uBO9359mYcIG3j5yxd3e5bc8n0nFfh+hppzLPVzkwrrMn2wLjPhEv3NO9Iv5V3Rj2GHyf2U3/lup+zulGZ77TCTbDl/udiz7YAtmuop9uQMqIULVmV53UJ2nvRpQS1OH2CGzQ3LhhhmdPHbRjpB7+jc5CijKO2yrNbda6hh/pjrBoPwAEzvYYWhCI4skwCFt3sQaupP7ISZccCW0gS660UMn1r/agAcfrgaLF7wY6R+MDoKKTIzLa9xmwCTuINESdMK0suYotWMeXBjMfkpnk7oXYi8Yz//znentwXE01cW7XF0EVBOdcHmSR6a6Uj/lCBKJJg8mM8iucfFthlCp2z6l9SC32LDkBUp5NdIXlnFmJ929CQNAuqDP7bLuYKmhy7ROZ12jpwyP7FC0CeNFgcJbCf5ExjLOti7KBPbU0BNpi4csWEsLApKqtgg+m8h6EN1cQWRYAknR32TDHlIcduuGn+QmIKqtZqxk+6kTeKF+HiL1HKTc7P9ZxpvDaiUhrdvatQQIbvcI4fUBp5H9xTFprHYByXe2kKb3SNuXGaG6oI1UBoLxRtJyWo8/pXe0TdavE5ySHyQ+8VZu6r/HAldbAJJcmsnAvGUaO2KlwXjNPgIHdZ6679/I2sDVgJ/sv7GtsNeq6g/MNFzCgq3KVjNiAQY4nG/gwjYDkA+5RSypDcT9+1sXocoscgYHOvpUfu7kFJKHYuqwVq6WVdxQnd+JSjQOf/YZNDaOcSbevQLacA9xPxGdym7HPAILcBuR6lokTgQCJWAp+CV9XqLW1EtbxfgT1zETxwKGz0SU4wDcAWOZzWC7sEFEjG2JTWg6NBzyE6szI8b9PWvjr8W2SvSWJ4MXrIQFajNgEcNM85znsh3AqE8Pwvp1fjQ3AR42+FLVMfe73D3sFq4Y/iiG4hd/Xod/gxAjx56vKNWlYDsbX9DaH1ok/iGjwcFmCEm435Jc754/j/mlyhAk7Rt/tyYa50h4Ub1m/ivKq2xM3ayIiPAYx5zmNH1fAbl8TDryvGCQZh9vX4y0pUoEPRwAdkird116KtEJNAU1wCtkkptYLFFbmlXViJ297aClAy7Thons8M9VmXXDiOvAaVertXfI4CNpPFyErRf+WoKUKTlnpvMsnmDuNmC6nPC6NRANIQw2KzUHYqkL6V1Wx0phc73bV8y4FV5hzVZcPvl8XrubvQITleOFFKQGi/GhyweCYyuRvGL7/8v6ZrH8LWUcTgKWsaTV13+ayhHocxsdByNl7gOJ055d8Zh24iGNJQv59OIDZBXSsMt650jpuwYGrGRQsYfTiznTmIFPy6Ohrib9ovDBowMIrKfqa32otTA1yQXWQwtZY4THBF8/OJddNnGjcq9vRNeCLWfqCCaFtoQ9mTgW8R2SbSdRmEutOPd952WKo7KGyOHpPrlXcGvMKlqLejGtoYvssPW5dVVaGyj5MYjMg8ir4wCEXFnxtBP6umd5T30qkouXvYdhw/HPb0ykAISDZNJJl+UkxbJqeeT2Ca/aILkL4Tg9J7p8qOAw89dlBwSfTgFcPZckxRmnW5qSdtPN9V1bTA5/NPGTZLh57M0DW4wDZNS2P2XAkyaoinhyqzSUIYpBr8t05AfUSdv2ZibA8DtJ95v7yD1I92rfClrpVwV2Hf+tyw6xreG9V8l7CV34bC7XQsT3cSdJSJqjuBCMcMeRWKG9S7kxWc4E8xCTaEbJFIxxkceWRdiB+olBLtQmqwH2ArQ8pc3X7iFpppBpnV2T0SY+//gYdU9q79G8xNZV52b1W9Yx3sLeTFqctHmZ5ROcu8fT6Gtj8M4p78djxziPUU48IKRfiHXODOo3qRVV2DkDr5R0azm13ZmCtXTH4enWHoaavlxTZPoXyfSTncQQW9JyCpIU7Y/piJ/+wW19x5ytwguNswLxmawarPWKJT08Er7wRKJkH+UjFBADV6FIXnnrJhdNmCNfW5T/zrvoZ3Lhb+GVAapC7k5VSK/XVv16eSRxbpEKNA4tyr73cTcy94HH8trsEhgFl5eSX4f4Qd9w8+jJEEddM6A0pH8ejIrV/x7dZJNxnSyxhDHJLLyLTAAaP1yNKfvLOUgR0pMddVlW4ezh+dGHP/+ljJUFZwp+m+uC6Gh8sFJm0fI0IlaRWnIiE9VTtZADo8nA4G/B7atsacLMfr9GwsriggsO6yjbYtJ0Okg73S1D9d76W+eEjzn1hdq3IcsbX/jhArPQCwPOoJl3936QgDL5atfc4pN9kGu4oW3BfbIYQbjfEJv1AFF+nXi0WfihekUHq16rrJxLrpVMTLCv6Og3w6A4aJnr4Bh/m2bK0etycQcwtn632Yau7uipMcKjPsfSjNogknWtH7p4ldDnI9wRv2IVpfbnYWj0T/xhNYrfkpgjUL/kb+KCGjdprlFS9TTcye63m0b1FflrSks2zE8HYMPzuO3/vHKitPsgUfPzozN9dksK23fIRixkwXkb2uQx60KZ9x6iqez67dcxxGMNvSUN55AqNO35NbfhGJsTCisK5JtMbAZEq3F8qgQ7Qwgum8RuH84EKYhcZwkntot/s4UJyFrrCFVCyqv6/DKZJ3GmvCYxIVPkRjPVEbBc+LZ76vwCt38E8rRYx1FTXy4vf2WzgrUtKizJwtSXJ21BtQdEZ9Zo2cuQc/U7jlEd0qz/Vy/aTjmD0Qv3LtBopFCeigRI7Ago1YStNGvQAfOmsjOJb/rMS/P+8qWly9BgLjRGqAMJPBcG+FsBGRC1BYk3sy21tbdx52HioiSUnloUsKo6H0Iuf3HopMZoOfAP82fx8nYNz+XgKEr2zr0JxwBN5oCUlir9SfqEsXQSQgtmVoFkJoB/9L5OyiNV/ZoE8/illLy5m0cPc6hwJyBNxUgu6A5jSbvkHSEU2fuNq1p3pbN+THVg03c9OEQ2II3aCwHxJykJ1+nbXYfiBPUTpnDnZ5qyOQvx5uv6kB4qBbRL977JD2QRcROax9jhLgvzw0TQvg8r/2RqaGzku6Lr/iXD/gpOXW34EGDQqX1iSrEg+K+ocq4c84CFX6mo9ttqoajYvGFVqhITJlqa6oe0z2IwYD/QCjM66Yc4e9l+gVedm5Q35y1I9eR4JrIbH/TEYt6egH/yofX6WqaAqb5UHd3yNhSHgccByyFMwQhnUtf6KKoWLyI/23hNDUGcvao1y2inG9Z6gSgKj8ezmC28/oo5/MlWMr2E4/8X3P+8hO1zpgk6yvJMJTWVeDZN2Bnlem7hEUFeNoij1NWDAitV0ITdmgt6WjvwCUImyoqxt8J9YecYwcIFS+7qyanpqCKa8we6nweZo1xblYDh/QoxSRG3p1LBv5ex3wnkFjPFvHgcg/Eh/cnifoa1buSMCOq3BfOh0ZKiw7W3YR1tWz07TqJ7x4JiA6wD/VSZH06aVXN8iiTERex6Xxu41aPkwcuv5Z3WkF+hNS/jpFBsV2QJ6u+Wx0nyXebWqoCAUXtd1zra4pPaukTOsFh8RY/SAkd3HS7atyWCshvSVjfGsNZwZmJv0ouqSK40fq8jFzuy0K9j8OcPPmyo7zM5DILQvy3RZrI+vdCML7C7BJbEQBx2LC0qLnpp+BgRVDZETFTc9p+3ca2HmEocsdEAciK3Red32k6R7k8V/g14YhKo1/OuuJ8czf9GM6Fiody1hTgvvQcWQVMaCAklyqjMSmc2F/spQqd1mgaizTRazcyxtt6P8/AZgsgV5bZU6cvjnISGjkGolTVqT7xRM+A6z7YY/wDPEQOfavz4pRQCZRVepZro2FTBELZ/TYHCK9ptOIJzrd0qz1PodkZPs4ZjFOPKG4H8qId1eD6+wefevJyRddwTxYSGELPlWvyIZlnNCXR08aZx0JHT46HWFiTJz3eoRfKyFMXBFdeXNywcNkVurp1sPFTTh1y1PZN7V630vG3Vp4LgWZFGHco3kefYOIasY0NzyvSPMh6mt3M78t7Vj8Q75I+/fAS1whn2vAXc4Atrw69pDAx5DQkEj4IGRpta85glXhzU824GCqBfxmh2AD5d0LXB92Bfc+vuZnM9SMSng0Dvq/bPqwL8/3sq4KIq/7fc2OnuZdTIwmia0lrsi5HQrz7YuZpcVrEiHlCDP411Wt9m3p4PKNG0WJ+a/2TjiMVT1F+D6aLpQUsR9of6W1QpRDX0U6InjXrH3Ztfuq+ec413AASCCrKZtVRGJDIscdNNTsA7E2Kh67lcdtB5sMXqkxX95pTdigG1oBG/ar5TU/9th/ftVY7i3iGRye0aHzjSwoZ6pLAxuocbbpkW/M5q/66G98GJtyzhvDiSmUxnx9KuKxoWCpPszSdjD1i71iBnxuxUsaDSG+bisHI8k8SoJxwfeb908vdj36wIYd3jcjXnoUGOXhCfaQs20tc7+Z8ybbqyrcXF0ADbDzfkAy37Faq6ksKfr5gatLK+pzOS1awoHgiB6QA7D6yZthRCVPUwDtlJkEcERSdzTOstlENGppJLucqvbINCjdVixrUSSmG+l/R6IYInTzTX6NgYLyBqoq7kOWl/bSEx7Z2kxyR8OMDm6EK4bYGWVoC2/Khx7KKqFo0So6gIRzdwjvmrnuBEozj/iz39SFLOC2bhlsxgS2TPo94h5wpmidIwyedSmM1YjABcZwv4Gitq6NxaqkLt3oFg55zinwO63aj877fGcfIGTnmBT9wKnfG6gY9D01CsNly6QtkJOqbwBFUZUB0DW7sEsAkS5G6RVISutnwsxPAmSXeixtohIWNeSdLStZ5ZKWLe3xXbG/dxiS9XecqOftHqzase6a7U2CipxAWNJB2uUCeIzUf2peHOfU+sI9u9xujQJBXLpZRNYuv21L54qHRBTW94YXeEypqJdOM/Vkh3CyVu01H3OliFdSkhERRj+GNdsNr6uKYakBcOWUejoBeyu3JeWRoVXMdsbuinbK/HGFJ72OZBx4sgmimGGYzWmSHot8/hlxiBom5Cyi7wcKZFQl0UKrYtzNLkafs9L7YhhyQ1GUw/+I9lbZOy/EkToIGHQDuryX3qFA59R0fDdFsvMExS5sH4p1udn1ny3TBL23VTYHVGn1CueH+yjAS1YgY6+ss/sGI5SdfKZuVYxyiUgDhE02fF7gfz1Kk40IXTq2XP7qsKN/cE8hxAfjeQyT3sbL6/t+ESfgXT3GM8Tcjcs4qehjiIqwEOzk7u9re3KOXKCHIfzcj6EaXVrKSkoK3tZYTCO5jrvznRF9+YSUsHxCFdQrnsjj21ZMWMgB18MXu5Cxb2jI2TwAvCvxOkrhmanD6mHm0Y4ozYho8mQlvMwdsi8uk4r42wADn2tE2UIPAq2X5y8WC9dpiSynR7xY0464xEofhGedsjHxiG2uHvePIH2/NYdt7wbnDltRRNf1bA/Lhp7xZjrNgY24QOyNs3eQ2hpmyzI6/wkpeWFW20BtJUYm0GKLxq98p66At7fcOO5U5ZRh9wi3L93HPU+z4f0W1ihN+crpPYpfbSXucgWmSyfGu8N54/P57ZZV8SQeiazUc4scApx9KnUKT65aTJqUFkZN0laM1C+jnqA95wDO4g5jkiWbIpkJsZtdhCdcE+CjAAveAFcixorv2+SHezDDXuAOs4+EiUg3vn8UtjyhkJHGkoMgv/Z6zWVnTCdbz8YlG3ZgGl+ig+KJh1n19q6ZPOFBVR1wbExgSkT8EDRkLmJ2LFiWXH4NqxIjmN7vdpZwijHp9vEJwdn0U/mdouAMRJpGydF0PKFRgyotsRDbVakIBaoh4by5WLzBFhe+J7PR7gbWU7aesmS47/EsEzsNMiVWdjuuNz/UsX1DHu6FFkGYjOCrlislr700g1PHDzP8/pFv+Em18tSu6Vh4Csj4Le7kyII0ozzmrkMN6a/3yfuvEsGvVtF9pLGHW/bwqJa8wyrpEpLAoliIb9jCTrvbG6MesyfgFq30KuJCKSfgkoC4rj+BLYxr+lCl5NSr8ekpYyCCc6KVIq/tmbrQ3m8EbJOoSaqnks+xOVIoAX3R+UBiz+7uNoKvEvWLBc2Ux+hhCC6CMU9S7sco9t2cmgmPIYc1DM5j8yom+t3ieBA93V+1hlloUyElxs96cwv64mP/3hcIw7hODRHL2ZYJyy7MmsOPzcrrtDnRD9Z6b174MBwYfAzX6qfUAAkQD00GCmk+NjZ+Sa7iSj/up+DiKbJuFMjEssJOr+m0oQjMyiTkHpvi+1eYj4oDh+SKqg3QsIstQbKjpgtszGy4oFZBIU5j1fM5CcaDdnuhjuaXyX3NsknigV97/PuGryUxFFIx20p+3ID53tLJry6O7sZcYKGMTxm6vgam5yNaksucEoWvUaCqCchIkyKPLo3BonBRBfMh7zZvGMCH7zIUvY5lww0yicyXBc4fcA6hpUb/xm33UhnzWKe1jfnlcJfAesZPHI2eqNrXWHtH9B4N9eTVyrDRPtB9oJMibTOV8LcnvOLJwM/yzyfXH915ulHzp7G+POEhXlHtzDvRCN9XfFtzNmepSJxK83H6S+cy35vDbohS7q0pBDtn0BJvR+30i7DVbZiqTlZhEISpvu5JXRa8uD5p6I4PvDIW2pujLu5mpRb2ZuKoD2wWvAlkJh60XiyqE9V9fX/QbD6JyTo2+9mzCpF6teshMujhRjNJt+4T0dKki7xkA8Ab9MNiczb9LZNysuarBP/11bVsAiwWCHonRmNB2jo0X6EUd9HuiqQYwg6e8RWwlrGk4Z22t8AYSQBXryxRh02O61togV/uXHjseMJTaUJlhjmJOw4cYWDpdn1DyCxtAeh/s0UARg+aDgmORY+gdNW8lDAs0dyqFpX6cDFqXQCrLU7gmxy60K/nZbcf48obwFriPvbQt0nPyQHw3ea6CoeK2noWsI/2ExBu2sVorR0KkKRScG44zIzuLwcauXEMPEVl9K+oNcPk7biRCO0AD97XYmOVc2DiZrH1dUTJ+YSQuNWRrNyhN/IaFODU+KdAV529My5K1hKHjpDscj3GznVdbvnwdouvQdgryRIpgnbsZqybNx0JJy3shf48boWHQj6cUcDCrqmObv2kEbFJqm8kCxpuUiGzlJpQP0LAUFBvxCbPEczlCM20t/wCoRpk5ozmFuv8QmY0WFuUEkPIJJP9o8+KNtpbwSqmh5NNTiKhuzvY5rbF0Z87g/xyewaN6XtvI1A7jGGxLtuOyHb3cREFnNrmGJ9vC9TYkYotrgxjg6QXc9USHcik8x4JljI0n2w28XY80fPehMMcM7dld+UFtaQmiuqUB5L8N8On3pz2GTIlqWxmPL+JqQ9rVESa7YT/6yl7aBk3MWwT7JblSaqepm7oHBYmLHFsotv1TG/x7qxPcrdZ7Ao7hGgLOszF4WKhTFlILwnlnnqD1jrWT5zenEYvUMVyr5sb+opdEmlOpVHF0U8aQR/88fLx9C4guImYubKNfWnieDxYMNraGTpMg/vfYyrhrGPZak5DPVKTG6Cdid5kACVaToeOlCVFNC6JyIMAmpU8TKj42VwIxAbEb4VVY1MwmcIWCkzwb3J0y4KkkmecfaedtbX5bpfw3fKP1ZnfxnNEqcn9T5TG8HbSB8784gSVAd/Y/r/RyjAAmpA7GL1XuRK/02QPv11lbN9yDl3SHaI7hmu72jcqPeXEu0RxZ9otsIAqqJ5Wm8SULH5MZ2NHkF3LsGdujW2cIlZy1vG4GL530OjSJcaBVhvhzWGgs+qU/gA+POay5mIJEdtxsPSbvfIMg/yh05yfQgrCOHwoEjgUEqV2+cPiMD3eEV+Sih+eQwnCRBYZ9V2We7D58FL2TUfU/Mvn13K2VVGFyU0bIBlmBFVkZAv+9nSg52QTvP5F2euhMi0jVnQCMFrqiNTyOjqTFhrUhQM9g/FAQ4JiJzQMPJ24mdfEDbJV6VsATOqH4OFX3yPHIlYhYg/4MOBeYGUszN28DDkQrUCPHFOYtsYqxbMVQsrG9U2f5Q4QDdNVwIiveMqNOsPeDxADj7BUubCeKE10gepDim5CMyYC7T+mvRjXVVUpmiJcogf9DpyFXjNqp21j7nF5tp71Frm3rvRhSiCcqtPZUgPJDYSRlow1N7qN92W2iJD+yrrAqdfqx8vqCUFmUvbUo0YIk1kML1eNtal+B1q4bn+hZFGlPfV2+od91eOAoDVHihcO+sR/3FreIuKnCnoXgsBEQqURHjELvHM0VdRiZvHs9JfXFUlnZYvC0KXZ6+98Tjxt7VlZzlIShMHWsLkC1BUEkwBWSIn44vsGwGs5yNO58xhDkYHUDof+++hlfaB+sEGG2/9rQP870HhfE8i0QaLQM4slEOndD/sjFlotDRwvOffsHTqDjROD1fYvKttIGdfQVrU1K7BVdGLg/U7Nmelu+ucdYGMWTOJfm5hhXy4eFwcoCLCieRw0t7XCAqvsg/vY6SyhFehoEE3yYpCrTrn47FWG15y9d5P7fw7jLFbm4UbhNWw6EKxSkMU2K4g6v4C/nSsP2K2C7ZVSkDBPA+L7HwnqlP3k3oVS3VCd0tBtG90fRinxWqhR4MIebir4VIdftX7yrd7IzQHVMvYEqPBkzCxYrs/N8TEJKjzp0bH8oqouJf2yiQ0xnVZe96eR1yfJuKXG0hGoiHxOwIvdwU6OUpO80QBnaJ8nR/gGvA6LrHxmc/VAimnef5X66vu5LzjtetT0o6UBK37aJP5jUMJ81GlgEzRilJ40j9gidzohn9NiwfPp1TsuKXWUWjcEs2r9/i+heiKLalXuLR/Ei5H0H78nCHHHS9OAmIOGWuLY8w+xLSlVVegcnvFtZ0gAWrAehQGlBI7eGLOPdrl6cygo+2FgclFKO5G5z9AevXZEg61+pis1KoJzhFoIB1u7eoKqZ3zS6pgcThSc8yaYYbl+3U9sJpMkUay+8nd45hrRGpSyA8CwAFsyMeap7PzKD84lk/fxxALQsxkko6G0/UyiYOGfnqzkGmhE8PdInITJF4ISStFiMZgBE+/k2QHSsnHzzVoL5uJdU0ZEw+poQdnnPbZIrXsdu+pCnV9k3MWIFnSfrfZOGbmwtSOawmhHCh49f/uJuovDbyWmplgMA+xj5DPhzl/Ci8KVas7L12eRx4/qr+H73cnvnl1GSOazQCmJuESn2J+08XsCM7uyT92nvfSwv1v+Ai+MdvKDXKC6kfsr6uX7uEJrK9vmoY5Hi92OSMln3pYWquNJogNpXNFwt95eTKyad8cmEjLrcZkSeBbIAZY2LTXZAAuUxeZfAYlkKLKVQoJ4pHuzBwS34ndpMWAF9JjDbz/DxomgoZvaeGom41YcfF1jGqBqlRJ+c3bAHsN9kpzI1kNBo9+fZFZ90AUTHTUBanaxgbzdIqeYShh9Yo3fk1NDCyi45Gaw8qKewHXizAwzlg28YMXb54F3gt7YZ3VyhIzXX8rvZ+I8uW275jMz39cRZoSmNfmI2h307WUTurtvyV2Dqk7KncG+XxEWoX69MEC+sZYFUS4i5YMl73Z6L+zWVXkHg6RfSpsAW5pXNCNZz+WBNDdF8GbdfTYN0sOwdi7WbHGmBWo0JWKUHgs/e/96CNqQHknleddcbNJem3miDOzPWxKDWlT4dqah8EPIPBjN0L/IENA2vkzL2bojpUMC0qnkia6LNZxzami1hm7Q+UWWon2EYlYd0zmI9wAzWhpAA6ncgVsodx6jbMmSUmm/QM3LpL9roSut8/1lZXQx0i8NK/5gG1cxMH2EmeIWnrsiEGq7OVSWsUqTGIZDm/l8i7QK+RHndIzVdy7vZmKm+seK+7MXc9LNHUXXzReVjjoESaBCOPcAgXEcQ5IjX9nmb/UomDlXEGW4m4GDToTB9oh1hNiUpeX3jw1hNpzRz72J6kKQ+qkfPbcU6sBjHWb2VH5HkX4zHerm9X3THuHtZu3xHGjpHChJu4xZ4nel3jQ0cXdTYT+cAS+Vpr+g+neEITzTImdhBme8S4QvAQhJtMzTJExvxp1fqhy1UBgwJrN0ZNUCZKyGwTadF0caurAHDW8WA/sLlmAJBZGR28EEP8thcUuezU/vN9+ZWOVgN3CZ5HVEf9g/F47ZajcS6ee2rw2emNh5HAkMPa+TMT9xQU6c/6WC1jzEWgVaxUdnh3eUliT1piggPSJYVH0xQSur/43SKLNs6k6pHhI2iuMXSKLkGV1pGo1BXdNdLefSaaRWgG07t+fGjx8pnrlQA5gcsk4HIN4CmBenwi2ck/fL0doshZAuJEBcvAi/Oe222RmOTifhg0YbyZy0SM+LUIxhSvHeJB+Ouy28KgWg8yBEYHnTWiY/AlmGWAUHmOqs0e9MNfiavLc/WSSvtKlTVNsFau4sKBv34XJWFqcwcEY1v1LYltY6J6IkmLJD25tunD1vVZ4670TL7coDYc4GkvbBSFnKEu69gTaCv1+hXhyOkveIBsLvwYNj9uj/5lRLYyAL3qVD1rd+5QlYwl4I9bqrCYIDn7AxLBW9stNNZc5+WnOeXGQCEvTQYYEd3kEpdJuTSXJZZLEJbQgbu3c+w7sO8zo5uBKpoenhev0AmZ8j86yzekgakt4g7dgzd5K0L6eHdF1yXMk24sASFYECYq8r4B57gr4vHXSM93yxoWu6Ul7+P2N7woFpHy6dYVjDmsTYOT+odWBPclS6b5AlqMWPZppGKcpo/ClIzxx8kysH0+Vh7xXirbY+A2s8T9jXid4QVAoL+sohltPxUQfYqsuOS5yZSfdaAH4qdHoQw954ZV5wK9tCcZKGiL9D6J/3XRC9WybKRe+WIBUfAI5DXjZEp4OjJXUzzGXbY6HiX0jXJUqP2fusG6OkXTXADqBil8xiH/1Z8DD6ZtKdbeYouS9QTTfgMXWPaaCKYF4UoaO40eEhbtxb0253a+ZC99/+UqrPfGLyjzdKXMTjACVDqtp10TvZNZl0ys1fEnO6NFqi8cq06IdD7jvotq3MCUOZxHldNNe0LS8fuMGb9tzEi97cwH6r+o57iSeJp0W9RunXqoobtoZoeplc1owUwoQXxnzgsEM1oycNeryvK7YrawUAbJCmhu4M88/Oxe4VSveoaEGQIgyj59OnRioN5hNNWKcFXWnXQH10zopVZn8rwckKTu8fsyNAxsI6ylriAEVQ++KSde8cMbETF38EXfGlKQJ1VDI7ePaeBWLPJcZeHD7UWQm1ZZz7QSNUsafIA9ZnAvaCXXQCeyjci6LAnMu0ba9sDoj8p+ra+m8htA1rPplwDKvZGbH5NjrWEvRJeve5jjkijpOX8Py2jq09xoKvOlC5faGlIHGUMErSBMQWEM0wKGNl4TFtmscRRlm2fEdBTQ6Z4yMZbGOIeXSTArRByIkpXfUK3fR5tucxCf0PLTV8mfYpW4LGBYFQg3WGobYLTxYcOcwO4vPulOSEHvgeG5U8W93z74J6BatKwx8TI81kfJoLEfJMXimuY+3g0POQB1WDqBmFP6+jxe+6nIbCej4AsHXb8PfbKGwJqjz/YHIJhbp8Y8M7v2+Km2L9hmHit9P3IH9htUeqjlV6RNKdOJu95wzGM7M0NeJXFUNFJqN3bXaZIkqzN/mVICyXmu5cHOG7//uG0lh5+ScLU65l6HfReCcZay8rpmxRqQ4/CT24xp+JkiEDwjflXyakYcok/ozyCUTdpF7EaWVPMhYQow48usWo3hn6rJUbmOzrY9fLoaJLEgt2j7m77C1R9YPp+o+tjG53Mi832IX5Z770hsn6+P5huWwPdqcCWiSaOUA7DjgwFze8Enz874sOrY678Ip4kBt5BGxOuiPZf7UKZTljcTko3Z9IlWur609mDkprOk1p7B/pZxnNVxvNJg7Ow3MPt1CAjgiZyikPMIB7rFqznJFbzFG0/8ulThxd9khD8UfkumzSneJFF7gArCHV/mIdftbvPV+tTgyg14H3kmGw3iOuSScI543WZYjLLnbWw47w/qUQNm3S0lozpzB+/pjFCZObNcNuUmE5ApphEcxWDNoHYh967qzRv1KTZ0Vpf6uZm0QHJ/aHLILJpjEpCp3hHQHenugpr1vrfRqeRh/XWK7gle7yVekd1zmoIXCaLKZlX9R8JwNRwHHTSxh4T8oZDdkR7L+W+cHeq2UBWNwsTp29owCJcpNH3OvKa7pSTD//9TNGA3L42V2qftOgLuPjf+Ash0Mtuq/vfnkm4v/+iqeSwd1BZUtERkDVvKnMixzSVWI+EbMrm7EWQBrCM9du5AOBLyXNMavVmtdbXRQdmRsbmIFrCIqKd2nGU72fZoE2ZO2qD/Yxh7wtWbfVHz8MisY84PJVwQoxQgkjRXZNPgDInbsX2PGemiLuVWaBtvpEhgyQ7TQ6R2KVR1mAFEgmfhLXYLouGmpvd5nkL+thpiF8StjEyAJaGkFRay5QfU7EjrSmmrTrbPlBg3ZPtkWmPOtVo0dM7Gj/kgIevMy633D4/183z8WzH8cOo1iUCilfChYCnRurpy7utWvF2QX3lqen6sJjygW5xzMESVeaXJACHKnAD0iTBKX2e0Qh7XqF8pQb26zTPlkKYExGerkXBJllqKM+wxiJYO9tm2Lzpwn40f8V2IvRv+B2M3Xm2cYk7kfimacnLwQ+6g0tG4b5K71ZWrRcusqi6L4gLtknUgqO0c4PHDq1xmoENXPulhFJPUEgHWrbK5iHVqVq6aNBjJHyPIWy3n9hLpE9YEcji0qR7R6iCGWCDg5SYUKdrusW4OOMTypfBnjS/CmZ55KzlX+3Z44bc/c2SSLEtzrjj8mHzV2y0p+YSYFi21wPuPl80C/5nAERrX0K4s93TQnBoOg8weUaU0ifR8bFRbAtRwJq2qChx0r0L8XdBFzZro3ZmoVqs7Wx7SxGRQZLU8ah9O4N/TPBQjDmUIKIJ6wyCs4M8CSexJt9h5hiJN2i3qq/pCL3D2xrGebcva93EAn4unIfKj2Jw11W9O1up3/6ytxuafs0arCI1b60/kp8AgxJimV+6stcq99sLV9+DZGkxJhU0EvTQLrOpYir23H84U2L84QOMSOPgwdQrMxr8CjvTJBGZqeaktNGFnfF2sg7tUmMB/+YM4xAC0uYCCezHujeNlRfZitg9ybAMbPTtWBfLjXfRBVy9Bv+r+g7YdYnbdXYxy5HnzhLOpkzN4x/95nb+AB5gAAp8lHfk6IDy/MpVPBVTRKQPmLqbDWRDHA8JPm6MYbrTMDZblNWsHdnJKS++GF9aA/IpBAV/Ga85Zuyz9soYhDNd5n0dpacazyDfTRU2WSWBJT9py7mb5axw5KkoPdJqT4rW3Z6JU6NtXB9ypz8DEAAoX2cxii2mwyqffo+svVrSRPTFztUXb25FpCh4oWBxcxokQ7U8xqaHDMh5kcDtJom5Bg8SKCnySYVJBFh+XmD+cBqbmZtIci5ljRpVfNc2Gl6+UAvQNXvXyL6jHZ4tH6VD+PYziQZFx7003NcBVqW6oaAwL2Epz9f2cAGUwJMVeFH6/It4euL26cS1Cksd/0YIreLDXdlJsB3Ldlibza5Ve7BTFTHG4jqS8A3WK1kEyRA+fR7xgOJh8AyEtLu1loLTYR8xzZfOMD6882pN7bkLcTuYBVOkVOh68xp84VyC0nGaY2JpQiIPqlQwW6ixj/zDzWz7deE+Mvl5hSynoR1vLnX2caGt+0HFmEqnKOeioQ5aaV23qekQQlwxX1P8NHga9bcbEnlynat/FnBcKt3+T1dTXAQZhbTR0art9dxCJfIuQtByYT9gnj0wkhMJkwMe51F6gIFB4SMHY2O4FJ/SLiaoMyogN8ntwokQu1IfW89NnQaojBIU0SuNi0OICL60tJR62ZP+nd4ShVsbyykp26ivV2BGHBhe7OSmIzKJcxsxCZcQUsX0UUReMGCsanznCVkC0iXzyq90KbtA59MQravRbeiElJBkeIJsDVfswlc7BZtaeMCnHd2Y8j/AUaSiKeO8a2KJ+SYEnWVT7Ss15WA5oqt6+L7eSBX58avc306bEdK+fS+NbK2IxDhIEBf3fCikceQIVZ5c43MWB6aWveRcrYyvg5twNPD1bX3C4kdI3DWoxaOxoVei2IStSdDjruVi/0tISn3pzu8nztT/niy7GI1DO6F6V0xORFWLPXPTVPdTB0oY3bz5NLueVxgP9dbnwpf6IoM5bHJBcX8Kk+49vmxHf8BjHGQstHgwnf7T34jAx6vRz9oaBVNncx/fhL/LM35L2eeppPiyDiPbvW3xYulR0Wo50e9B5qtjuJVf4j+/VHLT89kqXT8yxJ/7bGaV2hQa2w0M99jld+Kha2ASQ6e6Z3NSIio4O0NykdQpLlYGYio0pVeh0Bberv9YynCFuQwRKHwT6Wln3AZ0PzrA4U+HhC3HluMOcb2YlCOMyHsrSpWY/9dS3QGsIqigCr0F2ZBvRhwVF8l9Yrk5AqmpaOCeBMAtSFUVJEOn7Ax760f5o9PL55C0PPZUyDaZdhmu9Jzx6IExOn8BpW/TTgm9UUlKmohnNcOA3tgODi/TvD6Ncx0h1ZI/SAdjtfbzmRwE2eD4XmsfcvV1861V0T8MEjlp+vrhSjteIgo2X36c/Vsbar0/QoSljTZWOmAQFgGynURGQNrPn3TbyYZAG3zVDKkHOankbFYSXZ1dFDKhgFl6Qy6Ah4sGz2c+lqoykGjwsLv8c2CzU9FaGsl79e1wYrksCR2WznhTrir46vpSWbNynjhYc+3QAMLYGDonZi/FYH7okbCjQtp42DrmDk00F/VwoM66ClS38DGtReTVe9+o6AgKkGgG9pyX+M890Vc55A3jHoL96Eu5aEctQyL63XGb0GYHwJYha9vtgnYE1AL8xle4PIZ9vnrxeJ6T/UbJQDrzbAsnWtJ5eR57wSdFY6dpp9WUvKFyrklA/gVvHrgmiSTO3FHXo6SwqdWcIS3hQxQw2jVdD8JkK4XtS18Emqx6bjuOncL6M13TirGzcKHlMXVtKHZn0ouuhfGQ9YgehH3HAFXMR2yN9RcBNzfFxsp3FQTrORMqL3xe9I1+KgaHcxKNN9S+9CHsmFsorauLw5Ew5NPJPlfWjVGmgDNteSut+IuATgfMxiER16vyYhDNt4PaKI3Ef3GrbZ4POEOUbjm91ATzOjxP+AxUehYgGDlG9hNSk3a0gMOqQiZn8OWhFmVaIP57kXth3B6GJS8xIV26CwZ/LqfGPrcHQSVDzDKHqwGjXdiL+U/QofY8WzwZXhbBQ/HvBPT1zsWGXe0JpYIzjvP7TH8zVDdqSTLm8VSb68JTEfdrtv2OWD5c+NSuWHQ0YYVx+PE0k3UZBB4F2Jh3U2/eekwawnUFjkzDmDFBAtM69dtdcdt+NZSxCZZIrp8rqgu3q/U+kQzt66ZaljjyNOSlslxtJVF8sw/DUqKssWdDVqmqDM+H1jx1Lh6yPiPxiLvFmT9MmNMrm8t+0oz3OIT2Pisjw4nHxZ8SWJppSTriYubwGN+gCG0f2Ga1zDnhbBWslgPQJg61NxqQHWpHaE7iLUG0kwhNMzpgOWKhOANB4su9R4Zihq9distuKC9MTD6GCHdv0ew24pf5IueJNj7zD1jdAxNVLzgR1+59mrPkEerKqu9lgXuMF11nTNp8MDGO3JednTApEjojPtgqJpjMmIIiYVJkYjr0B5f2xUIu4hB3Fyro8DDq/uyqz1nzzMow0GORpGMFvWxG+nCz0gdbW25Dvfg4NJ+J1AvJuh4gRw7EgdZvPu+XPl06k8TZzUQSzx0NkaJO+1FXfQO7rZDUX/SIKLdN3DTwgYmVarTGqqj5Dz3MpivCMxVV0N/1614xvAp5xNOrOhM8P/ZWAV7mR17QxplWTagPdI7QQa5l+aHq8KdZLtIGwve8q5vCCAi2zrydhiDUgU0Zba7hi87OfBC41ajWLA079z1+nPUz5sSfnoNJQdtQ5Hp5s0v2Z79T14zK1XkMxy7prQEYY8+g+7eq/AcPQ5Z3ehE2i7Jb7jzlHwY7kJdKJy4Ww7Fu4XV5lR94bJLGMYY/c32Xq2xNj6+KGA1OENgvQzYsjK8ZMgSIzS6uKhuFcCk6iV31/X+CFwELDEazBey7nH8x+nnQJ89e0xEwzCgswq1N7xX/ZvyvXj3Kdz+EdPf5MlCA03I4gkkG7IiKk1mGwuslTzppU4bHA8MCoJBLpv5sONa5F7G62FsZPpJnMpu3xyCSCxVC89v8i5OyM3TgSIwDTPzBL0lnbDT7Jxn12CW7UyDzbEcqzvKvb+8Tz7w0pZE9Oar+4vwD8J8HIfcqTg+UrtYuap9TGJt50aY0L9jR4qtDr1IqNpRpgGG4zowyHbKpy8EWVNBl5ryFHsZI2+OTAcrwnu0PsvE25iXxeUR7niy18CgVhXTuQJzC/Pz8RhLf0VClDPLJA4VKJyiNhK0N5BKxkewYcg38NpqWhgqfKmUiY2oAa63zoD2RxIA7yC1ppfCXwY5wa3TlXJ02HoGGgY4aIKPgyrjLHzVC5SB/MsonBNofoIC1luLuuHbv8c3H6OhMPMGmi0h9rbunEkAcfqxceQfEM+trrQMeJL0GTX9JRb/h1ABLsdBusPhFCPQdO150UhF/b8LeQFNhxpduA4CvRD3ZMBwhUhqLSR+meKmhqszZ1bkzY9vToQKqdaKN10jDWhaZWA9FfDsdQsc1HgSSN/Q0L/VyXiGzTec43+PiF12RdI2RDn0a5XXVogIHu2SwDsaVVKMohIi4mZ9JoUCezHzWHhbbh60IvpndimsL5L3mc5lX9T+tbLvab9TXnYPoRlq/i+S5Tq5cKU2jwUWTE6EnqbAyHRrgWpPyuT2NwQLEgt2PkWtpCG31MjUQAAtLIBT4xQ6Nb7wNuoKpt5G/unq9koVS6YVXD06kM/nCf7GvrgEy91qW47lqJ0RPOzCwY1sLMy6QmQUU/qo5jZxS3ktprnJ5TNeKdaZN8KmIJa38g+9C2dIAiw2gQJMg6pYubnbKGuvL3Bb4eLXtE6UT701PzgXYwHziptpbEIqH43GkHfShKgpZ0VYtwdlCME/dI9IByO+MwO13wSk7xS80kIXOYsRszg4sdoRs4PBQzmRNu5dRONiwIemTAZMNX1aMSt6s9bLat/dZH/qBaK7HA7q2kykbFMahdx2XCyarbjP/bohd/hVUpQNoXTWsJ03qIrZe0tatfp4KdS0+fIfQHF9prSEdW8EJV3/HciAatcJguz8ri78zAMlgJwzzZERAYiLE9VnjPK24AjXYXRA9owjMzWCl6FLKI9bpfdBoYiKfWtQ3Oq/3D1bpJWGWmG4wjYgBXSMW3qjlQYSZ7mxjygEyGLQ3zxhsJGnMWf2VRon2HKCJ9/1b2QKpwLegad8M0sP46M6rhdkHsvILd7GyxsCwmu8ynBGxPBTBCksY8w96K1dKfWk4jS4ZBVr/tFaLbF4tAUAj8136q1ETg8/E7nK0WGRaY9WZm5Sp0BpJiuqTYobzXH+g86YpGyVmlI7LyCKOp8PirXJTHnNXnITT2OKVsCwCFpFqyKpX1BLQjsHO+tHnyuPI90el6e6VgGx6lAhk/QSVBdUb65GhFl/n6XRdosBy6dFPMHLB+YSAwkzdoQ3ym5QcZk0BcAO4rOjGC2iv7PL7uapUNCrRxPoH6UTYsLEnlJBTjEzBf0kRMhr4H6cZ1B+c/rXqOWuC/Z8KdDMtpihWKMWI5bKKG4ZLyhcCw9N6+uf3OAyzwOWD3YK+S7EPdqXS5j6q+8IGDklnAKC+WZPJOSA7v/UchdmVbJZojLVuUcxUhnI2GtZ772GqIbCSC8RQRMVbzKYuUjNDgVk3AEk7FGhpOwzuCvsXxHna3RJT80vfijjKfG8KgaKoASQrKe/4ir3JLRzLz0tmhvA+06jbqAzYRVEwpoCI5/+MCXFt/LZJa3XO3fFXYsvPqkwLcXwPfJRNgR42ZiRm8WsfF9VCssSg+FcDSR2PYTyXQDensloFVjx/AVjCiPlLmqIfhNu1pV7SM4eKl9eoz9t/JhH/NaSEajZMibLyYHIuphO2PrMPK07S0TKAffUegVAqUv4xMxTjVKBcCGra7h4FIxWRJAJW6Acc/ZQN2ztk5vx+qr/TceyZdDHrCMQjqJssRdZjDeafiOwcK1/hGwNKtQfHEyHw8m6Mpn2hDV/KtGiX8qVBoqVBiJThILOTyZhvDmuaztMPLCq2gKGY0q+rIHVWEAQcuxx1PRHrq/FwVNjk4s+B5kIXLVrj8p+vSln9zeijNS3gDIbV3NfjKqswBUlMiWK24oC3V/wLEBd9/cTPtOu1y6OQRIcpcDr4elB9XiI2VeMYcU5WJUWcEbTkOnG5VuvrCo5u9Ez3d81rK9HcxoESYKm0EQACVH8kt2PgmLI3Yy/W9eynT60g37SR+DG8kV82NmjuEqD+lXmWRRHDTIuqRTrD0MPDcdtlwIqsSglZhDRZd1n2GdU42LaTtvu+j9KUpiJ8x1ewoJ3d5u36V6NhMmHsvQtBVdmiV/xY8cdgyhguwrJOTrUham7PFwqEq4tbeDMogaZ0NTLL5GMl+cFvh+uuMmcLzkMC/L3HfEZRBMzae0X0mJ95Col9WfFXfO080uKA/elrV53+BgX4ZtuPt2MX0eWn45KfIHPTCnpdwnA1ay7vtqru/n1mDW3U15gUp+NKuLwMMrqcf2ppFoEgWxPgxkjA+Q1R5/CVMtMhKqJiWCX7iFc6wyIwpFFELcEs/7s99y8o77MMB2/Nb+jHCRpIkpmZDV8Pm5Eb+0Q5qtVW3rDxXHx7rFibWydjQOqEz143SxG0pYWXwe0iAsx9OU9A5c8ehP/BqdT7d8twZM864x/3FPtzABM98AOsh0vCPNMKMmABx8lk8+zFCdaDvgtRhsDzooczA45hAyR4Phcjc8A3LwUL9CLj1XJYwNAljyigV17B5wr4xL7MtAuHZUVJQ0dVqPifvuJ+vhvoNk/iTdiVv753yhf7Cw9TKxExgjdJouh0wuhFIItrfVFvd7/oS5lD1BsW8qX7nXTsx5TU4iWot9/8WF8BdELm413pRMqqt8hYdyuGyHxHBbmIwntyT9aujf4cck4nmNmdmqphsIz2u5qLIiicPCGdCYp1KW0dAEzWUs36LLolqFx0OnMhjnqcFZZGi7343KQi1ClWMQ/9JoUiJALy2jHpx31eY9iJRSmPYfVRxqF/elTjzBVPCVOwz1Ne5lrEUE0ta7BdE6k/MDOTBW47ADl2RviOw3fCleyCzyr1X5otRsYdJ6CQSWgE4FX82F4ZUzKAfHlsZ9D6PX00qPuGvcoToNpA/kl47rtKfj5RPCLIWohkJqsg5ApSUFpIpnp6Jhkk1q0ZqJNHrr/hRwmK2SRFS2SqigtAqqLxJCB7IkdTchN3vm7v0YGZnkpM1D8dztwDXbUEPlSOEJAYGvtTxopbR3rOvwQctDbneOh4LYG7o6lXIfGfZ8UjzK+EhDMuIGTjsTQCvhvf3onvnmEGDX6otPA4d+baqMI58DUn47+dSEkVT/VVLSfzHStNeANPxDPd75J8efCAAxx6IxcntGqRaW/NX2XZDfz4I+r5zITSKzE1ohaYqqccvLa8KPK34LwUEoejhUhLmRomw9YkgDTl7d07hd1GHmawubVzdbYmDfFOUAL28KBUuWlWsNp7ldBRGJPuNeKk6lJSANURwTZFPX2aJNJ8k7Gtc2jP5arZ9gmcsr3Py7zvGkLg6aHIwsRQyy+Ntobe/z9Ss3iUJpGQ5jQoYubuHM4/1ZRlHR/XOTKOM7QS3i19fKgg1B6oLNy9Lclwic4WvdUkISl3N6WYxeH6pcNIWuNHfzh5sYxN3Q/W14/yE57H1JL+OPt6mmG7Ziv9DkIL5qsdaVJV8EP6+Mnz5wvt+2rFBiRuAq0E7ZN+wYd33cJ1BreONLYRkXxRhfF2R/WDRr0f9qSjwvC/vMUCoZbER0qv/hVFYyia3+ycGT8nOc1sUiRPonKOO4KhOabfmmNf4JUBwbNdxBS2rWiN060Wgv+oJ/UI8vcV75tkAxuUJtYM00NALSMwYhgCjt9J389ZNd4ojUIsIgI1YpUJBI4Hqq1MB1F491vxvHE4JD2pXu17AepbzAGVozrOVDglUoMmwqoDcuwOU4Qxkk1dYIVMSuWbth2/N20GMSondzbHDCKaKDeoO6Hk2lw1XlBiwJU7g7fM3K4Z07MdfpxmT64/xfM6MQ+n3VA5qG18MKTm7dKWFoyRytnkuV5RLb6vJsi4BuUlpGuHcluNpc+oH15zBmK6GhWu8EFdfao2pElEbvN7i0JttNZ+Eo2OlftpWiMuTP15fuvJG088v/xq6nG3mOREUwm7hnKJe0pSERgrB4/cHgQWVO+p8LbDlfjozDhp907/nbUZrFIDpbay8ITafQkvcekYxMF5pLEOmHqcmtJ6Rmm+io/WmwP/QCqnB4RkRObTY8Y838s1fhIF+d4DXD+aanq9z4atu6x6rsRjJLsiAs0LEpmlenJMbq1wNO4SnerXTgtEa4vKXXX1dSwav0ig/ul6j0z7KYt7whiX0jfdNvk7+tFHF0bqsKq235/Kw9/u8vC6zcpwU6QVjBtGUlkG3UFRvQbS8zeOfJME2R8W/xVBxaFK6pAW8LNOK9xk4BhFknxHfNMAjgkBQ/260jh60hl+Fx88dR23WnmVaJXenzNJHnkKxygRU5WERatcVRAHKJFCLfiZP9Acrh9CCPGIier1IqKiah/ZQ9933xPbtPIMwSZDTzDqZSiasCwudtngGoOxQPdreknqi6/IhO9swrc7Q8COevqMZGrNDLSgHaljD8s3RlXC2XEA5O2/SDncm4JxQK23PpjiEdB6d2jkie8BKpdbXHzSoJ+wALFiADthWvk1Fl8rVigf/CANM339KKZeUGi5oeHgLwqZGk7YO5dh2y3yVUalRj5xAQEOQun8+ffONkAF04KRmPVIYqszQ0jGDV5b/cu3a2jqbl4c+IfVm+7okKxXbulnEmc+Fn/+m/3YKs4oL/J6yuUr6uBl1S/PTVWmxISwvYQSD1tRWaxGdDZTwp5K/E+z03AFG8mzAU6NMkvq3GMXGzblxC/K6Uz0Cr1cP7Ev3bHWVVRdrND4On7PFsxuSsDSJMB6RZ2fsQPt/Q83lkCMZLVm02Aw9EdJMHO60LBNSdzMlR9jqVNytT2W9+nPil6zmN/mJFt39OUF5dRzlo8lZ8moZ5RkJmZJrj2q76TP/XZ7vcHeiXGQXJku6+nv4PFsGDYRN8rFVRbBBF/BvTvUCU38DhqlAYXkYcaiivPRA/MZqYnfbR9dCK2p3Q/NeBVKyaO/CZw1WY9+IlwHAKxOw7F4ZTHA9rb8geVxcFMC3W9pb/BBcy1q7RdAWaJc1A5tPWRjcv2UP2tAJKCxXM+p9j69JLa9b9nZSbxuSWyp0x+o5POK88QEZLoDU+hnv0kGCKB9wZ+KFdi4d/1tFhIui90ksfbJxBD/nkCI3NT+zoUWBs6LoS40IifWcmtCl9yVc3l196byA1G9Lq6vVtxvdCmcg0CAc8QDrvjoKGKmyGSGgJeA6NFimdxCMmPvrFIF7JuF+rIdfdFzUxioJaiEXJqL5p9OKj7bG/a0oVF7QrUXZt7PRgvq67cdwIBhIxmqV3/0N4Jc978rESbDqemV42Zw3S0p8VelATU5hv2SJoH6URPuQUTYgYBVXC2V3iHnSdFD0FnUtd1otp0HIF5hnIzq6urHpmQKpjFGDR/SAJisglSPmZHdrj8k2QO/QCEMi5jSMR7e8jBj/p3P1OViaM/XOvsj1zBr1PmfG3NXBs/YCxi9pU0swbaORfoEkYct3ArfYBoQCe/ptO5iYKN0QzDBCLCoa35BkX8N43o5qbtZcpTxm2VFpXTPZ26orvstpDs0Oro6RE+3ftSZyXjkm/6C/wgQmMx7YE2K+FmNSZd0gcjFtGaB9BNtH2OFzSK3zNcCjrk0QA05g765SXkGlZ5jBRhGiCyPY9m+bdmWIquH8gkqye/KDNoZcG9OvDC8RcH+7wHuCL7EGrgnAJFSTRkLjEpfW9HX1raU/bxaAwZ3HDvEUflrPBCGaiHJ9LbgzqPK7h9AJ6QX4XlS3995U8xRDqz9/CTB1VDP0g1SL6npnnlqfkB7YvHCTPm8QbRH7D51xHxkJCnD3uWDtmz0S3TFIkWkD2zlhgcsMclJpd+/aniP1sz9xZ26uR7tf9+YAIIBDpIEl9DD0iR9Fv77RZmzOp9yUBDwx8AtaZyNrwUj05mCeQi5jssaTT2GX6nws5gA1pBco4m1tAbG0RA17ecXJsXyzEbYaO5PulGc0UGqs4gj8gbThJc5/Z16cLxpmxHqr+z+SEBKIcWmk1QgkwdSGz8UY45YQCv/Y0pmg2I6HSAUaCZAaSzv48UlpzZGOxETbteWWvXvKzZFBogyQGGIUnFj3I0slHBIHTB3RBnngQ8o09oPBhJH7yjlgKaGeldwB+AG9FN6kYd4omVnB1giju1BxZ72Aopo0r3LkIwFv38SC7bUhT1QB7zWRJa/6VeO1a83eznpym/BZJQL88J4mx40jSfd95pprfy5cTyh0OWBu8Ais6fJodGptIILXrde43gSuUiuCdWT7YhIytJ2UPAqNDosrFwyS8SY9vuKGzPmgKLWUXxEHmDRn2MBiHqGqm4bW+53AfAoLbQ1eDZhGbFOQDIuMfFUEM/GlEmvQF/rH0UWwnstksFpjWsbivw56VajuvAUPwOhDY+Wwt6kn/p1+KJTqbRdyxrXom0Rr7AVSgcho2OEecudzs/fn3NyGYv2+hlttkbyAj9N82zk7CELoDCkRbD6wCUOtpwBaBA7sme5c62VFqRq+ysOSNDceInDSSjW/ZhrQSNRbfYQXyGYyYocf6W00huUxPOorIekIN5Uqwuii6PWe050dCECvT8KoghQrTA57gVVh8l/Sb5ju3dlDdCMkNlEF4x+fD+Vuy/27pBWxQeW58+VDIIqPWhduQyB6Kj/49k8wX4M54Uql96hcWBmPPQF4rs+EQJZGy047xvsjMHXiFkh5+ie76Xbnne/C7zNfhgiQ5i68BL/pEWhSvYEYnNKD2ys1L5bski2YGDM9se8grN0h1NAU3JYekOKEuHtLw7vFl6W0C92KpMMetLPCsfeEEnIwirD7hIUecx45ltKydVS8P5lZGoJ7qHFKmuZjxvBb8Z5ds29Pvd+crA4BIiW3ndV6mXPlyWTjfR1VLCOVXGhDhptqxwud5olx/6PmitE//LIjSPJV0AfABkOVIELjb5drtPL5IiUq3vo1izNvMFFjucWvJirKFwpbhBziXwHC7xGqG/f8oB9KWlGegAuagggakJc20ijJT+RopJNDFa8necb0gTz6yv0wLEDreV+cvvBWinJV2eyynnit2RAG1WVNmDKRChuIM5o5vHuQd8j9qF+/xwKYyOEi905Gx43+p1V42P68ItmSmsuACpNcqHaugxRsq4/b8vxfZ9pBglEPCYmlbxcQ0UeO4OsFzZtWEh1mLXLcyYVM/20dn5q3a4MqeLgV99XN38EQmNn1GG9cG4vwF5//Reyt8dXb3qfXSq9YFDCYbexb/FosWCCLSLw2/UI+kFj3vhVJLnnzae7z+W9EbZQpXLdgdZp6cv/+4vLutTHSZtfm4+I2kdAHvUSn2kJeQomeQVxBK/PSr2IHVhL1ib+lucd6udvKvv232vb/yvlVqVcVtUgtiZsiXfrFIP3QL4jA8PBXa+7nlbIkp8y8ipWASBtEysJb9b2/BhM/zV3XVra4TDvFE6nLb5O8exRLw+slIBYibvC1kOSzHfFUqGXnn80iY7zok5bzrlp+A2hj3H6WB8k0Fc+7aT0wNPWxtfXx11nWuwwYSzaHULbFyKSsVrAekxD573KQsj8koEi39XzdLo34kOeRnNJV3Z0EQY9JCI1AKCKppBtu2ykYxnLWIQgsxXt/VOAzYvyl16RjBW9fP5pm9mHhsZUk5KEUzKNDHdo2I4nE5i52Y88J4BI33fc+Kmz//7xb8KW2Pqs5OCtDxGJ0+Ny+d4FJrmeXLE+aQS9eD4C8ez7uv5uukAOXeXfemH3Tbh4FX0A+K2NEFL/PK7yQp2j8FKvY2GE/5xd41pHMmyna/rs9ssJ5N2W+ySBsp4w2kBpMLPYalaOxwlWpHDq+p6di6vwg9A6jM2ER8q5LcSa7oLhWa3I3SfRLiReErCmXu4XvivbxH7CAfcIpfhhZAUkMVLXLzAVX3kiwcwyl2G+PNsKhZXYaHBE3OynMpyPTzWKA9B2cFBJpYJ0AZnvxVuIQr9xaTZQXiNT7kE9vPKHcB/1blZBsM/l1FzhfZ34JRDudES4yA2/B/HtZs1S6IKFBqZqTSjpYR5MOUMTdYZM5ydz5hhv+DU1fo4M5xeK/Kc++jBBvwefnsyep/P+JnLnINoy0opzT5dyeAHQAageEy019rIUbl4hHYWiGACFz51jv0MMm8lOwC/bDG/YrRIXO9IqAHeICKfawetNm7/ynX5EkssSjF5qqaYT8No4/fhgGiIhJhzlhx7tKv1XlTm7opaTHv963rZ/XTrq8oa8K1K2+Ei8jPDWXfS/nYetf5H1P61Eo2E6yBO8D+7ybe69/pMO72NrRqob4wj2fY6J+PDroo09UzE3wqkDgPMuDJiMLLP6QHbKn0HV5SbJy1p54hfePUzqe4Xs9l9wUpL+Rl5tI+V0BxXCFMqD9wDrgji6jw+R+FWOT/Uh0WLCWEfnkw+bSM2am5rhbQ0WaE2jwKklUTzE3wgWX4r7l1/MedhVC30dWyup09My2FXuWtnUxSZyVE9pV//tZKbviJISsemnCE1CXpjZjNKxW2kW3LpmoX9j1e8rYhOuQ4zBF6c+Fsi0vxE3wL09RmRayMWl0Q9Zzr0ll+7+Lg/JVT9cXVYUAqhM=</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】竞赛图</title>
      <link href="2021/01/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%AB%9E%E8%B5%9B%E5%9B%BE/"/>
      <url>2021/01/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%AB%9E%E8%B5%9B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>竞赛图(tournament)：有 $\binom{n}{2}$ 条边的有向图</p><a id="more"></a><p>性质：</p><ol><li>竞赛图强连通缩点后的 DAG 是一条链</li><li>竞赛图的强连通块存在一条哈密顿回路</li><li>竞赛图存在一条哈密顿路径</li><li>竞赛图 $size &gt; 1$ 的强连通块中，大小为 $[3, size]$ 的简单环均存在</li><li>兰道定理（竞赛图判定定理）：定义一个竞赛图的比分序列是把竞赛图每个点的出度从小到大排列得到的序列。一个长度为 $n$ 的序列 $s_1 \leq s_2 \leq s_3 \leq … \leq s_n$ 是合法比分序列当且仅当 $\forall i \in [1, n], \sum\limits_{j = 1}^i s_j \geq \binom{i}{2}$，且在 $i = n$ 时取等号，<a href="https://blog.csdn.net/a_crazy_czy/article/details/73611366" target="_blank" rel="noopener">证明</a> <del>没看懂</del></li></ol><h3 id="世界是个动物园"><a href="#世界是个动物园" class="headerlink" title="世界是个动物园"></a><a href="https://uoj.ac/problem/451" target="_blank" rel="noopener">世界是个动物园</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">官方题解:</span><br><span class="line"></span><br><span class="line">由于这是竞赛图，不难证明联盟即强连通分量，并且缩完强连通分量之后必然是一条链，前往后连有向边。考虑加入点x之后会发生啥，大概就是找到这条链上第一个有从x出发的边的点和最后一个向x连边的点，把链上这一段删掉，把x插进去代替这一段。我们只要维护一个动态标号，然后把x放在这一段前一个元素里面那一段的后面就好了（记一下每一段的结尾）。</span><br><span class="line"></span><br><span class="line">如果你这个用替罪羊或者treap搞一个double出来，区间min max就只要线段树维护就好了。如果你像我一样蠢拿了个splay强行cmp，那么强行rmq复杂度也是对的（两个log在n上），然后你就MLE了（</span><br></pre></td></tr></table></figure><p>这个“前往后连”不太准确，缩完是一条链，我们要找区间编号最小的有来自 $x$ 的边的 scc $L$，和编号最大的有去 $x$ 的边的 scc $R$，$[L, R]$ 这一段所有 scc 被缩为一个 scc。替罪羊或者 treap 动态维护编号（其实不用真的删除，搞一个并查集，将 fa 指向 $x$，把 $x$ 插到 $L$ 的位置就好了），线段树查询区间 min、max。用 double 是为了方便创造键值。</p><p><a href="https://uoj.ac/submission/452323" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 竞赛图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ Long Round 1</title>
      <link href="2021/01/05/UOJ%20Long%20Round%201/"/>
      <url>2021/01/05/UOJ%20Long%20Round%201/</url>
      
        <content type="html"><![CDATA[<p>好难啊。。</p><h2 id="T1-多线程计算"><a href="#T1-多线程计算" class="headerlink" title="$T1. 多线程计算$"></a>$T1. 多线程计算$</h2><hr><p>首先要知道一个事情：$n$ 个 $[0, 1)$ 数中第 $k$ 小数期望为 $\frac{k}{n + 1}$。根据概率的基本知识，我们不考虑存在灯同时亮起的情况，那么 $n * m$ 个灯依次亮起，有 $k$ 个灯亮的期望时长为 $\frac{1}{nm + 1}$，所以现在我们要算 $k$ 个灯亮且节能的状态个数，最后乘上 $\frac{k!(nm - k)!}{(nm + 1)(nm)!}$.</p><p>每个 $(x, y)$ 独立，分别算贡献即可。现在考虑 $(x, y)$ 给 $k$ 的贡献，容斥计算：枚举全亮的行列为 $i$、$j$，贡献为 $\binom{n}{i} \binom{m}{j} \binom{i}{x} \binom{j}{y} (-1)^{i - x} (-1)^{j - y} \binom{nm - im - jn + ij}{k - im - jn + ij}$。</p><p>最后那个组合数不关键，给它拆走。剩下的看似是个二维 $FFT$，实际上完全更简单——把 $\binom{n}{i} \binom{i}{x} (-1)^{i - x}$ 计到某个数组 $h_{i, y}$ 里（枚举 $y$ 对第一维做卷积），再枚举第一维对第二维做卷积，累计到 $[im + jn - ij]$ 里即可。做 $n$ 遍长度为 $m$ 的卷积和 $m$ 遍长度为 $n$ 的卷积，$O(nmlognm)$.</p><p><a href="https://uoj.ac/submission/446428" target="_blank" rel="noopener">$Code$</a></p><p>upd on 2021.3.2:<br>学习了第一句话那个结论的证明。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>先考虑最大值的期望。枚举最大值 $x$，$\int_0^1 x \cdot x^{n - 1} dx = F(1) - F(0) = \frac{1}{n + 1} 1^{n + 1} - \frac{1}{n + 1} 0^{n + 1} = \frac{1}{n + 1}$，还要再乘 $n$ 表示哪个最大。</p><p>推广：枚举第 $k$ 小值 $x$，$\int_0^1 x \cdot x^{k - 1} \cdot (1 - x)^{n - k} dx$。考虑分部积分，即 $\int_a^b uv’ dx = uv|_a^b - \int_a^b vu’ dx$。</p><p>设 $u = (1 - x)^{n - k}$, $v’ = x^k$，则 $v = \frac{1}{k + 1} x^{k + 1}$，$uv$ 在 $0$ 和 $1$ 处都为 $0$ 所以 $uv = 0$，原柿 $= \frac{n - k}{k + 1} \int_0^1 x^{k + 1}(1 - x)^{n - k - 1} dx$</p><p>设 $a_i = \int_0^1 x^i(1 - x)^{n - k} dx$，则有 $a_i = \frac{n - i}{i + 1} a_{i + 1}$，边界 $a_n = \frac{1}{n + 1}$，可得通项公式 $a_i = \frac{i!(n - i)!}{(n + 1)!}$，乘上 $n \cdot \binom{n - 1}{k - 1}$ 表示选择方案，得 $\frac{k}{n + 1}$。</p><h4 id="其实就是-Beta-函数！"><a href="#其实就是-Beta-函数！" class="headerlink" title="其实就是 $\Beta$ 函数！"></a><em>其实就是 $\Beta$ 函数！</em></h4><p>$\Gamma$ 函数：</p><script type="math/tex; mode=display">\Gamma(x) = \int_0^{+\infty} t^{x - 1} e^{-t} dt</script><p>$\Beta$ 函数（定义域是 $x &gt; 0$, $y &gt; 0$）：</p><script type="math/tex; mode=display">\Beta(x, y) = \int_0^{1} t^{x - 1} (1 - t)^{y - 1} dt</script><p>结论：</p><ul><li><p>$\Gamma(1) = 1$, $\Gamma(x) = (x - 1) \Gamma(x - 1)$, <strong>因此 $\Gamma(x) = (x - 1)!$</strong></p></li><li><p>$\Beta(x, y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}$ <a href="https://blog.csdn.net/xhf0374/article/details/53946146" target="_blank" rel="noopener">证……明？</a></p></li></ul><p><del>这俩基本够用了</del></p><p>我们求的是 $\Beta(k + 1, n - k + 1)$，化简以后乘上方案数就是 $\frac{k}{n + 1}$。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>引入第 $n + 1$ 个随机变量 $x$，可以认为第 $k$ 小变量的期望等于第 $n + 1$ 个变量小于等于第 $k$ 小变量的概率。考虑大小关系，共有 $k * n!$（新变量有 $k$ 个位置可插入），所以概率为 $\frac{k}{n + 1}$。</p><h2 id="T2-光伏元件"><a href="#T2-光伏元件" class="headerlink" title="$T2. 光伏元件$"></a>$T2. 光伏元件$</h2><hr><h2 id="T3-服务器调度"><a href="#T3-服务器调度" class="headerlink" title="$T3. 服务器调度$"></a>$T3. 服务器调度$</h2><hr><h2 id="T4-打击复读"><a href="#T4-打击复读" class="headerlink" title="$T4. 打击复读$"></a>$T4. 打击复读$</h2><hr><h2 id="T5-校验码"><a href="#T5-校验码" class="headerlink" title="$T5. 校验码$"></a>$T5. 校验码$</h2><hr><h2 id="T6-卫星基站建设"><a href="#T6-卫星基站建设" class="headerlink" title="$T6. 卫星基站建设$"></a>$T6. 卫星基站建设$</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6079]-养猫（线性规划转费用流）</title>
      <link href="2021/01/04/%5BLOJ6079%5D-%E5%85%BB%E7%8C%AB%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81%EF%BC%89/"/>
      <url>2021/01/04/%5BLOJ6079%5D-%E5%85%BB%E7%8C%AB%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>先做了 <a href="https://www.luogu.com.cn/problem/P3980" target="_blank" rel="noopener">$志愿者招募$</a>，一样的套路——线性规划转费用流。</p><p>先钦定所有时间吃东西，然后选一些时刻变成睡觉。$x_i = 0/1$ 表示 $i$ 时刻是否睡觉，是的话代价为 $s_i - e_i$。</p><p>可以列出不等式组：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} \geq ms</script><script type="math/tex; mode=display">x_1 + \cdots + x_{k} \leq k - me</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_{n - k + 1} + \cdots + x_n \leq k - me</script><p>变成标准型（就是不等号变等号）：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = ms + y_1</script><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = k - me - z_1</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_{n - k + 1} + \cdots + x_n = k - me - z_{n - k + 1}</script><p>线性规划转费用流要求每个变量恰好出现一次为正、一次为负，于是添加一个等式 $0 = 0$ 并两两做差：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = ms + y_1</script><script type="math/tex; mode=display">y_1 + z_1 = k - ms - me</script><script type="math/tex; mode=display">x_{k + 1} + (k - ms - me) = x_1 + z_1 + y_2</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">k - me = x_{n - k + 1} + \cdots + x_n + z_{n - k + 1}</script><p>这一类线性规划转费用流的建模方法，是把等式看作点，等式平衡对应网络流中的流量平衡。</p><p>那么每个变量看作流，为正则是入，为负则是出。从出的等式向入的等式连 $(cap, val)$ 的边。例如本题中 $x_i$ 连边为 $(1, s_i - e_i)$，而 $y_i$, $z_i$ 等辅助变量连边为 $(\infty, 0)$。</p><p>对于常数（设为 $c$）也要处理，为正则视为源点发出给你的，为负则视为你发出给汇点的：$(|c|, 0)$。</p><p>正确性怎么理解呢qwq？最大流跑完了，每个点的等式都被满足</p><p>回到本题，由于第一个等式的常数 $ms$ 在等式右边，我们把右边看作入，跑最大费用流就完事了。</p><p><a href="https://loj.ac/s/1026388" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】斯特林数</title>
      <link href="2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
      <url>2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这东西看过一遍就忘还是要手敲一遍 $L_AT_EX$ 才可以啊</p><p>第一类斯特林数：$n$ 元置换分为 $k$ 个轮换的方案数。有：$\sum\limits_{k = 0}^n {n \brack k} = n!$</p><p>第二类斯特林数：$n$ 个元素划分为 $k$ 个非空集合的方案数。有：$\sum\limits_{k = 0}^n {n \brace k} = B_n$，其中 $B_n$ 为贝尔数，表示 $n$ 的划分方案数。</p><p>递推：</p><p>$${n \brack k} = {n - 1 \brack k - 1} + (n - 1) {n - 1 \brack k}$$</p><p>$${n \brace k} = {n - 1 \brace k - 1} + k {n - 1 \brace k}$$</p><p>幂之间转换：</p><p>$$x^{\underline{n}} = \sum\limits_{k = 0}^n (-1)^{n - k} {n \brack k} x^k \Longleftrightarrow x^n = \sum\limits_{k = 0}^n {n \brace k} x^{\underline{k}}$$</p><p>$$x^{\overline{n}} = \sum\limits_{k = 0}^n  {n \brack k} x^k \Longleftrightarrow x^n = \sum\limits_{k = 0}^n (-1)^{n - k} {n \brace k} x^{\overline{k}}$$</p><p>设 $L(n, k) = \sum_j {n \brack j} {j \brace k} = \binom{n - 1}{k - 1} \frac{n!}{k!}$，则有</p><p>$$x^{\overline{n}} = \sum\limits_{k = 0}^n L(n, k)x^{\underline{k}} \Longleftrightarrow x^{\underline{n}} = \sum\limits_{k = 0}^n (-1)^{n - k} L(n, k) x^{\overline{k}}$$</p><p>（这是由前两条推出的，目前不知道有什么用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】LCT</title>
      <link href="2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LCT/"/>
      <url>2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LCT/</url>
      
        <content type="html"><![CDATA[<p>之前学的。以 备 重 修 qwq</p><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><p>把树剖成许多链，每条链用 splay 维护，中序遍历深度递增。</p><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><ul><li><p>打通 $x$ 到根的通路。过程是先把 $x$ 转到 $x$ 所在 splay 的根，然后让 $x$ 带着 $x$ 的左子树并到 $fa_x$ 所在 splay 中充作 $fa[x]$ 右儿子</p></li><li><p>这个过程 $x$ 和 $fa[x]$ 都和它们原本的右儿子断开了，但右儿子依然保留“父亲是谁”的信息）</p></li></ul><h3 id="makeroot"><a href="#makeroot" class="headerlink" title="makeroot"></a>makeroot</h3><ul><li>先 access，此时 $x$ 成了和根在同一 splay 中深度最大、中序遍历最末的点</li><li>再 splay，此时 $x$ 成了所在 splay 的根，但仍是深度最大。为了让 $x$ 成为根、变得深度最小，我们翻转 $x$ 的左右子树。<strong>注意：此操作不影响其他 splay 的深度顺序。</strong></li></ul><h3 id="findroot"><a href="#findroot" class="headerlink" title="findroot"></a>findroot</h3><ul><li>不断跳左儿子</li><li><em>珍爱生命，远离 findroot。。。</em> cut() 里判能否 cut 的部分还是这样吧：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch[y][<span class="number">0</span>] == x &amp;&amp; !ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">    cut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。"><a href="#LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。" class="headerlink" title="LCT 好像没法同时保证两个节点的子树信息都是对的。。无奈。。"></a><em>LCT 好像没法同时保证两个节点的子树信息都是对的。。无奈。。</em></h3><p>（模拟赛大爆炸</p><h2 id="关于-LCT-的时间复杂度分析"><a href="#关于-LCT-的时间复杂度分析" class="headerlink" title="关于 LCT 的时间复杂度分析"></a>关于 LCT 的时间复杂度分析</h2><p><a href="https://www.cnblogs.com/zhouzhendong/p/JunTanFenXi.html" target="_blank" rel="noopener">指路周指导博客 <del>对没错我就是贺了一遍</del></a></p><h3 id="access-1"><a href="#access-1" class="headerlink" title="access"></a>access</h3><p>考虑虚实链切换复杂度。</p><p>定义重儿子为 $size_x * 2 \geq size_{fa_x}$ 的点，其余为轻儿子。定义势能函数 $\phi$ 为又重又虚的节点数。考虑一次 splay 操作，当前 splay 根节点 $x$ 的情况：</p><ul><li>若它是轻儿子，则消耗 $1$ 时间，$\Delta \phi \leq 1$</li><li>若它是重儿子，则消耗 $1$ 时间，$\Delta \phi = 1$</li></ul><p>一次 access $x$ 的操作在过程中只会遇到 $logn$ 个轻儿子，因此一次 access 操作的均摊复杂度为 $O(logn)$。</p><h3 id="makeroot、link-cut"><a href="#makeroot、link-cut" class="headerlink" title="makeroot、link/cut"></a>makeroot、link/cut</h3><p>考虑过程中的轻重边变化量。</p><p>「把根从 $x$ 换成 $y$ 」「切除 $x$ 的子树 $y$」「连接以 $x$ 为根和以 $y$ 为根的连通块」的时候改变的轻重边只会是 $x$ 到 $y$ 路径上的，而前后 $x$ 到 $y$ 路径上都只有 $logn$ 条轻边。$O(logn)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】最长反链和它全家（详细揭秘）</title>
      <link href="2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%92%8C%E5%AE%83%E5%85%A8%E5%AE%B6%EF%BC%88%E8%AF%A6%E7%BB%86%E6%8F%AD%E7%A7%98%EF%BC%89/"/>
      <url>2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%92%8C%E5%AE%83%E5%85%A8%E5%AE%B6%EF%BC%88%E8%AF%A6%E7%BB%86%E6%8F%AD%E7%A7%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同志，扫盲了！</span><br></pre></td></tr></table></figure><ul><li><p>链：偏序关系中，链是形如 $a \leq b$ 的许多关系；$DAG$ 上，链是一个点集，其中任意两个点 $x$, $y$ 都能从 $x$ 到 $y$ 或从 $y$ 到 $x$。</p></li><li><p>反链：反链也是点集，不过其中任意两个点都不能走到彼此。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最长反链 = 最小链覆盖（Dilworth 定理：最长反链 = 最小链精确（即不可重）覆盖，通过传递闭包可以转为最小链可重覆盖，然而实现时都用网络流）</span><br><span class="line">最长链 = 最小反链覆盖</span><br></pre></td></tr></table></figure><ul><li><p>最大匹配：$DAG$ 的最大匹配概念同二分图的。</p></li><li><p>最小链覆盖：也叫最小路径覆盖，作用如其名，分为可重和不可重。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小链覆盖 = 顶点数 - 最大匹配（刚开始没有匹配，显然成立；接下来每匹配一对点，匹配数 +1，路径数 -1。匹配数 = 每条路径点数边数和。）</span><br></pre></td></tr></table></figure><ul><li><p>最小不可重链覆盖：拆点，用匈牙利算法或者网络流求解，连 $(x_{out}, y_{in})$</p></li><li><p>最小可重链覆盖：先传递闭包，再在形成的偏序集上做最小不可重链覆盖，跳过的点被当作重复经过，然而实现时一般用网络流建 $(x’, x, \infty)$ 这样的反边表示某些点被当作中间点做了传递闭包。</p></li><li><p>最大独立集：选出最多的点，其中两两无边相连。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大团 = 补图最大独立集</span><br></pre></td></tr></table></figure><ul><li><p>最小点覆盖：选择最少的点覆盖所有边。</p><ul><li>二分图的最小点覆盖可以这么求：先跑一遍最大匹配，令左边点只能走非匹配边，右边点只能走匹配边，最小点覆盖就是左侧未访问点加上右侧已访问点。</li></ul></li><li><p>最小边覆盖：选择最少的边覆盖所有点。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大匹配 = 最小点覆盖</span><br><span class="line">    每条边一定连着一个匹配点，否则连两个未匹配点匹配数应该 +1。</span><br><span class="line">二分图 最大独立集 = 顶点数 - 最小点覆盖</span><br><span class="line">    把最小点覆盖剔除，剩下的点就没有边相连了。</span><br><span class="line">二分图 最小边覆盖 = 顶点数 - 最大匹配</span><br><span class="line">    显然。同时也告诉我们最小边覆盖就是在最大匹配的基础上加边，变成完美匹配。</span><br><span class="line">二分图 最小割 = 最小点权覆盖集 = 点权和 - 最大点权独立集</span><br></pre></td></tr></table></figure><p>感觉类似题目（不 sb 的那种）都是用👆上面这套理论搞来搞去，比如 <a href="https://www.luogu.com.cn/problem/P4298" target="_blank" rel="noopener">$CTSC2008-祭祀$</a>：难点在构造方案。</p><p>第二问好想，每个点删除后做一遍最长反链看是否只减小了 $1$。</p><p>第一问，先说结论：选出新图所有 $x_{out}$ 和 $x_{in}$ 都在最大独立集里的点，就是原图最长反链。</p><p>证明：<br>有最大独立集合 $I$ = 顶点数 $2n$ - 最大匹配 $m$，设最长反链集合为 $A$，$I - A$ 为「$x_{out}$ 或 $x_{in}$ 在最大独立集里」的点集，$|I| - |A| \leq n$, $|A| \geq |I| - n = n - m$, 而 $|A| \leq n - m$，所以 $|A| = n - m =$ 原图最长反链。</p><p>所以匈牙利或者 $dinic$ 找最大匹配，再 dfs 找最小点覆盖，最大独立集 = 最小点覆盖补集。注意这题可重。</p><p><em>彩蛋：$dinic$ 在二分图上单次增广是 $O(n\sqrt{n})$ 的哦</em></p><p>upd: $96$ 分我太疑惑了？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】最大权闭合子图</title>
      <link href="2020/12/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
      <url>2020/12/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><hr><p>看到一篇很好的博客，终于会了这玩意儿！qwq 咱不来虚的哈，直接上正题</p><ul><li><p>什么是最大权闭合子图：</p><p>  每个点有点权，点权和最大的闭合子图即为最大权闭合子图</p></li><li><p>如何求解</p><p>  先说结论：$S$ 向正权点连，边权为权值，$T$ 向负权点连，边权为权值绝对值。<strong>最大权闭合子图权值即为正权和 - 最大流。</strong></p><p>  证明（半感性）：<strong>$S -&gt; T$ 的流量就是损失。</strong> 尽量选正权点为起点，所以 $S$ 向正权点连。一个正权点选会导致后续选一些负权点，但我们不知道选当前正权点是否优，就先选上，顶多后面被负权点损失掉为 $0$，不会亏。</p></li></ul><p>习题：</p><h3 id="Salty-Fish"><a href="#Salty-Fish" class="headerlink" title="$Salty Fish$"></a><a href="https://vjudge.net/problem/HDU-6634" target="_blank" rel="noopener">$Salty Fish$</a></h3><p>显然的最大权闭合子图模型。本质却是贪心——一个摄像头尽可能的清理掉子树里剩下的苹果中，深度大的。</p><p>与深度有关就长链剖分，开一个 $map$，$mp[x, d]$ 维护 $x$ 子树中深度为 $d$ 的苹果个数。每个苹果只在所在长链的根处被合并一次，$O((n + m)logn)$</p><p>然而这题要直接继承重儿子的 $map$，不然就 $MLE$。。以后写代码也注意一点。</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=34972168" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[THUWC2017]-大葱的神力</title>
      <link href="2020/12/22/%5BTHUWC2017%5D-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B/"/>
      <url>2020/12/22/%5BTHUWC2017%5D-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>玩玩提答！qwq。看到一句话：提答的本质是模拟退火和找规律。哦这样吗！那我去学模拟退火（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模拟退火算法流程（贺）：</span><br><span class="line">随机变化坐标，幅度为 T</span><br><span class="line">计算新解与当前解的差 delta。</span><br><span class="line">以最大化答案为例，若 delta &gt; 0 则用新解替换当前解；否则以 exp(-delta / T) 的概率用新解替换当前解。</span><br><span class="line">温度乘上一个小于 1 的系数，即降温。</span><br><span class="line">随着温度不断降低，变化幅度也不断减小，接受一个更劣解的概率也越来越小。</span><br></pre></td></tr></table></figure><p>调参看脸。有人说可以观察答案的变化率什么的，总之是个完全玄学的东西。</p><p>好，上正文！（其实是想存代码，好有成就感的说 qwq</p><p>每个 case 都有特性，需要观察找规律。</p><h3 id="Case-1-amp-2"><a href="#Case-1-amp-2" class="headerlink" title="Case 1 &amp; 2"></a>Case 1 &amp; 2</h3><p>暴搜 + （我的垃圾）剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>], b[<span class="number">30</span>], mp[<span class="number">30</span>][<span class="number">30</span>], sum, to[<span class="number">30</span>], ans, pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>], mx[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + mx[x] &lt; ans) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; ans) &#123;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                pos[i] = to[i];</span><br><span class="line">            &#125; ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x + <span class="number">1</span>);</span><br><span class="line">    rep(y, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[y] + a[x] &lt;= b[y]) &#123;</span><br><span class="line">            sum += mp[x][y];</span><br><span class="line">            to[x] = y;</span><br><span class="line">            used[y] += a[x];</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            sum -= mp[x][y];</span><br><span class="line">            used[y] -= a[x];</span><br><span class="line">            to[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("drawer2.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("drawer2.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            mx[i] = max(mx[i], mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) mx[i] += mx[i + <span class="number">1</span>];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pos[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h3><p>抽屉唯一，跑背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>, M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[M], w[M], f[M][N], lst[M][N], ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y ^ lst[x][y]) ans[x] = <span class="number">1</span>;</span><br><span class="line">    work(x - <span class="number">1</span>, lst[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">memset</span>(f, ~<span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">10000</span>) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j], lst[i][j] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= a[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &lt; f[i - <span class="number">1</span>][j - a[i]] + w[i]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - a[i]] + w[i];</span><br><span class="line">                    lst[i][j] = j - a[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">10000</span>) <span class="keyword">if</span> (f[n][i] &gt; f[n][id]) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    work(n, id);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-4-amp-5-amp-6"><a href="#Case-4-amp-5-amp-6" class="headerlink" title="Case 4 &amp; 5 &amp; 6"></a>Case 4 &amp; 5 &amp; 6</h3><p>大葱体积唯一且抽屉体积是大葱体积倍数——裸的费用流。</p><p>值得一提的是有个 Case 大葱体积都在 <del>19260817</del>19900000 左右，可视为微小的扰动，不会影响最终答案，取最大值作为体积就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(rest, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(rest));</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        v = max(v, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        add(i + n, T, b[i] / v, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mcmf();</span><br><span class="line">    rep(x, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-7"><a href="#Case-7" class="headerlink" title="Case 7"></a>Case 7</h3><p>只有第一个大葱体积不同，枚举它放在哪，跑多次费用流。跑了一分多钟，反正是提答 ~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m, Cost, V;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    rep(i, S, T) &#123;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">        pre[i] = <span class="number">0</span>;</span><br><span class="line">        inq[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    V = a[<span class="number">2</span>];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">48</span>] -= a[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        add(i + n, T, b[i] / V, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(j ,<span class="number">1</span>, m) &#123;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cost = Mcmf() - mp[<span class="number">1</span>][<span class="number">48</span>];</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">48</span>;</span><br><span class="line">    rep(x, <span class="number">2</span>, n) &#123;</span><br><span class="line">        ans[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(x, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-8-amp-9-amp-10"><a href="#Case-8-amp-9-amp-10" class="headerlink" title="Case 8 &amp; 9 &amp; 10"></a>Case 8 &amp; 9 &amp; 10</h3><p>没有任何规律。于是就上模拟退火（学以致用</p><p>我是 rand 排列，随便调参，最优解只有 51 万左右，然而其他人都是 60 万左右，心慌慌</p><p>交一发竟然也是 4 + 2 + 1，开心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> db down = <span class="number">0.986</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][M], to[N], idb[N], ida[N];</span><br><span class="line"><span class="keyword">int</span> used[N], tmp[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    db T = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">1e-15</span>) &#123;</span><br><span class="line">        random_shuffle(ida + <span class="number">1</span>, ida + n + <span class="number">1</span>);</span><br><span class="line">        random_shuffle(idb + <span class="number">1</span>, idb + m + <span class="number">1</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) tmp[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) used[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[idb[cur]] + a[ida[i]] &lt;= b[idb[cur]]) &#123;</span><br><span class="line">                used[idb[cur]] += a[ida[i]];</span><br><span class="line">                tmp[ida[i]] = idb[cur];</span><br><span class="line">                sum += mp[ida[i]][idb[cur]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cur; --i;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll del = sum - ans;</span><br><span class="line">        <span class="keyword">if</span> (del &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span>(-del / T) * RAND_MAX &gt; rand()) &#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">                rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T *= down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(o, <span class="number">1</span>, <span class="number">5</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) ida[i] = idb[i] = i;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>) * clock() % <span class="number">114514</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld :\n"</span>, ans);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://loj.ac/s/1017355" target="_blank" rel="noopener">评测记录</a></p><p>$10 * 7 + 4 + 2 + 1 = 77$，海星</p>]]></content>
      
      
      
        <tags>
            
            <tag> 提交答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】BM 算法 &amp; 常系数齐次线性递推</title>
      <link href="2020/12/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BM%20%E7%AE%97%E6%B3%95%20&amp;%20%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
      <url>2020/12/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BM%20%E7%AE%97%E6%B3%95%20&amp;%20%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Berlekamp-Massey"><a href="#Berlekamp-Massey" class="headerlink" title="$Berlekamp-Massey$"></a>$Berlekamp-Massey$</h1><p><a href="https://blog.csdn.net/hzj1054689699/article/details/90047110" target="_blank" rel="noopener">大佬1</a>  <a href="https://www.luogu.com.cn/blog/_post/234046" target="_blank" rel="noopener">大佬2</a></p><p>实现时下标经常多一位或少一位-_-|| 我预言不久的将来 BM 会沦为 xml 的脑内黑箱</p><h1 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h1><p>求出递推式，接下来就要递推啦。</p><p>是照着 <a href="https://www.cnblogs.com/zhouzhendong/p/Cayley-Hamilton.html" target="_blank" rel="noopener">zhouzhendong</a> 和 <a href="https://www.cnblogs.com/Winniechen/p/10246295.html" target="_blank" rel="noopener">Winniechen</a> 的博客学习的。也可以参考 <a href="https://oi-wiki.org/math/linear-recurrence/" target="_blank" rel="noopener">OI-wiki</a>，是两种解释，没有那么多线代前置芝士。</p><p>其实我讲不清楚，建议点 OI-wiki，它特别清楚。</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="$问题引入$"></a>$问题引入$</h2><p>给定一个数列，满足:</p><ul><li>$n \leq k$ 时，$f_n = a_n$</li><li>$n &gt; k$ 时，$f_n = \sum\limits_{i = 1}^k f_{n - i} * a_i$</li></ul><p>众所周知矩阵生来就做这事儿的，$O(k^3 log n)$. 当 $n$ 比较大的时候就没前途。</p><p>于是就出现了——特征多项式优化矩阵快速幂。求第 $n$ 项复杂度为 $O(k^2 log n)$</p><h2 id="前置数学芝士"><a href="#前置数学芝士" class="headerlink" title="$前置数学芝士$"></a>$前置数学芝士$</h2><ol><li><p>矩阵的特征值和特征向量</p><ul><li><p>若对于 $n$ 阶矩阵 $A$，有常数 $\lambda$、非零列向量 $\vec{v}$ 满足 $\lambda \vec{v} = A \vec{v}$，则称 $\lambda$ 为矩阵 $A$ 的<strong>特征值</strong>，$\vec{v}$ 为矩阵 $A$ 的<strong>特征向量</strong>。</p></li><li><p>上柿可以写作 $(\lambda I - A)\vec{v} = 0$, 左边括号里那玩意是矩阵的行列式，记做 $f(\lambda)$，即为矩阵 $A$ 的<strong>特征多项式</strong>，则对于某个矩阵的特征值 $\lambda_0$, 有 $f(\lambda_0) = 0$。</p></li><li><p>（注意：行列式和矩阵乘以一个数 $k$ 时是不同的，行列式是某行或某列乘 $k$，矩阵是所有数乘 $k$。别问为啥，这就是定义。）</p></li></ul></li><li><p>矩阵特征多项式和一个著名定理</p><ul><li><p>凯莱-哈密顿定理：$f(A) = 0$.</p></li><li><p>求解：$f(\lambda) = |\lambda I - A| = \lambda^m - \sum\limits_{i = 0}^{k - 1} a_{k - i} \lambda^i$</p></li></ul></li></ol><p>由上面那个柿子得到 $f(A) = A^k - b_1A^{k - 1} - c_2A^{k - 2}  … - c_k = 0$, 即 $A^k = c_1A^{k - 1} + … + c_k$，这告诉我们 $A_k$ 可以被 $A^0$ ~ $A^{k - 1}$ 的矩阵线性表出！（哇，有线代内味了</p><p>$A^{x + y} = A^x * A^y$,</p><p>$A^x = \sum b_i A^i$, $A^y = \sum c_i A^i$</p><p>因为有 $f(A) = 0$，所以 $A^{x + y} = \sum\limits_{k = 0}^{2K - 2} (\sum\limits_{i = 0}^{K - 1} b_ic_{k - i})A^k mod f(A)$，这个取模达到了降次的效果。用快速幂就是 $O(K^2 logn)$ 的。</p><p>zhouzhendong 大佬博客里有<del>非人</del>神仙 $O(klogklogn)$ 多项式操作，然而常人都写不动吧 QAQ？（就先不学了</p><p>$Template$：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">luogu_5497</span></span><br><span class="line"><span class="comment">加了常系数齐次线性递推的版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, de, K;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; f[N], ans, lst;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> x * y % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = x * y % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sub</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x - y + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, Mul(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) Mul(ret, a);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BM</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail = <span class="number">0</span>;</span><br><span class="line">    ll cur = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.size(); j++)</span><br><span class="line">            Add(cur, mul(b[i - <span class="number">1</span> - j], ans[j]));</span><br><span class="line">        <span class="keyword">if</span> (!((b[i] - cur) % mod)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!fail) &#123;</span><br><span class="line">            fail = i;</span><br><span class="line">            de = b[i] - cur;</span><br><span class="line">            rep(j, <span class="number">1</span>, i) ans.pb(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; now = ans;</span><br><span class="line">        ll w = mul(b[i] - cur, qpow(de, mod - <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (ans.size() &lt; lst.size() + i - fail)</span><br><span class="line">            ans.resize(lst.size() + i - fail);</span><br><span class="line">        Add(ans[i - fail - <span class="number">1</span>], w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lst.size(); j++)</span><br><span class="line">            Sub(ans[i - fail + j], mul(w, lst[j]));</span><br><span class="line">        <span class="keyword">if</span> (now.size() &lt; lst.size() + i - fail) &#123;</span><br><span class="line">            lst = now, fail = i, de = b[i] - cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doMul</span><span class="params">(ll x[], ll y[])</span> </span>&#123;</span><br><span class="line">    ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">        rep(j, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">            Add(tmp[i + j], mul(x[i], y[j]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * K - <span class="number">2</span>; i &gt;= K; i--) &#123;  <span class="comment">// 在取模</span></span><br><span class="line">        <span class="keyword">if</span> (!tmp[i]) <span class="keyword">continue</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, K)</span><br><span class="line">            Add(tmp[i - j], mul(a[j], tmp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">2</span> * K - <span class="number">1</span>)</span><br><span class="line">        x[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll c[N];  <span class="comment">// 系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fpow</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    c[<span class="number">0</span>] = tmp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) doMul(c, tmp);</span><br><span class="line">        doMul(tmp, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    BM(n);</span><br><span class="line">    K = (<span class="keyword">int</span>)ans.size();</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>) &#123;</span><br><span class="line">        ans[i] = (ans[i] % mod + mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">        a[i + <span class="number">1</span>] = ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>) b[i] = b[i + <span class="number">1</span>];</span><br><span class="line">    rep(i, K, n) b[i] = <span class="number">0</span>;</span><br><span class="line">    fpow(m);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">        Add(ans, mul(b[i], c[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="THUSCH2017-如果奇迹有颜色"><a href="#THUSCH2017-如果奇迹有颜色" class="headerlink" title="$THUSCH2017-如果奇迹有颜色$"></a><a href="https://loj.ac/p/2981" target="_blank" rel="noopener">$THUSCH2017-如果奇迹有颜色$</a></h3><p>这题比洛谷上的 Polya 模板题多了个相邻 $m$ 项颜色不能全不同的限制。</p><p>$|X/G| = \frac{1}{|G|} \sum_g m^{c(g)} = \frac{1}{|G|} \sum_k \phi(n / k) * f(k)$</p><p>现在要算 $f(gcd = k)$ 的染色方案数。可以状压计算，状态数是 $m^{m}$，直接跑矩阵快速幂能拿到 $55$ 分的好成绩，然后我就不会了</p><p>题解告诉我要去学常系数齐次线性递推，我就滚去学了。厚厚，新知识！（于是就有了这篇拼凑起来的笔记</p><p>猜测递推式长度小于 $m^{m}$，借助超能力（打表）发现 $m = 7$ 就 $409$.</p><p><a href="https://loj.ac/s/1012066" target="_blank" rel="noopener">$Code$</a></p><h3 id="NOI2017-泳池"><a href="#NOI2017-泳池" class="headerlink" title="$NOI2017-泳池$"></a><a href="https://uoj.ac/problem/316" target="_blank" rel="noopener">$NOI2017-泳池$</a></h3><p><strong>恰好</strong>用差分变为<strong>小于等于</strong>。设计 dp：$dp_{i, j}$ 表示有一块宽度为 $j$ 的区域，最下面 $i$ 行都是安全的，从下往上第 $i + 1$ 行及以上部分任意，<strong>且该区域内最大游泳场面积 $\leq K$</strong> 的概率。那么有：</p><script type="math/tex; mode=display">dp_{i, j} = dp_{i + 1, j} p^j + \sum\limits_{k = 1}^j dp_{i + 1, k - 1}dp_{i, j - k}(1 - p)p^{k - 1}</script><p>答案是 $dp_{0, n}$。</p><p>如果你打了表。。你就会发现 $dp_0$ 有递推式（谁这么熟练啊= =）于是一顿操作猛如虎，回头一看二百五。</p><p><a href="https://uoj.ac/submission/452703" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线性递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2019]-开关</title>
      <link href="2020/12/11/%5BZJOI2019%5D-%E5%BC%80%E5%85%B3/"/>
      <url>2020/12/11/%5BZJOI2019%5D-%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一-生成函数"><a href="#方法一-生成函数" class="headerlink" title="$方法一:生成函数$"></a>$方法一:生成函数$</h2><p>“神仙题！”（平庸的 xml 发出惊叹）</p><p>生成函数怎么想到的啊？/yiw 但的确很符合，因为按键是有顺序的，而每个键按多少次概率也不同，适合用形式幂级数表示。</p><p>设 $P = \sum p$.</p><p>分开考虑每个键。考虑 $[x^k]F_i(x)$ 表示第 $i$ 个位置按了 $k$ 次的概率贡献。当然是 EGF 啦因为是有顺序的按。</p><script type="math/tex; mode=display">F_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == s_i] \frac{ ( \frac{p_i}{P} ) ^n}{n!} x^n</script><script type="math/tex; mode=display">F(x) = \prod F_i(x)</script><p>写成 OGF <script type="math/tex">f(x) = \sum_k (k! * [x^k]F(x)) * x^k</script></p><p>$[x^k]G_i(x)$ 表示第 $i$ 个位置按了 $k$ 次，状态不变的概率。</p><p>然而只有 $F$ 能干啥呢？我们要求的是<strong>第一次</strong>到达目标状态，所以需要容斥。具体来说，设 $g(x)$ 表示 $k$ 次状态不变的 OGF，可按上述方法求出；设 $h(x)$ 为答案 OGF，则 $f(x) = g(x) \cdot h(x)$, 则 $h(x) = \frac{f(x)}{g(x)}$.</p><p>根据期望的定义，答案形如 $\sum_i if(i)$ 。啊这不就是 $h(1)$ 的导数嘛！$h’(1)$ 就是最终答案。</p><script type="math/tex; mode=display">G_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == 0] \frac{( \frac{p_i}{P} )^n}{n!} x^n</script><script type="math/tex; mode=display">G(x) = \prod G_i(x)</script><p>写成 OGF <script type="math/tex">g(x) = \sum_k (k! * [x^k]G(x)) * x^k</script></p><p>写成封闭形式</p><script type="math/tex; mode=display">F_i(x) = \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">F(x) = \prod \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">G_i(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">G(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}</script><p>将 $F(x)$ 写成 $\sum c_i e^{\frac{i}{P}x}$ 的形式，则有</p><script type="math/tex; mode=display">f(x) = \sum_k \left( k![x^k]F(x) \right) x^k</script><script type="math/tex; mode=display">= \sum_k k![x^k]( \sum_i c_i ( \sum_j \frac{(\frac{i}{P}x)^j}{j!} ) )x^k</script><script type="math/tex; mode=display">= \sum_k ( k! \sum_i c_i \frac{(\frac{i}{P})^k}{k!} ) x^k = \sum_k  (\sum_i c_i (\frac{i}{P})^k) x^k</script><script type="math/tex; mode=display">= \sum_i c_i \sum_k (\frac{i}{P})^k x^k = \sum_i \frac{c_i}{1 - \frac{i}{P}x}</script><p>同理有 $g(x) = \sum_i \frac{d_i}{1 - \frac{i}{P}x}$。$c_i$, $d_i$ 可以简单 $O(nP)$ 背包得出！</p><p>补充求导加减乘除法法则：</p><script type="math/tex; mode=display">(f(x) + g(x))' = f'(x) + g'(x)</script><script type="math/tex; mode=display">(f(x) - g(x))' = f'(x) - g'(x)</script><script type="math/tex; mode=display">(f(x) \cdot g(x))' = f'(x)g(x) + f(x)g'(x)</script><script type="math/tex; mode=display">(\frac{f(x)}{g(x)})' = \frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2}</script><p>所以要求 $h’(x)$，只要计算出 $f(1)$, $f’(1)$, $g(1)$, $g’(1)$.</p><p><strong>然后又是常识问题：无知如我就想直接带 1 进去了，但这不行！！！因为 $i = P$ 项的存在，函数不收敛！！！</strong></p><p>怎么办？乘上 $1 - x$</p><script type="math/tex; mode=display">f(x) = c_P + \sum\limits_{i \neq P} \frac{c_i(1 - x)}{1 - \frac{i}{P}x}</script><script type="math/tex; mode=display">f(1) = c_P</script><script type="math/tex; mode=display">f'(x) = \sum\limits_i \frac{ -c_i(1 - \frac{i}{P}x) - (c_i - c_ix)(-\frac{i}{P}) }{(1 - \frac{i}{P}x)^2} = \sum\limits_i \frac{ (\frac{i}{P} - 1)c_i }{ (\frac{i}{P}x - 1)^2 }</script><script type="math/tex; mode=display">f'(1) = \sum\limits_{i \neq P} \frac{c_i}{\frac{i}{P} - 1}</script><p>同理 $g(1) = d_P$, $g’(1) = \sum\limits_{i \neq P} \frac{d_i}{\frac{i}{P} - 1}$</p><script type="math/tex; mode=display">h'(1) = \sum\limits_{i \neq P} \frac{c_id_P - c_Pd_i}{(i - 1)d_P^2}</script><p>神奇！</p><p><a href="https://loj.ac/s/1010266" target="_blank" rel="noopener">$Code$</a></p><p>从中获得的启示：</p><ul><li>多考虑实际意义，例如本题中期望 -&gt; 导数。</li><li>推柿子：面对多项式束手无策，不如把它变成封闭形式搞事情，多项式的加减乘除和数的加减乘除类似的，还可以求导、ln、exp，多好啊！</li><li>推柿子：把 $\prod_{i = l}^{r}$ 变成一个 $r - l + 1$ 次的多项式，就可以 $\sum$ 啦！$\sum$ 就能搞事情啦！</li></ul><h2 id="方法二：异或卷积"><a href="#方法二：异或卷积" class="headerlink" title="$方法二：异或卷积$"></a>$方法二：异或卷积$</h2><p>咕咕？<del>（生成函数搞累了</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计划】20Dec 训练日志</title>
      <link href="2020/12/07/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Dec%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2020/12/07/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Dec%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】生成函数</title>
      <link href="2020/12/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
      <url>2020/12/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四种树的计数</title>
      <link href="2020/12/06/%E5%9B%9B%E7%A7%8D%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
      <url>2020/12/06/%E5%9B%9B%E7%A7%8D%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="有标号无根树"><a href="#有标号无根树" class="headerlink" title="有标号无根树"></a>有标号无根树</h2><p>$n^{n - 2}$</p><h2 id="有标号有根树"><a href="#有标号有根树" class="headerlink" title="有标号有根树"></a>有标号有根树</h2><p>$n^{n - 1}$</p><h2 id="无标号有根树"><a href="#无标号有根树" class="headerlink" title="无标号有根树"></a>无标号有根树</h2><p>设 $f_i$ 表示大小为 $i$ 的树的方案数，其生成函数为 $F(z) = \sum\limits_{i \geq 0} f_i z^i$，则</p><p>$$F(z) = z \prod\limits_{i \geq 0} (1 - z^i)^{-f_i}$$</p><p>取对数</p><p>$$\ln{F(z)} = \ln{z} + \sum\limits_{i \geq 0} \ln((1 - z^i)^{-f_i})$$</p><p>$$= \ln{z} - \sum\limits_{i \geq 0} f_i \ln(1 - z^i)$$</p><p>求导</p><p>$$\frac{F’(z)}{F(z)} = \frac{1}{z} + \sum\limits_{i \geq 0} f_i \frac{i z^{i - 1}}{1 - z^i}$$</p><p>化简</p><p>$$z F’(z) = F(z) + F(z) \sum\limits_{i \geq 0} f_i i \frac{z^i}{1 - z^i}$$</p><p>只看第 $n$ 项系数</p><p>$$n f_n = f_n + \sum\limits_{i = 1}^{n - 1} f_i  \sum\limits_j [j \mid n - i] f_j j$$</p><p>$$f_n = \frac{1}{n - 1}( \sum\limits_{i = 1}^{n - 1} f_i \sum\limits_j [j \mid n - i] f_j j )$$</p><p>可以用分治 NTT 解决。<del>假装我会吧，现在实在没心情写</del></p><h2 id="无标号无根树"><a href="#无标号无根树" class="headerlink" title="无标号无根树"></a>无标号无根树</h2><p>设 $g_i$ 表示无根树的方案，$f_i$ 同上。考虑无根树可以用重心表示，所以把不是重心的答案都减去。</p><p>$$h_n = f_n - \sum\limits_{i = 1}^{n / 2} f_i f_{n - i}$$</p><p>注意当 $n$ 为偶数时要特判，加上 $f_{n / 2}^2 - \binom{f_{n / 2}}{2}$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020赛前训练小结</title>
      <link href="2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E5%B0%8F%E7%BB%93/"/>
      <url>2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 前的做题记录整理</title>
      <link href="2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/"/>
      <url>2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP2020 总结</title>
      <link href="2020/11/18/CSP2020%20%E6%80%BB%E7%BB%93/"/>
      <url>2020/11/18/CSP2020%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>被 T1 搞得心态爆炸导致 T3 彻底降智，最后一小时浑浑噩噩一分都没捞着，大失败！</p><h2 id="T1-儒略日"><a href="#T1-儒略日" class="headerlink" title="$T1. 儒略日$"></a>$T1. 儒略日$</h2><hr><p>打了一个半小时左右，真的是。。。本场崩的罪魁祸首，关键是年份还算错了一处（取模），只拿到了暴力分。。。。</p><p><del>啊！！！！气死我了！！！！</del></p><p>T1 的使命就是来耗时间的，考察选手代码能力。即选择较优的写法，以缩短时间。。。比如说二分和小范围的预处理就很好。狂码 200 行的选手如我，不崩谁崩？</p><p><a href="https://loj.ac/submission/990046" target="_blank" rel="noopener">$Code$</a></p><h2 id="T2-动物园"><a href="#T2-动物园" class="headerlink" title="$T2. 动物园$"></a>$T2. 动物园$</h2><hr><p>呵，最后 5 min 发现数据范围 $0 \leq k \leq 64$… 再见，这美丽的世界。</p><p>于是比去年更烦了一重：要判 = 64 和 65 的，65 就是先减后加。</p><p><a href="https://loj.ac/submission/990047" target="_blank" rel="noopener">$Code$</a></p><h2 id="T3-函数调用"><a href="#T3-函数调用" class="headerlink" title="$T3. 函数调用$"></a>$T3. 函数调用$</h2><hr><p>被 T1 烦到了，思路完全乱掉，归根结底还是心理素质太差了！</p><p>这题只是简单的加法乘法原理题，只要注意到贡献都是以加为根本，以乘为辅，大概就能想出来。最终答案的原先面目都是一些加操作啊。</p><p>于是考虑维护乘操作对加操作的影响，记一个后缀乘积就好了，拓扑看似难写实则好写。。。</p><p><a href="https://loj.ac/submission/990045" target="_blank" rel="noopener">$Code$</a></p><h2 id="T4-贪吃蛇"><a href="#T4-贪吃蛇" class="headerlink" title="$T4. 贪吃蛇$"></a>$T4. 贪吃蛇$</h2><hr><p>这题看似简单 实则不愧对其第四题的地位。。。思维严密，挺有意思的。</p><p>重要性质（与 16 年的蚯蚓十分相似）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进食的蛇丢进另一个队列里，发现当前丢的一定是进食过的蛇里最弱的</span><br></pre></td></tr></table></figure></p><p>猜想：如果当前 $max$ 吃了 $min$，不会变成 $min$，就一定会吃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：之后吃了的 max 会比当前吃完的 max 更小。</span><br></pre></td></tr></table></figure></p><p>所以分为两个阶段：</p><ol><li>当前 $max$ 吃了 $min$，不会变成 $min$，就一直吃</li><li>当前 $max$ 吃了 $min$，会变成 $min$，会一直进行下去直到某条蛇吃了不会变成 $min$ 或总数 $= 2$，这时最后吃的那条会反悔，倒数第二条吃的一定会吃，倒数第三条会反悔。。。发现和递归层数的奇偶性有关。感觉十分nb。<br>$set$ 维护 $max$ &amp; $min$，$O(Tnlogn)$，$70$ 分。</li></ol><p>考虑优化，那必须 $O(n)$ 了</p><p>考虑双端队列</p><p>划一下题目中容易遗漏的条件：保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。</p><p>——不用 $sort$ 了！</p><p>$q1$ 维护没吃过和没被吃过的，$q2$ 维护吃过的。显然都是有序的。</p><p>就是在暴力的基础上改一改</p><p>对于我这种没有🧠的选手来说，先写暴力才有可能优化成正解。。。而且暴力也更稳，考场上要尽力的打高分啊！</p><p><a href="https://loj.ac/submission/989975" target="_blank" rel="noopener">$Code$(暴力)</a></p><p><a href="https://loj.ac/submission/990038" target="_blank" rel="noopener">$Code$(正解)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="$总结$"></a>$总结$</h2><hr><p>不要哀求，学会争取。感觉思维还是太慢了，细节又推不干净，接下来要训练思维的敏捷性，也要注重模拟赛的训练。</p><p>考场情况多，稳住。僵住的状态可以去窗口深呼吸，回来继续拼抢。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020复习计划</title>
      <link href="2020/11/10/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>2020/11/10/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Comet OJ Contest 75</title>
      <link href="2020/09/25/Comet%20OJ%20Contest%2075/"/>
      <url>2020/09/25/Comet%20OJ%20Contest%2075/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cometoj.com/contest/75/problems" target="_blank" rel="noopener">传送门</a></p><p>sooke 这套真是高质量好题 /dz</p><h2 id="A-绝境"><a href="#A-绝境" class="headerlink" title="$A. 绝境$"></a>$A. 绝境$</h2><hr><p>考虑容斥，答案就是每种 $n - 1$ 个操作的交集减去 $n$ 个操作的交集。求矩形交的前后缀和！</p><p><a href="https://cometoj.com/status/ykj87mpwfh7me0lbi15ciah6vj67ryd4" target="_blank" rel="noopener">$Code$</a></p><h2 id="B-命运"><a href="#B-命运" class="headerlink" title="$B. 命运$"></a>$B. 命运$</h2><hr><p>注意，边不相交这是个很有用而且很强的条件！这样限定了 $i$ 位置取的 $in_i$ 个点只能是上方的底部和下方的顶端一些点。</p><p>特殊性质一是很有启发意义的一档。发现每个点引出的边方向确定了！为什么？若 $p_{i - 1} + 1 = p_i$ 则向右，若 $p_{i - 1} - 1 = p_i$ 则向左。然后可以愉快的dp，$f[i, j]$ 表示到第 $i$ 点处理完后，上方有 $j$ 条边（下方有 $p_i - j$ 条边）</p><p>推广一下发现，每个点的入度和出度都定了！为啥啊</p><ul><li>$in_i + out_i = d_i$</li><li>$p_{i - 1} - in_i + out_i = p_i$</li></ul><p>然后继续用刚才思路做，枚举上方几条入边和出边：$f[i, j] = \sum_x \sum_y f[i - 1, j - x + y]$</p><p>转移是 $n^2$ 的。。。优化：$g[i, j] = \sum\limits_{x = 0}^{in_i} f[i - 1, j + x]$    $f[i, j] = \sum\limits_{y = 0}^{out_i} g[i, j - y]$ 发现都是前缀和形式，前缀和优化。</p><p><a href="https://cometoj.com/status/fxs5bt46b7u243sfjl627cmk3nze4yxb" target="_blank" rel="noopener">$Code$</a></p><h2 id="C-终焉"><a href="#C-终焉" class="headerlink" title="$C. 终焉$"></a>$C. 终焉$</h2><hr><p>答案显然是断边数 + 1。</p><p>技巧/经典套路1：修改是改变一个点和它周围一圈点时，考虑它的<strong>树上结构</strong>，只要修改父亲节点处就好了！</p><p>集合幂级数？FWT、FMT？？好像都只能做部分分</p><p>$f[x, s]$ 表示节点 $x$ 儿子中状态为 $s$ 的数量，发现这样修改和查询一个是 $O(2^m)$，一个是 $O(1)$，这太不均匀了！</p><p>经典套路2：分两段，比如说修改 $x$ 值为 $s$，那么 $f[fa, t]++$，其中前半段 $t$ 和 $s$ 相同，后半段 $s$ 是 $t$ 的子集；<br>查询的话就先 $s = ~s$，$ans += f[fa, t]$，其中后半段 $t$ 和 $s$ 相同，前半段 $t$ 是 $s$ 的子集。但这样时间是 $O(n2^{m / 2})$ 了，空间还是 $O(n2^m)$</p><p>经典套路3：度数分块</p><p>考虑 $bound$，当度数 $&lt; bound$ 时暴力修改/询问，$&gt; bound$ 时用上面的数组做，发现这样空间复杂度是 $O(n / d * 2^{m / 2})$；发现 $d = 2^{m / 2}$ 时最优！</p><p>就做完啦。</p><p><a href="https://cometoj.com/status/n8s13h50ao6gc6fvte6gb5opzqpcanel" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 总结 &amp; 题解</title>
      <link href="2020/09/14/NOIP2020%20%E6%80%BB%E7%BB%93%20&amp;%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/14/NOIP2020%20%E6%80%BB%E7%BB%93%20&amp;%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="写在-NOIP2020-之后"><a href="#写在-NOIP2020-之后" class="headerlink" title="写在 NOIP2020 之后"></a>写在 NOIP2020 之后</h2><hr><p>T3 构造我直接傻眼，搞了俩小时一分没得（这构造本质是模拟）。最近大赛考非正常题越来越多了，对码力的要求也逐步上升，这俩我都不擅长。对而且我还不擅长思维题。我擅长啥呢？套路题（有手就行的 sb 题）。</p><p>想要多写 LOJ 的神题、套路题、非正常题，想学生成函数。在役的时间，有一天便看一天的风景，dp 套 dp、生成函数这些人类智慧不看会后悔的吧 qvq？ 向前跋涉吧！<strong>“永远不要用行为上的努力来掩盖思维上的懒惰。”</strong></p><h2 id="成绩出了"><a href="#成绩出了" class="headerlink" title="成绩出了"></a>成绩出了</h2><hr><p>丧气话删了。“世上一切不幸都是由于当事者能力不足”</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>先 乘 后 除 /吐血 痛失 30 分，<strong>痛失高一赛季！</strong></p><p>正解就维护指数</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>好吧。。这题就是复杂度优化题。后面东西用树状数组我做到了，前面那个用倍增我真想不到啊。。</p><p>肯定要枚举 AB，然后发现确定了 AB 的长度，C 的奇数个数只有 2 种值，就很简单了。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>据说我写的是 $70$ 分，就每次挑两个柱子，当前柱有 $x$ 个黑，$y$ 个白（显然颜色不重要，我们就看作黑白），然后把两个柱子准备一下，即一个留 $x$ 个空位，一个留 $y$ 个空位，但我调了很久，还写挂了，痛失 $70$ 分。赛后看题解知道自己只想到了几个关键细节中的一个。</p><p>我们钦定总有一个柱子是空的，即每次操作完，有 $n$ 个柱子都是满的，这样可以简化很多。（第二个细节）</p><p>先看 $n = 2$ 的情况。发现可以在不改变其他柱子状态的情况下整理一个柱子，即白的在下，黑的在上。（第三个细节）</p><p>然后可以将柱子整理成同色的，具体就是，通过空柱子，我们可以 $reverse$ 一个柱子；两个柱子选一种颜色的球，<strong>需要保证两个柱子上此颜色的球数之和 $\leq m$</strong>，给丢到空柱子上，用一个柱子上的球填满另一个柱子再将塞到空柱子上的球拿回放在这个柱子上。（第四个细节）</p><p>$n &gt; 2$ 的情况分治就好了，复杂度 $O(5nmlogn)$，极限数据只跑了 $500000$。</p><p>需要注意的是，可能存在一个柱子颜色全是黑或全是白，merge 的时候可能会 $&gt; m$，需要特判。</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>暴 力 写 挂 我是屑</p><p>又是构造又是多项式的，爽啦。</p><p>对于暴力和正解都很重要的一个思想：每维是独立的。</p><p>如果模拟两轮没走完，发现每轮合法位置的变化量是线性的，即对于第 $i$ 维，第一轮走了 $a_i$，第二轮走了 $b_i$，那么再走 $x$ 轮减少的就是 $b_i - (a_i - b_i) * x$</p><p>枚举 $i$，现在计算的是第 $x + 2$ 轮做完第 $i$ 步的答案，合法的位置数是每维的合法位置乘起来。</p><p>将 $x$ 看作自变量，枚举 $i$，第 $x$ 轮走了 $i$ 步的答案是 $f(x) = \prod_j (tot_{j, i} - (a_j - b_j) * x)$，$tot_{j, i}$ 表示第 $j$ 维走了 $i$ 步的合法位置数</p><p>$\prod$ 写作 $\sum$, $f(x) = \sum_i c_i x^i$，最终答案即为 $\sum_i c_i (\sum\limits_{i = 1}^{mx} x_i)$（$mx$ 是走的轮数上限。</p><p>后面这玩意是个自然数幂和，$k \leq 3$ 时有通项公式，$k &gt; 3$ 时可以预处理因为题目保证 $max_{w_i} \leq 1e6$.</p><p>$O(nk^2)$，乘法是 $k^2$, 听说因为 $F$ 变化量小，通过什么拉格朗日插值可以做到 $O(nk)$（蒟蒻不会内个</p><h1 id="「不要在脑海里激情澎湃一会儿就当努力过了。」"><a href="#「不要在脑海里激情澎湃一会儿就当努力过了。」" class="headerlink" title="「不要在脑海里激情澎湃一会儿就当努力过了。」"></a><em>「不要在脑海里激情澎湃一会儿就当努力过了。」</em></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】平面图</title>
      <link href="2020/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
      <url>2020/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B9%B3%E9%9D%A2%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>什么是平面图？除了节点外边没有交点的图。对于一个区域，我们称其为<strong>面</strong>；包围这个区域的边称其为<strong>边界</strong>；边界的长度称为这个面的<strong>度</strong>。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. |E| &lt;= 3|V| - 6</span><br></pre></td></tr></table></figure><p>这告诉我们 <strong>平面图里 m 与 n 同阶</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. V - E + F = K + 1</span><br><span class="line"></span><br><span class="line">任何一个凸多面体（或连通平面图）满足上式，其中 F 为面数，K 为连通块数。</span><br></pre></td></tr></table></figure><p>欧拉定理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 平面图的判定：（以 [HNOI2010]-planar 为例）（其实是只会存在哈密顿回路的）哈密顿回路会连成一个环，每条边就是环上的一条弦，两条边 i 和 j 若 xi &lt; xj &lt; yi &lt; yj 则相交，只能一条放环里、一条放环外——这是个二分图嘛！二分图有无合法染色等价于有无解啦。</span><br></pre></td></tr></table></figure><p>接下来是平面图转对偶图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 对于一个 s-t 平面图（有源点和汇点的平面图），其对偶图中的一个环对应着原图中的一个割。</span><br><span class="line">将平面图最小割或最大流转化成对偶图最短路，效果绝佳。（但我没写过qvq）</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P3209" target="_blank" rel="noopener">HNOI2011-平面图判定</a></p><p>利用哈密顿路径上的编号先后 判断边是否交，转二分图判定就好啦，并查集和 $2-sat$ 都可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 平面图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以 CF1327F 为代表的一类限制计数问题</title>
      <link href="2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这类有限制的计数问题，套路在状态设计上。一般是区间上的问题，切入点是发现 dp 的要点有当前位置和满足限制的位置以及满足了哪些限制；转移就是 对于同一种限制同一个右端点找到最大的左端点，这之间必须有一个满足要求的位置。</p><h2 id="CF1327F"><a href="#CF1327F" class="headerlink" title="$CF1327F$"></a>$CF1327F$</h2><hr><p>按位处理，可以算出每一位的答案然后乘起来。子问题的解决必须是 $O(n)$ 的！！</p><p>限制为 1 很好处理，全部强制为 1 就可以了；为 0 就比较难搞，要求至少有一个位置是 0。</p><p>先只考虑为 0 的限制。对于一个位置 $i$ 找到所有右端点 $\leq i$ 的限制的最大左端点，设其为 $l_i$。$f[i, j]$ 表示填完了前 $i$ 个位置，满足了右端点 $\leq i$ 的所有限制，最后一个 0 的位置在 $j$，其中 $l_i \leq j \leq i$ 的方案数</p><p>那么 $f[i, j] = f[i - 1, j]$ $(j &lt; i)$，$f[i, i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[i - 1, k]$</p><p>想优化空间。发现 $i \neq j$ 的 $f[i, j]$ 好像没什么用，干脆令 $f[i]$ 表示原来的 $f[i, i]$，$f[i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[k]$。发现求了一个后缀和，又发现 $l_i$ 单调递增，所以 dp 是 $O(n)$ 的。</p><p>那加上 1 的限制怎么办？把那些已经强制为 1 的点拎走，剩下的做 dp。</p><p><a href="https://codeforces.com/problemset/submission/1327/92203899" target="_blank" rel="noopener">$Code$</a></p><h2 id="清华集训2017-某个歌姬的故事"><a href="#清华集训2017-某个歌姬的故事" class="headerlink" title="$[清华集训2017]-某个歌姬的故事$"></a>$[清华集训2017]-某个歌姬的故事$</h2><hr><p>离散化（u1s1这题离散化是大毒瘤。）</p><p>预处理出每个位置的上限 $up_i$，这样就把 $up_i$ 相同的相邻位置缩成了一个点。</p><p>对于限制 $[l_j, r_j, m_j]$ 显然只有 $l_j \leq i \leq r_j$ 中 $up_i = m_j$ 的点能贡献。<br>于是对于每个 $m_j$ 将所有 $up_i = m_j$ 的点拿出来做 dp。</p><p>怎么d？显然是满足每个限制区间内有一个点达到上限即可。<br>令 $f[i, j]$ 表示满足所有 右端点在 $1$ ~ $i$ 的限制，选的最后一个点是 $j$ 的方案数。</p><p>不同的 $m_j$ 是独立的，分别 dp 后把答案乘起来。</p><p><a href="https://loj.ac/submission/927800" target="_blank" rel="noopener">$Code$</a></p><h2 id="NOI2020-D1T2-命运"><a href="#NOI2020-D1T2-命运" class="headerlink" title="$[NOI2020 D1T2]-命运$"></a>$[NOI2020 D1T2]-命运$</h2><hr><p>区 间 上 树（</p><p>这个比赛时连 dp 方程都想不到。。。就写了最暴力的指数级容斥。。<strong>但实际上跟前两题的 dp 设计思路是很相似的！</strong></p><p>$dp[i, j]$ 表示 $i$ 的子树内状态已经确定，没有满足的链顶点的最大深度为 $j$ 的方案数（记录最深是因为深的满足了，浅的也满足了），边界就是链都满足了，$j = 0$</p><script type="math/tex; mode=display">dp[x, i] = (\sum\limits_{j = 0}^{dep_x} dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^i dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^{i - 1} dp[x, j] \times dp[y, i])</script><p>前两部分分别是 $(x, y)$ 这条边为 1 和为 0 的方案数。</p><p>二维dp，前缀和形式。。噫，这个东西和 pkuwc2018-minimax 好像啊！没错，就是整体dp，上线段树合并。</p><p>跟 minimax 一样的，碰到叶子结点就返回，其他节点由儿子节点 upd 上来。</p><p><a href="https://loj.ac/submission/927792" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[COCI2010]-ZUMA</title>
      <link href="2020/09/08/%5BCOCI2010%5D-ZUMA/"/>
      <url>2020/09/08/%5BCOCI2010%5D-ZUMA/</url>
      
        <content type="html"><![CDATA[<p>第一次碰到不会做的区间 dp。。这题的难点在于设计 dp 状态。。</p><p>发现普通的思路 $f[i, j]$ 没有办法做</p><p>$f[i, j, k]$ 表示在区间 $[i, j]$ 前放了 $k$ 个与 $c[i]$ 同色的球，连带着新加的球全部消掉的最小球数。</p><p>$f[i, j, k] =$</p><ol><li>$f[i, j, k + 1] + 1$（在前面加一个球）</li><li>$f[i + 1, j, k + 1]$ $(c[i] = c[i + 1])$</li><li>$f[i + 1, p - 1, 0] + f[p, j, k + 1]$ $(c[i] = c[p])$</li></ol><p>边界：$f[i, i, j] = K - 1 - j$</p><p>$f[i, j, K - 1] =$</p><ol><li>$f[i + 1, j, 0]$</li><li>$f[i + 1, j, K - 1]$ $(c[i] = c[i + 1])$（因为要求 $\geq K$ 个连续的球）</li><li>$f[i + 1, p - 1, 0] + f[p, j, K - 1]$（理由同 2）</li></ol><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, KK = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, c[N], f[N][N][KK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = min(x, y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        rep(j, <span class="number">0</span>, K - <span class="number">1</span>) f[i][i][j] = K - <span class="number">1</span> - j;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - len + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][K - <span class="number">1</span>]);</span><br><span class="line">            rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                    chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][K - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = K - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                chkmin(f[i][j][k], f[i][j][k + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                    chkmin(f[i][j][k], f[i + <span class="number">1</span>][j][k + <span class="number">1</span>]);</span><br><span class="line">                rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                    <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                        chkmin(f[i][j][k], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 664 Div1</title>
      <link href="2020/09/08/Codeforces%20Round%20664%20Div1/"/>
      <url>2020/09/08/Codeforces%20Round%20664%20Div1/</url>
      
        <content type="html"><![CDATA[<p>China-Round 好神仙 &gt; &lt;</p><p>xry 都参与出题啦，我们这届也开始征战四方了！加油，无限可能。</p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><hr><p>小贪心，先分成两个集合，枚举大的集合取几个。</p><p><a href="https://codeforces.com/contest/1394/submission/92126211" target="_blank" rel="noopener">$Code$</a></p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><hr><p>趣题！要求的是<strong>任何</strong>点都能走回到自己，$k$ 这么小显然指数级枚举啦，问题在于怎么快速判断</p><p>考虑 $n$ 条边这个条件，也就是说有 $n$ 个入度，而每个点都能走回到自己，每个点都有一个入度，这意味着 $n$ 条边的终点遍布 $n$ 个点</p><p>那么预处理一些东西，只要能实现集合并就好了。$bitset$ 过不去，怎么办？$hash$！$O(1)$ 合并</p><p>注意写双$hash$！学习一波新写法 :)</p><p><a href="https://codeforces.com/contest/1394/submission/92131053" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><hr><p>好题！</p><p>最大值最小，考虑二分（判定性问题就可做很多啦！</p><p>发现两个串相似的条件是 B 和 N 的个数相等，操作其实是加或减 $B$、$N$、$BN$</p><p>那么问题转化为判定是否存在一个 $t$ 使得对于任何 $i$，$dis(s_i, t) \leq mid$</p><p>来细化一下：在平面上，设 $s_i$ 对应的点为 $(a, b)$, $t$ 对应的点为 $(c, d)$, $dis(s_i, t) =$</p><ol><li>$(a - c)(b - d) &gt; 0$: $max{|a - c|, |b - d|}$</li><li>$(a - c)(b - d) &lt; 0$: $|a - c| + |b - d|$</li></ol><p>显然满足异号限制的点必然满足同号限制，即可以看做同号限制对所有 $s_i$ 都适用</p><p>化开来 $|x - x_i| \leq mid$, $|y - y_i| \leq mid$，即 $x \in [x_i - mid, x_i + mid]$, $y \in [y_i - mid, y_i + mid]$</p><p>对于异号限制，想想怎么把它化作“对所有都适用且刚好限制到异号点”</p><p><strong>这里有个经典trick：$|x| + |y| = |x - y|$，对于同号没有影响，而对于异号是等价的</strong></p><p>所以 $|(x - y) - (x_i - y_i)| \leq mid$，即 $(x - y) \in [x_i - y_i - mid, x_i - y_i + mid]$</p><p>至此我们得到了 $x$, $y$, $x - y$ 的限制，枚举一维就能得到另一维的范围，判断有无交就可以了。</p><p><a href="https://codeforces.com/contest/1394/submission/92186512" target="_blank" rel="noopener">$Code$</a></p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><hr><p><a href="https://blog.aor.sd.cn/archives/1246/" target="_blank" rel="noopener">咕咕，记一下大佬博客</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG4260]-博弈论与概率统计</title>
      <link href="2020/09/06/%5BLG4260%5D-%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>2020/09/06/%5BLG4260%5D-%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>赢的场数都确定了，$p$ 一点用都没有，我们要算出得分之和以后除以 $C(n + m, n)$。所以这是道计数题？</p><p>不能小于 $0$，想到了啥，卡特兰数！考虑平面上向右向上走问题</p><p>假设 $n \geq m$, 从 $(0, 0)$ 走到 $(n, m)$ 贡献是 $n - m$，方案数是 $C(n + m, n) - C(n + m, n + 1)$，就是用总数 - 碰到了边界线的方案数</p><p>从 $(0, 0)$ 走到 $(n, m - 1)$ 贡献是 $n - m + 1$，方案数是 $C(n + m, n + 1) - C(n + m, n + 2)$</p><p>…</p><p>所以总贡献是 $\sum \limits_{i = 0}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = (n - m)C(n + m, n) + \sum\limits_{i = 0}^{m - 1}C(n + m, i)$</p><p>$n &lt; m$ 会怎么样，$\sum \limits_{i = m - n}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = \sum\limits_{i = 0}^{n - 1}C(n + m, i)$</p><p>这样就结束啦（</p><p>哦不 多组询问。。</p><p>发现形如 $f(n, k) = \sum\limits_{i = 0}^k C(n, i)$ 的东西很难求</p><p>发现 $f(n, k) = \sum\limits_{i = 0}^k C(n - 1, i - 1) + C(n - 1, i) = 2f(n - 1, k) - C(n - 1, k)$</p><p>发现知道了 $f(n, k)$ 就可以在 $O(1)$ 时间内推出 $f(n \pm 1, k)$ 和 $f(n, k \pm 1)$！</p><p>莫队求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll T, p, unit = <span class="number">500</span>, tot;</span><br><span class="line">ll ans[N], fac[N], inv[N], divv[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> ll n, k, id; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = inv[i] * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.n / unit == b.n / unit ? a.k &lt; b.k : a.n / unit &lt; b.n / unit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; p;</span><br><span class="line">    pre(<span class="number">500000</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= m) &#123;</span><br><span class="line">            ans[i] = (n - m) * C(n + m, n) % mod;</span><br><span class="line">            q[i].k = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].k = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        q[i].n = n + m;</span><br><span class="line">        divv[i] = fac[n] * fac[m] % mod * inv[n + m] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + T + <span class="number">1</span>, cmp);</span><br><span class="line">    q[<span class="number">0</span>].n = <span class="number">-1e9</span>;</span><br><span class="line">    ll nn = <span class="number">0</span>, kk = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].k &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[i - <span class="number">1</span>].k &lt; <span class="number">0</span> || q[i - <span class="number">1</span>].n / unit &lt; q[i].n / unit) &#123;</span><br><span class="line">            nn = q[i].n, kk = q[i].k;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">0</span>, kk) (tot += C(nn, j)) %= mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nn &lt; q[i].n) tot = (tot * <span class="number">2</span> % mod - C(nn, kk) + mod) % mod, ++nn;</span><br><span class="line">            <span class="keyword">while</span> (nn &gt; q[i].n) --nn, tot = (tot + C(nn, kk)) % mod * inv[<span class="number">2</span>] % mod;</span><br><span class="line">            <span class="keyword">while</span> (kk &lt; q[i].k) ++kk, (tot += C(nn, kk)) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        (ans[q[i].id] += tot + mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i] * divv[i] % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LnOI2019]-加特林轮盘赌</title>
      <link href="2020/09/05/%5BLnOI2019%5D-%E5%8A%A0%E7%89%B9%E6%9E%97%E8%BD%AE%E7%9B%98%E8%B5%8C/"/>
      <url>2020/09/05/%5BLnOI2019%5D-%E5%8A%A0%E7%89%B9%E6%9E%97%E8%BD%AE%E7%9B%98%E8%B5%8C/</url>
      
        <content type="html"><![CDATA[<p>有意思的题（我不会概率所以它超有意思（</p><p>比较妙的通过“环”的性质，化无限为递推。设 $f[n, k]$ 表示长度为 $n$ 的环中第 $k$ 个人唯一幸存的概率，那么有 $f[n, k] = p0 \times f[n - 1, k - 1] + (1 - p0) \times f[n, k - 1]$, 特别的 $f[n, 1] = (1 - p0) \times f[n, n]$</p><p>这玩意作为 dp 有后效性，想到消元。暴力消元炸没了，但我们发现假设前 $i - 1$ 行都算出来了，第 $i$ 行所有 $f[i, j]$ 只与 $f[i, 1]$ 有关，于是想到经典套路：表示成 $a \times f[i, 1] + b$ 的形式，$\sum\limits_{j = 1}^i f[i, j] = 1$，解出 $f[i, 1]$。</p><p>$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> p0, f[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, K, cur = <span class="number">1</span>, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p0 &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (!p0) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(n == <span class="number">1</span> ? <span class="string">"1"</span> : <span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        lst = cur; cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span>, A = <span class="number">0</span>, b = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">2</span>, i) &#123;</span><br><span class="line">            a *= (<span class="number">1</span> - p0);</span><br><span class="line">            A += a;</span><br><span class="line">            b = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * b;</span><br><span class="line">            B += b;</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">1</span>] = (<span class="number">1</span> - B) / (A + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">2</span>, i)</span><br><span class="line">            f[cur][j] = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * f[cur][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, f[cur][K]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法利用等比数列求和公式。设当前轮 $f[i]$ 表示 $i$ 唯一存活的概率，$g[i]$ 表示 $i$ 被打死的概率，$g[i] = (1 - p0)^{i - 1} p (\sum\limits_{j = 0}^{\infty} ((1 - p)^n)^i) = \frac{(1 - p)^{i - 1}}{1 - ((1 - p)^n)^i}$，然后每打死一个人就得到一个新的局面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2020 题解</title>
      <link href="2020/09/04/ZJOI2020%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/04/ZJOI2020%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="D1T1-字符串"><a href="#D1T1-字符串" class="headerlink" title="$D1T1. 字符串$"></a>$D1T1. 字符串$</h2><hr><h2 id="D1T2-传统艺能"><a href="#D1T2-传统艺能" class="headerlink" title="$D1T2. 传统艺能$"></a>$D1T2. 传统艺能$</h2><hr><h2 id="D1T3-序列"><a href="#D1T3-序列" class="headerlink" title="$D1T3. 序列$"></a>$D1T3. 序列$</h2><hr><h2 id="D2T1-染色游戏"><a href="#D2T1-染色游戏" class="headerlink" title="$D2T1. 染色游戏$"></a>$D2T1. 染色游戏$</h2><hr><h2 id="D2T2-抽卡"><a href="#D2T2-抽卡" class="headerlink" title="$D2T2. 抽卡$"></a>$D2T2. 抽卡$</h2><hr><h2 id="D2T3-密码"><a href="#D2T3-密码" class="headerlink" title="$D2T3. 密码$"></a>$D2T3. 密码$</h2><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 666 Div1</title>
      <link href="2020/09/03/Codeforces%20Round%20666%20Div1/"/>
      <url>2020/09/03/Codeforces%20Round%20666%20Div1/</url>
      
        <content type="html"><![CDATA[<p>最近场都好思维啊</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>巧妙构造，第一次取 n - 1 个，第二次取剩下 1 个，第三次取 n 个，前两次的目的就是把所有元素变成 n 的倍数</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>没有思路，将 a 排序，发现如果最大的比其他和都大那先手显然必胜。这个思路有点东西，继续挖掘发现两个人都尽量避免出现这种不均衡的局面，<strong>所有元素就会被取完</strong>，所以判断奇偶性就可以了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>1 &lt;= r1 &lt;= r2 &lt;= r3 !!! 这个条件有点隐蔽，但是能简化一些分类讨论</p><p>所以要么 1 或 2 将所有的血量减一再用 1 打掉boss，要么 1 打掉小怪再 3 打掉boss</p><p>反复横跳。具体来说是跳一段回一步跳一段回一步…这样</p><p>dp, $f[i, 0/1]$ 表示最远到第 $i$ 关，前 $i - 1$ 关都消灭了，是否消灭了boss，0 代表消灭</p><p>初始 $f[1, 0] = a[1] <em> r1 + r3$, $f[1, 1] = min(r1 </em> (a[1] + 1), r2)$</p><p>$f[i, 0] = min(f[i - 1, 0] + d + (r1 <em> a[i] + r3), f[i - 1, 1] + d + min(r1 </em> (a[i] + 1), r2) + d + r1 + d + r1)$</p><p>$f[i, 1] = min(f[i - 1, 0] + d + min(r1 <em> (a[i] + 1), r2), f[i - 1, 1] + d + min(r1 </em> (a[i] + 1), r2) + d + r1 + d)$</p><p>答案是 $min(f[n, 0], f[n - 1, 1] + d + a[n] * r1 + r3 + d + r1)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO20OPEN (Gold) 题解</title>
      <link href="2020/09/02/USACO20OPEN%20(Gold)%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/USACO20OPEN%20(Gold)%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="T1-Haircut"><a href="#T1-Haircut" class="headerlink" title="T1. Haircut"></a>T1. Haircut</h2><hr><p>设每个点初始贡献是 v[i], 那么发现 v[i] 一定是到了某个时刻（其实就是 h[i]）刷一下变成 0 了，树状数组维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], ans[N], C[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += lowbit(x)) C[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ++a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        num[i] = i - <span class="number">1</span> - query(a[i]);</span><br><span class="line">        tot += num[i];</span><br><span class="line">        add(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        add(<span class="number">1</span>, -num[i]), add(a[i] + <span class="number">1</span>, num[i]);</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(i) + tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2-Favorite-Colors"><a href="#T2-Favorite-Colors" class="headerlink" title="T2. Favorite Colors"></a>T2. Favorite Colors</h2><hr><p>比较暴力的思路，并查集 + 启发式合并，就是很暴力的将每个点的子节点都并起来，O(n log n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, fa[N], col[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x].size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    t[x] = g[x];</span><br><span class="line">    g[x].clear();</span><br><span class="line">    <span class="keyword">int</span> rt = t[x][<span class="number">0</span>];</span><br><span class="line">    rt = getfa(rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = t[x][i];</span><br><span class="line">        y = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (rt == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (g[rt].size() &gt;= g[y].size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[y].size(); j++) g[rt].push_back(g[y][j]);</span><br><span class="line">            g[y].clear();</span><br><span class="line">            fa[y] = rt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[rt].size(); j++) g[y].push_back(g[rt][j]);</span><br><span class="line">            g[rt].clear();</span><br><span class="line">            rt = fa[rt] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[x].push_back(rt);</span><br><span class="line">    dfs(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) dfs(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getfa(i);</span><br><span class="line">        <span class="keyword">if</span> (!col[x]) col[x] = ++idx;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, col[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3-Exercise"><a href="#T3-Exercise" class="headerlink" title="T3. Exercise"></a>T3. Exercise</h2><hr><p>k = lcm(环长)，而 n = sum(环长)</p><p>考虑 lcm 这个东西本质是把质因数每一位取最高次幂乘起来</p><p><a href="https://www.cnblogs.com/123789456ye/p/12739149.html" target="_blank" rel="noopener">这个老清楚了</a></p><p>本题中运用的“最优构造”思想是很常用的，在不会影响答案的情况下贪心的取。</p><p>另外显然并不会重复计算某个 k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, f[N], vis[N], p[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= p[i]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = p[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;= j) &#123;</span><br><span class="line">                f[j] = (f[j] + <span class="number">1l</span>l * f[j - tmp] * tmp % m) % m;</span><br><span class="line">                tmp *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, n) ans = (ans + f[i]) % m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIonline 1~3场题解</title>
      <link href="2020/09/02/NOIonline%201~3%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/NOIonline%201~3%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>来订题（咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019 题解</title>
      <link href="2020/09/02/CSP2019%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/CSP2019%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>快要 csp2020 了，来补 2019 的题（咕</p><h2 id="D1T1"><a href="#D1T1" class="headerlink" title="D1T1"></a>D1T1</h2><hr><p>手玩就出来了？</p><h2 id="D1T2"><a href="#D1T2" class="headerlink" title="D1T2"></a>D1T2</h2><hr><p>容易想到统计每个节点为右端点的子串数，然后继承给子节点就好了。然后记录每个节点祖先中离它最近的未匹配的 ‘(‘ 是哪个，再记录一下每个节点为右端点的合法的 ‘(…)’ 数，就好了！</p><p>条条大路通罗马，有时候错误的思路也会导出正确的思路。要有信仰！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, res;</span><br><span class="line">ll fa[N], ans[N], lst[N], cur[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">2</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;fa[i]);</span><br><span class="line">    rep(x, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ans[x] = ans[fa[x]];</span><br><span class="line">        lst[x] = lst[fa[x]];</span><br><span class="line">        <span class="keyword">if</span> (s[x] == <span class="string">'('</span>) lst[x] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">')'</span> &amp;&amp; lst[x]) &#123;</span><br><span class="line">            cur[x] = cur[fa[lst[x]]] + <span class="number">1</span>;</span><br><span class="line">            lst[x] = lst[fa[lst[x]]];</span><br><span class="line">            ans[x] += cur[x];</span><br><span class="line">        &#125;</span><br><span class="line">        res ^= (<span class="number">1l</span>l * x * ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D1T3"><a href="#D1T3" class="headerlink" title="D1T3"></a>D1T3</h2><hr><p>部分分推出正解。</p><p>菊花：将数字按照 $(rt, p_1, p_2, … p_{n - 1})$ 排出来，发现相当于每个位置上的数往后移了一位。贪心的构造轮换。</p><p>链：对于在 $u$ 位置的要移到 $v$ 位置（假设 $u &lt; v$），显然 $[u, v]$ 之间的删边顺序是从左到右，$u$ 右边比 $u$ 左边删的早。打标记，$i$ 点 $tag_i = 0, 1, 2$ 表示无标记，先左后右，先右后左</p><p>这是<strong>很有启发性</strong>的两档分！接下来考虑满分做法，显然就是 $u$ 指向 $v$ 的出边是第一个删的，$v$ 指向 $u$ 的出边是第一个删的，$[u, v]$ 之间的点都还没被删。<br>抽象一点就是把图分成很多不相交的链了。</p><p>复杂度 $O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, w[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> deg, beg, end, fa[N];  <span class="comment">// end 和 beg 分别记录该点第一条删除的入边和出边，fa 将成对删除的邻边绑在一起</span></span><br><span class="line">    <span class="keyword">bool</span> st[N], ed[N];  <span class="comment">// ed 和 st 是记录某条边有无作为该边的 入/出 边，至于为什么要分开记录还不是很懂。。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        beg = end = <span class="number">-1</span>, deg = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, n) st[i] = ed[i] = <span class="number">1</span>, fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (~id &amp;&amp; (a[x].end == <span class="number">-1</span> || a[x].end == id)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[x].ed[id] &amp;&amp; (a[x].beg == <span class="number">-1</span> || a[x].deg &lt;= <span class="number">1</span> || a[x].getfa(id) != a[x].getfa(a[x].beg)))</span><br><span class="line">            ret = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == (i &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = (i &gt;&gt; <span class="number">1</span>), y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (~id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == a[x].end || ed == a[x].beg || a[x].getfa(id) == a[x].getfa(ed))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!a[x].ed[id] || !a[x].st[ed]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (~a[x].beg &amp;&amp; ~a[x].end &amp;&amp; a[x].deg &gt; <span class="number">2</span> &amp;&amp; a[x].getfa(id) == a[x].getfa(a[x].beg) &amp;&amp; a[x].getfa(ed) == a[x].getfa(a[x].end))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ret = min(ret, getpos(y, ed));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x].beg == <span class="number">-1</span> || a[x].beg == ed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[x].st[ed]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (~a[x].end &amp;&amp; a[x].deg &gt; <span class="number">1</span> &amp;&amp; a[x].getfa(ed) == a[x].getfa(a[x].end)) <span class="keyword">continue</span>;</span><br><span class="line">                ret = min(ret, getpos(y, ed));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == p) <span class="keyword">return</span> a[x].end = id, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == (i &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = (i &gt;&gt; <span class="number">1</span>), y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (Link(y, ed, p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (~id) &#123;</span><br><span class="line">                a[x].ed[id] = a[x].st[ed] = <span class="number">0</span>, --a[x].deg;</span><br><span class="line">                a[x].fa[a[x].getfa(id)] = a[x].getfa(ed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[x].beg = ed;</span><br><span class="line">            &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(lnk, <span class="number">-1</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">            a[i].init();</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            add(x, y), add(y, x);</span><br><span class="line">            ++a[x].deg, ++a[y].deg;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = getpos(w[i], <span class="number">-1</span>);</span><br><span class="line">            Link(w[i], <span class="number">-1</span>, pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, pos);</span><br><span class="line">        &#125; <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T1"><a href="#D2T1" class="headerlink" title="D2T1"></a>D2T1</h2><hr><p>（啊。。这个题目真的恶心。。差点没懂）</p><p>考虑每种食材都不超过 $\lfloor \frac{k}{2} \rfloor$ 这个限制很烦，考虑容斥，统计每种食材打破限制的总方案数然后减掉就好了。</p><p>对于第 $col$ 种食材打破限制，设 $f[i, j]$ 表示前 $i$ 个烹饪方法中选的第 $col$ 种食材的菜与不是第 $col$ 种食材的菜的个数差为 $j$ 的方案数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">102</span>, M = <span class="number">2002</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, tot = <span class="number">1</span>, ans;</span><br><span class="line">ll a[N][M], f[N][N &lt;&lt; <span class="number">1</span>], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i][j]), s[i] = (s[i] + a[i][j]) % mod;</span><br><span class="line">        tot = tot * (s[i] + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(col, <span class="number">1</span>, m) &#123;</span><br><span class="line">        f[<span class="number">0</span>][N] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            rep(j, N - i, N + i)</span><br><span class="line">                f[i][j] = (f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>] * a[i][col] % mod + f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (s[i] - a[i][col] + mod) % mod) % mod;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) ans = (ans + f[n][N + i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (tot - <span class="number">1</span> - ans + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T2"><a href="#D2T2" class="headerlink" title="D2T2"></a>D2T2</h2><hr><p>考场上写了 $n^3$ 暴力后突然聪明了一下，输出了一些东西，发现这玩意是单调的然后就多了 32 分 qvq 论信仰的力量。。</p><p>88 分就是再加个单调队列！100 分再加个高精度。。。</p><p>具体来说，$j$ 能转移到 i 当且仅当 $pre[i] - pre[j] &gt;= len[j]$，$len[j]$ 表示以 $j$ 为结束的段，$pre[i] &gt;= pre[j] + len[j]$。发现 $j$ 越大越好（这就是我考场上发现的单调性），单调队列一波就可以了。</p><p><a href="http://matthew99.blog.uoj.ac/blog/5299" target="_blank" rel="noopener">单调性的证明</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 88 分代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e7</span> + <span class="number">5</span>;</span><br><span class="line">ll n, tp, len[N], f[N], q[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; tp;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;pre[i]);</span><br><span class="line">        pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    q[++r] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; pre[q[l + <span class="number">1</span>]] + len[q[l + <span class="number">1</span>]] &lt;= pre[i]) ++l;</span><br><span class="line">        len[i] = pre[i] - pre[q[l]];</span><br><span class="line">        f[i] = f[q[l]] + (pre[i] - pre[q[l]]) * (pre[i] - pre[q[l]]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; pre[q[r]] + len[q[r]] &gt;= pre[i] + len[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T3"><a href="#D2T3" class="headerlink" title="D2T3"></a>D2T3</h2><hr><p>学习了 xht37 的思路（是我比较适应的方法）：算出每一个节点为重心的次数。</p><p>选一个重心为根，对于我们考虑的 $x (x\neq rt)$，<strong>割的边一定不在 x 的子树里</strong>。设 $mx[x] = \max\{size[y]\}$, $S$ = 割掉边后不包含 $x$ 的那块的 $size$，那么有：$2(n - S - size[x]) \leq n - S$, $2mx[x] \leq n - S$，也就是要求 $n - 2size[x] \leq S \leq n - 2mx[x]$ 且边不在 $x$ 子树中的边数</p><p>那个不等式用树状数组维护一下，就成了区间求和；第二个约束可以在进出某个子树的时候作差。</p><p>$x = rt$ 时怎么办？设 $size$ 最大的子树是 $u$ 的，次大的是 $v$ 的。割边在 $u$ 子树中时 $2size[u] \leq n - S$, 在 $v$ 子树中时 $2size[v] \leq n - S$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> T, n, rt, u, v;</span><br><span class="line"><span class="keyword">int</span> sz[N], mx[N], C1[N], C2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> C[], <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++x;  <span class="comment">// 使得 x 不为 0 的技巧</span></span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += lowbit(x)) C[x] += v;  <span class="comment">// !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> C[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++x;  <span class="comment">// 查询也一定要啊！！！</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>, mx[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; (n &gt;&gt; <span class="number">1</span>)) ff = <span class="number">0</span>;</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        mx[x] = max(mx[x], sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n - sz[x]) &gt; (n &gt;&gt; <span class="number">1</span>)) ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ff &amp;&amp; !rt) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    add(C1, sz[fa], <span class="number">-1</span>);</span><br><span class="line">    add(C1, n - sz[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x ^ rt) &#123;</span><br><span class="line">        ans += <span class="number">1l</span>l * x * (ask(C1, n - <span class="number">2</span> * mx[x]) - ask(C1, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">        ans += <span class="number">1l</span>l * x * (ask(C2, n - <span class="number">2</span> * mx[x]) - ask(C2, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (mark[fa]) mark[x] = <span class="number">1</span>;</span><br><span class="line">        ans += rt * (sz[x] &lt;= n - <span class="number">2</span> * sz[mark[x] ? v : u]);  <span class="comment">// rt 的贡献直接维护</span></span><br><span class="line">    &#125;</span><br><span class="line">    add(C2, sz[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    add(C1, sz[fa], <span class="number">1</span>);</span><br><span class="line">    add(C1, n - sz[x], <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x ^ rt) &#123;</span><br><span class="line">        ans -= <span class="number">1l</span>l * x * (ask(C2, n - <span class="number">2</span> * mx[x]) - ask(C2, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) g[i].clear();</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            g[x].push_back(y), g[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = rt = <span class="number">0</span>;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dfs1(rt, <span class="number">0</span>);</span><br><span class="line">        u = v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[rt].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = g[rt][i];</span><br><span class="line">            <span class="keyword">if</span> (sz[x] &gt; sz[u]) v = u, u = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[x] &gt; sz[v]) v = x;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n + <span class="number">1</span>) C1[i] = C2[i] = <span class="number">0</span>, mark[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) add(C1, sz[i], <span class="number">1</span>);</span><br><span class="line">        mark[u] = <span class="number">1</span>;</span><br><span class="line">        dfs2(rt, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[PKUWC2018]-Minimax</title>
      <link href="2020/08/30/%5BPKUWC2018%5D-Minimax/"/>
      <url>2020/08/30/%5BPKUWC2018%5D-Minimax/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5298" target="_blank" rel="noopener">传送门</a></p><p>以前好像碰到过类似 dp 套路？离散化，$f[i, j]$ 表示第 $j$ 小的数留到了 $i$ 节点的概率。转移：</p><script type="math/tex; mode=display">f[i, j] = f[ls, j] * (p[i] * \sum\limits_{k = 1}^{j - 1} f[rs, k] + (1 - p[i]) * \sum\limits_{k = j + 1}^m f[rs, k]) + f[rs, j] * (p[i] * \sum\limits_{k = 1}^{j - 1} f[ls, k] + (1 - p[i]) * \sum\limits_{k = j + 1}^m f[ls, k])</script><p>发现每个叶子结点的权值都不同，且都只会贡献一次，<strong>想到线段树合并</strong>（注意要合并的东西必须是 $O(n)$ 及以下级别的，不然上不了线段树合并）。然后发现线段树可以很好地维护区间和、区间乘标记等东西！</p><p>（哇线段树合并复杂度是啥呀我又不会了）</p><p>好吧来看看，合并两颗线段树的复杂度约等于它们 <strong>重合</strong> 的点数，设树有 $n$ 个节点，线段长度是 $m$，总复杂度就是 $O(nlogm)$（感性理解就是每加进来一个点最多增加 $logm$ 的复杂度）</p><p>这类题，即用动态开点线段树优化的二维dp，有个新名词叫做“整体dp”！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, M = N * <span class="number">60</span>, inv = <span class="number">796898467</span>, P = mod;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>], h[N], val[N], ans, ls[M], rs[M], tag[M], f[M], rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x] != <span class="number">1</span>) &#123;</span><br><span class="line">        tag[ls[x]] = <span class="number">1l</span>l * tag[ls[x]] * tag[x] % mod;</span><br><span class="line">        tag[rs[x]] = <span class="number">1l</span>l * tag[rs[x]] * tag[x] % mod;</span><br><span class="line">        f[ls[x]] = <span class="number">1l</span>l * f[ls[x]] * tag[x] % mod;</span><br><span class="line">        f[rs[x]] = <span class="number">1l</span>l * f[rs[x]] * tag[x] % mod;</span><br><span class="line">        tag[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    f[x] = (f[ls[x]] + f[rs[x]]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx, tag[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[x] = <span class="number">1</span>; <span class="keyword">return</span>;  <span class="comment">// 概率是 100%</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) insert(ls[x], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> insert(rs[x], mid + <span class="number">1</span>, r, pos);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> la, <span class="keyword">int</span> ra, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (y) psd(y);</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; !y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">1l</span>l * p * lb % mod + <span class="number">1l</span>l * (<span class="number">1</span> - p + mod) % mod * rb % mod) % mod;</span><br><span class="line">        f[x] = <span class="number">1l</span>l * f[x] * t % mod;</span><br><span class="line">        tag[x] = <span class="number">1l</span>l * tag[x] * t % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">1l</span>l * p * la % mod + <span class="number">1l</span>l * (<span class="number">1</span> - p + mod) % mod * ra % mod) % mod;</span><br><span class="line">        f[y] = <span class="number">1l</span>l * f[y] * t % mod;</span><br><span class="line">        tag[y] = <span class="number">1l</span>l * tag[y] * t % mod;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = f[ls[x]], b = f[ls[y]];</span><br><span class="line">    <span class="keyword">int</span> cur = ++idx; tag[cur] = <span class="number">1</span>;</span><br><span class="line">    ls[cur] = merge(ls[x], ls[y], la, (ra + f[rs[x]]) % mod, lb, (rb + f[rs[y]]) % mod, p);</span><br><span class="line">    rs[cur] = merge(rs[x], rs[y], (la + a) % mod, ra, (lb + b) % mod, rb, p);</span><br><span class="line">    upd(cur);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!son[x][<span class="number">0</span>] &amp;&amp; !son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        insert(rt[x], <span class="number">1</span>, m, val[x]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        dfs(son[x][<span class="number">0</span>]);</span><br><span class="line">        rt[x] = rt[son[x][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(son[x][<span class="number">0</span>]), dfs(son[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1l</span>l * val[x] * inv % mod;</span><br><span class="line">    rt[x] = merge(rt[son[x][<span class="number">0</span>]], rt[son[x][<span class="number">1</span>]], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1l</span>l * l * h[l] % mod * f[x] % mod * f[x] % mod) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    calc_ans(ls[x], l, mid), calc_ans(rs[x], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (!son[x][<span class="number">0</span>]) son[x][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> son[x][<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>]) h[++m] = val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h + <span class="number">1</span>, h + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>])</span><br><span class="line">            val[i] = lower_bound(h + <span class="number">1</span>, h + m + <span class="number">1</span>, val[i]) - h;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    calc_ans(rt[<span class="number">1</span>], <span class="number">1</span>, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
            <tag> 概率与期望 </tag>
            
            <tag> 整体dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2012]-迷失游乐园</title>
      <link href="2020/08/29/%5BNOI2012%5D-%E8%BF%B7%E5%A4%B1%E6%B8%B8%E4%B9%90%E5%9B%AD/"/>
      <url>2020/08/29/%5BNOI2012%5D-%E8%BF%B7%E5%A4%B1%E6%B8%B8%E4%B9%90%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2081" target="_blank" rel="noopener">传送门</a></p><p>看起来巨复杂的一道期望嗷，但是基环树还是比较套路的</p><p>先考虑纯树的情况：设 $f[x]$ 为 $x$ 往下走的期望，$g[x]$ 为往上走的期望</p><p>$f[x] = \frac{1}{son[x]} \sum (f[y] + w(x, y))$，$g[y] = w(x, y) + \frac{g[x] + f[x] \times son[x] - (f[y] + w(x, y))}{son[x] - [x == root]}$ 注意分母可能为 0，要特判。<br>$ans[x] = \frac{f[x] \times son[x] + g[x]}{son[x] + [x \neq root]}$</p><p>好啦 50 分到手，再来想想基环树，发现环上节点好少啊，<strong>不管怎样先用同样的思路撕烤撕烤</strong></p><p>发现 $f$ 和不在环上的点的 $g$ 和 $ans$ 是一样计算的，环上点的 $g$ 搞出来以后可以把不在环上点的 $g$ 也算出来</p><p>对于环上点，对于两个方向都做一遍，以向左为例，$l[x] = \frac{l[nxt] + f[nxt]}{2}$, $g[x] = \frac{l[x] + r[x]}{2}$, $ans[x] = \frac{f[x] \times son[x] + g[x] \times 2}{son[x] + 2}$</p><p>就做完了</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, top, idx;</span><br><span class="line"><span class="keyword">int</span> stk[N], dfn[N], son[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt, w[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> f[N], g[N], ans;</span><br><span class="line"><span class="keyword">bool</span> onc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, w[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        ++son[x];</span><br><span class="line">        getf(y, x);</span><br><span class="line">        f[x] += f[y] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) f[x] /= son[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (son[x] == <span class="number">1</span>) &#123;</span><br><span class="line">                    g[y] = w[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g[y] = w[i] + (f[x] * son[x] - (f[y] + w[i])) / (son[x] - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] + f[x] * son[x] - (f[y] + w[i])) / son[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (onc[x]) &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] * <span class="number">2</span> + f[x] * son[x] - (f[y] + w[i])) / (son[x] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] + f[x] * son[x] - (f[y] + w[i])) / son[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getg(y, x, op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getf(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    getg(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ans = f[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">2</span>, n)</span><br><span class="line">        ans += (f[i] * son[i] + g[i]) / (son[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findcir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findcir(y, x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[y] &lt; dfn[x]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; stk[top] != y) onc[stk[top--]] = <span class="number">1</span>;</span><br><span class="line">            onc[y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --top;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || !onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (y == st) <span class="keyword">return</span> f[x];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (calc(y, x, st) + w[i] + f[x] * son[x]) / (son[x] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        g[x] += calc(y, x, x) + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    g[x] /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    findcir(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) getf(i, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) calcg(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) getg(i, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (!onc[i]) ans += (f[i] * son[i] + g[i]) / (son[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans += (f[i] * son[i] + g[i] * <span class="number">2</span>) / (son[i] + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) solve1();</span><br><span class="line">    <span class="keyword">else</span> solve2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】简单计数题选做（1）</title>
      <link href="2020/08/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E9%A2%98%E9%80%89%E5%81%9A%EF%BC%881%EF%BC%89/"/>
      <url>2020/08/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E9%A2%98%E9%80%89%E5%81%9A%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>容斥、$dp$ 什么的都是基础，我这块不扎实= = 不能就这么心甘情愿被区分了啊，总是要挣扎的对吧。</p><h2 id="LG6075"><a href="#LG6075" class="headerlink" title="LG6075"></a><a href="https://www.luogu.com.cn/problem/P6075" target="_blank" rel="noopener">LG6075</a></h2><hr><p>来做绿题了（。发现每个元素是独立的，那算一个的贡献然后 $n$ 次方就好了。发现一个元素取与不取的情况是左下角引一条向右或向上的折线，一直走直到到达边界，这样折线的方案数是 $2^k$，所以总方案就是 $(2^k)^n$。</p><h2 id="USACO20JAN-Cave-Paintings-P"><a href="#USACO20JAN-Cave-Paintings-P" class="headerlink" title="[USACO20JAN]-Cave Paintings P"></a><a href="https://www.luogu.com.cn/problem/P6008" target="_blank" rel="noopener">[USACO20JAN]-Cave Paintings P</a></h2><hr><p>发现填了一个就要填一块，想到并查集。我们从下往上合并，注意不连通块合并的时候，方案数是相乘的。</p><h2 id="HNOI2015-落忆枫音"><a href="#HNOI2015-落忆枫音" class="headerlink" title="[HNOI2015]-落忆枫音"></a><a href="https://www.luogu.com.cn/problem/P3244" target="_blank" rel="noopener">[HNOI2015]-落忆枫音</a></h2><hr><p>$DAG$ 的树形图个数是 $\prod in[i]$（感性理解就是每个点找一个$fa$，由于不会形成环，怎么找都是合理的，据说可以用矩阵树定理证但蒟蒻不会）用严谨的语言表达，这个定理是<strong>有向无环图的生成外向树个数为所有入度非 0 的点的入度乘积</strong></p><p>再考虑有环的情况，显然要减去一些有环存在的状态（这环一定包含新加进来的那条边啦） 即 $\frac{\prod in[i]}{\prod\limits_{i on circle} in[i]}$。$dp$, $g[x]$ 表示从 $ed$ 到 $x$ 的上面这个东西之和，所以 $g[x] = \frac{1}{in[x]}\sum\limits_y g[y]$。计算 $g$ 数组可以建反图 + 记忆化搜索（注意这里正反的智慧）所以答案就是 $(\prod in[i]) - g[st]$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6289]-花朵</title>
      <link href="2020/08/19/%5BLOJ6289%5D-%E8%8A%B1%E6%9C%B5/"/>
      <url>2020/08/19/%5BLOJ6289%5D-%E8%8A%B1%E6%9C%B5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6289" target="_blank" rel="noopener">传送门</a></p><p>看它 $id$ 跟我 $loj$ $id$ 相同就做了做 =&gt; 调了 $3h+$ 惨败</p><hr><p>$upd$：重构 $AC$ 啦= =</p><p>根据 $dp$ 方程交换二三两维可以得到：</p><script type="math/tex; mode=display">f[x, 0] = \prod (f[y, 0] + f[y, 1])</script><script type="math/tex; mode=display">f[x, 1] = \prod f[y, 0]</script><p>就 nm 像矩阵乘法！但是上树了。说个笑话，暴力卷是 $n^2logn$ 的（</p><p>部分分的链和菊花启示我们要优雅的卷，比如剖成链，每条链先单独卷</p><p>长链还是重链呢？当然是重链啦，一次卷积的时间复杂度取决于卷的数组大小，长链那深度差可大了。</p><p>细一点说，把轻链信息用分治卷 并到轻链顶点的父亲上，一次 $O(size(x)log^2size(x))$，由于 轻儿子点数和$=\sum size(x) = O(nlogn)$，所以总共就是 $O(nlog^3n)$；再用分治卷 卷重链，总共 $O(nlog^2n)$（这里要注意，之前卷轻链的时候只要顾及轻链顶点和父亲的 $0$/$1$ 是否合法，卷重链的时候还要顾及两部分接口处的 $0$/$1$ 是否合法，所以要维护当前段的首尾是否为 $1$）</p><p>就做完啦，厚厚！三只 $log$ 三只 $log$ 跑得快跑得快 ~</p><p><a href="https://loj.ac/s/1020721" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2020网络同步赛体验记</title>
      <link href="2020/08/18/NOI2020%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C%E8%AE%B0/"/>
      <url>2020/08/18/NOI2020%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="$Day1$"></a>$Day1$</h2><hr><p>勤勤恳恳的扣了 114 分，取模错误 wa + 字母打错，fst 成 82 分。。。好难受啊</p><p>整整 32 分啊。这如果是联赛，谁担的起呢。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="$Day2$"></a>$Day2$</h2><hr><p>勤勤恳恳的抠了 ？分（对我自己都不确定正确性），民间数据还没出（出了也不测 qvq）</p><h2 id="出成绩了"><a href="#出成绩了" class="headerlink" title="出成绩了"></a>出成绩了</h2><hr><p>108</p><hr><p>【此处应有题解】</p><hr><p>来补了。</p><h2 id="D1T1-美食家"><a href="#D1T1-美食家" class="headerlink" title="$D1T1. 美食家$"></a>$D1T1. 美食家$</h2><p>我想到矩阵快速幂了！写出 $5n$ 个点的转移柿子了！甚至想到预处理 $2^i$ 的矩阵、行向量去乘是 $n^2$ 的了！</p><p>但我没写出来。。。好吧，不会就是不会，复杂度是 $O((5n)^3 log T + (5n)^2 log T \times K)$。你别看他有 4e8，人家是 O(能过) 耶= =</p><p>upd：考场代码分段乘的时候额外贡献加错位置了= = 我哭</p><p><a href="https://loj.ac/submission/927790" target="_blank" rel="noopener">$Code$</a></p><h2 id="D1T2-命运"><a href="#D1T2-命运" class="headerlink" title="$D1T2. 命运$"></a>$D1T2. 命运$</h2><p><a href="https://imilyx.github.io/2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">链接</a></p><h2 id="D1T3-时代的眼泪"><a href="#D1T3-时代的眼泪" class="headerlink" title="$D1T3. 时代的眼泪$"></a>$D1T3. 时代的眼泪$</h2><p>咕咕</p><h2 id="D2T1-制作菜品"><a href="#D2T1-制作菜品" class="headerlink" title="$D2T1. 制作菜品$"></a>$D2T1. 制作菜品$</h2><p>先将 $d$ 排序。</p><p>发现大数据范围里有 $n - 2 \leq m$，部分分 $m = n - 1$ 似乎很有未来。</p><p>考虑部分分 $m = n - 1$，$d_1$ 一定是 $&lt; k$ 的，为什么呢？如果 $d_1 \geq k$, 那么 $\sum d_i \geq n times k &gt; (n - 1) times k = m \times k = \sum d_i$，矛盾。每次削掉第一项，$n$ 转化成 $n - 1$，一定能够构造出来。同时 $d_1 + d_n \neq k$，用反证法也可以证明。</p><p>考虑 $m \geq n$ 时，$d_n \geq k$，证明方法同上面类似。于是将 $d_n -= k$，<strong>就转化成了 $m = n - 1$ 的问题</strong></p><p>最后一步！$m = n - 2$ 怎么搞。。可以证明，$m = n - 2$ 有解的充要条件是可以划分为两个 $m = n - 1$ 的子问题。充分性很好证，必要性就比较妙：考虑一个 n 个点的图，菜品视为边，那么最多只有 n - 2 条边，不会连通，此时必然存在至少两个连通块是树的形态——为什么？如果是环，边就不够用了。</p><p>实现的话，设 $S$ 是分出来的集合之一，$sz = |S|$, 那么 $\sum\limits_{i \in S} d_i = (sz - 1) \times k$，$\sum\limits_{i \in S} (d_i - k) = -k$，这是个 dp，$f[i, j]$ 表示前 i 个任意取能否使得总和为 j，bitset 维护, $O(\frac{n \times (n \times k)}{w})$</p><p><a href="https://loj.ac/submission/927794" target="_blank" rel="noopener">$Code$</a></p><h2 id="D2T2-超现实树"><a href="#D2T2-超现实树" class="headerlink" title="$D2T2. 超现实树$"></a>$D2T2. 超现实树$</h2><p>这题好 AT 的样子，结果是道结论题（脑子不好 死也想不出啊。。</p><p><a href="https://www.luogu.com.cn/blog/startd/solution-p6776" target="_blank" rel="noopener">大佬思路</a></p><p>“几乎完备”这种关系可以传递。太妙了吧！！！！！！！！！</p><p><a href="https://loj.ac/submission/927797" target="_blank" rel="noopener">$Code$</a></p><h2 id="D2T3-翻修道路"><a href="#D2T3-翻修道路" class="headerlink" title="$D2T3. 翻修道路$"></a>$D2T3. 翻修道路$</h2><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 659 Div1</title>
      <link href="2020/08/15/Codeforces%20Round%20659%20Div1/"/>
      <url>2020/08/15/Codeforces%20Round%20659%20Div1/</url>
      
        <content type="html"><![CDATA[<p>最近的场子，做一下。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>贪心就好了？也可以并查集维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, num[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (a[i] &gt; b[i]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ff) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">                num[a[i] - <span class="string">'a'</span>][b[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, <span class="number">25</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i][j]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    num[i][j] = <span class="number">0</span>;</span><br><span class="line">                    rep(k, j + <span class="number">1</span>, <span class="number">25</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (num[i][k]) &#123;</span><br><span class="line">                            num[j][k] += num[i][k], num[i][k] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>发现如果有一位 1 的个数是奇数就必然不会平局，然后分类讨论就好了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>C 和 A 的区别在于 C 有环。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO2020 体验记</title>
      <link href="2020/08/15/APIO2020%20%E4%BD%93%E9%AA%8C%E8%AE%B0/"/>
      <url>2020/08/15/APIO2020%20%E4%BD%93%E9%AA%8C%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>平心而论，这一场的暴力并不比 APIO2019 少很多，所以如果策略不失误的话几十分是肯定有的。但是一直在刚 T1，期间短暂的思考过 T2，T1 不知道是什么恶心数据把我卡了= = 于是就爆 0 了 没有体会到拿分的快感</p><p>所以<strong>策略</strong>是多么重要啊，<strong>开题顺序</strong>不会永远是 1-&gt;2-&gt;3 的啊。</p><p>下面就放一些订正的题解吧。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>预处理 + 单调队列，最优性问题 -&gt; 判定性问题</p><p>由于保证了 $\sum f(k)^2 \leq 4e5$，所以 $max(f(k))$ 最大就 600 多，虽然很粗糙但这是我们得到的最为有效的信息</p><p>只讲预处理。$dp[i, j]$ 表示到位置 $i$、承包商 $j$ 的最大粉刷长度，$dp[i, j] \geq m$ 那 $[i - m + 1, i]$ 就能被粉刷。</p><p>$dp[i, j] = dp[i - 1, (j - 1 + m) \% m] + 1(j \in c_i)$，这样时空都是 $O(nm)$ 的，空间可以滚动数组优化，时间可以用 $vector$ 存每个位置合法的 $j$，这样大概是 $O(n * max(f(k)))$，稳得很</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"paint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, C[N], A[M], B[N], f[<span class="number">2</span>][M], dp[N], q[N], l, r;</span><br><span class="line"><span class="keyword">bool</span> valid[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, a, id[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumInstructions</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> K, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, m - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, a[i] - <span class="number">1</span>) &#123;</span><br><span class="line">            id[b[i][j]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        x ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; id[c[i - <span class="number">2</span>]].size(); k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = id[c[i - <span class="number">2</span>]][k];</span><br><span class="line">                f[x][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; id[c[i]].size(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id[c[i]][k];</span><br><span class="line">            f[x][j] = f[x ^ <span class="number">1</span>][(j - <span class="number">1</span> + m) % m] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[x][j] &gt;= m) valid[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &lt; i - m) ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r &amp;&amp; valid[i - <span class="number">1</span>]) dp[i] = dp[q[l]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; dp[q[r]] &gt;= dp[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] &gt; <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>求的是最小非链状瓶颈路，可以在求最小瓶颈路的算法——$kruskal$重构树上略作修改。</p><p>具体来说，加边的时候就不要舍弃边了，都加上。考虑$kruskal$重构树的性质，一个点权为 $w$ 的节点子树内的点组成一个边权不超过 $w$ 的连通块。对于每个重构树上的节点，维护一个标记表示它对应的连通块是否是非链状路。非链状路的关系可以传递，即如果儿子的标记 $= 1$ 那么父亲的标记也 $= 1$。每次询问倍增找第一个标记 $= 1$ 的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, U[N], V[N], W[N], f[N][<span class="number">21</span>], fa[N], idx, deg[N], dep[N], val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u, v, w, g[N];</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, z; &#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.z &lt; b.z; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    idx = n;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getfa(e[i].x), y = getfa(e[i].y), z = e[i].z;</span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            val[idx] = z;</span><br><span class="line">            f[x][<span class="number">0</span>] = idx;</span><br><span class="line">            fa[x] = fa[idx] = idx;</span><br><span class="line">            mark[idx] = <span class="number">1</span>;</span><br><span class="line">            g[idx].push_back(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val[idx] = z;</span><br><span class="line">            f[x][<span class="number">0</span>] = f[y][<span class="number">0</span>] = idx;</span><br><span class="line">            fa[x] = fa[y] = fa[idx] = idx;</span><br><span class="line">            <span class="keyword">if</span> (mark[x] || mark[y] || (++deg[e[i].x]) &gt; <span class="number">2</span> || (++deg[e[i].y]) &gt; <span class="number">2</span>)  <span class="comment">// 子树中存在非链状块</span></span><br><span class="line">                mark[idx] = <span class="number">1</span>;</span><br><span class="line">            g[idx].push_back(x), g[idx].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mark[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    rep(j, <span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, idx)</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> mm,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w)</span> </span>&#123;</span><br><span class="line">    n = nn, m = mm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        e[i + <span class="number">1</span>] = (edge)&#123;u[i] + <span class="number">1</span>, v[i] + <span class="number">1</span>, w[i]&#125;;</span><br><span class="line">    Kruskal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumFuelCapacity</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xy = lca(++x, ++y);</span><br><span class="line">    <span class="keyword">if</span> (mark[xy]) <span class="keyword">return</span> val[xy];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!mark[f[xy][i]]) xy = f[xy][i];</span><br><span class="line">    xy = f[xy][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> xy ? val[xy] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>咕咕？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200814 题解</title>
      <link href="2020/08/14/XJOI200814%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/14/XJOI200814%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>今天赛 1 是联赛难度。感到自己有很多不足。</p><p>赛2：什么叫做乱搞啊 /kk</p><p><a href="http://115.236.49.52:83/contest/1587" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1588" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>没想出来但这种题有可能会出现在正式赛场上，<strong>所以要会乱搞啊！</strong></p><p>正解就是选出 K / m 个整行加上 K % m 个在同一行的元素。</p><p>有个伪证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a, b, c, d), e, f</span><br><span class="line">(h, i, j), k, l, m</span><br><span class="line"></span><br><span class="line">划了括号的是选的。</span><br><span class="line">1. j = e 那么不选 (i, j) 改选 (e, f) 不会更劣</span><br><span class="line">2. j &gt; e 不选 (i, j) 改选 (e, f)</span><br><span class="line">3. j &lt; e 那么 b &gt;= c &gt;= d &gt;= e &gt; j &gt;= k &gt;= l &gt;= m，不选 (b, c, d) 改选 (k, l, m)</span><br><span class="line">所以大概可以说明两行可以合并成一行，即必须取满其中一行。</span><br></pre></td></tr></table></figure></p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>图论今天真的要刷起来了，这题 lca 搞一搞就好了啊！都忘光了。。。树上路径就是到 lca 的路径啊。。。</p><p>那么分两种情况：</p><ul><li>$lca(c, d)$ 在 $lca(a, b)$ 子树中：发现 $lca(c, d)$ 不在 $a$ 到 $b$ 路径上即可</li><li>$lca(c, d)$ 不在 $lca(a, b)$ 子树中：$c$ 到 $d$ 的路径不经过连接 $lca(a, b)$ 和 $fa[lca(a, b)]$ 的边即可</li></ul><p>于是预处理一波就可以了。</p><p>（xj数据水，我一个 $O(n(nq + n^2))$ 的暴力跑过去了。。。。）</p><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>神仙构造（noip考构造吗）显然 $S &gt; \frac{n(n - 1)}{2}$ 的时候无解。然后还不会。。咕咕</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>这很 Atcoder 啊。。神仙构造 + 大乱搞题？咕咕</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>竟然给我乱搞出来了！考虑操作序列是形如 $(((S + k_1a)b + k_2a)b + k_3a)b + …$ 这样的。我们枚举有几个 $b$（显然只有 log 种），就变成类似于进制，所以要让 $\sum_i k_i$ 最小，只要“能减则减”就可以了。</p><p>—-分割线—-</p><p>我错了。这题没有一点素质，它的重点根本就是分类讨论，我吐了 思博题💢</p><p>!s   !t   s &lt; t   !a   !b   b = 1 这些你都判了吗</p><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>傻了傻了，枚举<strong>第一个</strong>a、b、c出现的位置就好了呗！这是 $O(n^3)$ 的，然后 $O(n^2)$ 的用树状数组维护就好了（？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200813 题解</title>
      <link href="2020/08/13/XJOI200813%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/13/XJOI200813%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>又是一天两场的 XJOI noi 模拟赛，每天都是暴力选手 被吊着打 /kk</p><p><a href="http://115.236.49.52:83/contest/1583" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1585" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>写了 $n^2$ 的 dp，一遍过样例好评（。）正解是 dp 优化，然而这题 dp 有很多种，我这种没法优化的样子（看起来很笨！）</p><p><a href="https://www.cnblogs.com/Flying2018/p/13498384.html" target="_blank" rel="noopener">来看看flying2018大佬的题解</a></p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>暴力没写就特别不应该。模并不会对正确性有影响。。。30分还是很好拿到的。考虑 $gcd = 1$ 的那档子分，画一画图找规律就好了呗，60分也不难啊。</p><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>60分这么香你为什么不写？啊？啊？？啊？？！$T = 2$ dp, $f[i, j]$ 表示第 $i$ 个区间能否和第 $i + 1$ 个区间交换；$l_i = i$ 的那档子分打个表找规律就出来了，$g[i] = 2g[i - 1] + i - 2$</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>题目好像出锅了，咕咕</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>不会，咕咕</p><p>—-分割线—-</p><p>来订正了。思维有点难度但并不是很毒的图论题，图论我太菜了啊 /kk 专题要刷起来了！</p><p>显然操作二和三建反图预处理一波就好了，难点在操作一。原题是 <a href="https://www.luogu.com.cn/problem/P3573" target="_blank" rel="noopener">[POI2014]RAJ-Rally</a></p><p>考虑 DAG 的性质。设 x 的拓扑序为 dfn[x], 对于一条边 (x, y) 显然 dfn[x] &lt; dfn[y]。强制走 (x, y) 的话显然拓扑序在 dfn[x] ~ dfn[y] 之间的点都不会经过，于是想到用 (x, y) 来更新那些点。</p><p>具体来说，设拓扑序比 x 小的集合为 A，比 x 大的集合为 B，以 x 为终点的最长路径为 dt[x]，为起点的最长路径为 ds[x], $f[x] = \max\limits_{(u, v) \in E, u \in A, v \in B}(dt[u] + 1 + ds[v])$</p><p>预处理这个 f, 发现每次 x 增大，A 只会多一个数，B 只会少一个数，可以动态维护最大值。</p><p><a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p3573" target="_blank" rel="noopener">这篇博客的图非常清晰，可以帮助理解动态维护的过程</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"><span class="keyword">int</span> degt[N], degs[N], dt[N], ds[N], ans[N], id[N], tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;e[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gt[N], gs[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        e[i].x = x, e[i].y = y;</span><br><span class="line">        degt[y]++, degs[x]++;</span><br><span class="line">        gt[x].push_back(y), gs[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!degt[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        id[++tot] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gt[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gt[x][i];</span><br><span class="line">            dt[y] = max(dt[y], dt[x] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(--degt[y])) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!degs[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gs[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gs[x][i];</span><br><span class="line">            ds[y] = max(ds[y], ds[x] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(--degs[y])) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) s.insert(ds[i]);</span><br><span class="line">    rep(o, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = id[o];</span><br><span class="line">        s.erase(s.find(ds[x]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gs[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gs[x][i];</span><br><span class="line">            s.erase(s.find(ds[x] + <span class="number">1</span> + dt[y]));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] = *s.rbegin();</span><br><span class="line">        s.insert(dt[x]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gt[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gt[x][i];</span><br><span class="line">            s.insert(dt[x] + <span class="number">1</span> + ds[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ty, x; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ty, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ty == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dt[x] + ds[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dt[e[x].x] + ds[e[x].y] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>min25筛和暴搜均可 AC（雾）不会 min25 就只能写暴搜啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll n, P;</span><br><span class="line">ll mark[N], p[N], tot, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) p[++tot] = i, cnt[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; j++) &#123;</span><br><span class="line">            mark[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; tot || x * p[t] &gt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x * p[t] * p[t] &gt; n) <span class="keyword">return</span> cnt[min(P, n / x)] - t + <span class="number">2</span>;  <span class="comment">// 优秀的剪枝们</span></span><br><span class="line">    ll ret = dfs(x, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (; x * p[t] &lt;= n; ) &#123;</span><br><span class="line">        x *= p[t];</span><br><span class="line">        ret += dfs(x, t + <span class="number">1</span>);</span><br><span class="line">        x *= p[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; P;</span><br><span class="line">    sieve(P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200812 题解</title>
      <link href="2020/08/12/XJOI200812%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/12/XJOI200812%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>丧心病狂，打了两场提（n）高（o）组（i）模拟赛。。。一天就这么没了【哭】</p><p><a href="http://115.236.49.52:83/contest/1578" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1579" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>不用 Boruvka，直接 Kruskal，从大到小枚举边权然后能连则连。</p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>神仙题！（也可能只是我不会线性代数¯\_(ツ)_/¯）原题是 <a href="https://www.luogu.com.cn/problem/CF388D" target="_blank" rel="noopener">CF388D</a></p><p>考虑异或 一般来说 就是 Trie 和线性基</p><p>诶？线性基好像可以！本题相当于给一组线性基就能产生一堆异或值，线性基和异或值共同组成集合</p><p>一组线性基对应一个集合，但<strong>一个集合可以有多组线性基</strong>，如果能让集合和线性基一一对应，集合的计数就转化成了线性基的计数</p><p>根据“特征点”的思想，我们对每组线性基高斯消元。可以证明高消后，不同的线性基生成的集合一定不同。</p><p>接下来对线性基做 dp 就好了。注意，高消后线性基能异或出来的最大值就是所有元素的异或值</p><p>dp 的状态设计：dp[i, j, k] 表示从最高位到第 i 位选了 j 个基，异或得到的最大值是否顶到上界（是则 k = 1，否则 k = 0）有点类似于数位 dp</p><p><a href="https://blog.csdn.net/C202044zxy/article/details/106119810" target="_blank" rel="noopener">细节</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, dp[<span class="number">32</span>][<span class="number">32</span>][<span class="number">2</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">30</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">30</span> - i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// k = 0</span></span><br><span class="line">            add(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i][j][<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; j) % mod);</span><br><span class="line">            add(dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>], dp[i][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// k = 1</span></span><br><span class="line">            ll x = (j == <span class="number">0</span> ? <span class="number">1</span> : (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))), y = (j == <span class="number">0</span> ? <span class="number">0</span> : (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], x * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], y * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>], dp[i][j][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], x * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">30</span>) add(ans, (dp[<span class="number">0</span>][i][<span class="number">0</span>] + dp[<span class="number">0</span>][i][<span class="number">1</span>]) % mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>先决题目是 [ZJOI2016]-旅行者，这里写一下题解</p><p>网格图可以分治！找到矩形的长边，用一条中轴线切成两半，当前分治的区间是 (lx, ly) (rx, ry)，处理的询问是 (ql, qr)（类似于整体二分）。对于每个询问：</p><ul><li>起始点在中轴线两侧，对于中轴线上每个点跑最短路更新答案</li><li>起始点在一侧，<strong>可能</strong>最短路也经过中轴线，也更新一波，再递归分治</li></ul><p>卡了小常，加了玄学头文件<br><a href="https://blog.csdn.net/neither_nor/article/details/51733997" target="_blank" rel="noopener">复杂度是 O(S logS sqrt(S))</a><br><a href="https://www.luogu.com.cn/discuss/show/74578" target="_blank" rel="noopener">如果没看懂这里还有一个（还是不懂。。</a></p><p>—-分割线—-</p><p>本题的区别就是有修改啦。我们可以知道每个格子变为不能走的时间（这个整体二分做），定义一条路径的值为这条路径上格子不能走时间的最小值，那我们就需要找一条值最大的路径看这个值是否大于询问的时间。离线，用旅行者的 分治 + dp 做。然而不会写代码，我只会咕咕</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>只会 16 分 O(nT)，告辞（咕咕</p><p><a href="https://www.luogu.com.cn/paste/a8hdc624" target="_blank" rel="noopener">正解是斯特林数相关？？？我谔谔</a></p><p>最后就是个卷积形式了。</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>莫反就有 60 分，可惜 T 了一个点</p><p>正解 要用 ODT 维护？？？我谔谔</p><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>神仙计算几何题，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 047 题解</title>
      <link href="2020/08/11/AGC%20047%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/11/AGC%20047%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>容易想到乘上 1e9，那么意味着相乘得到的数是 1e18 的倍数。即因子中 2 和 5 的个数都 &gt;= 18，开个桶随便做一下。【注意读入，我没用字符串就 wa 了 qvq 没试过 long double 不知道行不行</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易发现若 T 能和 S 匹配，把 T 第一个字符去掉以后就是 S 的一个后缀。</p><p>题目只给出了<strong>总</strong>串长！这启发我们想到结合 Trie 树等结构实现一个 O(n) 的算法。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>对多项式大师来说是套路题，对我来说。。qvq</p><p>容易想到枚举模后乘积。</p><script type="math/tex; mode=display">F(x) = \sum [a_i == x]</script><script type="math/tex; mode=display">ans = \sum\limits_d d \sum_{(xy\bmod P == d)}F(x)F(y)</script><p>我们想到了卷积，但这还不是卷积形式，于是再化一步：</p><script type="math/tex; mode=display">F(x) = \sum [g^{a_i} == x]</script><p>其中 g 是 P 的原根之一</p><script type="math/tex; mode=display">ans = \sum\limits_d g^d \sum_{((x + y)\bmod P == d)}F(x)F(y)</script><p>那这就是个循环卷积啦。</p><p>关于原根：原根的定义和性质：对于任何 $0$ ~ $P - 1$ 中的数 $i$、$j$($i \neq j$), 有 $g^i \neq g^j(\bmod P)$，即 $g^i$ 在 mod P 意义下可以取遍 $0$ ~ $P - 1$ 所有数。</p><p>关于找原根：原根很小，一般在 100 以内，枚举，若存在 P 的因子 x 使得 $g^{\frac{P - 1}{x}} \equiv 1 (\bmod P)$ 那么 g 就不是原根。否则就是。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>咕咕</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>咕咕</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】概率与期望</title>
      <link href="2020/08/11/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"/>
      <url>2020/08/11/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快乐期望 ~</span><br></pre></td></tr></table></figure><p>期望题往往应用到了期望的线性性质，可以说是解题的基础。</p><p>在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp</p><h2 id="套路1-直接递推-dp"><a href="#套路1-直接递推-dp" class="headerlink" title="套路1. 直接递推/dp"></a><strong>套路1. 直接递推/dp</strong></h2><hr><h3 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="$[NOI2005]-聪聪与可可$"></a><a href="https://www.luogu.com.cn/problem/P4206" target="_blank" rel="noopener">$[NOI2005]-聪聪与可可$</a></h3><p>简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能到达的。<strong>猫和鼠的距离不断减少</strong>，所以状态不会形成环，记忆化搜索就好了。</p><h3 id="SCOI2008-奖励关"><a href="#SCOI2008-奖励关" class="headerlink" title="$[SCOI2008]-奖励关$"></a><a href="https://www.luogu.com.cn/problem/P2473" target="_blank" rel="noopener">$[SCOI2008]-奖励关$</a></h3><p>n 这么小一定是状压啦。首先要明确的是，抛出什么宝物是随机的，但选择与否是我们决定的，也就是说我们要求<strong>最优策略下的最大期望得分</strong></p><p>$f[i, S]$ 表示前 $i - 1$ 轮取到的状态为 $S$，$i$ ~ $K$ 轮的最大期望得分。那么就有 </p><script type="math/tex; mode=display">f[i, S] = \frac{1}{n}(\sum\limits_{k\ is\ valid} max(f[i + 1, S], f[i + 1, S | (1 << (k - 1))] + p_k) + \sum\limits_{k\ isn't\ valid} f[i + 1, S])</script><h3 id="清华集训2017-小-Y-和恐怖的奴隶主"><a href="#清华集训2017-小-Y-和恐怖的奴隶主" class="headerlink" title="$[清华集训2017]-小 Y 和恐怖的奴隶主$"></a><a href="https://www.luogu.com.cn/problem/P4007" target="_blank" rel="noopener">$[清华集训2017]-小 Y 和恐怖的奴隶主$</a></h3><p>n 这么大一定是矩阵快速幂优化 dp 啦（雾）。以 $m = 3$ 为例，设 $f[i, a, b, c]$ 表示 $i$ 轮攻击后有 $a$ 个 1 血随从、$b$ 个 2 血随从、$c$ 个 3 血随从的概率，转移方程就很好想。。然后发现这个东西状态数是 166, 复杂度 $O(T166^3logn)$，考虑把 $2^i$ 的矩阵预处理出来，每次询问就只需用一个行向量去乘 logn 次矩阵，复杂度就变成了 $O(T166^2logn)$，然后还要卡很多常。。。所以这是道毒题</p><h2 id="套路2-无限循环转递推"><a href="#套路2-无限循环转递推" class="headerlink" title="套路2. 无限循环转递推"></a><strong>套路2. 无限循环转递推</strong></h2><hr><p>（这部分好神仙的！要巧妙设计状态，或者错位相减法（等比数列求和必备技能）等方法化柿子 qvq）</p><h3 id="SHOI2002-百事世界杯之旅"><a href="#SHOI2002-百事世界杯之旅" class="headerlink" title="$[SHOI2002]-百事世界杯之旅$"></a><a href="https://www.luogu.com.cn/problem/P1291" target="_blank" rel="noopener">$[SHOI2002]-百事世界杯之旅$</a></h3><p>应用极限的思想 <a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p1291" target="_blank" rel="noopener">题解</a></p><h3 id="六省联考2017-分手是祝愿"><a href="#六省联考2017-分手是祝愿" class="headerlink" title="$[六省联考2017]-分手是祝愿$"></a><a href="https://www.luogu.com.cn/problem/P3750" target="_blank" rel="noopener">$[六省联考2017]-分手是祝愿$</a></h3><p>看起来很神的期望题</p><p>首先 50 分从后往前取，好拿吧</p><p>考虑正解！从后往前取会确定一些<strong>必须要取</strong>的键，那么就相当于除开这些键 按了其他的键 <strong>就得按同一个键按回来</strong>，相当于多了一个必须要按的键（所以 f 的预处理得从 n，不能从 cnt 开始！）。所以 dp 的状态就是 f[i] 表示从 i 个必选的键转移到 i - 1 个必选的键的期望操作次数</p><script type="math/tex; mode=display">f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])</script><p>第一项表示选了一个必选的，一次就到 i - 1 去了；</p><p>第二项表示选了一个其他的，就得 f[i + 1] 次按回来，再 f[i] 次按到 i - 1 去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100003</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, cnt, res;</span><br><span class="line">ll col[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    col[j] ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j * j != i) col[i / j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)  <span class="comment">// !!! 从 n 开始</span></span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] * (ll)(n - i) % mod + n) % mod * quick_pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= K) res = cnt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt; K; --i) res = (res + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) res = res * (ll)i % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UVA10529-Dumb-Bones"><a href="#UVA10529-Dumb-Bones" class="headerlink" title="$[UVA10529]-Dumb Bones$"></a><a href="https://www.luogu.com.cn/problem/UVA10529" target="_blank" rel="noopener">$[UVA10529]-Dumb Bones$</a></h3><p>太神仙了吧woc</p><p>考虑<strong>单独</strong>一张骨牌摆放成功的期望次数 E</p><p>玄学化柿子（感性理解）</p><script type="math/tex; mode=display">E = 1 + pl(1 + pl(...) + pr(...)) + pr(1 + pl(...) + pr(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr)(1 + (pl + pr)(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr) + (pl + pr)^2 + (pl + pr)^3 ... + (pl + pr)^{\infty}</script><script type="math/tex; mode=display">= \frac{1}{1 - pl - pr}</script><p>（别化晕了</p><p>考虑连续的 x 张骨牌成功的期望。<strong>注意采取最优策略</strong></p><p>放第 x 张骨牌时，如果向左/右，就要花费一些步数去扶起左/右边的骨牌。后面那坨东西，根据<strong>期望的线性性质</strong></p><script type="math/tex; mode=display">f[x] = \min\limits_{i = 1}^x\{f[i - 1] \times \frac{1 - pr}{1 - pl - pr} + f[x - i] \times \frac{1 - pl}{1 - pl - pr} + \frac{1}{1 - pl - pr}\}</script><p>以往左倒为例解释一下：左边要重搭 $f[i - 1] \times [往左倒的期望次数] = f[i - 1] \times (E - 1) \times \frac{pl}{pl + pr}$，注意这是重搭的，初始还有一次，所以是 $f[i - 1] \times \frac{1 - pr}{1 - pl - pr}$</p><p>就做完了。uva 数据只有一组，非常的水，我怕了，题解柿子都不一样。</p><p>感想就是，<strong>期望的线性性质真的太重要了！</strong> 不然这种互相影响的问题就没法做了。</p><h3 id="CF908D-New-Year-and-Arbitrary-Arrangement"><a href="#CF908D-New-Year-and-Arbitrary-Arrangement" class="headerlink" title="$[CF908D]-New Year and Arbitrary Arrangement$"></a><a href="https://www.luogu.com.cn/problem/CF908D" target="_blank" rel="noopener">$[CF908D]-New Year and Arbitrary Arrangement$</a></h3><p>这题的关键在处理边界啦。</p><p>容易发现我们需要记录的是当前 a 和 ab 的数量。设 f[i, j] 表示 i 个 a，j 个 ab，那么 $f[i, j] = \frac{pa}{pa + pb}f[i + 1, j] + \frac{pb}{pa + pb}f[i, i + j]$</p><p>开头无限多个 b 怎么办？忽略掉，因为对 ab 的数量没有影响。</p><p>结尾无限多个 a 怎么办？这个就要搞一搞了。如果 i + j &gt;= k，那么只要加一个 b 就能结束。设 $P_a = \frac{pa}{pa + pb}$, $P_b = \frac{pb}{pa + pb}$</p><script type="math/tex; mode=display">f[i, j] = P_b \sum\limits_{k = 0}^{\infty} P_a^k (i + j + k)</script><script type="math/tex; mode=display">= P_b\sum\limits_{k = 0}^{\infty} P_a^k \times k + P_b(i + j)\sum\limits_{k = 0}^{\infty}P_a^k</script><script type="math/tex; mode=display">= i + j + \frac{P_a}{P_b}</script><h3 id="「PKUWC2018」猎人杀"><a href="#「PKUWC2018」猎人杀" class="headerlink" title="$「PKUWC2018」猎人杀$"></a><a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">$「PKUWC2018」猎人杀$</a></h3><p>很妙的概率题。</p><p>分母是变化的，很不好求。</p><p>问题可以转化一波，变成：死掉的猎人依旧算在概率里面，每一轮一直开枪直到射死一个没死过的猎人。这样每次能选的就是全集了。</p><p>设 $W = \sum w_i$, $T = \{w_i | (i has died)\}$, $sum(T) = \sum\limits_{i has died} w_i$</p><p>转化前射死 $i$ 的概率 $P = \frac{wi}{(W - T)}$</p><p>转化后射死 $i$ 的概率 $P = \frac{T}{W}P + \frac{wi}{W} = \frac{wi}{W - T}$</p><p>两者相等。</p><p>。</p><p>。</p><p>然后考虑容斥，钦定一个不包含 1 的猎人集合 T 在 1 之后死去。除了集合 T 和猎人 1 以外的剩余的猎人不用考虑，因为他们可以任意摆放在 1 的前面后面（也就是说概率是 1）</p><p>集合为 T 的人在 1 后面死的概率：</p><script type="math/tex; mode=display">P = \frac{w_1}{W}\sum\limits_{i = 0}^{\infty} (1 - \frac{sum(T) + w_1}{W})^i = \frac{w_1}{sum(T) + w_1}</script><p>容斥</p><script type="math/tex; mode=display">ans = \sum\limits_{T} (-1)^{|T|} \frac{w_1}{sum(T) + w_1}</script><p>枚举 $T$ 再背包预处理容斥系数可以做到 $n^2$，50 pts：</p><script type="math/tex; mode=display">ans = \sum\limits_{num = 0}^{W} \frac{w_1}{num + w_1} (\sum\limits_T (-1)^{|T|} [sum(T) == num])</script><p>好妙【吐血而亡</p><p>100 pts 的话就是后面那坨容斥系数用分治的 NTT 卷一下了（下标是 T），注意不是 cdq 分治，就是普通的分治。或者也可以堆优化，即每次选两个长度最小的卷。nlog^2n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, w[N], lim, sum[N], stk[<span class="number">32</span>], top, g[<span class="number">32</span>][N], ans, f[N], L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll f[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>, f[w[l]] = mod - <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ls, rs;</span><br><span class="line">    ls = stk[top--], solve(g[ls], l, mid);</span><br><span class="line">    rs = stk[top--], solve(g[rs], mid + <span class="number">1</span>, r);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= sum[r] - sum[l - <span class="number">1</span>]) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    get_rev();</span><br><span class="line">    NTT(g[ls], <span class="number">1</span>), NTT(g[rs], <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) f[i] = g[ls][i] * g[rs][i] % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) g[ls][i] = g[rs][i] = <span class="number">0</span>;</span><br><span class="line">    stk[++top] = ls, stk[++top] = rs;  <span class="comment">// 垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]), sum[i] = sum[i - <span class="number">1</span>] + w[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) stk[++top] = i;</span><br><span class="line">    solve(f, <span class="number">2</span>, n);</span><br><span class="line">    rep(i, <span class="number">0</span>, sum[n] - w[<span class="number">1</span>])</span><br><span class="line">        ans = (ans + w[<span class="number">1</span>] * quick_pow(i + w[<span class="number">1</span>], mod - <span class="number">2</span>) % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="套路3-高斯消元"><a href="#套路3-高斯消元" class="headerlink" title="套路3. 高斯消元"></a><strong>套路3. 高斯消元</strong></h2><hr><p>终于到了我最喜欢的部分 ~ 高消！</p><p>我纠结了很久的问题：图上游走问题 是以出发点度数作为分母还是终点度数作为分母，但这其实应题而异，主要跟你设计的 dp 状态有关。</p><h3 id="USACO10HOL-Driving-Out-the-Piggies-G"><a href="#USACO10HOL-Driving-Out-the-Piggies-G" class="headerlink" title="$[USACO10HOL]-Driving Out the Piggies G$"></a><a href="https://www.luogu.com.cn/problem/P2973" target="_blank" rel="noopener">$[USACO10HOL]-Driving Out the Piggies G$</a></h3><p>$f[x]$ 表示走到 x 不爆炸的概率（爆炸只要乘上 $\frac{p}{q}$ 就好了）</p><p>对于非起始点的 x，$f[x] = \sum \frac{(1 - \frac{p}{q})f[y]}{deg_y}$</p><h3 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="$[HNOI2013]-游走$"></a><a href="https://www.luogu.com.cn/problem/P3232" target="_blank" rel="noopener">$[HNOI2013]-游走$</a></h3><p>几个月前做的，现在来看却有了新的体会。</p><p>根据期望的线性性质，$E[分数之和] = \sum_{(u, v) \in G} E[(u, v)分数] = \sum_{(u, v) \in G} E[经过(u, v)的次数] \times val(u, v)$，那么算出每条边被经过次数后从小到大排序，贪心的从大到小赋边权就可以了。</p><p>边经过的期望次数可以转化成点经过的期望次数。$E[u, v] = \frac{E[u]}{deg_u} + \frac{E[v]}{deg_v}$, $E[u] = \sum \frac{E[v]}{deg_v} + [u == 1]$</p><h3 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="$[HNOI2011]-XOR和路径$"></a><a href="https://www.luogu.com.cn/problem/P3211" target="_blank" rel="noopener">$[HNOI2011]-XOR和路径$</a></h3><p>整个做不好做。根据期望的线性性质，按位考虑，计算出每一位为 1 的概率直接相加。$f[x]$ 表示从 x 到 n 当前位为 1 的概率。</p><script type="math/tex; mode=display">f[x] = \sum\limits_{(x, y) = 0} \frac{f[y]}{deg_y} + \sum\limits_{(x, y) = 1} \frac{1 - f[y]}{deg_y}</script><p>移项以后高消。注意边界，$f[n] = 0$</p><h2 id="套路4-分开考虑贡献"><a href="#套路4-分开考虑贡献" class="headerlink" title="套路4. 分开考虑贡献"></a><strong>套路4. 分开考虑贡献</strong></h2><hr><p>这部分主要是期望的线性性质的应用。其实前面的题目也有体现。</p><h3 id="仓鼠找sugar-II"><a href="#仓鼠找sugar-II" class="headerlink" title="$仓鼠找sugar II$"></a><a href="https://www.luogu.com.cn/problem/P3412" target="_blank" rel="noopener">$仓鼠找sugar II$</a></h3><p>数据范围这么大 不能高消 =&gt; 我不会做了！</p><p>把目标节点看作根，这样答案就成了到达根的期望步数和</p><p>设 $f[x]$ 表示从 x 向上走一步的期望步数，那么 $f[x] = \frac{1}{deg_x} + \frac{deg_x - 1}{deg_x}(1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x - 1} + f[x]) = 1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x} + f[x] = deg_x + \sum\limits_{y \in Son(x)}f[y]$, 叶子 $x$ 的 $f[x] = 1$</p><p>树形dp $n$ 次能获得 50 分的好成绩，考虑再优化——换根法。</p><p>设 $g[x]$ 表示在 $fa[x]$ 的儿子中除了 $x$ 以外的 $f$ 值之和。根从 $u$ 变成 $v$ 实际上只会影响 $u$ 和 $v$ 的 $f$ 值和子树大小，即 $f[u] = deg_u + g[v], f[v] = 0$，子树和随便搞一下。$ans = \frac{\sum\limits_{rt = 1}^n\sum\limits_{x = 1}^n f[x] \times sz[x]}{n^2}$</p><h3 id="小魔女帕琪"><a href="#小魔女帕琪" class="headerlink" title="$小魔女帕琪$"></a><a href="https://www.luogu.com.cn/problem/P3802" target="_blank" rel="noopener">$小魔女帕琪$</a></h3><p>根据期望的线性性质，$E[总数] = \sum\limits_i E[从 i 开始的七个魔法都不相同]$，每个位置 i 的连续七个不相同的概率都是相同的。答案就是 $7! \times \prod\limits_{i = 1}^7 \frac{a_i}{N - i + 1} \times (N - 6)$</p><h3 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="$[HNOI2015]-亚瑟王$"></a><a href="https://www.luogu.com.cn/problem/P3239" target="_blank" rel="noopener">$[HNOI2015]-亚瑟王$</a></h3><p>根据期望的线性性质，考虑每张牌对答案的贡献。发现第 $i$ 张牌被考虑到的次数<strong>只</strong>和前 $i - 1$ 张牌产生贡献的<strong>数量</strong>有关（设其为 $j$），因为这 $j$ 张牌产生贡献的时间和顺序不论怎样变换，第 $i$ 张牌都能被考虑到 $r - j$ 次。</p><p>于是想到 dp。$f[i, j]$ 表示在 $r$ 轮中前 $i$ 张牌有 $j$ 张产生贡献的概率，$g[i]$ 表示第 $i$ 张牌产生贡献的概率。那么</p><script type="math/tex; mode=display">f[i, j] = [j <= i - 1] \times f[i - 1, j] \times (1 - p[i])^{r - j} + [j > 0] \times f[i - 1, j - 1] \times (1 - (1 - p[i])^{r - j + 1})</script><script type="math/tex; mode=display">g[i] = \sum\limits_{j = 0}^{min(i - 1, r)}f[i - 1, j] \times (1 - (1 - p[i])^{r - j})</script><p>最终 $ans = \sum\limits_{i = 1}^n g[i] \times d[i]$</p><p>最终答案就是 $f[1, 0]$</p><h2 id="套路5-整数概率公式"><a href="#套路5-整数概率公式" class="headerlink" title="套路5. 整数概率公式"></a><strong>套路5. 整数概率公式</strong></h2><hr><p>这部分是真的没怎么练过。。</p><p>反正要知道公式：对于随机变量 $k &gt;= 0$, $E(k) = \sum\limits_{i = 0}^{\infty} P(k \ge i)$</p><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="$随机数生成器$"></a><a href="https://www.luogu.com.cn/problem/P3600" target="_blank" rel="noopener">$随机数生成器$</a></h3><p>根据上面那个公式，我们就是要计算出 $P(ans \ge i)$。发现 $\ge$ 不好求，$\leq$ 挺好求，因为每个区间里至少有一个 $\leq i$ 的就算满足条件了，所以考虑将 $P(ans \ge i)$ 转化为 $1 - P(ans &lt; i)$。</p><p>我们发现两个区间是包含关系的话，大的区间对答案没有贡献，于是操作一波使得区间们的左右端点不减。考虑某个位置的数，如果它 $\leq i - 1$ 就能对覆盖自己的区间产生贡献，而且覆盖自己的区间编号连续。考虑将点和区间互换，问题等价于每个点能覆盖一些区间，且覆盖的概率为 $p = \frac{i - 1}{x}$，用一些点去覆盖所有区间的概率。</p><p>容易想到 dp，设 $l[i]$ 表示点 i 覆盖的最左边的区间，$r[i]$ 是最右边的，$f[i]$ 表示强制选第 i 个点，然后覆盖了 $1$ ~ $r[i]$ 所有区间的概率，那么</p><script type="math/tex; mode=display">f[i] = p \times (\sum\limits_{r[j] \ge l[i] - 1} f[j] \times (1 - p)^{i - 1 - j} + [l[i] = 1](1 - p)^{i - 1})</script><p>最终答案就是 $\sum\limits_{r[i] = Q}f[i] \times (1 - p)^{n - i}$</p><p>直接做是 $n^3$ 的，前缀和维护一下就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">666623333</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, Q, top, L, R;</span><br><span class="line"><span class="keyword">int</span> stk[N], l[N], r[N];</span><br><span class="line">ll f[N], ans, pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &gt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; q[stk[top]].r &gt;= q[i].r) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = top;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) q[i] = q[stk[i]];</span><br><span class="line">    L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; Q &amp;&amp; q[R + <span class="number">1</span>].l &lt;= i) ++R;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R &amp;&amp; q[L].r &lt; i) ++L;</span><br><span class="line">        l[i] = L, r[i] = R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    prework();</span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        ll p = (i - <span class="number">1</span>) * qpow(x, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        ll pp = mod + <span class="number">1</span> - p;</span><br><span class="line">        ll invp = qpow(pp, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lst &lt; j &amp;&amp; r[lst] &lt; l[j] - <span class="number">1</span>)</span><br><span class="line">                tot = (tot - f[lst] * qpow(invp, lst) % mod + mod) % mod, ++lst;</span><br><span class="line">            f[j] = p * tot % mod * qpow(pp, j - <span class="number">1</span>) % mod;</span><br><span class="line">            tot = (tot + f[j] * qpow(invp, j) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &amp;&amp; r[j] == Q; --j) sum = (sum + f[j] * qpow(pp, n - j) % mod) % mod;</span><br><span class="line">        ans = (ans + <span class="number">1</span> - sum + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SHOI2016]-成绩比较</title>
      <link href="2020/08/11/%5BSHOI2016%5D-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83/"/>
      <url>2020/08/11/%5BSHOI2016%5D-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>首先发现恰好 K 名碾压的好难算啊！计数题嘛，想到容斥，f 恰好，g 至少，套路一波。</p><script type="math/tex; mode=display">g(k) = C^{k}_{n - 1} \times ( \prod_{i = 1}^m C^{n - r_i - k}_{n - k - 1} \sum\limits_{j = 1}^{U_i} j^{n - r_i} (U_i - j)^{r_i - 1} )</script><p>发现很有希望，但是后面那个 sigma 不太好搞，考虑拿出来预处理，运用二项式定理得</p><script type="math/tex; mode=display">\sum\limits_{l = 0}^{r_i - 1} C_{r_i - 1}^l (-1)^l U_i^{r_i - 1 - l} \sum\limits_{j = 1}^{U_i} j^{n - r_i + l}</script><p>后面那个 sigma 是个自然数幂求和，用拉格朗日插值法求，然而我不会所以<strong>咕咕</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 拉格朗日插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 复赛</title>
      <link href="2020/08/11/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/"/>
      <url>2020/08/11/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>A 变化的期望就是 (m - B 攻击成功的期望次数)，挺简单的一题</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><hr><p>题目读错了（这也能错？）我看成在任意位置加一了就不会做啊啊啊</p><p>操作二只会执行一次或不执行，因为把前面一串清零了还要变成 1 才能再做操作二，目的仅仅为了将后面一位变成 1，这显然用操作一就够了。。枚举操作二把多长的前缀变成 0 就好了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>小构造题。最小和最大是相似的情况，这里就考虑最大的。考虑我们想要大的数贡献尽量大，可以这样构造：l = 8, k = 3，000001110000011100000111… 从大到小依次给 1 赋值。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>咕咕</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>攻击总共有四种情况，其中如果同一轮中两个人都 miss 了相当于没有贡献，具体来说</p><p>设 $f(n, m)$ 为从 (n, m) 出发，Alice 活下来的概率。那么</p><p>$f(n, m) = f(n, m)(1 - p)(1 - q) + f(n, m - 1)p(1 - q) + f(n - 1, m)q(1 - p) + f(n - 1, m - 1)pq$</p><p>$f(n, m) = \frac{f(n, m - 1)p(1 - q) + f(n - 1, m)q(1 - p) + f(n - 1, m - 1)pq}{1 - (1 - p)(1 - q)}$</p><p>可以看作 </p><ul><li>case 1: $(n, m)$ 有 $a = \frac{pq}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n - 1, m - 1)$</li><li>case 2: 有 $b = \frac{p(1 - q)}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n, m - 1)$</li><li>case 3: 有 $c = \frac{q(1 - p)}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n - 1, m)$</li></ul><p>设最终移动到了 $(r, 1)$ <strong>(为什么不是 $(r, 0)$？因为最后一次 Alice 把 Bob 打死，Bob 没有机会攻击 Alice)</strong> ，case 1 操作了 $x$ 次，那么 case 2 操作了 $m - 1 - x$ 次，case 3 操作了 $n - r - x$ 次，就可以写出柿子：</p><p>$\sum\limits_{r = 1}^n \sum\limits_{x = 0}^{min(n - r, m - 1)} C(m - 1, x) \times C(m - 1 + n - r - x, m - 1) \times a^x b^{m - 1 - x} c^{n - r - x}$</p><p>这个不好搞，继续推，设 i = n - r - x</p><p>$\sum\limits_{x = 0}^{min(n - 1, m - 1)} a^xb^{m - 1 - x} C(m - 1, x) \sum\limits_{i = 0}^{n - 1 - x} C(m - 1 + i, i) c^i$</p><p>其中后面那个 sigma 可以前缀和预处理。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】SAM</title>
      <link href="2020/08/10/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SAM/"/>
      <url>2020/08/10/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SAM/</url>
      
        <content type="html"><![CDATA[<p>以 备 重 修（我觉得至少还得重修个三四次 QAQ）</p><p><a href="https://oi-wiki.org/string/sam/" target="_blank" rel="noopener">OI-wiki</a>（图片非常清晰直观）</p><p><a href="https://www.cnblogs.com/Flying2018/p/13444085.html" target="_blank" rel="noopener">Flying2018大佬的讲解</a></p><p>几个概念/一点理解：</p><ul><li>$len[u]$ 表示以节点 $u$ 为尾巴的最长路径。也等于它插入时的字符串长度。</li><li>不恰当的比喻：$SAM$ 的肉体是一棵压缩的 $Trie$ 树，骨架是 $parent$ 树。</li><li>起点到每个终止节点是一条 $S$ 的后缀，每个节点代表某个长度为 $len[u]$ 的前缀的一些_长度大于某一长度的后缀_。更确切的，$u$ 表示的子串长度是 $(len[fa], len[u]]$ 范围内的。本质不同的子串数等于从起点出发的路径数，也等于 $\sum len[u] - len[fa[u]]$。（$SAM$ 当然是个 $DAG$ 啦</li><li>根据 $endpos$ 的概念，有祖先关系的节点 $endpos$ 是子集（完全包含）关系，没有祖先关系的节点 endpos 就是不交的。</li><li>每次加入一个节点最多会增加两个节点，空间复杂度是 $O(n)$ 的。</li></ul><p>坑点：</p><ul><li>空间两倍 QWQ</li></ul><h3 id="CF1037H"><a href="#CF1037H" class="headerlink" title="$CF1037H$"></a>$CF1037H$</h3><p>思路是贪心。</p><p>如果 $l = 1$，$r = n$，由于要找的是字典序严格大于 $T$ 的，我们考虑找一个 $S$ 的前缀，后面跟一个稍大的字符 $ch$。用 SAM 求出每一位的 $ch$，没有的话就是 $-1$. 最后倒着找第一个不为 $-1$ 的。</p><p>考虑 $l$ 和 $r$ 有限制怎么做，增加一步：找 $ch$ 的时候判断 $endpos$ 集合里有无区间 $[l, r]$ 的串。</p><p>$endpos$ 集合在这道题里必须求出，我们可以用经典套路——$parent$树上跑线段树合并。</p><h3 id="CF700E"><a href="#CF700E" class="headerlink" title="$CF700E$"></a>$CF700E$</h3><p>子串啊什么的考虑 SAM。</p><p>考虑到 $s_i$ 必然是 $s_{i + 1}$ 的前缀和后缀（不然削掉前/后缀不会更劣），在 $parent$ 树上体现为 $s_i$ 是 $s_{i + 1}$ 的祖先，于是想到 $dp$，找最长链</p><p>怎么判断出现了两次呢？记录任意一个 $s_{i + 1}$ 的位置，$endpos$ 集合用线段树合并，就能查询了。</p><h3 id="区间本质不同子串个数"><a href="#区间本质不同子串个数" class="headerlink" title="$区间本质不同子串个数$"></a><a href="https://www.luogu.com.cn/problem/P6292" target="_blank" rel="noopener">$区间本质不同子串个数$</a></h3><p>类似于“区间元素数”，我们离线询问，给每种元素选一个特征点，对于每个右端点维护左端点的答案。具体来说，每次更新以当前位置为右端点的串的 $lstpos$，一个长度为 $T$ 的串对左端点在 $[1, lstpos - T + 1]$ 的询问有贡献。</p><p>考虑 $SAM$，区间右端点右移至 $r$ 在 $SAM$ 上就要把一整条路径集合里的子串 $lstpos$ 更改为 $r$。暴力做显然补星。这是个链赋值操作，于是考虑 $LCT$ + $tag$。每个位置 $access$ 后到根的路径上 $lstpos$ 都相同，且代表的子串长度连续（根据 $endpos$ 的定义），可以直接区间修改区间查询。</p><h3 id="事情的相似度"><a href="#事情的相似度" class="headerlink" title="$事情的相似度$"></a><a href="https://loj.ac/p/6041" target="_blank" rel="noopener">$事情的相似度$</a></h3><p>两个前缀 $x$ 和 $y$ 的最长公共后缀就是 $parent$ 树上的 $len[lca(x, y)]$。现在要求区间最深 $len[lca]$。</p><p>考虑离线询问，每次右移考虑 $r$ 的贡献。$SAM$ 上每个点维护它到目前被到达的最大时间，$LCT$ $access$ 赋值打标记（同一条链上的最大时间肯定相同），每次跳 $parent$ 树更新答案，注意更新的是一个区间的答案，线段树取 $\max$。</p><p>还有一种做法：容易想到 $dfn$ 序越近的对越优秀，不是最近的对对于答案没有贡献。想到启发式合并 $endpos$ 集合，$set$ 维护，找前驱后继。——查询区间啊，怎么办？注意到是三元组 $(l, r, v)$ ，丢到二维平面上二维数点就好。</p><p>记录 xml 的每日 sb：<strong>$parent$ 树上节点 $x$ 的祖先 $id$ 一定都小于 $x$，后代不一定小于 $x$。为什么？怎么建树的你看看去。</strong> 所以要处理一个按长度从大到小的操作序列。</p><p>都是两只 $log$ 的。因为「区间本质不同子串」写过第一种做法啦，这里想试试第二种！（哦呼</p><p><a href="https://loj.ac/s/1022230" target="_blank" rel="noopener">$Code$</a></p><h3 id="BJWC2018-Border-的四种求法"><a href="#BJWC2018-Border-的四种求法" class="headerlink" title="$BJWC2018-Border 的四种求法$"></a><a href="https://www.luogu.com.cn/problem/P4482" target="_blank" rel="noopener">$BJWC2018-Border 的四种求法$</a></h3><p>神题，比「区间本质不同子串」和「事情的相似度」高到不知道哪里去了。</p><p>往 $SAM$ 想，简直一脸蒙蔽啊。。这时候我们需要一些<strong>形式化</strong>：寻找最大的 $i$ 满足 $i - l + 1 \leq lcs(r, i)$，$lcs$ 是最长公共后缀</p><p>如果数据随机，那 $parent$ 树长得就比较平衡，树高 $log$，暴跳 + 查询每个 $r$ 的祖先 $endpos$ 集合里满足限制的 $i$ 最大值，线段树合并 $endpos$ 即可。</p><p>如果不随机呢？树高就 $O(n)$ 啦。不会做啦，$GG$ 啦。看题解啦。 <a href="https://www.luogu.com.cn/blog/c2522943959/solution-p4482" target="_blank" rel="noopener">题解</a></p><p>树分治/链分治，对重边的处理和轻边的合并及处理往往具有优秀的实现方法及复杂度，被套在树上问题也是很常见的啊啦啦！！</p><p>考虑一个询问查询了其子树的贡献和其所有祖先及祖先其他子树的贡献，子树贡献可以线段树合并照旧算。祖先呢？</p><p>考虑重链剖分后把询问复制 $log$ 份挂到祖先重链上（与它到根的路径交叉部分的末端），这样就只要分别处理每条链的询问了。总点数 $O(nlogn)$。</p><p>每条链从上到下把轻儿子的贡献合并进来，可以暴力插贡献因为轻儿子总数也就 $O(nlogn)$，拿一个下标为 $i$、权值为 $i - len[lca] + 1$ 的线段树维护区间最小值，这样查询在线段树上二分、根据最小值做出决策就可以了。</p><p>说说就好烦了呢qwq，写了一晚上 + 调了半个上午 200 行终于 AC 了呢qwq！多想，多思考。</p><p><a href="https://www.luogu.com.cn/record/44414778" target="_blank" rel="noopener">$Code$</a></p><h3 id="NOI2018-你的名字"><a href="#NOI2018-你的名字" class="headerlink" title="$NOI2018-你的名字$"></a><a href="https://loj.ac/p/2720" target="_blank" rel="noopener">$NOI2018-你的名字$</a></h3><p>问啥？询问串有多少个子串不是另一个询问串的子串。我们要求的是用 T 的本质不同子串个数 - 两串本质不同公共子串个数。</p><p>假设 $l = 1$, $r = |S|$, 答案就是 $\sum\limits_{i = 2}^{T.cnt} max(0, len[i] - max(len[fa[i]], 第一次走到 i 的 T 串位置与 S 的 LCS))$ 为什么是第一次走到？第一次走到就是最远的嘛，是 $(len[fa[i]], len[i]]$ 的 $len[i]$ 而不是 $len[fa[i]] + 1$。为什么要最远？本质不同公共子串个数等于要在 $parent$ 树上取路径并啊。</p><p>若 $l$ 和 $r$ 任意，加一个线段树合并 $endpos$ 集合帮助在跳 $S$ 的 $parent$ 树时判断当前位置是否合法，就可以了。</p><hr><p>广义 SAM！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200808 题解</title>
      <link href="2020/08/08/XJOI200808%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/08/XJOI200808%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>咕咕</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>部分分提醒正解。考虑 n &lt;= 2 时，设 $a_1 = A$, $a_2 = B$，那么 A 先取完时期望个数就是 $a_1 + \sum\limits_{i = 0}^{B - 1} \frac{C(A - 1 + i, i)}{2^{B + 1}} i$，B 先取完时就是 $a_1 + \sum\limits_{i = 0}^{A - 1} \frac{C(B - 1 + i, i)}{2^{B + 1}} B$。</p><p>根据期望的线性性质，$ans = (\sum\limits_{i = 2}^n \{第 i 个被拿的期望个数\}) + a_1$。现在就是怎么求解每种球的期望个数。我们设第 i 种球的期望个数为 $f_i$。</p><p>注意到选颜色是<strong>等概率</strong>的。本题中唯一的限制就是第一种球必须取完，那么 $f_i$ 只与在第一种球取完前 取了多少个第 i 种球有关，取其他球对它们没有影响，而且它们被取的概率是相同的，那就等价于之前的部分分算法。这样是 60 分。</p><p>考虑优化：将上面的方法看作从 $(a_1, a_i)$ 出发每次随机向下或向左走一步，直到走到坐标轴。走到 $(0, a)$ 的贡献是 $a_i - a$，走到 $(a, 0)$ 的贡献是 $a_i$，就能列出贡献柿子：</p><script type="math/tex; mode=display">f_i = \sum\limits_{j = 0}^{a_i - 1} \frac{C(a_1 - 1 + j, j)}{2^{a_1 + j}} \times j + a_i(1 - \sum\limits_{j = 0}^{a_i - 1} \frac{C(a_1 - 1 + j, j)}{2^{a_1 + j}})</script><p>容易发现 $a_i$ 增加 1 的时候 两部分的贡献分别都只会增加一项，可以 O(1) 算！这样就能线性求解了，是 O(值域) 的。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ310]-黎明前的巧克力</title>
      <link href="2020/08/08/%5BUOJ310%5D-%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/"/>
      <url>2020/08/08/%5BUOJ310%5D-%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>求的就是 $\sum\limits_{xor(S) = 0} 2^{|S|}$</p><p><strong>考虑它的生成函数</strong>: $\prod (1 + 2x^{\{a_i\}})$，其中这里的 $\prod$ 表示异或卷积</p><p>直接 FWT + 点乘 肯定不行。。</p><p>发现对 $(1 + 2x^{a_i})$ 做 FWT 后的点值不是 -1 就是 3（1 也就是 $x^0$，它对每位的贡献是 1，$2x^{a_i}$ 对每位的贡献是 2 或 -2），那么我们只要知道每位有多少个 -1/3 就好了</p><p>有个性质：线性变换的和 = 和的线性变换，于是我们把所有多项式加起来做一遍 FWT，对于第 $i$ 位设有 $k$ 个 -1，那么 $-k + 3(n - k) = f_i$（$f_i$ 就是和的 FWT），就能解出 $k$，也就得到了第 $i$ 位点乘的结果！然后一遍 IFWT 就好了！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">2e6</span> + <span class="number">10</span>, inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">ll n, a[N], f[N], bit3[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(ll a[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!((j &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                ll x = a[j], y = a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))];</span><br><span class="line">                a[j] = (x + y) % mod, a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] = (x - y + mod) % mod;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">-1</span>) (a[j] *= inv2) %= mod, (a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] *= inv2) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = n;</span><br><span class="line">    bit3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        bit3[i] = bit3[i - <span class="number">1</span>] * <span class="number">3</span> % mod;</span><br><span class="line">        f[a[i]] += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FWT_xor(f, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">    ll inv4 = quick_pow(<span class="number">4</span>, mod - <span class="number">2</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = ((<span class="number">3</span> * n - f[i] + mod) % mod) * inv4 % mod;</span><br><span class="line">        f[i] = (k &amp; <span class="number">1</span> ? mod - bit3[n - k] : bit3[n - k]);</span><br><span class="line">    &#125;</span><br><span class="line">    FWT_xor(f, <span class="number">20</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (f[<span class="number">0</span>] - <span class="number">1</span> + mod) % mod);  <span class="comment">// 减去空集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】集合幂级数</title>
      <link href="2020/08/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
      <url>2020/08/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200807 题解</title>
      <link href="2020/08/07/XJOI200807%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/07/XJOI200807%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>这题就是典型的部分分提醒正解。</p><p>01 那部分可以引导想到 bitset，但 $O(q <em> n / 32)$ 的显然不对，于是想到 $O(q </em> 2^k / 32)$ 的，即 $f[i, s]$ 表示在第 i 个所在集合 s 中有没有值“扩散”到第 i 个，然后 or 和 and 操作能分别代替 max 和 min 操作，就做完了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, Q, cnt;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>][N], b[<span class="number">13</span>][N], t[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">bitset</span>&lt;4096&gt; B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, K) rep(j, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, K) t[i] = a[i][j];</span><br><span class="line">        sort(t + <span class="number">1</span>, t + K + <span class="number">1</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, K) b[i][j] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, K) <span class="keyword">if</span> ((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) B[i][s] = <span class="number">1</span>;</span><br><span class="line">    cnt = K;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            B[++cnt] = (B[x] | B[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            B[++cnt] = (B[x] &amp; B[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = K; j; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                rep(i, <span class="number">1</span>, K) <span class="keyword">if</span> (a[i][y] &gt;= b[j][y]) s |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (B[x][s]) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[j][y]); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>显然要枚举最终颜色 $i$。问题抽象成有 $s + 1$ 个点 $0 ~ s$，当前在 $a_i$，每步可以向左向右或不动，问走到 $s$ 的期望步数，其中在 $0$ 点和 $s$ 点时都是 0。</p><p><a href="https://www.luogu.com.cn/blog/cjyl/solution-cf850f" target="_blank" rel="noopener">题解</a>，等差数列那里还是比较妙的！其实期望题多是从概念出发，我还是概念不清啊。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>看起来就很套路的题。想到转化就好不少= =</p><p>这个平方很难搞啊！考虑它的实际意义：连通块路径数期望的两倍。根据期望的线性性质，我们可以把大期望化成小期望，分别考虑每条路径的贡献。（套路！有碰到过好几次啊啊啊）</p><p>设 $p(i, x, y)$ 表示 $x$、$y$ 在 $i$ 天后还在同一连通块的概率，显然前 $i - 1$ 天 $x$ 到 $y$ 的路径上的边都没被砍，因此</p><script type="math/tex; mode=display">p(i, x, y) = \frac{ C(n - 1 - dist(x, y), i - 1) }{ C(n - 1, i - 1) } = \frac{(n - i)!(n - 1 - dist(x, y))!}{(n - 1)!(n - i - dist(x, y))!}</script><p>设 $E(i)$ 表示第 $i$ 天的路径数期望，那么</p><script type="math/tex; mode=display">E(i) = \sum\limits_{x, y \in V} p(i, x, y) \times 1</script><p>枚举 $z = dist(x, y)$ 就能把组合数拆开，就可以化成卷积形式了。设 $g(z)$ 表示 $dist(x, y) = z$ 的 $(x, y)$ 对数（点分治 + FFT），那么</p><script type="math/tex; mode=display">E(i) = \frac{(n - i)!}{(n - 1)!} \sum\limits_z g(z) \times (n - 1 - z)! \times \frac{1}{(n - i - z)!}</script><p>卷积形式，FFT 就做完了。</p><p>调到去世，发现是三处sb错误 ：）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, l, lim;</span><br><span class="line">ll f[N][<span class="number">20</span>], rev[N];</span><br><span class="line">ll fac[N], inv[N], F[N], G[N], A[N], B[N];</span><br><span class="line">ll sz[N], rt, T, mark[N], len[N], tot, bin[N], mxdep, num[N], mx[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = inv[i] * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    l = <span class="number">0</span>, lim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n) l++, lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) (a[i] *= Inv) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>, mx[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        getrt(y, x);</span><br><span class="line">        sz[x] += sz[y], mx[x] = max(mx[x], sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[x] = max(mx[x], T - sz[x]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x] &lt; mx[rt]) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, ll dep)</span> </span>&#123;</span><br><span class="line">    ++bin[dep];</span><br><span class="line">    mxdep = max(mxdep, dep);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        getdis(y, x, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    get_rev(mxdep &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, mxdep) A[i] = B[i] = bin[i], bin[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, mxdep + <span class="number">1</span>, lim - <span class="number">1</span>) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) A[i] = (A[i] * B[i]) % mod;</span><br><span class="line">    NTT(A, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, min(n, mxdep &lt;&lt; <span class="number">1</span>)) num[i] = (num[i] + op * A[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mark[x] = <span class="number">1</span>, mxdep = <span class="number">0</span>, getdis(x, <span class="number">0</span>, <span class="number">0</span>), calc(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        mxdep = <span class="number">0</span>, getdis(y, x, <span class="number">1</span>), calc(<span class="number">-1</span>);  <span class="comment">// 容斥出一定经过 x 的路径数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        T = sz[y], mx[rt = <span class="number">0</span>] = <span class="number">1e9</span>, getrt(y, x), solve(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    init(n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    T = n, mx[rt = <span class="number">0</span>] = <span class="number">1e9</span>, getrt(<span class="number">1</span>, <span class="number">0</span>), solve(rt);</span><br><span class="line">    get_rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) num[i] = (num[i] + mod) % mod;</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) A[i] = num[i] * fac[n - <span class="number">1</span> - i] % mod, B[i] = inv[i];</span><br><span class="line">    rep(i, n, lim - <span class="number">1</span>) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) A[i] = (A[i] * B[i]) % mod;</span><br><span class="line">    NTT(A, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, A[n - i - <span class="number">1</span>] * fac[n - i - <span class="number">1</span>] % mod * inv[n - <span class="number">1</span>] % mod);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[PKUWC2018]-随机游走</title>
      <link href="2020/08/06/%5BPKUWC2018%5D-%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/"/>
      <url>2020/08/06/%5BPKUWC2018%5D-%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/</url>
      
        <content type="html"><![CDATA[<p>终于来搞这个早就想搞的题了！！著名（雾）的 $minmax$ 题</p><p>据说可以<a href="https://www.cnblogs.com/Mychael/p/9229291.html" target="_blank" rel="noopener">不用 $minmax$ 容斥</a>，设 $f[i, S]$ 表示从 $i$ 出发走完 $S$ 集合的期望 + 把 dp 柿子表示成 $Ax + B$ 的形式就可以做到 $O(n2^n)$ 的复杂度。。。大同小异吧</p><p>考虑 $minmax$ 容斥，设 $f[i]$ 为从 $i$ 点出发，到达集合 $S$ 中第一个点的期望时间，那么只要计算 $f[x]$ 就好了。</p><p>本题是树的形态，可以推得：</p><ul><li>$x \in S$, $f[x] = 0$</li><li>$x \notin S$, $f[x] = \frac{f[fa_x]}{deg_x} + (\sum\limits_{y \in Son(x)}\frac{f[y]}{deg_x}) + 1$</li></ul><p>发现父亲和儿子很不好搞，而每个节点只有一个父亲，我们就用到一个套路：将 $f[x]$ 表示为 $A * f[fa] + B$ 的形式</p><p>从下往上做，推得：$A_x = \frac{1}{deg_x - \sum A_y}$, $B_x = \frac{\sum B_y + deg_x}{deg_x - \sum A_y}$</p><p>复杂度 $O(n2^n)$。可以用 FMT 或者 FWT_and 做容斥。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, M = <span class="number">20</span>, N = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, Q, st, S;</span><br><span class="line">ll f[N], g[N], deg[M], a[M], b[M];</span><br><span class="line"><span class="keyword">int</span> to[M &lt;&lt; <span class="number">1</span>], nxt[M &lt;&lt; <span class="number">1</span>], lnk[M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((S &gt;&gt; (x - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        a[x] = b[x] = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] = b[x] = deg[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        a[x] = (a[x] - a[y] + mod) % mod;</span><br><span class="line">        b[x] = (b[x] + b[y]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] = quick_pow(a[x], mod - <span class="number">2</span>);</span><br><span class="line">    b[x] = a[x] * b[x] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i += (k &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)</span><br><span class="line">                f[i + j + k] = (f[i + j + k] + f[i + j] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> ((j &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>)</span><br><span class="line">                f[j] = (f[j] + f[j - (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q &gt;&gt; st;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">        ++deg[x], ++deg[y];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">1</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &#123;</span><br><span class="line">        S = s; dfs(st, <span class="number">0</span>);</span><br><span class="line">        f[s] = (__builtin_popcount(s) &amp; <span class="number">1</span>) ? b[st] : mod - b[st];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FWT_or();  // 两个等价的。都可以。</span></span><br><span class="line">    FMT();</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x, bit = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), bit |= (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[bit]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> minmax容斥 </tag>
            
            <tag> 集合幂级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[清华集训2017]-无限之环</title>
      <link href="2020/08/06/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%5D-%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/"/>
      <url>2020/08/06/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%5D-%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>好神奇的题！</p><p>与联通性相关的最优性问题，先考虑插头dp，但是数据范围过大，gg。</p><p>观察图形发现是有限种上下左右的接口（注意直管不能翻转），而且是<strong>网格图</strong>，于是考虑费用流。（根本想不到且就算知道了也依旧不会做啊啊啊）</p><ul><li>怎么判断图是否漏水？</li></ul><p>发现水在相邻的格子间流动，<strong>不漏等价于相邻格子间接口能对上</strong>，那么把接口抽象成管道就是 容量为 1 且必须满流。那么黑白染色，白点连 S，黑点连 T，每个格子分成上下左右中五个点，对于白点，中间指向周围；对于黑点，周围指向中间。这样满流，即流量等于接口数，就是不漏。（同时也有了让水流动的动力！）</p><p>考虑旋转怎么处理：改变的接口对应连边，注意容量都是 1，这样跑费用流的时候一个格子只能选一种状态。</p><p>代码在 uoj 上并没有 AC，T 了很多发，大概是建边不够优秀，然而不想改了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, st, ed, idx, t1, t2, num;</span><br><span class="line"><span class="keyword">int</span> id[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = N * <span class="number">5</span>, MM = N * <span class="number">100</span>;  <span class="comment">// 开足了！！！</span></span><br><span class="line">    <span class="keyword">int</span> lnk[M], fr[MM], to[MM], nxt[MM], cnt = <span class="number">1</span>, cap[MM], val[MM];</span><br><span class="line">    <span class="keyword">int</span> level[M], dis[M], pre[M], inq[M];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++num;</span><br><span class="line">        to[++cnt] = y, fr[cnt] = x, nxt[cnt] = lnk[x], lnk[x] = cnt, cap[cnt] = c, val[cnt] = v;</span><br><span class="line">        to[++cnt] = x, fr[cnt] = y, nxt[cnt] = lnk[y], lnk[y] = cnt, cap[cnt] = <span class="number">0</span>, val[cnt] = -v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        add(x, y, c, v), add(y, x, c, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, T) dis[i] = inf, pre[i] = inq[i] = <span class="number">0</span>;</span><br><span class="line">        inq[S] = <span class="number">1</span>;</span><br><span class="line">        q.push(S);</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = to[i];</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                    dis[y] = dis[x] + val[i];</span><br><span class="line">                    pre[y] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[y]) q.push(y), inq[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != inf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">McMf</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (spfa(S, T)) &#123;</span><br><span class="line">            --t1;</span><br><span class="line">            cost += dis[T];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = T; x != S; x = fr[pre[x]]) &#123;</span><br><span class="line">                cap[pre[x]]--, cap[pre[x] ^ <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t1 ? <span class="number">-1</span> : cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> MCMF;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) rep(k, <span class="number">0</span>, <span class="number">4</span>) id[i][j][k] = ++idx;</span><br><span class="line">    st = <span class="number">0</span>, ed = ++idx;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add(id[i][j][<span class="number">4</span>], id[i][j][k], <span class="number">1</span>, <span class="number">0</span>), ++cnt;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = i + dx[k], ty = j + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (tx &amp;&amp; ty &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m) add(id[i][j][k], id[tx][ty][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(st, id[i][j][<span class="number">4</span>], cnt, <span class="number">0</span>);</span><br><span class="line">            t1 += cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add(id[i][j][k], id[i][j][<span class="number">4</span>], <span class="number">1</span>, <span class="number">0</span>), ++cnt;</span><br><span class="line">            add(id[i][j][<span class="number">4</span>], ed, cnt, <span class="number">0</span>);</span><br><span class="line">            t2 += cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">5</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                add2(id[i][j][(k + <span class="number">1</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][(k + <span class="number">3</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> (!((x &gt;&gt; k) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">1</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">3</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add2(id[i][j][k], id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("%d\n", cnt);</span></span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, McMf(st, ed));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 011 题解</title>
      <link href="2020/08/05/AGC%20011%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/05/AGC%20011%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>AB 水题= =</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>C 比 D 难诶 /kk</p><p><a href="https://blog.csdn.net/WerKeyTom_FTD/article/details/78216823?locationNum=5&amp;fps=1" target="_blank" rel="noopener">看了题解</a></p><p>特——别好的题！二分图真香</p><p>$C = V - E + F$ 学呆了，用不到就有点难受= = ？</p><p>原图中的独立点是最好搞的，设独立点个数为 p，则贡献为 $np * 2 - p^2$</p><p>考虑题目条件：$(a, b)$ 到 $(c, d)$ 有边当且仅当 $a -&gt; c$，$b -&gt; d$，等价于 $a、b$ 同时移动了一步到达 $c、d$。因此推得状态 $(a, b)$ 能到达状态 $(c, d)$ ，显然当且仅当路径 $a -&gt; c$ 和 $b -&gt; d$ 的<strong>奇偶性相同</strong>。由此联想到<strong>二分图</strong>。</p><p>考虑“特征点”$(x, y)$ 即无法在新图连通块内到达 $(t, k)$ 使得 $t &lt; x$ 或到达 $(x, z)$ 使得 $z &lt; y$。可以理解为字典序最小。<strong>显然特征点个数就是连通块个数。</strong></p><p>我们发现，特征点第一维 $x$ 必须是原图连通块中最小的点。第二维 $y$ 可以是最小的点。但如果 $y$ 所在连通块是二分图，且和所在连通块里的最小点 $z$ 不在同一边，就无法变成 $z$（ $(x, y) -&gt; (x, z)$，$x -&gt; x$ 的奇偶性可以看作偶，那么 $y -&gt; z$ 的奇偶性如果是奇就不行）。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>找规律发现滚一次球后串变为取反后左移一位，末尾补位A。大致原因就是</p><ul><li>A-&gt; B 变成 A A-&gt;</li><li>A-&gt; A 变成 B A-&gt;</li><li>开头和结尾也符合规律</li></ul><p>发现 2n 步（不是 n 步，因为串的奇偶性有影响）必然会把初始的串给替换掉（可以理解为一位一位溢出了，其中有至多 n 步是第一位为 A 的要弹回），串就变成了 ABABAB… 或者 BABABA… 的形式，讨论一下奇偶性就好了</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>咕咕</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】xza《Graph Theory》</title>
      <link href="2020/08/04/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91xza%E3%80%8AGraph%20Theory%E3%80%8B/"/>
      <url>2020/08/04/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91xza%E3%80%8AGraph%20Theory%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TC10947-TwoSidedCards"><a href="#TC10947-TwoSidedCards" class="headerlink" title="$TC10947-TwoSidedCards$"></a><a href="https://vjudge.net/problem/TopCoder-10947" target="_blank" rel="noopener">$TC10947-TwoSidedCards$</a></h2><hr><p>正-反，二元关系，想到正反面数字对应连边，每张卡都变成了一条有向边。</p><p>我们发现形成的图是一个环！！因为正反都是排列，每个数字的度数都是 2。</p><p>分环讨论，设当前环长度为 $L$，选了 $k$ 个数字，显然相邻的不能选，所以方案数就是 $C(L, 2k)$ 还要 $*2$。</p><p>背包合并。</p><h2 id="CF547D-Mike-and-Fish"><a href="#CF547D-Mike-and-Fish" class="headerlink" title="$CF547D-Mike and Fish$"></a><a href="https://codeforces.com/problemset/problem/547/D" target="_blank" rel="noopener">$CF547D-Mike and Fish$</a></h2><hr><p><a href="https://blog.csdn.net/PoPoQQQ/article/details/46125833" target="_blank" rel="noopener">题解</a></p><p>和上一题有异曲同工之妙。行-列，想到二元关系，于是行列建点，每个点都变成了一条有向边。设红色表示入边，蓝色表示出边，我们要给边定向，使得新图每个点的入度出度之差不超过 1。</p><p>怎么做？考虑<strong>构造欧拉回路</strong>。复习一波欧拉回路的定义：欧拉回路是经过图 G 中<strong>所有</strong>边的回路。但目前二分图中有偶数个（一定是偶数个，因为保证有解）奇数度点。有奇数度点就很难处理！</p><p>可以将奇数度点两两配对（通过连一些无关紧要的辅助边），对于每个连通块选一个初始为奇数度的点跑（注意先跑辅助边），没有就跑初始为偶数度的点，欧拉回路红蓝染色，就很好写。</p><p>这个正确性比较显然：欧拉回路上每个点入度出度都想同，每个点连的辅助边最多 1 条，删去辅助边后仍能满足限制。</p><p>复习欧拉回路基本写法：套圈法，其实就是把不同的环连在一起，<strong>dfs 函数还是有不少细节的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">            mark[i] = mark[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            lnk[x] = nxt[i];  <span class="comment">// 当前弧优化</span></span><br><span class="line">            dfs(to[i]);</span><br><span class="line">            stk[++top] = id[i];</span><br><span class="line">            i = lnk[x];  <span class="comment">// !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TC12330-CoinsGame"><a href="#TC12330-CoinsGame" class="headerlink" title="$TC12330-CoinsGame$"></a><a href="https://vjudge.net/problem/TopCoder-12330" target="_blank" rel="noopener">$TC12330-CoinsGame$</a></h2><hr><p>假装你已经知道这是“等价类”的题目。考虑两个格子等价，当且仅当任意操作后原本在两个格子上的硬币要么同时在棋盘上，要么同时移出了棋盘，那么合法的方案至少有一个这样的格子对。</p><p>发现正做很难，考虑补集转化。发现等价的关系是可以传递的，那么就形成了很多个团。等价关系可以 bfs 找，并查集维护。用总方案减去只选这些团的方案数就好了。</p><h2 id="CF19E-Fairy"><a href="#CF19E-Fairy" class="headerlink" title="$CF19E-Fairy$"></a><a href="https://codeforces.com/problemset/problem/19/E" target="_blank" rel="noopener">$CF19E-Fairy$</a></h2><hr><p>很好的题。</p><p><strong>对于环的题目，可以考虑 dfs 树，因为有个很优的性质：所有环在 dfs 树上的体现就是 树边 + 返祖边（没有横叉边，因为是 dfs 树）</strong></p><p><strong>而环到 {返祖边集合} 是单射</strong></p><p>设奇环数为 $x$</p><ul><li>$x = 0$，删任何一条边都可以</li><li>$x = 1$，只能删奇环上的边</li><li>$x &gt; 1$，不能删返祖边。考虑所有的树边，能被删掉当且仅当所有的奇环经过了它且<strong>没有偶环经过它</strong></li></ul><p>树上差分就好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO2019 题解</title>
      <link href="2020/08/04/APIO2019%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/04/APIO2019%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="T1-奇怪装置"><a href="#T1-奇怪装置" class="headerlink" title="$T1. 奇怪装置$"></a><a href="https://loj.ac/problem/3144" target="_blank" rel="noopener">$T1. 奇怪装置$</a></h2><hr><p>考虑到这有周期性，我们思考时刻 $t1$ 和 $t2$ $(t1 &lt; t2)$ 在何时意义相同：设 $L = t2 - t1$ （$L$ 即是周期大小）</p><script type="math/tex; mode=display">L + \lfloor \frac{L}{B} \rfloor \equiv 0 (mod\ A)</script><script type="math/tex; mode=display">L \equiv 0 (mod\ B)</script><p>那么那个下取整就可以拆了，整理一下：</p><script type="math/tex; mode=display">\frac{L(B + 1)}{B} \equiv 0 (mod\ A)</script><p>有一个定理：$ac \equiv bc(mod m)$，则 $a \equiv b(mod \frac{m}{gcd(m, c)})$，于是</p><script type="math/tex; mode=display">L \equiv 0 (mod\ \frac{AB}{gcd(AB, B + 1)})</script><p>而因为 $gcd(x, x + 1) = 1$ 恒成立，所以</p><script type="math/tex; mode=display">L \equiv 0 (mod\ \frac{AB}{gcd(A, B + 1)})</script><p>得到了周期大小，我们将区间在模 $L$ 意义下求区间覆盖就好了。</p><h2 id="T2-桥梁"><a href="#T2-桥梁" class="headerlink" title="$T2. 桥梁$"></a><a href="https://loj.ac/problem/3145" target="_blank" rel="noopener">$T2. 桥梁$</a></h2><hr><p>1、2、4档部分分都挺好拿的？那不就有 43 pts 了</p><p>考虑没有修改操作：对于每个询问，将值大于等于 wi 的边加入并查集，最终答案就是 si 所在并查集大小。但加入修改的话，枚举所有边或者所有操作都 TLE。显然这是因为，询问太多的时候枚举边会炸，修改太多的时候枚举操作会炸。</p><p>考虑<strong>均摊，把操作分块</strong>，设块大小为 S，每过 S 个操作就暴力重构一次。</p><p>具体来说，分块处理，将一个块内的所有询问按照重量从大到小排序，边枚举询问边将块内不修改的边插入；而对于块内修改的边，顶多 S 条，用可撤销并查集维护，暴力插入再暴力删除。</p><p>O(Q/S * mlogm + QS)，S 取 sqrt(mlogm) 的时候最优。我觉得这个分块很难想到，很神仙（虽然最终复杂度其实是 1e8，需要卡常</p><p>代码也太难写了吧！！！啊！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, Q, unit;</span><br><span class="line">ll fa[N], sz[N], pos[M], mark[M], pre[M], nxt[M];</span><br><span class="line">ll fax[M], fay[M], szx[M], szy[M], ans[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, z, id; &#125;e[M], e2[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> x, y, id; &#125;q1[M], q2[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpe</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.z &gt; b.z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpq2</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.y &gt; b.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz[x] &gt; sz[y]) swap(x, y);</span><br><span class="line">    fa[x] = y, sz[y] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">1</span>, ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) ch == <span class="string">'-'</span> ? ff = <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    x = ch &amp; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch = getchar())) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch &amp; <span class="number">15</span>);</span><br><span class="line">    x = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unit = max(unit, <span class="number">1l</span>l);  <span class="comment">// !!!!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span>; o &lt;= (Q - <span class="number">1</span>) / unit + <span class="number">1</span>; ++o) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = (o - <span class="number">1</span>) * unit + <span class="number">1</span>, r = min(o * unit, Q), l1 = <span class="number">0</span>, l2 = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) mark[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                ++l1;</span><br><span class="line">                read(q1[l1].x), read(q1[l1].y);</span><br><span class="line">                <span class="keyword">if</span> (pre[q1[l1].x]) nxt[pre[q1[l1].x]] = l1;</span><br><span class="line">                pre[q1[l1].x] = l1;</span><br><span class="line">                nxt[l1] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mark[q1[l1].x])  <span class="comment">// !!!!</span></span><br><span class="line">                    mark[q1[l1].x] = i;</span><br><span class="line">                q1[l1].id = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++l2;</span><br><span class="line">                read(q2[l2].x), read(q2[l2].y);</span><br><span class="line">                q2[l2].id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(e2, e, <span class="keyword">sizeof</span>(*e) * (m + <span class="number">1</span>));  <span class="comment">// ！！！！！！注意这么写会快很多</span></span><br><span class="line">        sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmpe);</span><br><span class="line">        sort(q2 + <span class="number">1</span>, q2 + l2 + <span class="number">1</span>, cmpq2);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, n) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, l2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= m &amp;&amp; e[pos].z &gt;= q2[i].y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mark[e[pos].id]) &#123;</span><br><span class="line">                    merge(e[pos].x, e[pos].y);</span><br><span class="line">                &#125;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(j, <span class="number">1</span>, l1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((!nxt[j] || q1[nxt[j]].id &gt; q2[i].id) &amp;&amp; q1[j].y &gt;= q2[i].y &amp;&amp; q1[j].id &lt; q2[i].id) ||  <span class="comment">// 询问前最后一次修改或修改在询问后但之前的边重量符合条件</span></span><br><span class="line">                    (mark[q1[j].x] &gt; q2[i].id &amp;&amp; e2[q1[j].x].z &gt;= q2[i].y)) &#123; <span class="comment">// e 排序了，要有个 e2 来存原来的顺序</span></span><br><span class="line">                    <span class="keyword">int</span> x = getfa(e2[q1[j].x].x), y = getfa(e2[q1[j].x].y);</span><br><span class="line">                    fax[j] = x, fay[j] = y, szx[j] = sz[x], szy[j] = sz[y];</span><br><span class="line">                    merge(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[q2[i].id] = sz[getfa(q2[i].x)];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l1; j; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fax[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = fax[j], y = fay[j];</span><br><span class="line">                    fa[x] = x, fa[y] = y, sz[x] = szx[j], sz[y] = szy[j];</span><br><span class="line">                    fax[j] = fay[j] = szx[j] = szy[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(e, e2, <span class="keyword">sizeof</span>(*e) * (m + <span class="number">1</span>));</span><br><span class="line">        rep(i, <span class="number">1</span>, l1)</span><br><span class="line">            e[q1[i].x].z = q1[i].y;</span><br><span class="line">        rep(i, <span class="number">1</span>, r - l + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (ans[i]) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    unit = <span class="built_in">sqrt</span>(m * <span class="built_in">log</span>(m) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].z);</span><br><span class="line">        e[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3-路灯"><a href="#T3-路灯" class="headerlink" title="$T3. 路灯$"></a><a href="https://loj.ac/problem/3146" target="_blank" rel="noopener">$T3. 路灯$</a></h2><hr><p>两道数据结构题！！！。。。1、2、4 档分好好拿呀= = 看题解学了正解。</p><p>考虑在连通区间 $[l, r]$ 中去掉一条边 $[k, k + 1]$，影响的只是 $[l, k]$ 到 $[k + 1, r]$ 的联通性。</p><p>考虑将贡献差分，时间段 = 时间点相减：</p><ul><li>加入边，$[l, k]$ 到 $[k + 1, r]$ 所有答案 $- i$</li><li>删除边，$[l, k]$ 到 $[k + 1, r]$ 所有答案 $+ i$</li></ul><p>同时对于询问的时刻 t，若两个点连通，答案要 $+ t$</p><p>看到点对，想到转化成平面问题。把区间抽象成坐标，就是二维数点问题，离线用树状数组套线段树或者 CDQ 分治。$O(nlog^2n)$</p><p>然而代码先咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Boruvka</title>
      <link href="2020/08/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Boruvka/"/>
      <url>2020/08/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Boruvka/</url>
      
        <content type="html"><![CDATA[<p>$Boruvka..Bvrouka…Brouvka….???$</p><p>$Boruvka$ 是一个古老的最小生成树算法，综合了 $Kruskal$ 和 $Prim$.（我觉得更像是进阶版 $Prim$）</p><p>它的算法流程是：初始时每个节点都是一个连通块，每次从<strong>每个</strong>块伸出去一条最短边，然后把新形成的连通块缩成一个新的块。每次 块个数至少减半，所以时间复杂度是 log 的。算法正确性可以参考 $Prim$ 的，相当于每次扩展多棵子树。</p><p>B <strong>合并只有 log 次</strong>，这是 K 和 P 做不到的。</p><p>通常它作为一种<strong>思想</strong>会很有用，比如<strong>位运算生成树</strong>，通常是边权难以直接维护的。</p><h2 id="CF888G"><a href="#CF888G" class="headerlink" title="$[CF888G]$"></a>$[CF888G]$</h2><hr><p>题意：边 $<i, j>$ 边权为 $a_i XOR a_j$ 的最小生成树</i,></p><p>考虑 $Trie$ 树，共有 $n - 1$ 个 $LCA$（$n - 1$ 个有两个儿子的节点）</p><p>根据 B 算法的<strong>思想</strong>，（将每个子树视为一个块），容易发现若 $x$ 同时有 $0/1$ 子树，两个子树就会连边</p><p>遍历 $Trie$ 树，在每个 $LCA$ 处做启发式合并、查左右子树连边的最小值</p><h2 id="CF1305G"><a href="#CF1305G" class="headerlink" title="$[CF1305G]$"></a>$[CF1305G]$</h2><hr><p>题意：连边 $<i, j>$ 规则为 $a_i AND a_j = 0$ 的最大生成树</i,></p><p>注意到这是一棵树，且它的特性在于，每个点的入度仅为 1.</p><p>于是有个很妙的方法：将每条边权值改为 $a_i + a_j$，最终答案是边权和 $- \sum{a_i}$，那么答案就转化成最大生成树。</p><p>$boruvka$ 算法直接做，每一轮子集 dp 维护出每个二进制集合内最大和次大的点权，<strong>两个点所在集合不同</strong>，这样查询的时候查询补集，就算最大的点权和当前点在同一集合里，也能“撞”掉，选到次大点。可以用 pair 记录 &lt;点权，集合的id&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, a[N], fa[N], cnt;</span><br><span class="line">ll ans;</span><br><span class="line">pii mx[M][<span class="number">2</span>], cur[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), fa[i] = i;</span><br><span class="line">        ans -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, M - <span class="number">1</span>)</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                mx[i][j] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            pii t = make_pair(a[i], getfa(i));</span><br><span class="line">            <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>] &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>].se != t.se) mx[a[i]][<span class="number">1</span>] = mx[a[i]][<span class="number">0</span>];</span><br><span class="line">                mx[a[i]][<span class="number">0</span>] = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[a[i]][<span class="number">1</span>] &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>].se != t.se) mx[a[i]][<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, M - <span class="number">1</span>) &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">18</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mx[i][<span class="number">0</span>] &lt; mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mx[i][<span class="number">0</span>].se != mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k].se) mx[i][<span class="number">1</span>] = mx[i][<span class="number">0</span>];</span><br><span class="line">                            mx[i][<span class="number">0</span>] = mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[i][<span class="number">1</span>] &lt; mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mx[i][<span class="number">0</span>].se != mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k].se) mx[i][<span class="number">1</span>] = mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, n)</span><br><span class="line">            cur[i] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = getfa(i);</span><br><span class="line">            <span class="keyword">int</span> t = ((M - <span class="number">1</span>) ^ a[i]);</span><br><span class="line">            <span class="keyword">if</span> (mx[t][<span class="number">0</span>].se != <span class="number">-1</span> &amp;&amp; mx[t][<span class="number">0</span>].se != f) &#123;</span><br><span class="line">                cur[f] = max(cur[f], make_pair(mx[t][<span class="number">0</span>].fi + a[i], mx[t][<span class="number">0</span>].se));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[t][<span class="number">1</span>].se != <span class="number">-1</span> &amp;&amp; mx[t][<span class="number">1</span>].se != f) &#123;</span><br><span class="line">                cur[f] = max(cur[f], make_pair(mx[t][<span class="number">1</span>].fi + a[i], mx[t][<span class="number">1</span>].se));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == i &amp;&amp; merge(i, cur[i].se)) &#123;</span><br><span class="line">                cnt--, ans += cur[i].fi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(2^{18} <em> 18 </em> logn)$</p><h2 id="UOJ176"><a href="#UOJ176" class="headerlink" title="$[UOJ176]$"></a>$[UOJ176]$</h2><hr><p>题意：边 $<i, j>$ 边权为 $a_i AND a_j$ 的最大生成树</i,></p><p>通过 cf1305g，我们积累了一定的经验。直接想到 B 算法，现在的问题就是怎么维护 a &amp; b 最大。</p><p>枚举子集的话应该可以做，不过是 3^18 的？</p><p>再想想 trie 树，我们发现跟 XOR 不同的是，1 的话走 1，0 的话走 0/1 皆可，可这样的复杂度是不对的啊，$O(n<em>2^m</em>logn)$ ！</p><p>这时只要<strong>自底向上</strong>（不然会出问题）将 1 子树合并到 0 子树上就好了！就变成了 1 走 1，0 走 0！复杂度就是 $O((n + 2^m) * mlogn)$</p><p>实现细节跟前一题一样，保留两个最大的 id，保证“撞”掉还有，查询的时候要求每时每刻走到的子树都有 和当前点不在同一集合的点</p><p>总之就是走 保证存在合法解的最优路径！</p><p>（还有一个完全不同、而且特别简单易懂的<a href="http://vfleaking.blog.uoj.ac/blog/1244" target="_blank" rel="noopener">好办法</a>，详见算法七）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, M = <span class="number">8e6</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;  <span class="comment">// 无语子😓 M 开 2 &lt;&lt; 18 就 MLE，开 8e6 就 AC。。。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, idx, rt, cas;</span><br><span class="line"><span class="keyword">int</span> a[N], fa[N], ch[M][<span class="number">2</span>], mx[M][<span class="number">2</span>];</span><br><span class="line">ll ans;</span><br><span class="line">pii cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] == mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">1</span>], mx[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &lt; mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">0</span>], mx[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &gt; mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">1</span>], mx[y][<span class="number">0</span>]);</span><br><span class="line">    mx[x][<span class="number">0</span>] = max(mx[x][<span class="number">0</span>], mx[y][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++idx;</span><br><span class="line">    ch[idx][<span class="number">0</span>] = ch[idx][<span class="number">1</span>] = <span class="number">0</span>, mx[idx][<span class="number">0</span>] = mx[idx][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">int</span> t = newnode();</span><br><span class="line">    ch[t][<span class="number">0</span>] = merge(ch[x][<span class="number">0</span>], ch[y][<span class="number">0</span>]);</span><br><span class="line">    ch[t][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], ch[y][<span class="number">1</span>]);</span><br><span class="line">    upd(t, x), upd(t, y);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>], rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (ls) dfs(ls, dep - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rs) dfs(rs, dep - <span class="number">1</span>);</span><br><span class="line">    ch[x][<span class="number">0</span>] = merge(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> dep, <span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx[x][<span class="number">0</span>] != id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &lt; id) mx[x][<span class="number">1</span>] = mx[x][<span class="number">0</span>], mx[x][<span class="number">0</span>] = id;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[x][<span class="number">1</span>] &lt; id) mx[x][<span class="number">1</span>] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = ((val &gt;&gt; dep) &amp; <span class="number">1</span>);</span><br><span class="line">    insert(ch[x][c], dep - <span class="number">1</span>, val, id);</span><br><span class="line">    mx[x][<span class="number">0</span>] = mx[x][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    upd(x, ch[x][<span class="number">0</span>]), upd(x, ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>, (id == mx[x][<span class="number">0</span>] ? mx[x][<span class="number">1</span>] : mx[x][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = ((val &gt;&gt; dep) &amp; <span class="number">1</span>), ls = ch[x][<span class="number">0</span>], rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rs || (id == mx[rs][<span class="number">0</span>] &amp;&amp; mx[rs][<span class="number">1</span>] == <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(ls, dep - <span class="number">1</span>, val, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pii t = query(rs, dep - <span class="number">1</span>, val, id);</span><br><span class="line">            t.fi += (<span class="number">1</span> &lt;&lt; dep);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(ls, dep - <span class="number">1</span>, val, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ++cas;</span><br><span class="line">        rep(i, <span class="number">0</span>, idx) &#123;</span><br><span class="line">            ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            mx[i][<span class="number">0</span>] = mx[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = rt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            insert(rt, m, a[i], getfa(i));</span><br><span class="line">            cur[i] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(rt, m);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = getfa(i);</span><br><span class="line">            pii t = query(rt, m, a[i], f);</span><br><span class="line">            cur[f] = max(cur[f], t);</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == i &amp;&amp; cur[i].se &gt; <span class="number">0</span> &amp;&amp; unite(i, cur[i].se)) &#123;</span><br><span class="line">                cnt--, ans += cur[i].fi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Jul CF&amp;AT 练题汇总</title>
      <link href="2020/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jul%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jul%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CF1039D"><a href="#CF1039D" class="headerlink" title="CF1039D"></a><a href="https://www.luogu.com.cn/problem/CF1039D" target="_blank" rel="noopener">CF1039D</a></h2><hr><p>树的每个节点至多属于其中一条路径!!!</p><p>看到题目：这能做？能做？？能做？？？？</p><p>对不起，用根号分治就是能做（皮</p><ul><li>k &lt;= sqrt(n) 的暴力算，O(nsqrt(n))</li><li>k &gt; sqrt(n) 的，容易发现答案一定在 (0, sqrt(n)) 的区间内单调不增，最多只有 sqrt(n) 种，所以对于当前的 k 二分出与它答案相同的最右位置，更新这一段的答案</li></ul><p>复杂度 O(nsqrt(n)*logn)</p><p>HINT：常数巨大，普通 dfs 递归会 T。。要先处理 dfs 序然后从下往上 dp。。。5070ms。。。</p><p>据说能用整体二分做，先咕咕</p><h2 id="CF1039E"><a href="#CF1039E" class="headerlink" title="CF1039E"></a><a href="https://www.luogu.com.cn/problem/CF1039E" target="_blank" rel="noopener">CF1039E</a></h2><hr><p>LCT + 分块，先咕咕</p><h2 id="CF455D"><a href="#CF455D" class="headerlink" title="CF455D"></a><a href="https://www.luogu.com.cn/problem/CF455D" target="_blank" rel="noopener">CF455D</a></h2><hr><p>操作 1 每次只移动两位，而且操作 2 询问的信息可合并，可以用分块 + 双端队列，O(n <em> sqrt(n) </em> logn) cf 神评测机就跑过去了！</p><h2 id="CF1045B"><a href="#CF1045B" class="headerlink" title="CF1045B"></a><a href="https://www.luogu.com.cn/problem/CF1045B" target="_blank" rel="noopener">CF1045B</a></h2><hr><p><a href="https://www.cnblogs.com/yyf0309/p/9808323.html" target="_blank" rel="noopener">题解</a></p><p>妙题，容易想到 无法构成的数可以全用 A 中或全用 B 中的数构成。设不能构成的数为 t，A 中构成 t 的数为 X 和 Y。</p><p>由模的性质得，若 X &lt; t 则 Y &lt; t, 若 X &gt; t 则 Y &gt; t，所以任何一个 t 将 A 集合划为两半，每一部分首尾配对后，每对的和都等于 t</p><p>如何判 1 ~ i 首尾配对的值相同？设 1 &lt;= a &lt; b &lt; c &lt; d &lt;= i, 若 a + d = b + c 则 a - b = c - d，做一个差分然后跑 manacher 或 hash 判回文就好了，妙啊。</p><h2 id="CF1249D2"><a href="#CF1249D2" class="headerlink" title="CF1249D2"></a><a href="https://www.luogu.com.cn/problem/CF1249D2" target="_blank" rel="noopener">CF1249D2</a></h2><hr><p>贪心，我真的不行。。按左端点排序，从左往右扫，大根堆维护右端点，若左端点覆盖次数超过 K 则弹出堆顶线段</p><h2 id="CF255E"><a href="#CF255E" class="headerlink" title="CF255E"></a><a href="https://www.luogu.com.cn/problem/CF255E" target="_blank" rel="noopener">CF255E</a></h2><hr><p>第一次感觉博弈论没那么高冷哈哈哈</p><p>打出 1e6 的表发现 sg 值很小，只为 0 ～ 3。将 a 从小到大排序，尺取法做（就是双指针一样的，左端点挪+右端点挪）。</p><p>或者可以前缀和，记录 sum(i, j) 表示 1 ~ i 内 sg = j 的个数，这样就可以 O(1) 算！！</p><h2 id="CF280C"><a href="#CF280C" class="headerlink" title="CF280C"></a><a href="https://www.luogu.com.cn/problem/CF280C" target="_blank" rel="noopener">CF280C</a></h2><hr><p>一个节点有贡献 1 ，当且仅当它到根的路径上没有点染黑。所以选到它的概率是 1 / dep[x], 期望是 1 * 1 / dep[x]，跟除祖先们外的节点无关（其他不产生影响的就可以不管了，反正对于一个局部来说啥都没发生）</p><h2 id="CF200A"><a href="#CF200A" class="headerlink" title="CF200A"></a><a href="https://www.luogu.com.cn/problem/CF200A" target="_blank" rel="noopener">CF200A</a></h2><hr><p>暴力优化，非常之厉害</p><p>考虑多次询问一个位置，暴力查询的话会重复查询一些距离，开数组存一下就好了。</p><p>每次询问时更新，O(能过) 系列但真的跑的很快！</p><h2 id="CF208B"><a href="#CF208B" class="headerlink" title="CF208B"></a><a href="https://www.luogu.com.cn/problem/CF208B" target="_blank" rel="noopener">CF208B</a></h2><hr><p>n 很小，记忆化搜索。注意到每一位只受后第一位和后第三位影响，状态只要记录连续三位。</p><h2 id="CF187D"><a href="#CF187D" class="headerlink" title="CF187D"></a><a href="https://www.luogu.com.cn/problem/CF187D" target="_blank" rel="noopener">CF187D</a></h2><hr><p>发现被一个红灯卡了后，之后的花费都是可以预处理的（求一下每个点从 0 时刻走到终点的时间）。把 dist 都 mod(g + r)，问题就变成了求右边最近的 dist 在 [g, r - 1] 内的位置，权值线段树维护区间最小值</p><h2 id="CF190E"><a href="#CF190E" class="headerlink" title="CF190E"></a><a href="https://www.luogu.com.cn/problem/CF190E" target="_blank" rel="noopener">CF190E</a></h2><hr><p>复杂度是关于 m 的。。链表或 set 优化 bfs，每个点只会被访问度数次，复杂度 O(mlogn)</p><h2 id="CF191E"><a href="#CF191E" class="headerlink" title="CF191E"></a><a href="https://www.luogu.com.cn/problem/CF191E" target="_blank" rel="noopener">CF191E</a></h2><hr><p>求第 K 大连续区间的 val 和。考虑二分判定，离散化 + 树状数组维护。</p><h2 id="CF185D"><a href="#CF185D" class="headerlink" title="CF185D"></a><a href="https://www.luogu.com.cn/problem/CF185D" target="_blank" rel="noopener">CF185D</a></h2><hr><p>很好的数学题</p><p>设 $x = k^{2^l} + 1$</p><p>$k^{2^{l + 1}} + 1 = (x - 1)^2 + 1$</p><p>$gcd(x, (x - 1)^2 + 1) = gcd(x, x^2 - 2x + 1) = gcd(x, 2)$</p><ul><li>k 为奇数：ans = $\frac{PROD}{2^{r - l}}$</li><li>k 为偶数：ans = $PROD$</li></ul><p>根据等比数列的知识，$PROD = \frac{(k^{2^{r + 1}} - 1)}{(k^{2^l} - 1)}$</p><h2 id="CF432D"><a href="#CF432D" class="headerlink" title="CF432D"></a><a href="https://www.luogu.com.cn/problem/CF432D" target="_blank" rel="noopener">CF432D</a></h2><hr><p><a href="https://ouuan.github.io/post/cf432d-prefixes-and-suffixeskmp/" target="_blank" rel="noopener">讲得好的题解</a></p><p>KMP 性质题，f[nxt[i]] = 1 + sum{f[i]}</p><h2 id="CF1107F"><a href="#CF1107F" class="headerlink" title="CF1107F"></a><a href="https://www.luogu.com.cn/problem/CF1107F" target="_blank" rel="noopener">CF1107F</a></h2><hr><p>贷款有三种：不用，付完，没付完</p><p>考虑没付完的贷款，b 大的靠后买更优，所以可以先将 b 从大到小排序</p><p>f[i, j] 表示在前 i 个中选，j 个没付完的 C 最大值</p><h2 id="CF687C"><a href="#CF687C" class="headerlink" title="CF687C"></a><a href="https://www.luogu.com.cn/problem/CF687C" target="_blank" rel="noopener">CF687C</a></h2><hr><p>问能拼出哪些，就想到了 bitset：f[i, j] 表示前 i 个共 j 元能拼出的集合，f[i, j] = f[i - 1, j] | f[i - 1, j - c[i]] | (f[i - 1, j - c[i]] &lt;&lt; c[i])</p><h2 id="LightOJ1422"><a href="#LightOJ1422" class="headerlink" title="LightOJ1422"></a><a href="https://vjudge.net/problem/LightOJ-1422" target="_blank" rel="noopener">LightOJ1422</a></h2><hr><p>区间 dp，f[l, r] = min(f[l + 1, r] + 1, (f[l + 1, i - 1] + 1) + (f[i, r] - 1)(其中 c[l] = c[i]))</p><p>小细节是 f[i, r] - 1，由于 i 可能对 [i + 1, r] 同颜色的衣服有影响，所以不是 f[i + 1, r]; 但要减去重复买的钱。</p><h2 id="CF840C"><a href="#CF840C" class="headerlink" title="CF840C"></a><a href="https://www.luogu.com.cn/problem/CF840C" target="_blank" rel="noopener">CF840C</a></h2><hr><p><a href="https://blog.csdn.net/can919/article/details/80154917" target="_blank" rel="noopener">好的题解</a></p><p>将相乘为完全平方数的数放在同一组里，问题转化成了经典问题：有多少个排列使得相邻两数不在同一组里。</p><p>容斥 + dp，ans = (至少 0 相邻相同的方案数) - (至少 1 相邻相同的方案数) + (至少 2 相邻相同的方案数) …</p><p>dp[i, j] 表示前 i 种数分为 j 块的方案数（无序），相同块中的数相同。即至多 j - 1 不相同，即至少 (n - 1) - (j - 1) = n - j 相同。</p><p>$dp[i, k] = \sum{ dp[i - 1, k - j] \times C(ni - 1, j - 1) \times \frac{n_i!}{j!} }$</p><p>除以 j! 表示使块无序，乘以 n_i! 表示总排列数（迷惑）</p><hr><p>upd：<a href="https://blog.csdn.net/qq_31759205/article/details/77487920" target="_blank" rel="noopener">另一好的题解</a></p><p>还是这个好懂且正常👍</p><p>转移的时候枚举把当前集合分成多少段，有多少段插在之前相同的相邻元素间</p><p>注意由于 size 之和是 n，复杂度不是 O(n^4) 是 O(n^3)</p><h2 id="CF15E"><a href="#CF15E" class="headerlink" title="CF15E"></a><a href="https://www.luogu.com.cn/problem/CF15E" target="_blank" rel="noopener">CF15E</a></h2><hr><p><a href="https://www.cnblogs.com/yyf0309/p/8418287.html" target="_blank" rel="noopener">题解题++ qwq</a></p><p>找规律容易发现：路线是从 H 一直沿着边沿斜线走，拐一圈走到 H 正下方第一个点再拐一圈走到另一斜线，走回 H。</p><p>但后面就不知道怎么做了qaq？看大佬博客吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200731 题解</title>
      <link href="2020/07/31/XJOI200731%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/31/XJOI200731%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我仿佛智障了= =</span></span><br><span class="line"><span class="comment">这一看就很可以递推的样子啊，数位 dp 真的不是很难，是我数位 dp 太弱了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll T, K, l, r, f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">65</span>], bit2[<span class="number">65</span>];</span><br><span class="line"><span class="comment">// f[0, ,] 是已经有一位取小、后面就没有限制的方案数</span></span><br><span class="line"><span class="comment">// f[1, ,] 是受/不受到数位限制的总方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> (a - b + mod) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> (a + b + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    bit2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        bit2[i] = bit2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;  <span class="comment">// 这里的 0 是 (1 &lt;&lt; 0)，也就是 1！1 有 3 种方案！！！</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][i] = (f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>][i] = (f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod + bit2[i] * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2</span>][i] = (f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] % mod + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod * bit2[i] % mod + bit2[i] * bit2[i] % mod * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// !!!</span></span><br><span class="line">    ll cnt = <span class="number">0</span>, x = n;</span><br><span class="line">    <span class="keyword">while</span> (x) x &gt;&gt;= <span class="number">1</span>, ++cnt;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">3</span> : <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">0</span>][i] = (f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">1</span>][i] = (f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod + bit2[i] * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">2</span>][i] = (f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">2</span>][i - <span class="number">1</span>] % mod + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod * bit2[i] % mod + bit2[i] * bit2[i] % mod * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">                f[<span class="number">1</span>][j][i] = f[<span class="number">1</span>][j][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][K][cnt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; K;</span><br><span class="line">    init(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sub(calc(r, K), calc(l - <span class="number">1</span>, K)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>考虑贪心，不断合并平均值最大的块和它的父亲所在连通块。</p><p>证明的话，sum1 <em> num2 &lt; sum2 </em> num1, sum1 / num1 &lt; sum2 / num2，按平均值从大到小排序，堆维护。</p><p>进阶版的 poj-2054，很像 AGC023f-01 on tree，经典贪心了。</p><p><strong>注意！！！我自己写的时候用了priority_queue，但对 sum 和 num 的操作却是在外面做的，也就是说对pq没有修改！而且这样还破坏了pq的结构！！！最后 WA 成了 15pts！！！痛心</strong> </p><p><strong>正确的做法是每次将 fa 从堆里弹出来，对 fa 的操作做完后再 push 一个新的 fa 进去。为了方便执行“弹出操作”，我们用 set 维护优先队列。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, rt, c[N], fa[N], num[N], sum[N], ans, fat[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        ll t2 = sum[id] * num[a.id], t1 = sum[a.id] * num[id];</span><br><span class="line">        <span class="keyword">return</span> t1 &lt; t2 || (t1 == t2 &amp;&amp; id &gt; a.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fat[x] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; rt;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[i]);</span><br><span class="line">        num[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt, rt);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (i != rt) q.insert((node)&#123;i&#125;);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.begin()-&gt;id;</span><br><span class="line">        q.erase(q.begin());</span><br><span class="line">        <span class="keyword">int</span> f = getfa(fat[x]);</span><br><span class="line">        q.erase((node)&#123;f&#125;);</span><br><span class="line">        ans += sum[x] * num[f];</span><br><span class="line">        sum[f] += sum[x], num[f] += num[x];</span><br><span class="line">        fa[x] = f;</span><br><span class="line">        <span class="keyword">if</span> (f != rt) q.insert((node)&#123;f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans + sum[rt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 数位dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】zzd《FFT入门》</title>
      <link href="2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91zzd%E3%80%8AFFT%E5%85%A5%E9%97%A8%E3%80%8B/"/>
      <url>2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91zzd%E3%80%8AFFT%E5%85%A5%E9%97%A8%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="套路1-字符串匹配"><a href="#套路1-字符串匹配" class="headerlink" title="套路1. 字符串匹配"></a><strong>套路1. 字符串匹配</strong></h1><hr><p>我们发现匹配的字符对<strong>下标之差是定值</strong>，翻转其中一个串以后就变成了，匹配的字符对<strong>下标之和是定值</strong>，这是满足卷积形式的。（好妙啊QAQ，卷积形式真的万能</p><h2 id="BZOJ4503"><a href="#BZOJ4503" class="headerlink" title="${[BZOJ4503]}$"></a>${[BZOJ4503]}$</h2><p>不能直接 kmp 啊，通配符的 fail 指针不好定。考虑卷积。</p><p>我们希望通过某一位是否为 0 来判断能否在某位匹配上。可以让相同字符差为 0，做一个平方就不会有“正 + 负 = 零”的情况发生。</p><p>但通配符怎么搞？它可以与任何字符配啊。我们希望有通配符存在 就是 0，那么通配符值 = 0，乘到柿子里去就好了。</p><h3 id="sum-limits-i-1-n-sum-limits-j-1-m-S-i-T-j-2-S-i-T-j"><a href="#sum-limits-i-1-n-sum-limits-j-1-m-S-i-T-j-2-S-i-T-j" class="headerlink" title="\sum\limits_{i = 1}^n\sum\limits_{j = 1}^ m (S_i - T_j)^2 S_i T_j"></a><script type="math/tex">\sum\limits_{i = 1}^n\sum\limits_{j = 1}^ m (S_i - T_j)^2 S_i T_j</script></h3><p>这个东西拆开来，做三次 FFT。</p><h2 id="CF528D"><a href="#CF528D" class="headerlink" title="${[CF528D]}$"></a>${[CF528D]}$</h2><p>按照上一题的套路，我们设 $f[i, c]$ 表示 $[A 的位置 i 匹配字符 c]$，$g[i, c]$ 表示 $[B 的位置 i == c]$。相减之后做平方，这个东西展开太困难了，而且要做很多次 FFT，常数爆炸，考虑别的方法。</p><p>显然 $f[i, c]$ 和 $g[i, c]$ 只是 0/1，若 $A[i]$ 能匹配上 $B[j]$，那么存在一个 $c$，$f[i, c] \times g[j, c] = 1$。</p><p>发现字符集很小，我们分别对每种字符做一次卷积，若位置 i 的四种值之和 == $|B|$ 则位置 $i - |B| + 1$ 可以匹配。复杂度$O(4nlogn)$.</p><h1 id="套路2-卷积形式变形"><a href="#套路2-卷积形式变形" class="headerlink" title="套路2. 卷积形式变形"></a><strong>套路2. 卷积形式变形</strong></h1><hr><p>常用技巧是翻转和更换求和指标。</p><h2 id="ZJOI2014-力"><a href="#ZJOI2014-力" class="headerlink" title="${[ZJOI2014]-力}$"></a>${[ZJOI2014]-力}$</h2><p>自己还推了一部分，hh</p><p>设 $F(i) = \frac{1}{i^2}$，$G(i) = q_i$，一些不合法的下标，值为 0.</p><script type="math/tex; mode=display">E(i) = (\sum\limits_{j = 0}^iF(j) \times G(i - j)) - (\sum\limits_{j = i}^m F(j - i) \times G(j))</script><p>第一个括号里是裸的卷积形式，第二个括号要再做一做。</p><p>更换求和指标：</p><script type="math/tex; mode=display">\sum\limits_{j = 0}^{m - i} F(j) \times G(j + i)</script><p>翻转：（其中 $G^r(i)$ 表示 $G(m - i)$）</p><script type="math/tex; mode=display">\sum\limits_{j = 0}^{m - i} F(j) \times G^r(m - i - j)</script><h1 id="套路3-背包问题相关"><a href="#套路3-背包问题相关" class="headerlink" title="套路3. 背包问题相关"></a><strong>套路3. 背包问题相关</strong></h1><hr><h2 id="CF286E-Ladies’-Shop"><a href="#CF286E-Ladies’-Shop" class="headerlink" title="${[CF286E]-Ladies’ Shop}$"></a>${[CF286E]-Ladies’ Shop}$</h2><p>比较自然的想法，f[a[i]] = 1，f[0] = 1，f 与自己做卷积，做最多 m 次就得到了所有能表示的数。但这样是 O(m log^2 m)的。</p><p>但其实并不用做 m 次。实际上一次卷积就能得出答案。</p><p>一次卷积后，那些 f[i] &gt; 2 的 i 就是可以省略的。为什么？初始一次，f[i] 与 f[0] 相乘一次，还有其他能组成 i 的数字的贡献… 反过来说，f[i] = 2 的 i 就是必选的。</p><h1 id="套路4-分治FFT"><a href="#套路4-分治FFT" class="headerlink" title="套路4. 分治FFT"></a><strong>套路4. 分治FFT</strong></h1><hr><p>（好难啊 QAQ 我没有脑子）</p><h2 id="Lydsy1704月赛-二元运算"><a href="#Lydsy1704月赛-二元运算" class="headerlink" title="${[Lydsy1704月赛]-二元运算}$"></a>${[Lydsy1704月赛]-二元运算}$</h2><p>先不考虑括号里的限制。加法可以直接算，减法要变一下：</p><script type="math/tex; mode=display">ans_k = \sum\limits_{i = k}^n a_i \times b_{i - k}</script><script type="math/tex; mode=display">ans_k = \sum\limits_{i = 0}^{n - k} a_{i + k} \times b_i</script><p>翻转，再将 ans 下标加 n，凑一个卷积形式：</p><script type="math/tex; mode=display">ans_{n + k} = \sum\limits_{i = 0}^{n - k}a_{i + k} \times b_{n - i}^r</script><p>考虑括号里的限制，容易发现在值域上，左区间对右区间一定有贡献，于是想到<strong>分治值域</strong>。具体来说，对于每个数值区间 [l, r]：</p><ul><li>$x = y$: 贡献给 $0$</li><li>$x &lt; y$: $a[l, mid]$ 卷 $b[mid + 1, r]$</li><li>$x &gt; y$: $a[mid + 1, r]$ 卷 $b[l, mid]$</li></ul><p>（我今天才知道在递归过程中计算一个子问题对另一个子问题的贡献的分治就叫 CDQ 分治？？？）</p><h2 id="CF553E-Kyoya-and-Train"><a href="#CF553E-Kyoya-and-Train" class="headerlink" title="${[CF553E]-Kyoya and Train}$"></a>${[CF553E]-Kyoya and Train}$</h2><p>乍一看更像是 dp 题，于是考虑 dp：$f[i, j]$ 表示到 $i$ 位置耗时 $j$ 的最小期望代价，$f[x, t] = min\{c(x, y) + f[y, t + k] \times P_{e, k}\}$，其中 P 表示经过 e 边耗时 k 的概率。</p><p>注意到后面那坨东西可以翻转变成卷积形式，然后这玩意就是分治 FFT 啦，分治时间，对于 $[l, r]$ 先做 $[mid, r]$ 再做 $[l, mid)$。复杂度 $O(mTlog^2T)$.</p><h1 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a><strong>杂题</strong></h1><hr><h2 id="BZOJ3160-万径人踪灭"><a href="#BZOJ3160-万径人踪灭" class="headerlink" title="${[BZOJ3160]-万径人踪灭}$"></a>${[BZOJ3160]-万径人踪灭}$</h2><p>我们先忽略条件 2，最后减去条件 2 的就好了（用 manacher 算）</p><p>按照朴素的解法，展开做多次 FFT 也是可以的，然而还有更简便的方法。考虑<strong>只有 a 和 b</strong>，分开来做再同一位置的相乘，正确性显然。</p><h2 id="Cerc2015-Frightful-Formula"><a href="#Cerc2015-Frightful-Formula" class="headerlink" title="${[Cerc2015]-Frightful Formula}$"></a>${[Cerc2015]-Frightful Formula}$</h2><p>首先假装已经知道这是 FFT 题！然后快乐推柿子。显然答案只分为 $(i, 1)/(1, i)$ 初始值的贡献 和 $(i, j)$ 额外加上的 $c$ 的贡献。</p><p>$(i, 1)/(1, i)$:</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n C(n - i + n - 1, n - i)\times  a^{n - i} b^{n - 1}</script><p>$(i, j)$:</p><script type="math/tex; mode=display">\sum\limits_{i = 2}^n \sum\limits_{j = 2}^n C(n - i + n - j, n - i) \times a^{n - i} b^{n - j} c</script><p>设 $A_i = \frac{a^{n - i}}{(n - i)!}$, $B_i = \frac{b^{n - i}}{(n - i)!}$:</p><script type="math/tex; mode=display">c\sum\limits_{i = 2}^n \sum\limits_{j = 2}^n (2n - i - j)! \times A_iB_j</script><p>枚举 i + j:</p><script type="math/tex; mode=display">c\sum\limits_{i = 4}^{2n} (2n - i)! \sum\limits_{j = 2}^{i - 2} A_jB_{i - j}</script><p>这就是卷积形式了。</p><h2 id="Hnoi2017-礼物"><a href="#Hnoi2017-礼物" class="headerlink" title="${[Hnoi2017]-礼物}$"></a>${[Hnoi2017]-礼物}$</h2><p>我们设得到序列为 a 和 b，设给 a 每一位加 c</p><script type="math/tex; mode=display">ans = \sum (a_i + c - b_i)^2</script><script type="math/tex; mode=display">ans = \sum a_i^2 + \sum b_i^2 + n \times c^2 + 2c \times (\sum a_i - \sum b_i) - 2 \sum a_ib_i</script><p>和 c 有关的项可以枚举或用二次函数求极值，最后一项用卷积求，考虑怎么搞，显然将 a 翻转后复制一份就好啦。</p><h2 id="CF958F3-Lightsabers-hard"><a href="#CF958F3-Lightsabers-hard" class="headerlink" title="${[CF958F3]-Lightsabers(hard)}$"></a>${[CF958F3]-Lightsabers(hard)}$</h2><p>把每种颜色能选的 01 生成函数乘起来，朴素做法会 TLE，考虑<strong>启发式合并</strong>，堆 + vector 维护。$O(nlog^2n)$</p><p>（分治也能做！</p><h2 id="CF623E-Transforming-Sequence"><a href="#CF623E-Transforming-Sequence" class="headerlink" title="${[CF623E]-Transforming Sequence}$"></a>${[CF623E]-Transforming Sequence}$</h2><p>显然 $n &gt; k$ 的时候无解。</p><p>容易发现跟数值具体大小没有关系，关键是每次都有<strong>新的二进制位被填上</strong>。</p><p>小数据的话可以 dp，$f[i, j]$ 表示前 $i$ 个数有 $j$ 个二进制位为 $1$，转移 $f[i, j] = \sum\limits_{k = 0}^{j - 1} f[i - 1, k] \times 2^k \times C(j, k)$，其中 $2^k$ 表示原来已有的可放可不放。</p><p>考虑优化：</p><script type="math/tex; mode=display">\frac{f[i, j]}{j!} = \sum\limits_k \frac{f[i - 1, k] \times 2^k}{k!} \times \frac{1}{(j - k)!}</script><p>这样是 $O(n^2 log n)$ 的，然后我就想不出了。。但还能优化！！考虑到这样一次一次转移太慢了，我们<strong>加大转移的步长</strong>，倍增，合并每段的 dp 值，相当于 dp[n &amp; (2 ^ 0)] 卷 dp[n &amp; (2 ^ 1)] … 卷dp[n &amp; (2 ^ 最高位)]，这样就能在 $O(k log^2 k)$ 的时间复杂度内求出了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jcvb《组合计数问题》题解</title>
      <link href="2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91Jcvb%E3%80%8A%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E3%80%8B/"/>
      <url>2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91Jcvb%E3%80%8A%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>组合数、stirling数</li><li>生成函数 + FFT/NTT</li><li>一些特定的结论（矩阵树，burnside，prufer…）</li><li>一些思想（容斥、补集转化）</li></ul><p>都是常用的技巧！</p><p>DP 每道都是吧 qvq 太重要了，有时用 FFT/NTT 加速。</p><h2 id="TC12004-SetAndSet"><a href="#TC12004-SetAndSet" class="headerlink" title="$[TC12004]-SetAndSet$"></a><a href="https://vjudge.net/problem/Topcoder-12004" target="_blank" rel="noopener">$[TC12004]-SetAndSet$</a></h2><hr><p>按位考虑。</p><p>若对于某一位，存在一个数当前位为 0，则这一位为 0 的数不能全在一边。</p><p>不能全在一边 就很难做，考虑<strong>补集转化</strong>，计算 全在一边 的。我们发现这样会算重，准确来说算的是“至少有几位不同”。</p><p>考虑<strong>容斥思想</strong>，答案 = 总数 - 至少 1 位不同 + 至少 2 位不同 - …</p><p>用 dfs 枚举，并查集维护即可，将枚举位为 0 的并到一块儿去。</p><h2 id="BZOJ1471-不相交路径"><a href="#BZOJ1471-不相交路径" class="headerlink" title="$[BZOJ1471]-不相交路径$"></a>$[BZOJ1471]-不相交路径$</h2><hr><p>不相交难做，相交好做。考虑<strong>容斥</strong>第一个相交的点。计算总方案数的时候用到了拓扑序（路径上排在 x 前面的点 y，拓扑序一定比 x 小）</p><h2 id="SHOI2009-舞会"><a href="#SHOI2009-舞会" class="headerlink" title="$[SHOI2009]-舞会$"></a>$[SHOI2009]-舞会$</h2><hr><p>就是那道-已经没有什么好害怕的了，dp 计算 g 数组，f[i, j] 表示前 i 个女生有 j 个匹配了。</p><h2 id="某CEOI题"><a href="#某CEOI题" class="headerlink" title="$[某CEOI题]$"></a>$[某CEOI题]$</h2><hr><p>什么容斥小于号改为大于号的，咕咕</p><h2 id="TC14170-Divfree"><a href="#TC14170-Divfree" class="headerlink" title="$[TC14170]-Divfree$"></a>$[TC14170]-Divfree$</h2><hr><p>想不到的容斥dp。。</p><p>不合法的状态 (A, B) 是 B 是 A 的真约数时。数字 k 的真约数只有 log(k) 个，k 是 50000，也就是说不合法的链的长度最多 16。</p><p>考虑容斥，f[i] 表示<strong>合法的</strong>长度为 i 的链方案数，g[i] 表示<strong>不合法的</strong>长度为 i 的链方案数。g 可以预处理。</p><p>$f[n] = f[n - 1] <em> g[1] - f[n - 2] </em> g[2] + f[n - 3] * g[3]…$ 太妙了。</p><h2 id="稳定多米诺覆盖"><a href="#稳定多米诺覆盖" class="headerlink" title="$[稳定多米诺覆盖]$"></a>$[稳定多米诺覆盖]$</h2><hr><p><a href="https://imilyx.github.io/2020/07/30/[51nod1518]-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/" target="_blank" rel="noopener">链接</a></p><h2 id="TC13891-Gxor"><a href="#TC13891-Gxor" class="headerlink" title="$[TC13891]-Gxor$"></a>$[TC13891]-Gxor$</h2><hr><p>一道斯特林数相关的数学题</p><p>f[i] 表示至少 i 个连通块，g[i] 表示恰好 i 个连通块，我们要求 g[1]</p><p>考虑一个实际连通块数量为 p 的图，它会在我们枚举 k 个连通块的时候被算 $S_2(p, k)$ 次</p><p>有个柿子：$\sum_i (-1)^{i - 1} S_2(n, i) * (i - 1)! = [n = 1]$</p><p><a href="https://blog.csdn.net/qq_35950004/article/details/106126524" target="_blank" rel="noopener">比较清楚的证明</a></p><p>好神奇啊，消化消化。。。</p><p>$g[1] = \sum\limits_{i = 1}^n f[i] <em> S_1(i, 1) </em> (-1)^{i - 1}$</p><p>f[k] 很难算的样子，怎么办？注意到 n 只有 9，暴搜，强制块与块之间的边不能连（这个高斯消元解异或方程组来搞）。C(17, 9) 左右，嗯很稳！</p><p>代码有一些小细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gxor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll T, n, ans, len, tot;</span><br><span class="line">    ll fac[<span class="number">15</span>], a[N], b[N], col[N], lg[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">15</span>][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            rep(u, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                rep(v, u + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (col[u] != col[v]) a[tot++] = b[t];</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[tot] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">0</span>, T - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((a[cur] &gt;&gt; i) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    rep(j, cur + <span class="number">1</span>, tot - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                            swap(a[j], a[cur]); <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rep(j, cur + <span class="number">1</span>, tot - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// swap(a[j], a[cur]);</span></span><br><span class="line">                        a[j] ^= a[cur];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((a[cur] &gt;&gt; i) &amp; <span class="number">1</span>) ++cur;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += fac[d] * (<span class="number">1l</span>l &lt;&lt; (T - cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = x; t; t = (t - <span class="number">1</span>) &amp; x)</span><br><span class="line">            <span class="keyword">if</span> (t &amp; (x &amp; -x)) &#123;  <span class="comment">// 包含 x 的末尾 1 位置，这样不会重复枚举</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u; u = (u - <span class="number">1</span>) &amp; u)</span><br><span class="line">                    col[lg[u &amp; -u]] = lg[x &amp; -x];</span><br><span class="line">                dfs(x - t, d + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">countsubs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s)</span> </span>&#123;</span><br><span class="line">        T = s.size();</span><br><span class="line">        len = s[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) <span class="keyword">if</span> (i * (i - <span class="number">1</span>) / <span class="number">2</span> == len) &#123; n = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, T - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            rep(u, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">                rep(v, u + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i][t] == <span class="string">'1'</span>) b[t] |= (<span class="number">1l</span>l &lt;&lt; i);</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, <span class="number">10</span>) lg[(<span class="number">1</span> &lt;&lt; i)] = i;</span><br><span class="line">        rep(i, <span class="number">2</span>, <span class="number">10</span>) fac[i] = fac[i - <span class="number">1</span>] * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i += <span class="number">2</span>) fac[i] = -fac[i];</span><br><span class="line">        dfs((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[51nod1518]-稳定多米诺覆盖</title>
      <link href="2020/07/30/%5B51nod1518%5D-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/"/>
      <url>2020/07/30/%5B51nod1518%5D-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<p>我们发现恰好 k 条线不被跨过很难搞，但是至少 k 条线不被跨过就可以 dp，想到容斥（二项式反演）。</p><p>同时枚举行和列的复杂度太高，但是枚举一维后，另一维就可以 dp 了。</p><p>我们选择枚举列，行做 dp：</p><ul><li>f[i, j] 表示 i 行 j 列恰好填满的方案数（插头dp预处理），</li><li>g[k] 表示<strong>至少</strong> k 条<strong>列线</strong>，0 条行线的方案数（0 条行线 通过容斥实现）</li></ul><p><strong>注意：这里插头dp 轮廓线 和回路计数的<a href="https://www.cnblogs.com/iiyiyi/p/5846864.html" target="_blank" rel="noopener">不太一样</a></strong></p><p>（所以要就题论题的设计轮廓线啊！！！）</p><p>重点总结：1. 想到容斥 2. 想到枚举一维后 dp 另一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>], f[<span class="number">20</span>][<span class="number">20</span>], ans, g[<span class="number">20</span>], row[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> tot = (<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>, p = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][tot] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, lim) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp[p], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[p]));</span><br><span class="line">            rep(s, <span class="number">0</span>, tot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((s &gt;&gt; (lim - <span class="number">1</span>)) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    (dp[p][(s &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 竖放一块 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(s &amp; <span class="number">1</span>) &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">                        (dp[p][(s &lt;&lt; <span class="number">1</span> | <span class="number">3</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 横放一块</span></span><br><span class="line">                    (dp[p][(s &lt;&lt; <span class="number">1</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 不放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][lim] = dp[p ^ <span class="number">1</span>][tot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) calc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = m = <span class="number">16</span>;</span><br><span class="line">    prework();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        rep(s, <span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>), (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>) &#123;</span><br><span class="line">            vec.clear();</span><br><span class="line">            <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, m)</span><br><span class="line">                <span class="keyword">if</span> ((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) vec.push_back(i - lst), lst = i;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                row[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.size(); j++)</span><br><span class="line">                    (row[i] *= f[i][vec[j]]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                g[i] = row[i];</span><br><span class="line">                rep(j, <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                    (g[i] -= row[i - j] * g[j] % mod) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((vec.size()) &amp; <span class="number">1</span>) (ans += g[n]) %= mod;</span><br><span class="line">            <span class="keyword">else</span> (ans -= g[n]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> 插头dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200730 题解</title>
      <link href="2020/07/30/XJOI200730%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/30/XJOI200730%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>求最小生成树边权期望。</p><p>“保证距离值相同的道路数小于 30”，显然可以用矩阵树定理。</p><p>根据期望的可加性，整棵树的期望 = 每条边的期望 之和。考虑最小生成树的性质（具体可见 JSOI2008-最小生成树计数），我们分别处理不同长度的边。而每条边的概率是：（包含这条边的生成树个数）/（总生成树个数）。分开做就可以过了，虽然时间复杂度是不对的。</p><p>然而还有一个神仙做法：<a href="https://www.cnblogs.com/Flying2018/p/13406278.html" target="_blank" rel="noopener">flying2018大佬博客</a></p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>为什么没往数据结构想呢。。。要反思，这一看就很线段树嘛</p><p>忽略 limit 的限制——最左的位置可以二分。</p><p>max值是<strong>单调不增</strong>的。</p><p>线段树维护每一个 f[i] 和 max{…}。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 矩阵树定理 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】插头dp</title>
      <link href="2020/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8F%92%E5%A4%B4dp/"/>
      <url>2020/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8F%92%E5%A4%B4dp/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zinthos/p/3897854.html" target="_blank" rel="noopener">这个讲的还不错</a></p><p>重修插头dp！今日主题：讲讲那些奇怪的插头们</p><ul><li>划分阶段（从上到下、从左到右逐格递推）：qvq，轮廓线以上就是已经处理好的状态，只等着根据当前格的插头状态往下推了。</li><li>根据当前格有无左、上插头，推向有无右、下插头的状态。</li><li>关于换行，我们编号 m + 1 个位置 0 ~ m, 显然当前行 0 ~ m - 1 的会转移到 1 ~ m，右移一位就好了。</li><li>朴素的轮廓线只有 0/1 表示有无插头，但以洛谷那道例题为例，这样处理是会出现多个回路的情况的。这时候需要用括号表示法 + X进制（X &gt; 2, 通常取X = 4为宜因为位运算很快且写起来方便）来维护插头之间的联通性（限制了一些非法状态的转移），当然，分类情况也多了不少。。。</li><li>Hash表可以通过去重以及排除无用状态极大的加速插头dp的速度。</li><li>理解不了的话，建议画图 qvq！</li></ul><h2 id="hdu1693"><a href="#hdu1693" class="headerlink" title="hdu1693"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1693" target="_blank" rel="noopener">hdu1693</a></h2><hr><p>可以有多个回路。朴素轮廓线，可以开 f[i, j, s]，也可以滚动数组（细节注意！！！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, m, cas;</span><br><span class="line">ll mp[<span class="number">15</span>][<span class="number">15</span>], f[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            rep(j, <span class="number">1</span>, m)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>, tot = (<span class="number">1</span> &lt;&lt; (m + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            swap(cur, pre);  <span class="comment">// !!!</span></span><br><span class="line">            <span class="built_in">memset</span>(f[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[cur]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; s &gt;= <span class="number">0</span>; --s)</span><br><span class="line">                f[cur][s &lt;&lt; <span class="number">1</span>] = f[pre][s];</span><br><span class="line">            rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">                swap(pre, cur);</span><br><span class="line">                <span class="built_in">memset</span>(f[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[cur]));</span><br><span class="line">                rep(s, <span class="number">0</span>, tot) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> is_r = (s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>, is_d = (s &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!mp[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!is_r &amp;&amp; !is_d)</span><br><span class="line">                            f[cur][s] = f[pre][s];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (is_r &amp;&amp; is_d) &#123;</span><br><span class="line">                            f[cur][s] = f[pre][s - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) - (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_r ^ is_d) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ss = s | (<span class="number">1</span> &lt;&lt; j) | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                            f[cur][s] = f[pre][ss - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] + f[pre][ss - (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            f[cur][s] = f[pre][s + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) + (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: There are %lld ways to eat the trees.\n"</span>, ++cas, f[cur][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷模板"><a href="#洛谷模板" class="headerlink" title="洛谷模板"></a><a href="https://www.luogu.com.cn/problem/P5056" target="_blank" rel="noopener">洛谷模板</a></h2><hr><p>只能有一个闭合回路。</p><p>（一些废话：这是我上来对着题解写的第一道插头dp，hash优化 + 括号表示一个没少。。qwq 被毒死了呀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">590027</span>, N = <span class="number">6e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, ans, ex, ey, pre, cur = <span class="number">1</span>;</span><br><span class="line">ll bits[<span class="number">30</span>], tots[<span class="number">2</span>], lnk[N], nxt[N], to[N], cnt, sta[<span class="number">2</span>][N], dp[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsh</span><span class="params">(ll state, ll val)</span> </span>&#123;</span><br><span class="line">    ll x = state % mod;</span><br><span class="line">    <span class="keyword">for</span> (ll i = lnk[x]; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> (sta[cur][to[i]] == state) &#123;</span><br><span class="line">            dp[cur][to[i]] += val; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    tots[cur]++;</span><br><span class="line">    sta[cur][tots[cur]] = state;</span><br><span class="line">    dp[cur][tots[cur]] = val;</span><br><span class="line"></span><br><span class="line">    to[++cnt] = tots[cur], nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll cursta, curans;</span><br><span class="line">    <span class="keyword">int</span> is_d, is_r;</span><br><span class="line">    dp[cur][tots[cur] = <span class="number">1</span>] = <span class="number">1</span>, sta[cur][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, tots[cur]) sta[cur][j] &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            swap(pre, cur);</span><br><span class="line">            <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">            tots[cur] = cnt = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, tots[pre]) &#123;</span><br><span class="line">                cursta = sta[pre][k], curans = dp[pre][k];</span><br><span class="line">                is_r = (cursta &gt;&gt; bits[j - <span class="number">1</span>]) % <span class="number">4</span>, is_d = (cursta &gt;&gt; bits[j]) % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!is_r &amp;&amp; !is_d)</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!is_r &amp;&amp; !is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j] &amp;&amp; mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta + (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) + <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r &amp;&amp; !is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta - is_r * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) + is_r * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j])</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!is_r &amp;&amp; is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j])</span><br><span class="line">                        hsh(cursta + is_d * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - is_d * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">1</span> &amp;&amp; is_d == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                    rep(l, j + <span class="number">1</span>, m) &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = (cursta &gt;&gt; bits[l]) % <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">1</span>) ++cnt;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">2</span>) --cnt;</span><br><span class="line">                        <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">                            hsh(cursta - (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - (<span class="number">1</span> &lt;&lt; bits[j]) - (<span class="number">1</span> &lt;&lt; bits[l]), curans);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">2</span> &amp;&amp; is_d == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = j - <span class="number">2</span>; l; --l) &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = (cursta &gt;&gt; bits[l]) % <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">1</span>) ++cnt;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">2</span>) --cnt;</span><br><span class="line">                        <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">                            hsh(cursta - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j]) + (<span class="number">1</span> &lt;&lt; bits[l]), curans);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">2</span> &amp;&amp; is_d == <span class="number">1</span>) &#123;</span><br><span class="line">                    hsh(cursta - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">1</span> &amp;&amp; is_d == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == ex &amp;&amp; j == ey)</span><br><span class="line">                        ans += curans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) ex = i, ey = j, mp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">25</span>) bits[i] = (i &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    DP();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51nod1518-稳定多米诺覆盖"><a href="#51nod1518-稳定多米诺覆盖" class="headerlink" title="51nod1518-稳定多米诺覆盖"></a><a href="https://vjudge.net/problem/51Nod-1518" target="_blank" rel="noopener">51nod1518-稳定多米诺覆盖</a></h2><hr><p>终于到你了，感动中国！</p><p><a href="https://imilyx.github.io/2020/07/30/[51nod1518]-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/" target="_blank" rel="noopener">链接</a></p><p>暂时就更这么多吧，后续还会做题 &amp; 写单篇博（可能</p>]]></content>
      
      
      
        <tags>
            
            <tag> 插头dp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200728 题解</title>
      <link href="2020/07/28/XJOI200728%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/28/XJOI200728%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>两道数据结构题给我搞吐了。。。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>原题是 CF418E</p><p>容易发现矩阵的奇数行（除了1）和偶数行是相同的. 感性理解就是把很多串 1，2，3 … 穿插在一起，每次转换一下。</p><p>分块做，f[i, j] 表示第一行前 i 块中数字 j 出现的次数，g[i, j] 表示第二行前 i 块中数字 j 出现的次数</p><p>维护的时候注意 f 和 g 的加减顺序！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> h, n, m, idx, unit = <span class="number">1000</span>, num;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][N], g[M][N], val[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    num = n / unit + (n % unit &gt; <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (!mp[a[i]]) &#123;</span><br><span class="line">            mp[a[i]] = ++idx;</span><br><span class="line">            val[idx] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = mp[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, num) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = (i - <span class="number">1</span>) * unit + <span class="number">1</span>, r = min(i * unit, n);</span><br><span class="line">        rep(j, <span class="number">1</span>, n)  <span class="comment">// 上界取 idx 是不行的！！！g数组最大值为 n！！！</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j], g[i][j] = g[i - <span class="number">1</span>][j];</span><br><span class="line">        rep(j, l, r)</span><br><span class="line">            f[i][a[j]]++, g[i][f[i][a[j]]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp[y]) &#123;</span><br><span class="line">                mp[y] = ++idx;</span><br><span class="line">                val[idx] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            y = mp[y];</span><br><span class="line">            rep(i, (x - <span class="number">1</span>) / unit + <span class="number">1</span>, num)</span><br><span class="line">                g[i][f[i][a[x]]]--, f[i][a[x]]--;</span><br><span class="line">            a[x] = y;</span><br><span class="line">            rep(i, (x - <span class="number">1</span>) / unit + <span class="number">1</span>, num)</span><br><span class="line">                f[i][a[x]]++, g[i][f[i][a[x]]]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, val[a[y]]); <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, y / unit * unit + <span class="number">1</span>, y) &#123;</span><br><span class="line">                f[y / unit][a[i]]++, g[y / unit][f[y / unit][a[i]]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x &amp; <span class="number">1</span> ? g[y / unit][f[y / unit][a[y]]] : f[y / unit][a[y]]);</span><br><span class="line">            rep(i, y / unit * unit + <span class="number">1</span>, y) &#123;</span><br><span class="line">                g[y / unit][f[y / unit][a[i]]]--, f[y / unit][a[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>结论题，就是删掉前 n 个</p><p>这种题应该要打表 + 找规律 + 特判啊，别愣在那里。。。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>考虑没有操作 2，显然一遍 dfs 就能解决（考虑节点 x，它作为 lca 的贡献可以用 询问的a在子树中的个数 和 子树中黑色点的id和 来算）</p><p>考虑有操作 2，本质上多了时间这一维度（经典套路），用线段树合并（时间为下标）</p><p>点 x 作为 lca 的贡献就在合并的时候算。显然时间较小的id和对时间较大的询问有影响。因此要计算 左半边的id和 与 右半边的询问个数 之积（线段树上分治处理）</p><p>O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx;</span><br><span class="line"><span class="keyword">int</span> col[N], lst[N], rt[N];</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> cnt, ls, rs; ll sum; &#125;tr[N * <span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = tr[x].ls, rs = tr[x].rs;</span><br><span class="line">    tr[x].cnt = tr[ls].cnt + tr[rs].cnt;</span><br><span class="line">    tr[x].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[x].cnt += v1;</span><br><span class="line">        tr[x].sum += v2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tr[x].ls, l, mid, pos, v1, v2);</span><br><span class="line">    <span class="keyword">else</span> modify(tr[x].rs, mid + <span class="number">1</span>, r, pos, v1, v2);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">        x = (x | y); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[x].cnt += tr[y].cnt, tr[x].sum += tr[y].sum; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    val[id] += <span class="number">1l</span>l * tr[tr[x].rs].cnt * tr[tr[y].ls].sum;</span><br><span class="line">    val[id] += <span class="number">1l</span>l * tr[tr[x].ls].sum * tr[tr[y].rs].cnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(tr[x].ls, tr[y].ls, l, mid, id);</span><br><span class="line">    merge(tr[x].rs, tr[y].rs, mid + <span class="number">1</span>, r, id);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        merge(rt[x], rt[y], <span class="number">0</span>, m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">        <span class="keyword">if</span> (col[i]) modify(rt[i], <span class="number">0</span>, m, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            modify(rt[x], <span class="number">0</span>, m, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (col[x]) val[x] += x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            col[x] ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (col[x]) &#123;</span><br><span class="line">                modify(rt[x], <span class="number">0</span>, m, i, <span class="number">0</span>, x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                modify(rt[x], <span class="number">0</span>, m, i, <span class="number">0</span>, -x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, val[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 线段树合并 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200727 题解</title>
      <link href="2020/07/28/XJOI200727%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/28/XJOI200727%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>只订了 A B，题真好（nán）啊 ~</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>答案是 $\sum (ai + k - a[i] mod k)$</p><p>考虑 a[i] &lt; k 的时候，这段长度就是 k</p><p>所以我们可以将 k 从小到大排序，对于每个 k 删掉 &lt; k 的 a[i]，对于剩下的点做前缀和、二分，边界特殊处理</p><p>为什么这样复杂度是对的呢？<strong>每个 a[i] 被计算它的大小次</strong>，所以是 O(n + Qlogn) 的（瓶颈在于二分）</p><p>太妙了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, Q, tot;</span><br><span class="line">ll cur[N], a[N], b[N], pos[N], pre[N], ans[M];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> ll l, r, k, id; &#125;q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span> </span>&#123; <span class="keyword">return</span> a.k &lt; b.k; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            pos[++tot] = i;</span><br><span class="line">            a[tot] = i - <span class="number">1</span> - pos[tot - <span class="number">1</span>];</span><br><span class="line">            b[tot] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">        cur[i] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].k);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        ll l = q[i].l, r = q[i].r, k = q[i].k;</span><br><span class="line">        <span class="keyword">if</span> (k != q[i - <span class="number">1</span>].k) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">1</span>, tot)</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt;= k) a[++cnt] = a[j], b[cnt] = b[j];</span><br><span class="line">            tot = cnt;</span><br><span class="line">            rep(j, <span class="number">1</span>, tot) pre[j] = pre[j - <span class="number">1</span>] + a[j] / k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur[l - <span class="number">1</span>] == cur[r]) &#123;</span><br><span class="line">            ans[q[i].id] = r - l + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(b + <span class="number">1</span>, b + tot + <span class="number">1</span>, cur[l - <span class="number">1</span>] + <span class="number">2</span>) - b;</span><br><span class="line">        <span class="keyword">int</span> y = upper_bound(b + <span class="number">1</span>, b + tot + <span class="number">1</span>, cur[r]) - b - <span class="number">1</span>;</span><br><span class="line">        ans[q[i].id] = (r - pos[cur[r]]) + k * (cur[r] - cur[l - <span class="number">1</span>] + (pre[y] - pre[x - <span class="number">1</span>]) + (pos[cur[l - <span class="number">1</span>] + <span class="number">1</span>] - l) / k);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易列出 dp 柿子 $f[i, j] = \sum\limits_k f[i - 1, j - a_k]$，答案就是 $f<a href="i\ mod\ n = 0">l, i</a>$</p><p>容易想到矩阵快速幂，但是复杂度太高会爆炸</p><p>从生成函数的视角出发，设 $g(x) = \sum\limits_i x^{a_i}$，则 $[j + a_k] f^i = \sum [j]f^{i - 1} \times [a_k] g$，这是<a href="https://www.cnblogs.com/birchtree/p/12287474.html" target="_blank" rel="noopener">循环卷积</a>的形式。所以说我们平时写的 fft/ntt 其实就是忽视了 2^? 的循环卷积！本题 n 是 2^?，若不是，则需要做任意长度fft了。（我不会</p><p>卷积快速幂其实就是转化成点值形式，点对点直接做快速幂。</p><p>m 个限制可以分段做再乘起来，每做完一个限制就把下一个限制位置的方案数置为 0，复杂度是 O(mnlog^2n)</p><p><a href="https://www.cnblogs.com/Flying2018/p/13387482.html" target="_blank" rel="noopener">据说还能容斥？？？咕咕</a></p><p>code（分段做）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">66000</span> * <span class="number">2</span>, G = <span class="number">3</span>, G1 = (mod + <span class="number">1</span>) / G;</span><br><span class="line">ll n, L, m, Q, lim = <span class="number">1</span>;</span><br><span class="line">ll r[N], f[N], g[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">limits</span> &#123;</span> ll x, y; &#125;li[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(limits a, limits b)</span> </span>&#123; <span class="keyword">return</span> a.x &lt; b.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G : G1, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;li[i].x, &amp;li[i].y);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); f[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    li[++m] = (limits)&#123;L, <span class="number">0</span>&#125;;</span><br><span class="line">    sort(li + <span class="number">1</span>, li + m + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, ++l;  <span class="comment">// &lt; n 哦，是循环卷积</span></span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">    ntt(f, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        ntt(g, <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">0</span>, n - <span class="number">1</span>) g[j] = g[j] * quick_pow(f[j], li[i].x - li[i - <span class="number">1</span>].x) % mod;  <span class="comment">// 点值直接做快速幂</span></span><br><span class="line">        ntt(g, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) g[li[i].x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, g[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>看了 <a href="https://www.cnblogs.com/Flying2018/p/13399374.html" target="_blank" rel="noopener">Flying2018大佬博客</a> 来订正了。。。</p><p><strong>本题所有思考基于一个性质：对于 $gcd(a, b) = 1$，$l = a \times b$, $len(l) = lcm(len(a), len(b))$</strong></p><p>所以只要考虑所有 = 质数的 m 就好了。</p><p>考虑 f(n) 怎么算，显然 $f(n) = x \times a^n + \sum\limits_{i &lt; n} c \times a^i$</p><p>那么就是要求 $x \times a^n + \sum\limits_{i &lt; n} c \times a^i \equiv x (mod m)$ 的最小 n</p><p>即 $\frac{a^n - 1}{a - 1} \equiv x(1 - a^n) (mod m)$ </p><p>然后开始分讨：</p><ul><li>a = 0：循环节为 1</li><li>a = 1：</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> NTT优化 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ455]-雪灾与外卖</title>
      <link href="2020/07/27/%5BUOJ455%5D-%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96/"/>
      <url>2020/07/27/%5BUOJ455%5D-%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<p><a href="http://uoj.ac/problem/455" target="_blank" rel="noopener">传送门</a></p><p>感觉这题好神啊，可撤销贪心什么的傻傻想不明白，模拟费用流也太高级了吧</p><hr><p>复习一下网络流</p><p>注意反悔边</p><p>如果裸的跑，即 EK，会 T，$O(nm^2)$</p><p>优化就是在最短路上跑，（更准确地说是保留在原来的残量网络中可以被增广的边即连的点）dinic，$O(n^2m)$</p><hr><p>回到本题</p><p>裸的费用流 或者 根据贪心用单调队列做 是 25 分</p><p>正解是用可撤销贪心来模拟费用流（什么）</p><p><a href="https://www.cnblogs.com/yinwuxiao/p/10325138.html" target="_blank" rel="noopener">学习了这篇博客</a></p><p>重点在于模拟退流，即反悔操作</p><p>考虑将人和餐厅按坐标排序，从左往右做，维护两个堆分别储存人和餐厅的贡献们</p><p>先忽略 $c$ 的限制，即将餐厅拆点</p><p><strong>对于人</strong>，把它与左边最优的餐厅匹配，贡献是 $x_i + v_j$, 其中 $v_j$ 是左边餐厅的贡献</p><p>如果人要反悔，贡献就是 $-2x_i - v_j$</p><p>注意这里餐厅没有反悔的必要，因为餐厅与人的匹配不会相交，只需要保证人反悔再反悔能匹配上原餐厅就好了</p><p><strong>对于餐厅</strong>，把它与左边最优的人匹配，贡献是 $y_i + w_i + v_j$，其中 $v_j$ 是左边人的贡献</p><p>如果人要反悔，贡献就是 $-y - w$</p><p>如果餐厅要反悔，$-v_j - 2y$</p><p>这样复杂度是 $O((n + \sum c)log(n + \sum c))$</p><p>考虑去掉拆点，发现当前暂时匹配同一个餐厅的人 的反悔贡献是相同的，于是可以把它们压在一起</p><p>$O((n + m)log(n + m))$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;  <span class="comment">// 第二位是个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line">ll n, m, X[N], Y[N], W[N], C[N];</span><br><span class="line">ll ans, tot;</span><br><span class="line">priority_queue&lt;pll, <span class="built_in">vector</span>&lt;pll&gt;, greater&lt;pll&gt; &gt; A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_x</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y;</span><br><span class="line">    <span class="keyword">if</span> (B.empty()) y = inf;</span><br><span class="line">    <span class="keyword">else</span> y = B.top().first;</span><br><span class="line">    ans += x + y;</span><br><span class="line">    A.push(make_pair(<span class="number">-2</span> * x - y, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (B.size()) &#123;</span><br><span class="line">        ll t = B.top().second;</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) B.push(make_pair(y, t - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_y</span><span class="params">(ll y, ll w, ll c)</span> </span>&#123;</span><br><span class="line">    ll m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c != m &amp;&amp; A.size() &amp;&amp; y + w + A.top().first &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ll x = A.top().first;</span><br><span class="line">        ll t = A.top().second, tt = min(c - m, t);</span><br><span class="line">        ans += tt * (x + y + w);</span><br><span class="line">        A.pop();</span><br><span class="line">        <span class="keyword">if</span> (tt != t) A.push(make_pair(x, t - tt));</span><br><span class="line">        B.push(make_pair(-x - <span class="number">2</span> * y, tt));</span><br><span class="line">        m += tt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m) A.push(make_pair(-y - w, m));</span><br><span class="line">    <span class="keyword">if</span> (c != m) B.push(make_pair(-y + w, c - m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;X[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;Y[i], &amp;W[i], &amp;C[i]), tot += C[i];</span><br><span class="line">    <span class="keyword">if</span> (tot &lt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; j &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[i] &lt; Y[j]) push_x(X[i]), ++i;</span><br><span class="line">        <span class="keyword">else</span> push_y(Y[j], W[j], C[j]), ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) push_x(X[i]), ++i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= m) push_y(Y[j], W[j], C[j]), ++j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 可撤销贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ513]-清扫银河</title>
      <link href="2020/07/27/%5BUOJ513%5D-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/"/>
      <url>2020/07/27/%5BUOJ513%5D-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<p><a href="http://peehs-moorhsum.blog.uoj.ac/blog/5486" target="_blank" rel="noopener">官方题解</a> 逻辑很清晰！</p><p>若有解则必然可以在 m + 1 次操作里出解。</p><p><strong>证明：</strong><br>首先要知道一个性质：无向图的任何环都可以由若干个非树边覆盖的环异或得到。也就是说有用的操作一只有 m - n + 1 个。</p><p>而操作二等价于每次选一个点，将与这个点相邻的边全部反转，也就是说有用的操作二有 n 个。</p><p>总共操作数为 m + 1 个，解异或方程组，必然可以在 m + 1 次操作里出解，况且多个操作二还可以合成一个呢。</p><p>但真的这样做却是 O(m^3 / 32) 的，考虑优化。</p><p>将所有 1 边形成的图称为目标子图。</p><p>根据<strong>欧拉回路</strong>的知识，若目标子图中每个节点的度数都是偶数，则必然可以通过不超过 m - n + 1 次操作一将边权都变成 0.</p><p>因此只要考虑，仅用操作二能否让目标子图中每个节点度数变成偶数。</p><p>这样是 O(n^3 / 32) 的。</p><p>异或什么的想想方程组啊，，，虽然暴力，但到底是个切入口。不过后续就需要找性质了。</p><p>正式做题时，逆推回去比较好：环上点的度数都是偶数…所以blabla</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; a[N], x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i][i]) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, n) <span class="keyword">if</span> (a[j][i]) &#123; swap(a[i], a[j]); <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!a[i][i]) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) <span class="keyword">if</span> (a[j][i]) a[j] ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i][n + <span class="number">1</span>];</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) t ^= (a[i][j] * x[j]);</span><br><span class="line">        <span class="keyword">if</span> (!a[i][i] &amp;&amp; t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x[i] = t;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            a[x][x].flip(), a[y][y].flip(), a[x][y] = <span class="number">1</span>, a[y][x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (z) a[x][n + <span class="number">1</span>].flip(), a[y][n + <span class="number">1</span>].flip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(Gauss() ? <span class="string">"yes"</span> : <span class="string">"no"</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) a[i].reset();</span><br><span class="line">        x.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 017 题解</title>
      <link href="2020/07/27/AGC%20017%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/27/AGC%20017%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>A dp 一下就好了</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>枚举减了多少次，算出这个 n - 1 项数列末项的最小值和最大值，显然这个范围内任何一个数都是可达的</p><p>check b 是否在范围内就好了</p><h2 id="C"><a href="#C" class="headerlink" title="*C"></a>*C</h2><hr><p>设 f[i] 表示按 ai 排序的某个前缀 i 个球，是否合法</p><p>显然 f[i + num[j]] 在 i + num[j] = j 的时候也是合法的</p><p>到这里就不会了，，，</p><p>题解巧妙的转化成了线段覆盖，i 号球的是 [i - num[i], i] 这一段，答案就是 [0, n] 间没被覆盖的线段数</p><p>为什么？首先所有线段被覆盖次数之和为 n，那么没被覆盖的线段需要从 重复覆盖的线段 移过去，正确性显然。</p><h2 id="D"><a href="#D" class="headerlink" title="*D"></a>*D</h2><hr><p>竟然是经典套路。。学习一波</p><p>Hackenbush删边游戏，<strong>sg[x] = XOR( sg[son] + 1 )</strong>，好像归纳法可证</p><p>这玩意还有一些奇奇怪怪的扩展，比如无向连通图上玩游戏。。。</p><p>这就需要用环搞事情了（不会</p><h2 id="E"><a href="#E" class="headerlink" title="*E"></a>*E</h2><hr><p>大概想到要转化成图上问题了，但暴力建边 n^2 + 哈密顿路径显然不可做。。。</p><p>考虑欧拉路径，h 只有 200，我们将左边贴地高度 k 的形状 和右边离地高度 k 的形状 标号 k，左边离地高度 k 的形状 和右边贴地高度 k 的形状 标号 -k，那么每个积木就成了连接两个形状的有向边</p><p>问题就转化成了：能否找到若干条 s -&gt; t 的路径，包含所有边且 s &gt; 0, t &lt; 0</p><p>这需要满足条件：</p><ul><li>x &gt; 0, in[x] &lt;= out[x]</li><li>x &lt; 0, in[x] &gt;= out[x]</li><li>在每个（弱）连通分量中，必须有一个点 x, in[x] != out[x]</li></ul><p>正确性还是比较显然的，证明考虑不断拿环就好了。</p><p>upd: 别忘了连双向边（可以从 t 搜回 s）</p><h2 id="F"><a href="#F" class="headerlink" title="*F"></a>*F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 015 题解</title>
      <link href="2020/07/27/AGC%20015%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/27/AGC%20015%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>AB均为水题</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>网格图常见套路：C = V - E + F，前缀和，处理一下临界的行和列</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>一般的位运算题都是一位一位分开来搞，但这题没法这么做。</p><p>整体考虑。首先 A 和 B 前面相同的位可以忽略。</p><p>设第一个不同的位为 p，我们将区间划分为 $[A, 2^p)$ 和 $[2^p, B]$。</p><p>单取 $[A, 2^p)$，可以 or 出 $[A, 2^p)$</p><p>单取 $[2^p, B]$，设 B 中除 p 以外的最高位为 d，可以 or 出 $[2^p, 2^{d + 1})$</p><p>两个区间都取，可以 or 出 $[2^p + A, 2^{p + 1})$</p><p>答案就是这三个区间的并集。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>看染了点 i 能染哪些点 j：</p><ul><li>xi &gt; xj, vi &lt; vj</li><li>xi &lt; xj, vi &gt; vj</li></ul><p>可以将 v 升序排列，设 li 表示最左的 xj &gt;= xi 的 j，ri 表示最右的 xj &lt;= xi 的 j。那么 i 能染到的区间就是 [li, ri]（这个区间中有些点是被 li 和 ri 染到的）</p><p>问题就转化成：给你若干个区间 [li, ri] 满足 li、ri 递增，求有多少种区间集合能覆盖所有的点？</p><p>dp，f[i] 表示选第 i 区间，覆盖 [1, ri] 的方案数，显然当 j &lt; i 且 Rj &gt;= li - 1 时 f[j] 可以转移到 f[i]</p><p>若 f[j] 能转移到 f[i]，则 f[j + 1] 也能转移到 f[i]，所以设 L 为最左边的 j, [L, i - 1] 的都能转移到 f[i]。容易发现 L 是单调递增的，维护 L 和前缀和就可以做了！</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>结论题，不是很懂（据说官方题解挂掉了？</p><p>逆推一波想到斐波那契数列，这很优的样子</p><p>证明看<a href="https://blog.csdn.net/corsica6/article/details/88579827" target="_blank" rel="noopener">这个博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week4测试题解</title>
      <link href="2020/07/26/Week4%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/26/Week4%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/contest/385165#overview" target="_blank" rel="noopener">传送门</a></p><p><a href="https://zybuluo.com/Cyani/note/1727491" target="_blank" rel="noopener">GHIK的题解</a></p><p>吐槽一句，我是罚时巨怪无疑了，noip可不会给你罚时的机会啊！！！</p><p>提高准确度，力求一遍写对！！！</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>double 会爆精度，可以用 hash（其实就是为了不爆 longlong 而加模数罢了）</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p><strong>可以三分套三分</strong>的题都是单谷函数。据说可以模拟退火，而我并不会那个。。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>题目看错了。。。n^2 做即可</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>随着行的数增大，每个数的位数也会增大，但<strong>至多 log 次</strong>。因此行的位数总变化次数为 O(n log10^9)，因此可以求出每一行的位数，这个大概二分什么的皆可吧。</p><p>然后对于询问，二分行，二分列，再用主席树或者离线树状数组维护一下吧，我也不会，咕咕。</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><hr><p>没看懂，咕咕</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><hr><p>考虑最终棋盘每行每列不会超过 1 个棋子，且所有留到最后的棋子都是在初始位置上</p><p>想到二分图匹配。最多留下来，是平面最大独立集问题，行列建点连边，跑二分图最大匹配。</p><p>那么最少留下来呢？并查集，将所有能互相吃的棋子连一条边，答案就是连通块数。</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><hr><p>二维 FFT，告辞，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJU-ACM 7.23 F 以及类似模型总结</title>
      <link href="2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在讲此题之前，我们先来看看两个问题：</p><ul><li>n 个点的有标号无向连通图计数（poj1737）</li><li>左边 n 个点、右边 m 个点的有标号连通二分图计数</li></ul><p>我们采取 dp 来解决这一类图的计数问题。</p><p>f[n] 表示 n 个点都和点 1 相连的连通图数，g[n] 表示 n 个点的图数</p><p>显然 $f[n] = g[n] - \sum\limits_{i = 1}^{n - 1} C(n - 1, i - 1) <em> f[i] </em> g[n - i]$</p><p>后面这一坨是不连通的图数，为了防止重复计数，我们枚举<strong>与点 1 相连</strong>的块。</p><p>那么第二个问题也是一样的套路，f[n, m] 表示左边 n 个点、右边 m 个点都和左边第 1 个点相连的连通图数，g[n, m] 表示左 n 右 m 的图数, $f[n, m] = g[n, m] - \sum\limits_{i = 1}^{n - 1} \sum\limits_{j = 1}^{m} C(n - 1, i - 1) <em> C(m, j) </em> f[i, j] * g[n - i, m - j]$</p><p>显然上面这两个柿子都是卷积形式，可以用 FTT/NTT 优化。</p><hr><p>回到本题！</p><p>f[n, m] 表示 n 个点 m 条边的连通图数</p><p>$f[n, m] = g[n, m] - \sum\limits_{i = 1}^{n - 1} \sum\limits_{j = 1}^m C(n - 1, i - 1) <em> f[i, j] </em> g[n - i, m - j]$</p><p>这也是卷积形式，但是 NTT 是 O(n^4 logn) 的。考虑我们重复计算了 DFT 和 IDFT 很多次，保留 f 的 DFT 形式（点值形式），就可以优化到 O(n^4 logn)。据说卡卡常就能过，但是 TLE 了= = 假装 AC</p><p>（挂一个<a href="https://www.kdocs.cn/l/sfiEGXVVWPTR?f=201" target="_blank" rel="noopener">官方题解</a>，我没看懂 F 的复杂度分析，，咕咕）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (register int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">2e4</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, G = <span class="number">3</span>, G1 = (mod + <span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, lim = <span class="number">1</span>;</span><br><span class="line">ll fac[M], inv[M], r[M], h[M], f[N][M], g[N][M], c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, m) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, m) inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; m * <span class="number">2</span>) lim &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G : G1, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    m = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    init();</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, i * (i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            g[i][j] = C(i * (i - <span class="number">1</span>) / <span class="number">2</span>, j);</span><br><span class="line">        NTT(g[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, lim - <span class="number">1</span>) &#123;</span><br><span class="line">            h[j] = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                h[j] = (h[j] + c[i - <span class="number">1</span>][k - <span class="number">1</span>] * f[k][j] % mod * g[i - k][j] % mod) % mod;  <span class="comment">// 保留 DFT 形式，省一个 log</span></span><br><span class="line">            f[i][j] = (g[i][j] - h[j] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(f[n], <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, m) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NTT优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 初赛（B）</title>
      <link href="2020/07/26/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BB/"/>
      <url>2020/07/26/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BB/</url>
      
        <content type="html"><![CDATA[<p>A B C 均为水题（A它卡我精度！必须整型处理，吐了</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>我是 10^5 枚举，可以过，但是更正经的解法是状压 dp 阿。。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>这题不对劲！这，这不是（简化版的）第一场的 G 嘛！费用流裸题</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>这看上去像一道傻*题，不是吗不是吗不是吗（有诈</p><p>咕咕</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>大观察题</p><p>首先我们知道 Alice 囤题是为了耽误 Bob 的时间</p><p>若 Alice 能在 \sum_{i = 1}^p {b_i} 的时间内写完第 p 题，就可以拿到 1 分，因为她可以等 Bob 刚好写完第 p 题的时候提交</p><ul><li>那么 Bob 按顺序写了所有题！（好惨阿</li></ul><p>设 Alice 能拿 1 分的题的集合为 S，显然 Alice 按编号从小到大做 S 中的题最优，因为对后面题的影响最少</p><ul><li>那么顺序这个难搞的东西就被解决了！</li></ul><p>然后就可以 dp 了，考虑到 n 只有 2000，我们设计 n^2 的 dp</p><p>显然重要量就三个：位置，分数，时间，其中时间的范围很大</p><p>f[i, j] 表示前 i 道题，Alice 拿了 j 分的最小时间，转移考虑是否选当前的题</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>神题，需要仔细思考 hanoi 游戏的进程</p><p>显然是，为了移动一个大盘子，让其他小盘子聚拢到一根柱子的过程的重复版本，那么我们就有了子问题</p><p>然后后面就看不懂了，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 016 题解</title>
      <link href="2020/07/24/AGC%20016%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/24/AGC%20016%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>016 的难度比 015 高 ~</p><p>智商被完虐了。。【失去梦想.jpg】</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>枚举最终变成哪个字母</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易发现 min 与 max 相差不超过 1</p><p>若 min = max，则要么每种颜色都是 1 个，要么每种颜色都有 2 个以上</p><p>若 min + 1 = max，分类讨论就好了，样例大良心 qvq</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>透过样例 2 我们看出，若 n 是 h 的倍数且 m 是 w 的倍数，不可能构造</p><p>那么我们应该使得 n % h、m % w 的部分的贡献尽量大。这边提供一种乱搞思路：定一个较大的值为 d，对于 (h 倍数，w 倍数) 的位置放 -(hw - 1)d - 1，其余位置放 d</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>不错的思维题</p><p>容易发现，若将异或值视为 n + 1 位的序列元素，整个操作就等价于不断将 x (1 &lt;= x &lt;= n) 位置与 n + 1 位置的元素交换</p><p>题解方法非常神仙：</p><p>若 ai != bi，则从 ai 向 bi 连边</p><p>最终答案 = 总边数 + 连通块数 - 1</p><p>注意这里的总边数是不考虑 n + 1 的</p><p>大小为 x 连通块需要 x - 1 次，块与块之间 n + 1 位置的转换需要 1</p><p>对于第 n + 1 个位置单独考虑，若它独一个点则是要考虑到连通块里的</p><p>正确性可以分类讨论一下，比较显然。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>伪概率题，超级无敌妙！解法容易理解，却想不到哇。。</p><p>考虑钦定一只活到最后的鸡，设它为 i。</p><p>它能活着，必然有其他的鸡为它而死，那么我们维护一个集合，表示为 i 死的鸡有哪些。</p><p>考虑时间倒流。每当集合里的鸡出现时，我们将另一只鸡加入集合；若另一只鸡已经在集合中，那么这只钦定的鸡活不到最后。</p><p>枚举两只活到最后的鸡，判他们的集合是否交，若交则无解，因为一只鸡不能死两次。</p><p>真就 留着你是为了炖了你呗（</p><p>具体实现用 bitset，O(nm + n^3 / 32)，注意 bitset &amp; 操作是 O(n) 的</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>sg(1) ^ sg(2) != 0 不好考虑，正难则反，我们用 2^m - ( sg(1) = sg(2) 的方案数 )</p><p>考虑边集显然不现实，我们考虑点集。</p><p>将 DAG 中的点按照 sg 值分层，显然点 1 和点 2 在同一层</p><p>根据分层，想到子集dp，f[S] 表示只考虑 S 这个点集使得 sg(1) = sg(2) 的方案数（注意 S 必须同时包含或不包含 1 和 2）</p><p>转移就枚举 S 的子集 T，设 U 为补集，其中 T 中 sg 值都不为 0，U 中 sg 值都为 0（U 其实就是底层点集），也就是说 1 和 2 必须同时在 T 中或者 U 中</p><p>统计方案的四条规则：</p><ul><li>U 不能内部连边</li><li>T 内部就是 f[T]</li><li>T 中每个点都至少有一条到 U 的边（T 中 sg 值 += 1）</li><li>U 到 T 随便连</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第三轮选讲</title>
      <link href="2020/07/22/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/22/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kdocs.cn/l/srN6cUALrHvX?f=201" target="_blank" rel="noopener">7.21 题解</a></p><h2 id="7-21-A"><a href="#7-21-A" class="headerlink" title="[7.21 A]"></a>[7.21 A]</h2><hr><p>是斐波那契数列啊啊啊啊！所以当然 S(i, j) + S(i, j + 1) = S(i, j + 2)，精妙。</p><p>但是后面的矩阵设计就不知道了，咕咕。</p><p>upd: 还有另一种<a href="https://www.cnblogs.com/Flying2018/p/13356497.html" target="_blank" rel="noopener">神仙做法</a></p><p>upd: 还有一种 <a href="https://www.cnblogs.com/Wendigo/p/13357673.html" target="_blank" rel="noopener">矩阵 + 倍增</a></p><p><a href="https://www.kdocs.cn/l/shvH8qsctES4?f=201" target="_blank" rel="noopener">7.22 题解</a></p><h2 id="7-22-E"><a href="#7-22-E" class="headerlink" title="[7.22 E]"></a>[7.22 E]</h2><hr><p>实在是太妙了orz。。再说一次，枚举顺序要想到状压啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll n, pos[<span class="number">25</span>][<span class="number">30</span>], dp[<span class="number">1</span> &lt;&lt; <span class="number">21</span>][<span class="number">30</span>], ans;</span><br><span class="line"><span class="comment">// pos[i, j] 表示接上 i 串前 1 在位置 j，接上后的位置</span></span><br><span class="line"><span class="comment">// dp[s, i] 表示已接上的串的集合为 s，1 在位置 i 的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">26</span>) &#123;  <span class="comment">// 枚举接上 i 串前的 1 在哪（ 0 表示 sum</span></span><br><span class="line">            pos[i][j] = j;</span><br><span class="line">            rep(k, <span class="number">1</span>, len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k] - <span class="string">'a'</span> + <span class="number">1</span> == pos[i][j]) pos[i][j] = <span class="number">0</span>;  <span class="comment">// 与 sum 交换了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!pos[i][j]) pos[i][j] = s[k] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">26</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[s][j]) &#123;</span><br><span class="line">                rep(i, <span class="number">1</span>, n)</span><br><span class="line">                    <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))))</span><br><span class="line">                        dp[s | (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][pos[i][j]] += dp[s][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">26</span>) ans += dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-22-F"><a href="#7-22-F" class="headerlink" title="[7.22 F]"></a>[7.22 F]</h2><hr><p>cf453b 的加强版</p><p>bi 大于 100 显然不优，所以考虑 100 以内的数。</p><p>100 以内质数有 25 个，不能直接状压。考虑到 50 以内的质数有 15 个，而 50 以上的质数必然只会单独出现且越小越好。选 ai 去匹配，更大一些的 ai 显然不会更差。</p><p>所以考虑将 a 从小到大排序，枚举 i，先用 50 以内的质数处理出前 i 个数的结果，再考虑贪心选取大于 50 的质数、与后 n - i 个数一一匹配的结果。</p><hr><p><a href="https://www.kdocs.cn/l/sfiEGXVVWPTR?f=201" target="_blank" rel="noopener">7.23 题解</a></p><h2 id="7-23-C"><a href="#7-23-C" class="headerlink" title="[7.23 C]"></a>[7.23 C]</h2><hr><p>原题是 <a href="http://uoj.ac/contest/51/problem/513" target="_blank" rel="noopener">清扫银河</a> ！</p><p>我的题解是<a href="https://imilyx.github.io/2020/07/27/[UOJ513]-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/" target="_blank" rel="noopener">这个</a></p><h2 id="7-23-D"><a href="#7-23-D" class="headerlink" title="[7.23 D]"></a>[7.23 D]</h2><hr><p>数论题，咕咕</p><h2 id="7-23-E"><a href="#7-23-E" class="headerlink" title="[7.23 E]"></a>[7.23 E]</h2><hr><p>概率 + 生成函数，咕咕</p><h2 id="7-23-F"><a href="#7-23-F" class="headerlink" title="[7.23 F]"></a>[7.23 F]</h2><hr><p>我写的题解是<a href="https://imilyx.github.io/2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">这个</a></p><p>据说还能斯特林反演？咕咕</p><h2 id="7-23-G"><a href="#7-23-G" class="headerlink" title="[7.23 G]"></a>[7.23 G]</h2><hr><p>burnside引理 + 生成函数，特别神仙的题，咕咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SDOI2017选讲</title>
      <link href="2020/07/21/SDOI2017%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/21/SDOI2017%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h2><hr><p>至少有一个数是质数的情况 = 忽略质数的情况 - 无质数的情况，矩乘加速</p><h2 id="新生舞会"><a href="#新生舞会" class="headerlink" title="新生舞会"></a>新生舞会</h2><hr><p>很裸的分数规划 + km或费用流判是否合法，我不会km qwq。。</p><p>网络流，要计算空间啊。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;  <span class="comment">// 空间要开足</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>][<span class="number">105</span>], b[<span class="number">105</span>][<span class="number">105</span>], S, T;</span><br><span class="line"><span class="keyword">int</span> to[N], fr[N], lnk[N], cnt, nxt[N], cap[N], pre[N], rest[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="keyword">double</span> val[N], dis[N], ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">double</span> v)</span> </span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    to[cnt] = y, fr[cnt] = x, nxt[cnt] = lnk[x], lnk[x] = cnt, cap[cnt] = c, val[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">double</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    rep(i, S, T) dis[i] = <span class="number">-1e18</span>, inq[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">    inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>, dis[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &gt; <span class="number">0</span> &amp;&amp; dis[y] &lt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) &#123;</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] == <span class="number">-1e18</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += dis[T] * rest[T];</span><br><span class="line">    <span class="keyword">int</span> x = T;</span><br><span class="line">    <span class="keyword">while</span> (x != S) &#123;</span><br><span class="line">        cap[pre[x]] -= rest[T], cap[pre[x] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        x = fr[pre[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + n, T, <span class="number">1</span>, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">double</span> v = a[i][j] - b[i][j] * mid;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, v);</span><br><span class="line">            add(j + n, i, <span class="number">0</span>, -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>; <span class="keyword">double</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; b[i][j];</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) ans = mid, l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬币游戏"><a href="#硬币游戏" class="headerlink" title="硬币游戏"></a>硬币游戏</h2><hr><p>神仙题，想不出来orz</p><p>直接 AC 自动机 + 高斯消元是 O((nm)^3) 的，因为有 nm 个方程</p><p>最终复杂度应该在 O(n^3) 以内，方程数应该是 O(n) 级别的</p><p>关键点是用 N 来表示没有人获胜的状态，将方程数压缩到 n + 1 个，然后解方程</p><p>例如：A = TTH, B = HTT</p><p>N + TTH = A赢 + (B赢 + H) + (B赢 + TH)</p><p>0.125N = A赢 + 0.75B赢</p><p>n + 1 个变量，n + 1 个方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> ull P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> g[N][N], bit2[N], x[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ull pre[N][N], sub[N][N], pw[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = i;</span><br><span class="line">        rep(j, i, n) <span class="keyword">if</span> (g[j][i] &gt; eps) id = j;</span><br><span class="line">        swap(g[i], g[id]);</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = g[j][i] / g[i][i];</span><br><span class="line">            rep(k, i + <span class="number">1</span>, n + <span class="number">1</span>) g[j][k] -= g[i][k] * t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">        x[i] = g[i][n + <span class="number">1</span>] / g[i][i];</span><br><span class="line">        rep(j, <span class="number">1</span>, i - <span class="number">1</span>) g[j][n + <span class="number">1</span>] -= g[i][n + <span class="number">1</span>] * (g[j][i] / g[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bit2[<span class="number">0</span>] = pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) bit2[i] = bit2[i - <span class="number">1</span>] * <span class="number">0.5</span>, pw[i] = pw[i - <span class="number">1</span>] * P;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            pre[i][j] = pre[i][j - <span class="number">1</span>] + (s[j] == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">0</span>) * pw[j];</span><br><span class="line">            sub[i][j] = sub[i][j - <span class="number">1</span>] * P + (s[m - j + <span class="number">1</span>] == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">0</span>) * P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        g[i][n + <span class="number">1</span>] = -bit2[m];</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(a, <span class="number">1</span>, m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[i][a] == sub[j][a]) &#123;</span><br><span class="line">                    g[i][j] += bit2[m - a];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) g[n + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    g[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    Gauss(n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, x[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】数学2</title>
      <link href="2020/07/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%95%B0%E5%AD%A62/"/>
      <url>2020/07/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%95%B0%E5%AD%A62/</url>
      
        <content type="html"><![CDATA[<h2 id="Flowers-and-Chocolate"><a href="#Flowers-and-Chocolate" class="headerlink" title="Flowers and Chocolate"></a><a href="https://vjudge.net/problem/CodeForces-865G" target="_blank" rel="noopener">Flowers and Chocolate</a></h2><hr><p>生成函数题，好想做出来啊，，杠了一天半了，只能咕咕</p><h2 id="加权约数和"><a href="#加权约数和" class="headerlink" title="加权约数和"></a><a href="https://vjudge.net/problem/51Nod-1584" target="_blank" rel="noopener">加权约数和</a></h2><hr><p>咕咕<br><a href="https://zybuluo.com/mayiyang/note/1725968" target="_blank" rel="noopener">题解</a></p><h2 id="概率好题"><a href="#概率好题" class="headerlink" title="概率好题"></a><a href="https://vjudge.net/problem/51Nod-1667" target="_blank" rel="noopener">概率好题</a></h2><hr><p>求 sum{a_i} &lt; sum{b_i} 的方案数，其中 a_i 和 b_i 有取值范围</p><p>考虑到 a_i 和 b_i 有一个下限 l，将柿子化为 sum{l_i + x_i} &lt; sum{l_i + x_i} 的形式，其中 0 &lt;= x_i &lt;= r_i</p><p>隔板法 + 容斥即可</p><h2 id="小Q的集合"><a href="#小Q的集合" class="headerlink" title="小Q的集合"></a><a href="https://vjudge.net/problem/51Nod-1778" target="_blank" rel="noopener">小Q的集合</a></h2><hr><p>看到 n 这么大，模数却只有 1e6 应该想到 lucas 定理啊</p><p>m 又是质数，(T^k - (S - T)^k) % m 成一个周期为 m 的数列</p><p>然后一发乱搞就好了（</p><h2 id="BBQ-Hard"><a href="#BBQ-Hard" class="headerlink" title="BBQ Hard"></a><a href="https://vjudge.net/problem/AtCoder-agc001_e" target="_blank" rel="noopener">BBQ Hard</a></h2><hr><p>C(Ai + Aj + Bi + Bj, Ai + Aj) 就是求从 (0, 0) 走到 (Ai + Aj, Bi + Bj) 的方案数</p><p>移位，变成求从 (-Ai, -Bi) 走到 (Aj, Bj) 的方案数</p><p>那么对于每个点，我们计算从它左下区域走上来的方案数之和</p><p>显然 dp[i, j] = dp[i - 1, j] + dp[i, j - 1]。坐标值都很小，可以枚举。最后别忘了减去 (-Ai, -Bi) 对 (Ai, Bi) 的贡献。</p><h2 id="Leftmost-Ball"><a href="#Leftmost-Ball" class="headerlink" title="Leftmost Ball"></a><a href="https://vjudge.net/problem/AtCoder-agc002_f" target="_blank" rel="noopener">Leftmost Ball</a></h2><hr><p>转化一下就是求已放白球数 &gt;= 已放彩球种类的方案数，容易想到每放一种颜色就把 K 个全放完的想法。</p><p>其实真正重要的只有那 n 个白球和那 n 个第一次放下的彩球。dp，f[i, j] 表示已放 i 白球，j 种彩球的方案数。</p><h2 id="Card-game-for-three"><a href="#Card-game-for-three" class="headerlink" title="Card game for three"></a><a href="https://vjudge.net/problem/AtCoder-arc061_d" target="_blank" rel="noopener">Card game for three</a></h2><hr><p>并不是很难的题，第一步想懂了后面就好办了。</p><p>将 a、b、c 的赢看作又抽了一张卡，即 b 抽了第 m + 1 张，c 抽了第 k + 1 张，而 a 抽了第 n 张（a 先手）枚举 a 赢之前 b 和 c 各抽了几张卡，化柿子 + 分类讨论即可。</p><h2 id="Unicyclic-Graph-Counting"><a href="#Unicyclic-Graph-Counting" class="headerlink" title="Unicyclic Graph Counting"></a><a href="https://vjudge.net/problem/AtCoder-asaporo2_f" target="_blank" rel="noopener">Unicyclic Graph Counting</a></h2><hr><p><a href="https://www.cnblogs.com/zwfymqz/p/8869956.html" target="_blank" rel="noopener">prufer序列重修</a></p><p>度数建图，容易想到 prufer 序列，但这是基环树。</p><p>定义本题的 prufer 序列为将树删完后的 prufer 序列，只剩下一个环 和连着环的编号最大的点。</p><p>想到树上节点在 prufer 序列中出现次数为 deg - 1，环上只有一个节点出现次数为 deg - 3，其他都是 deg - 2（特判只有一个环的情况）。</p><p>环大小为 k 时，环排列数为 (k - 1)! / 2（环有旋转同构和翻转同构），prufer 序列数为 (n - k + 1)! / prod{ (di - ?)! }</p><p>dp计算分母那玩意，f[i, j, k] 表示前 i 个点有 j 个环上点，k 为 0/1 表示是否选了出现次数 deg - 3 的点。</p><p>所以最后答案就是 $\sum\limits_{i = 3}^{n - 1} f[n, i, 1] \times (n - i - 1)! \times \frac{(i - 1)!}{2}$</p><h2 id="Team-Work"><a href="#Team-Work" class="headerlink" title="Team Work"></a><a href="https://vjudge.net/problem/CodeForces-932E" target="_blank" rel="noopener">Team Work</a></h2><hr><p><a href="https://www.cnblogs.com/gzy-cjoier/p/8426987.html" target="_blank" rel="noopener">第二类斯特林数</a></p><p>柿子很好列出来，<a href="https://www.cnblogs.com/cjyyb/p/9706019.html" target="_blank" rel="noopener">怎么推呢？</a></p><ul><li>看到 i^k 的形式想想斯特林数</li><li>循环复杂度高时想想替换枚举顺序</li><li>碰到阶乘形式想想凑组合数</li></ul><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a><a href="https://vjudge.net/problem/HDU-1521" target="_blank" rel="noopener">排列组合</a></h2><hr><p>指数型生成函数模板题，回去就重修生成函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 排列组合 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 初赛（A）</title>
      <link href="2020/07/20/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BA/"/>
      <url>2020/07/20/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BA/</url>
      
        <content type="html"><![CDATA[<p>A, B, C 均为水题。。rk306，进复赛了 ~</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>D 其实也是水题，这题目是真的难懂。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, sx, sy, a[<span class="number">505</span>][<span class="number">505</span>], ans, tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1e9</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">int</span> ren = <span class="number">0</span>, rnd = <span class="number">0</span>;</span><br><span class="line">                rnd = (<span class="built_in">abs</span>(i - sx) + <span class="built_in">abs</span>(j - sy) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                tot = <span class="number">0</span>;</span><br><span class="line">                val.clear();</span><br><span class="line">                rep(k, <span class="number">-3</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                    rep(l, <span class="number">-3</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">abs</span>(k) + <span class="built_in">abs</span>(l) &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!k &amp;&amp; !l) <span class="keyword">continue</span>;  <span class="comment">// 城市建成后第一个工作者不会移动到别的格子去。。。错失AC</span></span><br><span class="line">                        <span class="keyword">if</span> (i + k &lt; <span class="number">1</span> || i + k &gt; n || j + l &lt; <span class="number">1</span> || j + l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                        val.push_back(a[i + k][j + l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sort(val.begin(), val.end());</span><br><span class="line"></span><br><span class="line">                ren = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>, food = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (ren &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tt = <span class="number">8</span> * ren * ren;</span><br><span class="line">                    <span class="keyword">if</span> (food &lt; tt) &#123;</span><br><span class="line">                        tt -= food;</span><br><span class="line">                        <span class="keyword">int</span> k = tt / cur + (tt % cur &gt; <span class="number">0</span>);</span><br><span class="line">                        rnd += k, food += k * cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++ren;</span><br><span class="line">                    <span class="keyword">if</span> (!val.size()) <span class="keyword">continue</span>;</span><br><span class="line">                    cur += val.back(), val.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                ans = min(ans, rnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>不是很难但理解了很久的期望题</p><p>由于 a 从外到内递减，必然会形成很多从内向外的树，所以连通块数的期望其实就是树根数的期望。</p><p>考虑每个段作为树根的贡献。</p><p>第一层是 a[i] / 2</p><p>第 i 层每个段是 (1 / a[i - 1] - 1 / a[i]) <em> (a[i - 1] / 2) </em> (a[i] / 2) = (a[i] - a[i - 1]) / 4</p><p>其中，1 / a[i - 1] 是上一层白块概率，但是黑块要完全待在白块里就要减去 1 / a[i]</p><p>那么如果出现只有一个点相碰的情况，这概率怎么算呢？</p><p>其实不用算它，它的概率为 0。</p><p>因为在连续空间下，计算一个子空间的概率就是在算这个空间的测度 (可以理解成一维是长度, 二维是面积, 三维是体积)</p><p>在Lebesgue测度(欧氏空间下最常用的测度定义, 我们学到的微积分基本都基于它)下，一维空间中的一个点测度就是 0</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>选点必然是从小到大选，所以可以二分最后选的点（权值最大的点），对于每块区域讨论一下（不想写，代码就让它咕咕吧（）</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>时刻具有可二分性。设二分的值为 t，容易想到对于每个格点，与每个在 t 时刻内能到达它的窗户连边，跑网络流，但是这样节点个数是 nm 级别的。考虑优化，窗户只有 6 个，那用二进制表示窗户到格点的到达状态，将状态相同的点们缩成一个点，跑最大流就好了。</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>官方题解太毒瘤，，我看的<a href="https://blog.csdn.net/weixin_44282912/article/details/107454309" target="_blank" rel="noopener">这个</a></p><p>时间复杂度应该是跑不满的 sqrt(n) * log(sqrt(n))</p><p>思考了一波推柿子的意义，把 sigma 化掉、去掉无效枚举状态（比如 n / d^2，d &gt; sqrt(n) 就是无效的），判断当前柿子能否预处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】矩阵树定理</title>
      <link href="2020/07/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
      <url>2020/07/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://oi-wiki.org/graph/matrix-tree/" target="_blank" rel="noopener">OIWiki上的矩阵树相关</a></p><hr><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a><a href="https://blog.csdn.net/qq_36396104/article/details/89298227" target="_blank" rel="noopener">行列式</a></h2><p>$n \times n$ 的矩阵 A 的行列式可以理解为行或列向量所构成的超平行多面体的有向面积或有向体积，是一个标量。</p><p>矩阵 A 的行列式用 det(A) 表示。</p><p><a href="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fr=aladdin#2" target="_blank" rel="noopener">行列式初等变换(最下面)</a></p><ul><li>行列互换，行列式值不变</li><li>行列式一行或一列的公因子可以提出去</li><li>行列式中若有某一行是两组数的和，则该行列式等于两个行列式的和</li><li>两行或两列交换，行列式变号（区别于第一条）</li><li>两行或两列相同，行列式为 0</li><li>两行或两列成比例，行列式为 0</li></ul><hr><h2 id="高斯消元化为上三角矩阵："><a href="#高斯消元化为上三角矩阵：" class="headerlink" title="高斯消元化为上三角矩阵："></a>高斯消元化为上三角矩阵：</h2><p>运用了行列式的初等变换。</p><ul><li>实数：直接处理</li><li>模意义：1. 模为质 可用逆元  2. 模不为质 用辗转相除法，复杂度会多一个 log（详情见例题代码）</li></ul><hr><h2 id="基尔霍夫矩阵"><a href="#基尔霍夫矩阵" class="headerlink" title="基尔霍夫矩阵"></a>基尔霍夫矩阵</h2><p>A 为邻接矩阵，D 为度数矩阵，Kirchhoff矩阵为 K = D - A</p><p>行列式 a[i, i] 记录点 i 度数，a[i, j] 表示 i, j 之间边数的相反数。</p><p>具体实现的话，设 kirchhoff 矩阵为 a，若存在边 (u, v) 则 a[u, u]++, a[v, v]++, a[u, v]—, a[v, u]—</p><p>Kirchhoff矩阵每行内数的和和每列内数的和都为 0，所以行列式为 0</p><hr><h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><p>用于求解图上的生成树个数。</p><p>无向图生成树个数 = Kirchhoff 矩阵任何一个 N - 1 阶<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%90%E5%BC%8F/2671796?fr=aladdin" target="_blank" rel="noopener">主子式</a>的行列式的绝对值.</p><p>有向图相关见<a href="https://www.xht37.com/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">这里</a> （由于本人过于菜 连有向图生成树是啥都不会 先咕咕 后续做到题了再来填坑！）</p><p>可能是，去掉根所在的那行那列，度数矩阵外向树就是入度，内向树就是出度。</p><p>无向图，谁是根并不重要所以随便去掉哪一行&amp;列都可以；</p><p>有向图，删去指定的根所在的行和列，求剩下的矩阵行列式即可。</p><p>如果图不连通，那么任意 N - 1 阶主子式为 0。证明：如果图不连通，那么每个连通块内的点构成的矩阵仍然是 Kirchhoff 矩阵，而连通块不止一个，所以去掉第 i 行第 i 列之后，一定有一个连通块仍然是 Kirchhoff 矩阵，也就是行列式为 0 。</p><hr><h2 id="变元矩阵树定理"><a href="#变元矩阵树定理" class="headerlink" title="变元矩阵树定理"></a>变元矩阵树定理</h2><p>求所有生成树总边积的和。行列式 a[i, i] 记录点 i 边权和，a[i, j] 表示 i, j 之间边权的相反数。</p><hr><h2 id="例题1-HEOI2015-小Z的房间"><a href="#例题1-HEOI2015-小Z的房间" class="headerlink" title="例题1. [HEOI2015]-小Z的房间"></a>例题1. <a href="https://www.luogu.com.cn/problem/P4111" target="_blank" rel="noopener">[HEOI2015]-小Z的房间</a></h2><p>模板题，注意模数非质</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dir[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, a[<span class="number">100</span>][<span class="number">100</span>], id[<span class="number">10</span>][<span class="number">10</span>], idx;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) id[i][j] = ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i][j]) &#123;</span><br><span class="line">                rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tx = i + dir[k][<span class="number">0</span>], ty = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tx &gt; n || ty &gt; m || !id[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> x = id[i][j], y = id[tx][ty];</span><br><span class="line">                    a[x][x]++, a[y][y]++, a[x][y]--, a[y][x]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, idx - <span class="number">1</span>) &#123;  <span class="comment">// n - 1 阶主子式</span></span><br><span class="line">        rep(j, i + <span class="number">1</span>, idx - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j][i]) &#123;  <span class="comment">// 在模意义下用辗转相除法，类比 gcd(a, b) = gcd(b, a % b) 直到 b = 0，用第 i 行消第 j 行</span></span><br><span class="line">                ll d = a[i][i] / a[j][i];</span><br><span class="line">                rep(k, i, idx - <span class="number">1</span>)</span><br><span class="line">                    a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                swap(a[i], a[j]), ans = -ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans * a[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题2-SHOI2016-黑暗前的幻想乡"><a href="#例题2-SHOI2016-黑暗前的幻想乡" class="headerlink" title="例题2. [SHOI2016]-黑暗前的幻想乡"></a>例题2. <a href="https://www.luogu.com.cn/problem/P4336" target="_blank" rel="noopener">[SHOI2016]-黑暗前的幻想乡</a></h2><p>容斥 + 矩阵树定理</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">ll n, a[<span class="number">20</span>][<span class="number">20</span>], res;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; g[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, x, y; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            g[i].push_back(make_pair(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = g[i][j].first, y = g[i][j].second;</span><br><span class="line">                    a[x][x]++, a[y][y]++, a[x][y]--, a[y][x]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                    ll d = a[i][i] / a[j][i];</span><br><span class="line">                    rep(k, i, n - <span class="number">1</span>)</span><br><span class="line">                        a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                    swap(a[i], a[j]), ans = -ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans * a[i][i] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + ((n - <span class="number">1</span> - cnt) &amp; <span class="number">1</span> ? <span class="number">-1l</span>l : <span class="number">1l</span>l) * ans + mod) % mod;  <span class="comment">// !!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题3-SDOI2014-重建"><a href="#例题3-SDOI2014-重建" class="headerlink" title="例题3. [SDOI2014]-重建"></a>例题3. <a href="https://www.luogu.com.cn/problem/P3317" target="_blank" rel="noopener">[SDOI2014]-重建</a></h2><p>推柿子 + 变元矩阵树定理，显然边权跟概率有关</p><p>$\sum\limits_{T}(\prod\limits_{e \in T} P_e \prod\limits_{e \not\in T}(1-P_e))$</p><p>$\sum\limits_T( \prod\limits_{e \in T} P_e \frac{ \prod\limits_e (1 - P_e) }{ \prod\limits_{e \in T} (1 - P_e) } )$</p><p>$\prod\limits_e (1 - P_e) \sum \prod\limits_{e \in T} \frac{P_e}{1 - P_e}$</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> D[N][N], ans = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = n - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, N) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = i;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, N)</span><br><span class="line">            <span class="keyword">if</span> (D[mx][i] &lt; D[j][i]) mx = j;</span><br><span class="line">        <span class="keyword">if</span> (mx != i) ff ^= <span class="number">1</span>, swap(D[mx], D[i]);</span><br><span class="line">        <span class="keyword">if</span> (D[i][i] &gt; -eps &amp;&amp; D[i][i] &lt; eps) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, N) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = D[j][i] / D[i][i];</span><br><span class="line">            rep(k, i, N) D[j][k] -= t * D[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">        ret *= D[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) ret *= <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(D[i][j]) &lt; eps) D[i][j] = eps;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">1.0</span> - D[i][j]) &lt; eps) D[i][j] = <span class="number">1.0</span> - eps;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) ans *= (<span class="number">1</span> - D[i][j]);</span><br><span class="line">            D[i][j] /= (<span class="number">1.0</span> - D[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">                D[i][i] += D[i][j], D[i][j] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans * solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题4-JSOI2008-最小生成树计数"><a href="#例题4-JSOI2008-最小生成树计数" class="headerlink" title="例题4. [JSOI2008]-最小生成树计数"></a>例题4. <a href="https://www.luogu.com.cn/problem/P4208" target="_blank" rel="noopener">[JSOI2008]-最小生成树计数</a></h2><p><strong>最小生成树性质：对于所有最小生成树，每种边权的边数相同；且对于所有生成树，某种权值的边连完后图的联通性相同</strong></p><p>所以可以分别处理每种权值，乘起来。</p><p>算同种边权的边的贡献，由于具有相同权值的边不超过 10 条，暴搜也可以过。。（2^10 很稳的！</p><p>正解是矩阵树。注意，同种边权的边联通性相同并不等于连通，因此要连一些桥，并不影响矩阵树算答案。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">31011</span>, N = <span class="number">105</span>, M = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, ans = <span class="number">1</span>, num;</span><br><span class="line">ll fa[N], fat[N], id[M &lt;&lt; <span class="number">1</span>], a[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; a.w; &#125;</span><br><span class="line">&#125;e[M], t[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fat[x] == x ? x : fat[x] = getfa2(fat[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                ll d = a[i][i] / a[j][i];</span><br><span class="line">                rep(k, i, n - <span class="number">1</span>)</span><br><span class="line">                    a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                swap(a[i], a[j]), ret = -ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = (ret * a[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    rep(i, l, r) &#123;</span><br><span class="line">        t[i] = e[i];</span><br><span class="line">        <span class="keyword">int</span> u = getfa(t[i].u), v = getfa(t[i].v);</span><br><span class="line">        t[i].u = u, t[i].v = v;  <span class="comment">// 类似于缩点</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        id[++cnt] = u, id[++cnt] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = unique(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>) - id - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt) fat[i] = i;</span><br><span class="line">    rep(i, l, r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i].u == t[i].v) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = getfa(t[i].u), v = getfa(t[i].v);</span><br><span class="line">        <span class="keyword">if</span> (u != v) --num, fa[u] = v;</span><br><span class="line"></span><br><span class="line">        u = lower_bound(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>, t[i].u) - id;</span><br><span class="line">        v = lower_bound(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>, t[i].v) - id;</span><br><span class="line">        a[u][u]++, a[v][v]++, a[u][v]--, a[v][u]--;</span><br><span class="line"></span><br><span class="line">        u = getfa2(u), v = getfa2(v);</span><br><span class="line">        <span class="keyword">if</span> (u != v) fat[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, cnt) &#123;  <span class="comment">// 有可能不连通，那么连一些桥，并不影响矩阵树算答案</span></span><br><span class="line">        <span class="keyword">int</span> u = getfa2(i), v = getfa2(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        a[u][u]++, a[v][v]++, a[u][v]--, a[v][u]--;</span><br><span class="line">        fat[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * Gauss(cnt) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    num = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i = j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= m &amp;&amp; e[i].w == e[j].w) ++j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= m; ++j) <span class="keyword">if</span> (e[i].w != e[j].w) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; j) &#123;</span><br><span class="line">            calc(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> u = getfa(e[i].u), v = getfa(e[i].v);</span><br><span class="line">            <span class="keyword">if</span> (u != v) fa[u] = v;</span><br><span class="line">            --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);  <span class="comment">// 判定最小生成树的存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 矩阵树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第二轮选讲</title>
      <link href="2020/07/17/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/17/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="7-17-A"><a href="#7-17-A" class="headerlink" title="7.17 A"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/A" target="_blank" rel="noopener">7.17 A</a></h2><hr><p>算简单题里的偏难题吧。。</p><ul><li>操作 2 次数至少为 max{a_i}</li><li>所有数必须同时减到 0</li></ul><p>进行减一后再加倍不会优于先加倍再减一（我也不知道为啥），所以在最大值 max 没进行一次减一操作时让每个数翻倍，尽可能靠近 max；然后一起减一，比 max 小的数在途中必然会有减到 max 的一半的时候，这时候再翻倍就好了。</p><h2 id="7-17-D"><a href="#7-17-D" class="headerlink" title="7.17 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/D" target="_blank" rel="noopener">7.17 D</a></h2><hr><p><a href="https://www.luogu.com.cn/blog/zyxxs/post-717-d-ti-ti-xie" target="_blank" rel="noopener">数学大佬的博客</a></p><p>反射性质的转化很有意思！代码就先咕咕</p><h2 id="7-17-E"><a href="#7-17-E" class="headerlink" title="7.17 E"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/E" target="_blank" rel="noopener">7.17 E</a></h2><hr><p><a href="https://www.kdocs.cn/l/sf6G7oaScGQm?f=201" target="_blank" rel="noopener">题解</a></p><p>很妙的dp！我不会设计状态。。。</p><h2 id="7-17-F"><a href="#7-17-F" class="headerlink" title="7.17 F"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/F" target="_blank" rel="noopener">7.17 F</a></h2><hr><p>1 &lt;= |B| &lt;= |A|</p><p>B 串拼起来的东西只要是 A 的最小循环节就好了。</p><p>有个很妙的转化：将与 A 中 [i, j] 匹配的 B 串看作从 i 指向 j + 1 的<strong>有向边</strong>（注意取模）</p><p>那么问题就变成了求最小环，floyd 可以跑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第一轮选讲</title>
      <link href="2020/07/15/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/15/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="7-13-D"><a href="#7-13-D" class="headerlink" title="7.13 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102643/problem/D" target="_blank" rel="noopener">7.13 D</a></h2><hr><p><a href="https://www.luogu.com.cn/blog/zyxxs/post-713-d-ti-ti-xie" target="_blank" rel="noopener">挂一个大佬博客</a></p><p>为啥第一个柿子等于第二个柿子：</p><p>左边式子 = </p><p>P(lca = L) * L +</p><p>P(lca = L - 1) * (L - 1) +</p><p>P(lca = L - 2) * (L - 2) + </p><p>… + </p><p>P(lca = 0) * 0</p><p>重新整理一下就是</p><p>P(lca = L) + </p><p>P(lca = L) + P(lca = L - 1) +</p><p>P(lca = L) + P(lca = L - 1) + P(lca = L - 2) +</p><p>P(lca = L) + P(lca = L - 1) + P(lca = L - 2) + P(lca = L - 3) +</p><p>… +</p><p> P(lca = L) + P(lca = L - 1) + P(lca = L - 2) + P(lca = L - 3) + … P(lca = 1)</p><p>那么左边就等于 sum{1 to L}{P(lca &gt;= i)}</p><p>由于 P(lca &gt;= 0) = 1</p><p>那么进而等于 sum{0 to L}{P(lca &gt;= i)} - 1</p><p>关于本题卷积：</p><p>g(n) = 1 / n! <em> (-1)^n </em> (1 - c^{-n * (l + 1)}) / (1 - c^n)</p><p>h(n) = 1 / n!</p><p>f(n) = \sum_{1 &lt;= j &lt;= n - 1} (n - 1)! <em> g(j) </em> h(n - j - 1)</p><p>其实就是把组合数拆开来了</p><p>最后柿子的 l + 1 是 c = 1 的贡献</p><p>不得不说太妙了，杠了一晚上，数学是短板啊</p><h2 id="7-14-A"><a href="#7-14-A" class="headerlink" title="7.14 A"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/A" target="_blank" rel="noopener">7.14 A</a></h2><hr><p>和<a href="https://codeforces.com/contest/1230/problem/E" target="_blank" rel="noopener">这道</a>一样都用到了 gcd 个数不超过 logn 的性质</p><h2 id="7-14-B"><a href="#7-14-B" class="headerlink" title="7.14 B"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/B" target="_blank" rel="noopener">7.14 B</a></h2><hr><p>听说是广义 sam + 线段树合并，咕咕（题解已存</p><h2 id="7-14-C"><a href="#7-14-C" class="headerlink" title="7.14 C"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/C" target="_blank" rel="noopener">7.14 C</a></h2><hr><p>听说是 wqs 二分，咕咕</p><h2 id="7-14-D"><a href="#7-14-D" class="headerlink" title="7.14 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/D" target="_blank" rel="noopener">7.14 D</a></h2><hr><p>有思路的题，对于每个第一步走到的 (x, y)，延长直线经过的整点个数是 n / max(x, y)</p><p>也就是说 n / max(x, y) + 1 = m 且 gcd(x, y) = 1</p><p>枚举左上半边，x 大于 y 的部分，就是求 n / x(下取整) = m - 1 的 x</p><p><strong>x_min = n / m + 1, x_max = n / (m - 1)</strong></p><p>求个 phi 的前缀和就好了</p><h2 id="7-14-E"><a href="#7-14-E" class="headerlink" title="[7.14 E]"></a>[7.14 E]</h2><hr><p><a href="https://www.cnblogs.com/Flying2018/p/13297095.html" target="_blank" rel="noopener">https://www.cnblogs.com/Flying2018/p/13297095.html</a></p><p><a href="https://www.luogu.com.cn/blog/zkdxlpro/post-713-acm-bu-fen-jian-yao-ti-xie" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/zkdxlpro/post-713-acm-bu-fen-jian-yao-ti-xie</a></p><p>咕咕咕</p><h2 id="7-15-A"><a href="#7-15-A" class="headerlink" title="[7.15 A]"></a>[7.15 A]</h2><hr><p>算出最大生成树和最小生成树，判断之间是否有斐波那契数存在（必然可以用一些 1 边替换掉 0 边</p><h2 id="7-15-B"><a href="#7-15-B" class="headerlink" title="[7.15 B]"></a>[7.15 B]</h2><hr><p>考虑一个序列自动机（就是每个位置向之后离自己最近的26个字符的位置分别连一条边）</p><p>相当于在序列自动机上选一个黑点，选任意个后继染黑</p><p>$sg(x) = mex_{T \subset nxt(x)}(XOR_{k\in T}sg(k))$</p><p>而 sg 只会是 2^0, 2^1, 2^2…</p><p>这也很好想，归纳可得，若当前节点的 sg 是 2^i, 后继的 sg 只会是 2^0, 2^1 … 2^{i - 1}，选任意个 sg 值异或起来得到的是 0 ~ 2^i - 1，因此 mex 出来就是 2^i。</p><p>这就等价于对后继的重标号取 mex，非常喵喵</p><h2 id="7-15-E"><a href="#7-15-E" class="headerlink" title="[7.15 E]"></a>[7.15 E]</h2><hr><p>真就 O(nlogn) 算法满地爬呗。。。比赛时没想有点可惜</p><p>可以 dfs 序上建主席树，或者 dsu on tree + 树状数组，或者线段树合并，etc。。</p><h2 id="7-15-F"><a href="#7-15-F" class="headerlink" title="[7.15 F]"></a>[7.15 F]</h2><hr><p>巧妙的构造。题意其实就是构造一个没有等差数列的排列。每次按奇偶位排序，例如奇数位放前面、偶数位放后面，这样就消除了跨越左右的等差数列，分治思想</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Week2测试题解</title>
      <link href="2020/07/15/Week2%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/15/Week2%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="AIZU2989"><a href="#AIZU2989" class="headerlink" title="AIZU2989"></a><a href="https://vjudge.net/contest/381744#problem/B" target="_blank" rel="noopener">AIZU2989</a></h2><hr><p>giao，全想着 L、R 逆推了，但是写挂了，爬。。实际上有更好写的做法</p><p>发现 ai 相对顺序无关，可以先从小到大排序。容易发现操作都是 小于某数的向左 大于某数的向右，ai 一直具有单调性（这个我想到了。。）  二分就好了</p><h2 id="AIZU2990"><a href="#AIZU2990" class="headerlink" title="AIZU2990"></a><a href="https://vjudge.net/contest/381744#problem/C" target="_blank" rel="noopener">AIZU2990</a></h2><hr><p>注意，初始只能往右走。就是个 sb 题！！题目读错了哭</p><p>一直在想 set，但这题用 set 会很麻烦。</p><p>序列差分，算出每个点经过的次数 x，来回的次数就是 max{x}，减去的前后缀也必定是 经过 x 次点的最左和最右。。。</p><h2 id="AGC041B"><a href="#AGC041B" class="headerlink" title="AGC041B"></a><a href="https://atcoder.jp/contests/agc041/tasks/agc041_b" target="_blank" rel="noopener">AGC041B</a></h2><hr><p>不错的题，容易想到答案满足单调性，可以二分。二分的位置只要奋力超过或赶上 p 即可，那么 m 位评委尽量不投 p 就好了。</p><h2 id="AIZU2992"><a href="#AIZU2992" class="headerlink" title="AIZU2992"></a><a href="https://vjudge.net/contest/381744#problem/E" target="_blank" rel="noopener">AIZU2992</a></h2><hr><p>不是很难的dp，可惜题目读不懂。。</p><p>显然 a，r，b 从大到小排序最优。dp，红色总数不能超过 totr，黑色总数不能超过 totb，所以 f[i, j, k] 表示前 i + j 中有 i 红，j 黑，红色总数为 k 的最大不改变颜色的气球数量</p><h2 id="AIZU2995"><a href="#AIZU2995" class="headerlink" title="AIZU2995"></a><a href="https://vjudge.net/contest/381744#problem/F" target="_blank" rel="noopener">AIZU2995</a></h2><hr><p>好题！</p><p>考虑整棵树，每个点选 ci 还是 di，这跟“树”这个结构没有关系，就是一个经典问题：一个 n 个点 m 条边的图，每条边连接 ci 和 di，可以染黑 ci 或 di，问最大黑点数</p><p>显然是 min{|V|, |E|}：首先最多有 |V| 个，其次如果边为 V - 1（是树）那就是 V - 1</p><p>min{|V|, |E|} = |V| - 1 + [是否存在非树边]，并查集维护就好了。</p><p>对于每个子树：dsu on tree。考虑到 有删除操作，用可撤销并查集维护。是真的难写（</p><h2 id="AIZU2991"><a href="#AIZU2991" class="headerlink" title="AIZU2991"></a><a href="https://vjudge.net/contest/381744#problem/G" target="_blank" rel="noopener">AIZU2991</a></h2><hr><p>2^{n+1} 中选 2^n 个，也就是选一半</p><p>v 和 v ^ X 必然选一个，&amp;值为 A 的对必然不选一个，|值为 O 的对必然不选一个（找这样的对，枚举子集即可</p><p>2-sat，输出卡行末空格恶心了我半天</p><h2 id="AIZU2994"><a href="#AIZU2994" class="headerlink" title="AIZU2994"></a><a href="https://vjudge.net/contest/381744#problem/H" target="_blank" rel="noopener">AIZU2994</a></h2><hr><p>C = V - E + F</p><p>C：连通块数   V：点数   E：边数   F：内部区域数</p><p>（注意网格图经常考这个）</p><p>由期望的线性性得，E(C) = E(V) - E(E) + E(F)</p><p>而本题是树，F 为 0</p><p>所以 E(c1c2) = E(v1v2) + E(e1e2) - E(v1e2) - E(v2e1)</p><ul><li><p>点点贡献：可以推柿子（别忘了组合数），也有更灵活的解法。考虑一对点 (a, b) 的贡献（a 在树 1 中，b 在树 2 中），是 1 / 4, 而总共有 n(n - 1) 对点，所以就是 n(n - 1) / 4</p></li><li><p>点边贡献：枚举树 2 中一条边 (u, v)，与树 1 中点 x 的贡献是 1 / 8, 总共是 (n - 1)(n - 2) / 8</p></li><li><p>边边贡献：这个就不能 O(1) 算了，枚举树 2 中一条边 (u, v)，与树 1 中边的总贡献是 (n - 1 - u和v在树 1 中连的边) / 16</p></li></ul><p>套路，据我哥说在他们那个时候，乘积期望也是套路题哇！多练多练</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】树的进阶</title>
      <link href="2020/07/15/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6/"/>
      <url>2020/07/15/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>难度递增！</p><h2 id="CF1305D"><a href="#CF1305D" class="headerlink" title="CF1305D"></a><a href="https://codeforces.com/problemset/problem/1305/D" target="_blank" rel="noopener">CF1305D</a></h2><hr><p>n / 2 次询问，想到每次删至少两个节点。最暴力的思路是选任意两个节点，将 lca 为根的两个节点所在的子树删掉，但是这会被一条链的情况卡成询问 n 次。考虑选任意两个叶子，若 lca 等于其中之一那么那个叶子就是根，否则删除两个叶子。</p><h2 id="CF1210C"><a href="#CF1210C" class="headerlink" title="CF1210C"></a><a href="https://codeforces.com/problemset/problem/1210/C" target="_blank" rel="noopener">CF1210C</a></h2><hr><p>询问每条链的 gcd 之和。考虑 gcd 一个很重要的性质：长度为 n 的区间所有子区间的 gcd 不会超过 logn 个。log 级别，开 vector 或者 map 存每个节点为下端点的链gcd，每次更新只有 logn 复杂度。</p><h2 id="CF980E"><a href="#CF980E" class="headerlink" title="CF980E"></a><a href="https://codeforces.com/problemset/problem/980/E" target="_blank" rel="noopener">CF980E</a></h2><hr><p>考虑到 2^i 是个很特殊的东西，必然贪心的选 i 大的节点。按 i 从大到小排序，i 节点保证被选的前提是 i 到根的所有节点都保留，暴力判保留节点后是否超过 n - K 会 TLE，可以用 dfs 序上树状数组。做标记暴力跳就好了，反正是 O(n).</p><h2 id="CF1098C"><a href="#CF1098C" class="headerlink" title="CF1098C"></a><a href="https://codeforces.com/problemset/problem/1098/C" target="_blank" rel="noopener">CF1098C</a></h2><hr><p>考虑 K（最大分支）满足二分性质，先二分出最终答案 ans，判能否构成树的条件是：一条链形式的子树和 &gt;= S, K 叉树形式的子树和 &lt;= S。构造也很容易，我的方法是将一条链的末尾节点不断挂上来，填一棵 K 叉树。</p><h2 id="CF1149C"><a href="#CF1149C" class="headerlink" title="CF1149C"></a><a href="https://codeforces.com/contest/1149/problem/C" target="_blank" rel="noopener">CF1149C</a></h2><hr><p>有意思的题，考虑直径的括号序列，必然是 )))())))…(((((()(((( 这样 ‘)))))’ + 匹配括号 + ‘(((((‘ 的形式。经典套路，将 ( 设为 1，) 设为 -1，答案就是相邻的两段序列之差最大值，可以用线段树维护（各种细节啊啊啊。。</p><h2 id="CF1083C"><a href="#CF1083C" class="headerlink" title="CF1083C"></a><a href="https://codeforces.com/contest/1083/problem/C" target="_blank" rel="noopener">CF1083C</a></h2><hr><p>有意思的题+1，询问每条链最大的 mex。神仙做法。首先，能线段树维护的信息都具有<strong>可合并性</strong>。容易想到二分 mex，判能否构成链。线段树 [l, r] 节点表示 权值为 l ~ r 的节点能否构成链，合并时枚举端点用 lca 判点是否在路径上即可。最后外面那个二分也可以省掉，直接在线段树上“二分”，统计答案。</p><h2 id="AGC023F"><a href="#AGC023F" class="headerlink" title="AGC023F"></a><a href="https://atcoder.jp/contests/agc023/tasks/agc023_f" target="_blank" rel="noopener">AGC023F</a></h2><hr><p>神仙题++</p><p>先考虑前置问题：两个 01 序列相接，逆序对尽量小</p><p>设它们 01 个数分别为 sx0, sx1, sy0, sy1, x &lt; y</p><p>显然 sx1 <em> sy0 &lt;= sx0 </em> sy1 时不必交换两者。</p><p>变形：sx1 / sx0 &lt;= sy1 / sy0.</p><p>考虑此题，初始时将点看作连通块，取出目前没有被选且 s1 / s0 最小的连通块（堆维护）</p><p>若它的父亲已经被选，就选了它；否则容易证明它一定会在它的根的父亲被选后立刻被选，就将它和根的父亲所在连通块合并，得到新的连通块</p><p>类似的还有 POJ2054-Color a Tree，贪心的每次将最大的点和它父亲合并</p><h2 id="CF1168D"><a href="#CF1168D" class="headerlink" title="CF1168D"></a><a href="https://codeforces.com/contest/1168/problem/d" target="_blank" rel="noopener">CF1168D</a></h2><hr><p>充要条件是所有叶子的深度相同，设为 mxdep, 设 lenx = mxdep - depx</p><p>且对于任何节点 x，sum{f(x, c)} &lt;= lenx，其中 f(x, c) 表示任何一条 x 到其子树中叶子的链上 c 出现次数的最大值</p><p>证必要性：显然       证充分性：据说用归纳法证明</p><p>怎么处理修改？总不能每次暴力往上跳修改 f(x, c) 吧。</p><p>注意到当节点只有一个孩子时不需要判上面那个东西，相当于可以忽视</p><p>因此想到将父亲只有自己一个孩子的节点向上压缩，修改的复杂度就是深度</p><p>而满足每一层的节点个数都严格大于上一层（不然就压缩了），深度只有 sqrt(n)</p><p>总复杂度就是 O(Qsqrt(n)), 非常的喵！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】字符串</title>
      <link href="2020/07/09/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/07/09/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="POJ3167"><a href="#POJ3167" class="headerlink" title="[POJ3167]"></a>[POJ3167]</h2><hr><p>KMP + 树状数组，注意细节</p><h2 id="CF547E"><a href="#CF547E" class="headerlink" title="[CF547E]"></a>[CF547E]</h2><hr><p>套路好题（</p><p>首先有个性质：AC自动机 fail 树上的父亲节点是子节点的子串。</p><p>然后就有个经典套路：AC自动机上找一个串的出现次数可以在 fail 树上跑。</p><p>将询问离线，从小到大插入 AC 自动机（插入方法是节点 val = 1），树状数组维护 dfs 序算询问点子树中 1 的个数。</p><h2 id="965E"><a href="#965E" class="headerlink" title="[965E]"></a>[965E]</h2><hr><p>考虑在 Trie 上做。然后就变成一棵有许多黑点的 Trie 树，要将黑点尽可能地放到祖先节点去。</p><p>优先队列维护，优先放原本深度大的点。</p><h2 id="HDU3336"><a href="#HDU3336" class="headerlink" title="[HDU3336]"></a>[HDU3336]</h2><hr><p>KMP 性质题。AC 自动机上找串出现次数可以跑 fail 树，但本题要所有前缀，会TLE。</p><p>考虑 fail 指针意义，设计 DP：f[i] 表示以 i 结尾的所有前缀个数，f[i] = f[fail[i]] + 1.</p><h2 id="HDU5536"><a href="#HDU5536" class="headerlink" title="[HDU5536]"></a>[HDU5536]</h2><hr><p>套路题直接上 01 trie，值得注意的是：本题 n^3 会 TLE，因为重复插入了很多串； n^2 枚举 i 和 j 再减掉 Trie 中 i 和 j 串的贡献就可以过啦。</p><hr><p>总结：</p><ul><li><p>KMP 和 AC 自动机可解决出现位置（分别用 fail 指针和 fail 树）；</p></li><li><p>想除去 Trie 或 AC 自动机中某个串时只要将 串沿途的 val -= 1 就好了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU4653]-我的微积分初探</title>
      <link href="2020/07/08/%5BHDU4653%5D-%E6%88%91%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E5%88%9D%E6%8E%A2/"/>
      <url>2020/07/08/%5BHDU4653%5D-%E6%88%91%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://coderoj.gitee.io/2020/07/01/3880663/" target="_blank" rel="noopener">同班大佬刚了一晚的博客</a></p><p>真的很神了，从他的博客里也能学到理论知识，本篇博客主要对上文中部分文字做解释 ~</p><ul><li><p>原函数：对于一个定义在某区间的已知函数 $f(x)$，如果存在可导函数 $F(x)$，使得在该区间内的任一点都存在 $dF(x)=f(x)dx$，则在该区间内就称函数$F(x)$ 为函数 $f(x)$ 的原函数。</p></li><li><p>牛顿-莱布尼茨公式（微积分基本定理）：一个连续函数在区间 $[a，b]$ 上的定积分等于它的任意一个原函数在区间 $[a，b]$ 上的增量</p></li></ul><p>——用<a href="https://www.shuxuele.com/calculus/integration-introduction.html" target="_blank" rel="noopener">点这里</a> 注水那个例子来解释，连续函数就是 $f(x) = 2x$, 原函数就是 $F(x) = x^2 + C$</p><ul><li><p>根据<a href="https://www.shuxuele.com/calculus/integration-rules.html" target="_blank" rel="noopener">积分法则</a>可以得到 $\int^1_0 y^{p-1}<em>dx = (\frac{1}{p}</em>y^p)|^1_0$，其中等式右边表示 将 $1$ 和 $0$ 代入 $\frac{1}{p}*y^p$ 后相减，原理是👆微积分基本定理</p></li><li><p>对于两个不相关的事件，乘积的期望 = 期望的乘积，且本题在单位球中（半径为 $1$），因此 $k$ 扩展那里 $ans(p, n, k) = ans(p, n - 1, k - 1) * ans(p, n, 0)$，相当于把第 $k$ 个的距离缩到第 $0$ 个的距离范围内。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】贪心</title>
      <link href="2020/07/07/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%B4%AA%E5%BF%83/"/>
      <url>2020/07/07/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>专题助我发现：我贪心弱的一！！！多练！！！</p><h2 id="CF1373F"><a href="#CF1373F" class="headerlink" title="CF1373F"></a><a href="https://codeforces.com/problemset/problem/1373/F" target="_blank" rel="noopener">CF1373F</a></h2><hr><p>做法一：二分 + 贪心 O(nlogn)（题解做法）</p><p>本题单调性体现在哪呢？？显然当第一个电站供应量确定时，所有电站的供应量都确定了</p><p>设 b[1] 流给 a[1] 的量为 x</p><p>有两种情况：<br>· “断流”，即 x 太大，导致 b[1] 给 a[2] 供应太少，导致后面断流<br>· 流一圈后从 b[n] 流回 a[1] 的量加上 x 不 &gt;= a[1]，因为中途可能有点满流</p><p>也就是说 x 太大太小都不行，二分传回值标记一下就行了。</p><p>做法二：差分约束 O(n)</p><p>观察到有很多限制，设 x[i] 表示 b[i] 给 a[i] 的量就可以差分约束，但是 spfa 跑是 n^2 的好像会被卡，，观察建成的图，是一朵菊花的样子，而我们只要判是否有正权环就行，这个可以 O(n) 做。</p><p>做法二 Code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), tot -= a[i];</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]), tot += b[i];</span><br><span class="line">        <span class="keyword">if</span> (tot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">ll mn = b[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, <span class="number">2</span> * n) &#123;</span><br><span class="line">sum += a[i % n + <span class="number">1</span>] - b[i % n + <span class="number">1</span>];</span><br><span class="line">mn = min(mn, sum + b[i % n + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (sum - mn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">puts</span>(ff ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NOIP2012国王游戏"><a href="#NOIP2012国王游戏" class="headerlink" title="NOIP2012国王游戏"></a><a href="https://www.luogu.com.cn/problem/P1080" target="_blank" rel="noopener">NOIP2012国王游戏</a></h2><hr><p>很经典的题，贪心 + 高精度</p><p>邻项交换，微扰可以证明贪心正确性</p><h2 id="CF1251E2"><a href="#CF1251E2" class="headerlink" title="CF1251E2"></a><a href="https://codeforces.com/problemset/problem/1251/E2" target="_blank" rel="noopener">CF1251E2</a></h2><hr><p>考虑选择 x 人时，所有 mi &lt; x 的人都会自动投票，所以将 m 降序排列且降序处理</p><h2 id="CF1329C"><a href="#CF1329C" class="headerlink" title="CF1329C"></a><a href="https://codeforces.com/problemset/problem/1329/C" target="_blank" rel="noopener">CF1329C</a></h2><hr><p>一句话题意：拿掉元素和尽可能大的同时维护二叉堆性质</p><p>我们肯定贪心的取靠近根结点的位置，每个位置取到不能取为止。</p><p>什么叫不能取？它扯上来那条链的末尾节点深度为 g 了。所以我们对于每个节点维护链尾节点就好了！</p><h2 id="AtCoder-cf17-final-d"><a href="#AtCoder-cf17-final-d" class="headerlink" title="AtCoder-cf17_final_d"></a><a href="https://atcoder.jp/contests/cf17-final/tasks/cf17_final_d?lang=en" target="_blank" rel="noopener">AtCoder-cf17_final_d</a></h2><hr><p><a href="https://img.atcoder.jp/cf17-final/editorial.pdf" target="_blank" rel="noopener">https://img.atcoder.jp/cf17-final/editorial.pdf</a></p><p>· 贪心 + dp</p><p>关于为什么按 hi + pi 升序排列，官方题解说的很有道理，大致意思就是 显然对于高度的限制<strong>越松越好</strong>，通过邻项微扰来证明贪心正确性。</p><p>这边提供另外一种证明：考虑一个合法的选的序列，对于每一个 i 必须满足 sum_{j &lt;= i}{h_j} &lt;= h_i + p_i,<br>因为前缀和递增所以 hi + pi 也必须递增。</p><p>总之是一道很妙的题！</p><h2 id="HDU5380"><a href="#HDU5380" class="headerlink" title="HDU5380"></a><a href="https://vjudge.net/problem/HDU-5380" target="_blank" rel="noopener">HDU5380</a></h2><hr><p><a href="https://www.cnblogs.com/keximeiruguo/p/7684032.html" target="_blank" rel="noopener">https://www.cnblogs.com/keximeiruguo/p/7684032.html</a></p><p>把糖果视作价格高低不同，就可以贪心了（这题好hard</p><h2 id="luogu1484种树"><a href="#luogu1484种树" class="headerlink" title="luogu1484种树"></a><a href="https://www.luogu.com.cn/problem/P1484" target="_blank" rel="noopener">luogu1484种树</a></h2><hr><p>这类问题选择当前最优解时可能不是全局最优解，那怎么办？<strong>反悔贪心</strong> 可以使得贪心随便选择，都能到达正解。</p><p>具体操作用优先队列。对于限制采用缩点（用了 i 就将 l[i]、i、r[i] 缩在一起，反悔了选择了 l[i] 和 r[i] 就将 l[l[i]]、l[i]、i、r[i]、r[r[i]] 缩在一起），反悔就将权值为 val[l[i]] + val[r[i]] - val[i] 的点入队，每次取队首就好了。</p><h2 id="SP27102"><a href="#SP27102" class="headerlink" title="SP27102"></a><a href="https://www.luogu.com.cn/problem/SP27102" target="_blank" rel="noopener">SP27102</a></h2><hr><p>我们优先格式化 a &lt;= b 的硬盘，按 a 从小到大排序，可以尽量用少的空间来换多的空间，贪心，使得策略最可能成功。</p><hr><p>总结：做贪心题直觉很重要，限制越松越好之类的 要体会到啊，多练。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2369]-Ants on a Circle</title>
      <link href="2020/07/04/%5BAT2369%5D-Ants%20on%20a%20Circle/"/>
      <url>2020/07/04/%5BAT2369%5D-Ants%20on%20a%20Circle/</url>
      
        <content type="html"><![CDATA[<p>两人碰面后方向相反速度不变——这种题有个名字：弹性碰撞（还挺形象</p><p>网络上也有类似的：<a href="https://www.cnblogs.com/liuchanglc/p/12700770.html#_label6" target="_blank" rel="noopener">点我</a></p><p>弱化版1：（上面博客 $T1$）要求所有最终的位置，从小到大输出，不要求一一对应</p><p>解法：可以看作相遇的蚂蚁们穿过了彼此，发生碰撞了</p><p>弱化版2：（上面博客 $T2$）</p><p>解法：碰撞的过程可以看作交换编号，因此可以得出结论：编号为 $i$ 的蚂蚁碰到 $x$ 个逆向的蚂蚁后编号变为 $i + x$。</p><p>本题：一个道理，可以看作一只蚂蚁穿过 $0$ ~ $l - 1$，所有编号都会左移/右移一位</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, L, T, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; T;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="keyword">int</span> w; <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;a[i], &amp;w);</span><br><span class="line">a[i] += (w == <span class="number">1</span> ? T : -T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">pos += a[i] / L - (a[i] % L &lt; <span class="number">0</span>);</span><br><span class="line">a[i] = (a[i] % L + L) % L;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">pos = (pos % n + n) % n + <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[pos]);</span><br><span class="line">pos = (pos == n ? <span class="number">1</span> : pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Jun CF&amp;AT 练题汇总</title>
      <link href="2020/06/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jun%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/06/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jun%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CF1076E-Vasya-and-a-Tree"><a href="#CF1076E-Vasya-and-a-Tree" class="headerlink" title="[CF1076E]-Vasya and a Tree"></a>[CF1076E]-Vasya and a Tree</h2><hr><p>· 巧妙的dfs</p><p>没有数据结构可以直接维护，数据范围是3e5所以考虑dfs（？）  到达节点 x 时将 x 的操作执行掉（方法：根据深度维护一个树状数组，回溯时统计答案并消除影响）</p><h2 id="CF731F-Video-Cards"><a href="#CF731F-Video-Cards" class="headerlink" title="[CF731F]-Video Cards"></a>[CF731F]-Video Cards</h2><hr><p>· 利用“倍数”<br>· 观察数据范围：ai &lt;= 2e5!!!</p><p>y 要减到 x 的 k 倍时，y 在 xk ～ x(k + 1) - 1 的区间内。所以只要记录每个区间有几个数就可以算了，前缀和正解！！</p><p>再抽象化。求的是 sum{ 下取整(ai / x) * x }，那么枚举 下取整(ai / x) 就好了。</p><p>所以是.. nlogn?</p><p>P.S. 注意重复的 a[i] 别重复枚举qwq，200000个 1 就炸飞了啊嗷？</p><h2 id="CF1163C1-Power-Transmission-Easy-Edition"><a href="#CF1163C1-Power-Transmission-Easy-Edition" class="headerlink" title="[CF1163C1]-Power Transmission(Easy Edition)"></a>[CF1163C1]-Power Transmission(Easy Edition)</h2><hr><p>恶·心的计算题</p><h2 id="CF981D-Bookshelves"><a href="#CF981D-Bookshelves" class="headerlink" title="[CF981D]-Bookshelves"></a>[CF981D]-Bookshelves</h2><hr><p>·位运算+dp</p><p>从高位到低位chk：能否在已chk的高位取 1/0 的情况下，该位取 1。</p><h2 id="CF599D-Spongebob-and-Squares"><a href="#CF599D-Spongebob-and-Squares" class="headerlink" title="[CF599D]-Spongebob and Squares"></a>[CF599D]-Spongebob and Squares</h2><hr><p>推式子题，算出 m 关于 k 和 n 的关系式。枚举 n，算出 m。根据式子可得，n 大约是 1e6 级别的，所以不会 T！</p><h2 id="CF148E-Porcelain"><a href="#CF148E-Porcelain" class="headerlink" title="[CF148E]-Porcelain"></a>[CF148E]-Porcelain</h2><hr><p>·分组背包</p><p>先处理第 i 组容量为 j 时的最大价值和 val[i, j], 再注意到每组只能取一个 val[]，想到分组背包。</p><p>【惊！1e8 竟然可以 AC？</p><h2 id="CF1311F-Moving-Points"><a href="#CF1311F-Moving-Points" class="headerlink" title="[CF1311F]-Moving Points"></a>[CF1311F]-Moving Points</h2><hr><p>·树状数组+离散化</p><p>分类讨论，可得出结论：xi &lt; xj 且 vi &lt; vj，i 和 j 就不能相遇了（代价为 xj - xi）。</p><p>于是用树状数组计算 xj - xi 之和。</p><h2 id="CF1043E-Train-Hard-Win-Easy"><a href="#CF1043E-Train-Hard-Win-Easy" class="headerlink" title="[CF1043E]-Train Hard, Win Easy"></a>[CF1043E]-Train Hard, Win Easy</h2><hr><p>·妙题！</p><p>min(xi + yj, xj + yi) 这样子涉及到不同组的就很不爽，没法处理</p><p>xi + yj - (xj + yi) = (xi - xj) - (yi - yj)</p><p>讨论 (xi - xj) - (yi - yj) 的正负就好了</p><h2 id="CF1360H-Binary-Median"><a href="#CF1360H-Binary-Median" class="headerlink" title="[CF1360H]-Binary Median"></a>[CF1360H]-Binary Median</h2><hr><p>·二分</p><p>m 才 60。。要注意编号计算，很恶心</p><h2 id="CF1157D-N-Problems-During-K-Days"><a href="#CF1157D-N-Problems-During-K-Days" class="headerlink" title="[CF1157D]-N Problems During K Days"></a>[CF1157D]-N Problems During K Days</h2><hr><p>·构造</p><p>只要想到“在 1 2 .. k 的基础上修改”就好了，注意“2倍关系”的限制</p><h2 id="CF1015E2-Stars-Drawing-Hard-Edition"><a href="#CF1015E2-Stars-Drawing-Hard-Edition" class="headerlink" title="[CF1015E2]-Stars Drawing (Hard Edition)"></a>[CF1015E2]-Stars Drawing (Hard Edition)</h2><hr><p>·套路题</p><p>并没有数量限制啊，凡是上下左右都有’<em>‘的位置都可以画十字啊，size根据上下左右’</em>‘的长度来定，别忘了check是否完全覆盖，，，</p><h2 id="CF792D-Paths-in-a-Complete-Binary-Tree"><a href="#CF792D-Paths-in-a-Complete-Binary-Tree" class="headerlink" title="[CF792D]-Paths in a Complete Binary Tree"></a>[CF792D]-Paths in a Complete Binary Tree</h2><hr><p>·找规律</p><p>把每个数分解成 2 的幂次乘奇数的形式</p><h2 id="CF1012C-Hills"><a href="#CF1012C-Hills" class="headerlink" title="[CF1012C]-Hills"></a>[CF1012C]-Hills</h2><hr><p>·DP</p><p>设置的状态包括位置（第 i 个山坡）、已修建房屋数量（j）、当前位置是否受上一座房屋影响（k）</p><h2 id="CF19B-Checkout-Assistant"><a href="#CF19B-Checkout-Assistant" class="headerlink" title="[CF19B]-Checkout Assistant"></a>[CF19B]-Checkout Assistant</h2><hr><p>·背包</p><p>选了 k 个, 时间为 T,  T = t1 + t2 + … + tk,</p><p>T &gt;= n - k, T + k &gt;= n</p><p>所以 (t1 + 1) + (t2 + 2) + … + (tk + k) &gt;= n.</p><p>由此想到将 ti ++。</p><p>问题转化为：选择总体积 &gt;= n 的物品使得总费用最小，01背包</p><h2 id="CF9D-How-many-trees"><a href="#CF9D-How-many-trees" class="headerlink" title="[CF9D]-How many trees?"></a>[CF9D]-How many trees?</h2><hr><p>·DP</p><p>设计状态应包含节点数(i), 高度(j)</p><p>好写好调OvO</p><h2 id="CF730J-Bottles"><a href="#CF730J-Bottles" class="headerlink" title="[CF730J]-Bottles"></a>[CF730J]-Bottles</h2><hr><p>·背包</p><p>第一问比较好想，贪心，优先用 b[i] 大的杯子，算出答案为 k；</p><p>第二问<strong>是在第一问基础上的</strong>，设 tot = sigma(a[i]), 选中的杯子 a[i] 之和为 A，b[i] 之和为 B</p><p>那么必须满足 tot - A &lt;= B - A, 即 tot &lt;= B</p><p>现在有三条：</p><ol><li>选 k 个杯子；</li><li>B &gt;= tot；</li><li>A 最大。</li></ol><p>背包！写的时候数组开错了，越界，各种灵异事件 ಥ_ಥ 时间复杂度其实是 1e8 的，但 93ms 就过了，emm？</p><h2 id="CF946G-Almost-Increasing-Array"><a href="#CF946G-Almost-Increasing-Array" class="headerlink" title="[CF946G]-Almost Increasing Array"></a>[CF946G]-Almost Increasing Array</h2><hr><p>·树状数组维护dp</p><p>经典题，撇开“去掉一个”的限制，严格增加就是 j &gt; i, a[j] &gt; a[i], a[j] - a[i] &gt;= j - i 即 a[j] - j &gt;= a[i] - i; 那么维护一个 LIS 就好了</p><p>枚举去掉的位置，该位置后面的 要从 a[i] - i 变成 a[i] - i + 1（哎呀就这意思你懂的吧</p><p>倒腾倒腾就出来了</p><h2 id="CF478D-Red-Green-Towers"><a href="#CF478D-Red-Green-Towers" class="headerlink" title="[CF478D]-Red-Green Towers"></a>[CF478D]-Red-Green Towers</h2><hr><p>·线性DP</p><p>最大高度要先算qwq，f[i, j] 表示从上往下数第 i 层，用了 j 个红色的方案数，然后滚动数组优化空间</p><h2 id="CF1132F-Clear-the-String"><a href="#CF1132F-Clear-the-String" class="headerlink" title="[CF1132F]-Clear the String"></a>[CF1132F]-Clear the String</h2><hr><p>·区间DP</p><p>（完了我怎么简单题也不会</p><p>考虑当前字符，两种删除方法：1. 直接单个删除 2. 和后面同色的一起删除</p><p>所以就是 f[l, r] = min(f[l + 1, r] + 1, f[l + 1, i - 1] + f<a href="i 与 l 同色">i, r</a>)</p><h2 id="CF1344A-Hilbert’s-Hotel"><a href="#CF1344A-Hilbert’s-Hotel" class="headerlink" title="[CF1344A]-Hilbert’s Hotel"></a>[CF1344A]-Hilbert’s Hotel</h2><hr><p>·喵题！</p><p>观察样例第三组，找规律：</p><p>区间 [0, 1, 2, 3] 变为 [5, 6, 7, 4]</p><p>区间 [4, 5, 6, 7] 变为 [9, 10, 11, 8]</p><p>…</p><p>区间 [0 + nk, 1 + nk, 2 + nk, 3 + nk] 变为 [5 + nk, 6 + nk, 7 + nk, 4 + nk]</p><p>如果集合 [5 + nk, 6 + nk, 7 + nk, 4 + nk] 含有相同的数字那就是 NO 啦</p><p>若 k 相同时，这四个数有 % n 同余的，那就是 NO</p><p>为什么呢？a + nk = b + nk (% n)   =&gt;   a + nk’ = b</p><h2 id="CF140A-New-Year-Table"><a href="#CF140A-New-Year-Table" class="headerlink" title="[CF140A]-New Year Table"></a>[CF140A]-New Year Table</h2><hr><p>几何题，最近也看了高中数学必修四的三角函数，正好用到！吸吸。注意，c++函数都是弧度制，pi = acos(-1)。</p><h2 id="CF141C-Queue"><a href="#CF141C-Queue" class="headerlink" title="[CF141C]-Queue"></a>[CF141C]-Queue</h2><hr><p>考虑把 1 ~ n 作为身高分给 n 个人。每个人的排名只受前面人的影响，所以我们倒着来分。</p><h2 id="CF141D-Take-off-Ramps"><a href="#CF141D-Take-off-Ramps" class="headerlink" title="[CF141D]-Take-off Ramps"></a>[CF141D]-Take-off Ramps</h2><hr><p>一眼最短路。注意：起点 x - p, 终点 x + d, 费用 p + t</p><p>容易想到起点向终点连边，但是题目还可以不选跳板，甚至逆行。不用从一个位置向其他每个位置连边，那样时空都是 n^2 的！考虑到每次徒步走都是有目标的，没有无缘无故的逆行，只要在出发点和目标之间连边就好了。</p><h2 id="CF145B-Lucky-Number-2"><a href="#CF145B-Lucky-Number-2" class="headerlink" title="[CF145B]-Lucky Number 2"></a>[CF145B]-Lucky Number 2</h2><hr><p>·找规律</p><p>最基本的性质：4开头7结尾：47比74多1；  7开头4结尾：74比47多1；  4开头4结尾 / 7开头7结尾：相同</p><p>因此 |num(47) - num(74)| &gt; 1 的情况都是无解。再根据 num(47) 和 num(74) 的大小关系进行分讨（呕</p><h2 id="CF242E-XOR-on-Segment"><a href="#CF242E-XOR-on-Segment" class="headerlink" title="[CF242E]-XOR on Segment"></a>[CF242E]-XOR on Segment</h2><hr><p>·数据结构康复训练（</p><p>维护区间异或和。因为区间和无法直接异或，我们想到对二进制每一位分别开线段树！异或变成 0/1 个数的转换了。</p><h2 id="CF380C-Sereja-and-Brackets"><a href="#CF380C-Sereja-and-Brackets" class="headerlink" title="[CF380C]-Sereja and Brackets"></a>[CF380C]-Sereja and Brackets</h2><hr><p>刚开始想到是 r 前的对数 - l 前的对数 - 过交界处的对数，但是最后一项不会维护T T</p><p>区间括号配对数直接线段树维护就好了嘛，记录每个区间多余的 ‘(‘’)’ 个数和已配对的个数</p><h2 id="CF1244C-The-Football-Season"><a href="#CF1244C-The-Football-Season" class="headerlink" title="[CF1244C]-The Football Season"></a>[CF1244C]-The Football Season</h2><hr><p>x = (p - yd) / w.</p><p>因此要满足两个限制：1. x为整数 2. x + y &lt;= n</p><p>第一个用 exgcd 应该也能做。。但 w 很小呀，枚举 y = 0 ~ w - 1 也能过</p><h2 id="CF1359D"><a href="#CF1359D" class="headerlink" title="[CF1359D]"></a>[CF1359D]</h2><hr><p>枚举最大值，统计每个连续自序列的最大值</p><h2 id="CF181D-Word-Cut"><a href="#CF181D-Word-Cut" class="headerlink" title="[CF181D]-Word Cut"></a>[CF181D]-Word Cut</h2><hr><p>可以发现就是一个字符串不断循环。n^2 找出 s 与 t 相配的所有位置，dp就可以了</p><h2 id="CF176C-Playing-with-Superglue"><a href="#CF176C-Playing-with-Superglue" class="headerlink" title="[CF176C]-Playing with Superglue"></a>[CF176C]-Playing with Superglue</h2><hr><p>需要手玩的一道题。容易发现 max(abs(x1 - x2), abs(y1 - y2)) &gt; 4 的时候是后手赢，= 4 且 min = 3 或 4 的时候是后手赢，其余时间都是先手，至于为什么。。这跟这个游戏的规则有关系。</p><h2 id="CF180E"><a href="#CF180E" class="headerlink" title="[CF180E]"></a>[CF180E]</h2><hr><p>套路——用vector维护同一颜色的位置，查找就很方便</p><h2 id="CF148D"><a href="#CF148D" class="headerlink" title="[CF148D]"></a>[CF148D]</h2><hr><p>期望概率什么的 Qaq dp算是最善良的了。。</p><p>f[i, j] 表示袋子里还有 i 个白的、j 个黑的，公主赢的概率，转移方程不难，因为在一轮转移中龙的情况一并考虑掉了。</p><p>还有一种方法，因为有精度限制，枚举几千轮模拟操作也是可以过的，，</p><h2 id="CF453B"><a href="#CF453B" class="headerlink" title="[CF453B]"></a>[CF453B]</h2><hr><p>b不会 &gt;= 59, 因为选 1 必然不会更差！</p><p>58 以内有 16 个质数，每个只能用一次。想到什么了？状压dp. （3e8 2000ms丝毫不慌</p><h2 id="CF453C"><a href="#CF453C" class="headerlink" title="[CF453C]"></a>[CF453C]</h2><hr><p>思路不难想，来回震荡着走。选一个走奇数次的点作为根结点，dfs，每次走出子树时保证子树的点都满足要求了，子树的根结点就和它的父亲震荡，根结点和儿子震荡，可以证明这样一个节点最多走 4 次（</p><h2 id="CF182C"><a href="#CF182C" class="headerlink" title="[CF182C]"></a>[CF182C]</h2><hr><p>正着倒着各做一遍，对于每个区间，维护正负性相反的数中绝对值 K 大的。说白了就是动态维护 K 大和，我们用小根堆维护（注意实现的时候用两个 multiset，细节多</p><h2 id="CF187B"><a href="#CF187B" class="headerlink" title="[CF187B]"></a>[CF187B]</h2><hr><p>想法是 f[i, j, T] 表示 i 到 j 转换了 T 次，f[i, j, T] = min(f[i, k, T - 1] + f[k, j, 0])</p><p>floyd 大有学问啊（</p><h2 id="CF198E"><a href="#CF198E" class="headerlink" title="[CF198E]"></a>[CF198E]</h2><hr><p>x和y的限制可以缩为距离初始点(x, y)的距离的限制</p><p>所以就是对于队列中每个(r, p) 找到还没被删除的点集中 dis &lt;= r 且 m &lt;= p 的点，删除并加入队列</p><p>可以线段树 + set 维护，每个 dis 处都有个 set，迷惑操作但是很好写（</p><p>这是题解做法，要是真比赛碰到我八成会杠二维数点，留坑待填</p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Mar CF&amp;AT 练题汇总</title>
      <link href="2020/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Mar%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Mar%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AT2164"><a href="#AT2164" class="headerlink" title="[AT2164]-"></a>[AT2164]-</h2><hr><h2 id="AT2167-Blackout"><a href="#AT2167-Blackout" class="headerlink" title="[AT2167]-Blackout"></a>[AT2167]-Blackout</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 156</title>
      <link href="2020/03/01/Atcoder%20Beginner%20Contest%20156/"/>
      <url>2020/03/01/Atcoder%20Beginner%20Contest%20156/</url>
      
        <content type="html"><![CDATA[<p>ABC自动水过…</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><hr><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">所以才知道单算 C(n, m) 是 O(m) 复杂度的？？？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a, b, fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        ll a = (n + i - m) % mod;</span><br><span class="line">        ll b = i % mod;</span><br><span class="line">        res = res * (a * quick_pow(b, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ans = (quick_pow(<span class="number">2</span>, n) - <span class="number">1</span> + mod) % mod;</span><br><span class="line">    ans = (ans - C(n, a) + mod) % mod;</span><br><span class="line">    ans = (ans - C(n, b) + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><hr><p>首先 k &gt;= n 的时候答案是 C(2 * n - 1, n - 1)</p><p>然后 k &lt; n 的时候就可以枚举 位置空着的人数 了！就好了！我也好奇我当时在想啥呀</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, fac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[<span class="number">2</span> * n] = quick_pow(fac[<span class="number">2</span> * n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; i--) inv[i - <span class="number">1</span>] = inv[i] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (K &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, C(<span class="number">2</span> * n - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        rep(k, <span class="number">0</span>, K)</span><br><span class="line">            tot = (tot + C(n, k) * C(n - (n - k) + (n - k - <span class="number">1</span>), n - k - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><hr><p>这题挺好</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco20Feb (Gold)</title>
      <link href="2020/03/01/Usaco20Feb%20(Gold)/"/>
      <url>2020/03/01/Usaco20Feb%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p>这次的 gold 比前两场都水？！？T2已经离正解很近了唉。。T3就是个大暴力唉。。。。</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><hr><p>差分约束，大于小于搞清楚就可以</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, C, s[N], dis[N], inq[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], val[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"timeline.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"timeline.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; C;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]), add(<span class="number">0</span>, i, -s[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, C) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, x; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        add(a, b, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><hr><p>赛时想了个 DP，最后发现少考虑一种情况。。</p><p>但赛后才知道加上那个情况就可以不用 DP 这么麻烦了！！！</p><p>不过口胡了一个与此题无关的、算区间内区间的 O(nlogn) 算法。。也算小小小有收获了！！！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单独算每个区间 [l, r] 的贡献（就是 2^&#123;n - 1 - 不包含[l - 1, l]的区间数&#125;）</span></span><br><span class="line"><span class="comment">赛时降智。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt[N], mi[N] = &#123;<span class="number">1</span>&#125;, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"help.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"help.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; e[i].l &gt;&gt; e[i].r, cnt[e[i].l]++, cnt[e[i].r]--;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * n) cnt[i] += cnt[i - <span class="number">1</span>], mi[i] = mi[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = (ans + mi[n - <span class="number">1</span> - cnt[e[i].l - <span class="number">1</span>]]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><hr><p>一个大暴力，没啥好说_(´ཀ`」 ∠)_ 怪我太菜。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">正常每次dfs，递归常数大。。写checker⬇️就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, sz[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        num[x].push_back(sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">1</span>) num[x].push_back(n - sz[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bin[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((n - <span class="number">1</span>) % k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k - <span class="number">1</span>) bin[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num[i][j] % k;</span><br><span class="line">            <span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (bin[k - x]) bin[k - x]--, cnt--;</span><br><span class="line">            <span class="keyword">else</span> bin[x]++, cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"deleg.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"deleg.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, chk(i)); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Feb CF&amp;AT 练题汇总</title>
      <link href="2020/02/29/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Feb%20CF&amp;AT%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/02/29/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Feb%20CF&amp;AT%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AT1984-Wide-Swap"><a href="#AT1984-Wide-Swap" class="headerlink" title="[AT1984]-Wide Swap"></a>[AT1984]-Wide Swap</h2><hr><p><a href="https://imilyx.github.io/2020/02/09/%5BAT1984%5D-Wide%20Swap/" target="_blank" rel="noopener">见此篇</a></p><h2 id="AT2004-Anticube"><a href="#AT2004-Anticube" class="headerlink" title="[AT2004]-Anticube"></a>[AT2004]-Anticube</h2><hr><p><a href="https://imilyx.github.io/2020/02/10/%5BAT2004%5D-Anticube/" target="_blank" rel="noopener">见此篇</a></p><h2 id="CF17C-Balance"><a href="#CF17C-Balance" class="headerlink" title="[CF17C]-Balance"></a>[CF17C]-Balance</h2><hr><ul><li>找性质：定义一个字符串的最简化为删除相邻同类字符后的字符串，例如：aabbbc 最简化为 abc。变化后的 B 的最简化是变化前 A 的最简化的子序列。不难懂，但是很难想。。。</li></ul><p>我觉得这个性质应该切入点是：字符串 S 中 l 的位置要同化 [l, r] 这个区间，显然是像推土机一样推过去的，它以自己替换了 [l, r] 的最简化。</p><p>简单 DP 即可。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">51123987</span>, N = <span class="number">160</span>;</span><br><span class="line"><span class="keyword">int</span> n, nxt[N][<span class="number">3</span>], f[N][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>], ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">2</span>) nxt[n + <span class="number">1</span>][i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">2</span>) nxt[i][j] = nxt[i + <span class="number">1</span>][j];</span><br><span class="line">        nxt[i][s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lim = (n + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(a, <span class="number">0</span>, lim)</span><br><span class="line">            rep(b, <span class="number">0</span>, lim)</span><br><span class="line">                rep(c, <span class="number">0</span>, lim) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a + b + c == n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(a - c) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(b - c) &lt;= <span class="number">1</span>)</span><br><span class="line">                            upd(ans, f[i][a][b][c]);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">0</span>] != <span class="number">-1</span>)  <span class="comment">// 用 nxt 来 和用 s 最简化后的字符串来是一个道理</span></span><br><span class="line">                        upd(f[nxt[i][<span class="number">0</span>]][a + <span class="number">1</span>][b][c], f[i][a][b][c]);  <span class="comment">// 有可能会无限停留在当前位置，不过没有关系，a + b + c = n 的时候就会停止</span></span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                        upd(f[nxt[i][<span class="number">1</span>]][a][b + <span class="number">1</span>][c], f[i][a][b][c]);</span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">                        upd(f[nxt[i][<span class="number">2</span>]][a][b][c + <span class="number">1</span>], f[i][a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CF17D-Notepad"><a href="#CF17D-Notepad" class="headerlink" title="[CF17D]-Notepad"></a>[CF17D]-Notepad</h2><hr><p>没有什么好说的，一眼不是高精度！。没错就是—</p><ul><li>扩展欧拉函数板子题！【啊怎么又是欧拉</li></ul><p><a href="https://www.cnblogs.com/ywwyww/p/8510981.html" target="_blank" rel="noopener">这个大佬精辟总结了</a></p><p>题目没有保证底数(b)和模数(c)互质所以不能用数论中的欧拉定理，要用扩展版本。<strong>还有一点，注意指数小于 phi(模数) 的时候定理不成立！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧拉函数 降幂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll b, b2, n, c, phi;</span><br><span class="line"><span class="keyword">char</span> s1[N], s2[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % c;</span><br><span class="line">        a = a * a % c;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s%lld"</span>, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>, &amp;c);</span><br><span class="line">    phi = getphi(c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b</span></span><br><span class="line">    rep(i, <span class="number">1</span>, len) b = (b * <span class="number">10</span> + (s1[i] - <span class="string">'0'</span>)) % c;</span><br><span class="line">    <span class="comment">// b - 1</span></span><br><span class="line">    b2 = (b - <span class="number">1l</span>l + c) % c;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, len) n = (n * <span class="number">10</span> + (s2[i] - <span class="string">'0'</span>)) % phi;</span><br><span class="line">    <span class="comment">// n - 1</span></span><br><span class="line">    n = (n - <span class="number">1l</span>l + phi) % phi + phi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        ll realN = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, len) realN = realN * <span class="number">10</span> + (s2[i] - <span class="string">'0'</span>);</span><br><span class="line">        realN -= <span class="number">1l</span>l;</span><br><span class="line">        <span class="keyword">if</span> (realN &lt; phi) n -= phi;  <span class="comment">// !!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = b2 * quick_pow(b, n) % c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans ? ans : c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF17E-Palisection"><a href="#CF17E-Palisection" class="headerlink" title="[CF17E]-Palisection"></a>[CF17E]-Palisection</h2><hr><p>有点意思啊！</p><p>题目要求相交回文串对数，考虑到存在包含关系，直接处理细节会很多很不好写。</p><p>俗话说得好，<strong>正难则反！</strong></p><ul><li>相交对数 = 总数 - 不相交对数。manacher + 前缀和维护</li></ul><p>计算一个位置左边的回文串右端点个数，与该位置右边的回文串左端点个数相乘，这样是会<strong>算重</strong>的！！</p><p>所以我们固定一个位置，该位置作为左端点的串个数 与该位置左边的回文串右端点相乘，这样显然不会重。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e6</span> + <span class="number">10</span>, mod = <span class="number">51123987</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, len, p[N], pos, mx, l[N], r[N];  <span class="comment">// l[x]/r[x]: x 位置作为左/右端点的字符串个数</span></span><br><span class="line">ll ans, sum;</span><br><span class="line"><span class="keyword">char</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">            p[i] = min(p[pos * <span class="number">2</span> - i], mx - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + p[i]) mx = i + p[i], pos = i;</span><br><span class="line"></span><br><span class="line">        ++l[i - p[i] + <span class="number">1</span>], --l[i + <span class="number">1</span>];  <span class="comment">// 中心到每一个 [左端点，中心] 的点 都有一个回文串</span></span><br><span class="line">        ++r[i], --r[i + p[i]];</span><br><span class="line"></span><br><span class="line">        ans = (ans + (p[i] &gt;&gt; <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans * (ans - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">    len = n;</span><br><span class="line">    s[n = <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, len) s[++n] = a[i], s[++n] = <span class="string">'#'</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'['</span>, s[n + <span class="number">1</span>] = <span class="string">']'</span>;</span><br><span class="line"></span><br><span class="line">    manacher();</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        l[i] += l[i - <span class="number">1</span>], r[i] += r[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (ans - (ll)l[i] * sum % mod + mod) % mod;  <span class="comment">// 正难则反</span></span><br><span class="line">            sum = (sum + r[i]) % mod;  <span class="comment">// 相当于二阶差分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2301-Solitaire"><a href="#AT2301-Solitaire" class="headerlink" title="[AT2301]-Solitaire"></a>[AT2301]-Solitaire</h2><hr><p>取数前肯定是 V 字形的（1 是谷底）</p><ul><li>一个取数序列，只要存在一种 V 字形的安排，就是合法的</li></ul><p><a href="https://blog.csdn.net/weixin_30820077/article/details/96464019" target="_blank" rel="noopener">这个大佬讲的比我清楚</a></p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, K, f[N][N], sum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    per(i, n, <span class="number">2</span>) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, K - <span class="number">2</span>) &#123;</span><br><span class="line">        sum = f[i][n - i + <span class="number">1</span>];</span><br><span class="line">        per(j, n - i, <span class="number">2</span>) &#123;</span><br><span class="line">            sum = (sum + f[i][j]) % mod;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = (f[i + <span class="number">1</span>][j] + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n - (K - <span class="number">1</span>) + <span class="number">1</span>) ans = (ans + f[K - <span class="number">1</span>][i]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n - K - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, n - K - <span class="number">1</span>) ans = (ans &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2005-Sequential-operations-on-Sequence"><a href="#AT2005-Sequential-operations-on-Sequence" class="headerlink" title="[AT2005]-Sequential operations on Sequence"></a>[AT2005]-Sequential operations on Sequence</h2><hr><p><a href="https://imilyx.github.io/2020/02/11/[AT2005]-Sequential%20operations%20on%20Sequence/" target="_blank" rel="noopener">见此篇</a></p><h2 id="AT2043-AND-Grid"><a href="#AT2043-AND-Grid" class="headerlink" title="[AT2043]-AND Grid"></a>[AT2043]-AND Grid</h2><hr><p>构造题，以前做到过！很神仙的思路，想不到qwq 构造形状如嵌在一起的手指一般</p><h2 id="AT2046-Namori"><a href="#AT2046-Namori" class="headerlink" title="[AT2046]-Namori"></a>[AT2046]-Namori</h2><hr><p>简介（雾）：一道绝妙的转化好题</p><p><strong>树 是 二 分 图！！！</strong></p><p><a href="https://www.luogu.com.cn/blog/flashblog/solution-at2046" target="_blank" rel="noopener">这个大佬就写的到位，偶环部分写得特别好</a></p><p>然后来谈谈自己的理解：</p><ol><li><p>这种转化下，将相邻两个同色同时反转 等价于 将相邻两个是否有硬币情况交换一下</p></li><li><p>也许看到这种反转题第一步就应该按照深度什么的来个黑白反转。。？这样才能进展qwq。。<strong>模型转化靠做题练</strong></p></li><li><p>奇环和偶环要分开考虑（偶环是二分图，奇环不是）<strong>奇环中断掉的边只有分摊部分转移、加快运输的作用</strong></p></li></ol><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans, stx, sty, fx, fy;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], s[N], a[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    s[x] = val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x], y; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> ((y = to[i]) != f)</span><br><span class="line">            dfs(y, x, -val), s[x] += s[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    stx = sty = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> ((fx = getfa(x)) != (fy = getfa(y))) fa[fx] = fy;</span><br><span class="line">        <span class="keyword">else</span> &#123; stx = x, sty = y; <span class="keyword">continue</span>; &#125;  <span class="comment">// 环上边，给它断掉！</span></span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(stx, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) a[++top] = s[i];</span><br><span class="line">        <span class="keyword">if</span> ((dep[stx] - dep[sty]) &amp; <span class="number">1</span>) &#123;  <span class="comment">// 偶环</span></span><br><span class="line">            <span class="keyword">if</span> (s[stx]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">            sort(a + <span class="number">1</span>, a + top + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) s[i] -= a[top &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 奇环</span></span><br><span class="line">            <span class="keyword">if</span> (s[stx] &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) s[i] -= s[stx] &gt;&gt; <span class="number">1</span>;  <span class="comment">// 环上的树们只管把多余的往外输送就好了，主要是环上边决定运输方向！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[stx]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans += <span class="built_in">abs</span>(s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2063-Sugigma-The-Showdown"><a href="#AT2063-Sugigma-The-Showdown" class="headerlink" title="[AT2063]-Sugigma: The Showdown"></a>[AT2063]-Sugigma: The Showdown</h2><hr><p>我哥解说太赞了！！！超好评</p><p>在一棵树上，先手不被抓到的唯一情况是：红树上存在一条边 x-&gt;y, 蓝树上 x 到 y 的距离 &gt; 2。</p><p>接下来说明为什么除此之外都会被抓到。</p><p>首先，在一棵<strong>普通</strong>树上，后手可以把先手往角落里逼（因为没有环），先手挂了。</p><p>回到这题，“蓝树上 x 到 y 的距离 &lt;= 2”，首先不用考虑距离 = 1 的情况（这就是普通树的情况）</p><p>现在距离 = 2，后手站在两条蓝边的中间节点上，先手在 x 或 y 上，显然如瓮中捉鳖，先手挂了。</p><p>因此先手要逃离这个结构，但一逃离就是距离 = 1 的情况，还是会挂。。</p><p>我哥讲的真好，就这个道理！</p><p>所以时间就是两倍的后手步数，先手只要找到离后手最远且他能比后手抢先到达的点呆着就好。。。</p><h2 id="AT2064-Many-Easy-Problems"><a href="#AT2064-Many-Easy-Problems" class="headerlink" title="[AT2064]-Many Easy Problems"></a>[AT2064]-Many Easy Problems</h2><hr><p>一道非模板的 NTT~ 可以想到算每个点在多少联通块里出现，但这显然不好算，正难则反，继而转为算每个点在多少联通块里不出现</p><p><a href="https://m-sea-blog.com/archives/4576/" target="_blank" rel="noopener">挂一个大佬博客，推的式子就是这个亚子</a></p><p>然后感触比较深的就是：设 F = f ✖️ g， {\sum_{i, 0, n} f(n - i)·g(i)} = F(n) ！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">感慨：卷积原来是这么用的啊..</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">924844033</span>, N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, lim = <span class="number">1</span>, l;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], ecnt;</span><br><span class="line"><span class="keyword">int</span> sz[N], cnt[N], r[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll f[N], g[N], fac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++ecnt] = y, nxt[ecnt] = lnk[x], lnk[x] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = quick_pow(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) inv[i - <span class="number">1</span>] = inv[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x], y; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> ((y = to[i]) != fa)</span><br><span class="line">            dfs(y, x), sz[x] += sz[y], cnt[sz[y]]++;</span><br><span class="line">    cnt[n - sz[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? <span class="number">5</span> : <span class="number">554906420</span>, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll x = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    pre();</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) f[i] = <span class="number">1l</span>l * cnt[i] * fac[i] % mod;</span><br><span class="line">    reverse(f, f + n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n) g[i] = inv[i];</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n * <span class="number">2</span>) lim &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">    NTT(f, <span class="number">1</span>), NTT(g, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim) f[i] = (f[i] * g[i]) % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (n * C(n, i) % mod - inv[i] * f[n - i] % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 618 Div1</title>
      <link href="2020/02/29/Codeforces%20Round%20618%20Div1/"/>
      <url>2020/02/29/Codeforces%20Round%20618%20Div1/</url>
      
        <content type="html"><![CDATA[<p>第一次 vp Div1 ~</p><h3 id="A-Anu-Has-a-Function"><a href="#A-Anu-Has-a-Function" class="headerlink" title="A. Anu Has a Function"></a>A. Anu Has a Function</h3><hr><p>考虑 (x | y) - y 的意义：等同于保留所有<strong>只有 x 为 1</strong>的二进制位</p><p>那么就很好办：选择不和其他数撞位的、有最高位的数放第一个</p><ul><li>二进制题要考虑意义</li></ul><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, a[N], id[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">if</span> ((x &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (id[j] &gt; <span class="number">0</span>) id[j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!id[j]) id[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (id[i] &gt; <span class="number">0</span>) &#123; swap(a[<span class="number">1</span>], a[id[i]]); <span class="keyword">break</span>; &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Water-Balance"><a href="#C-Water-Balance" class="headerlink" title="C. Water Balance"></a>C. Water Balance</h3><hr><p>有点意思。最终，若将相邻、值相等的位置归为一块，必不存在第 i 块的值大于第 i + 1 块的情况。第 i 块如果很小，它肯定会优先与 i - 1 合并而不是和 i + 1（字典序嘛。。）单调栈维护！！</p><p>还有一种思路：维护下凸壳，也一样可以做</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N], s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; <span class="keyword">double</span> ave; &#125;stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]), s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        stk[++top] = (node)&#123;i, i, a[i]&#125;;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top].ave &lt; stk[top - <span class="number">1</span>].ave) &#123;</span><br><span class="line">            top--, stk[top].r = stk[top + <span class="number">1</span>].r;</span><br><span class="line">            stk[top].ave = (s[stk[top].r] - s[stk[top].l - <span class="number">1</span>]) / (stk[top].r - stk[top].l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, top) rep(j, stk[i].l, stk[i].r) <span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, stk[i].ave);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2005]-Sequential operations on Sequence</title>
      <link href="2020/02/11/%5BAT2005%5D-Sequential%20operations%20on%20Sequence/"/>
      <url>2020/02/11/%5BAT2005%5D-Sequential%20operations%20on%20Sequence/</url>
      
        <content type="html"><![CDATA[<p>又是道大好题，，</p><ul><li>思维题，概括不了</li></ul><ol><li>这步必须想到，是根基。对照样例应该也能发现这个性质：用单调栈将 $q$ 变成上升的序列，<strong>第 $i$ 步操作后得到的序列就是第 $i - 1$ 步操作得到序列的几倍 + 前缀</strong></li><li>见过推土机吗？这题实现起来就是这样。设 $f[i]$ 表示第 $i$ 步操作后的序列在最终序列中出现的次数，显然 $f[i] = f[i + 1] * (len[i + 1] / len[i])$，余数部分找循环节，诸如此类，递规处理。不断被肢解，最后剩下的一小撮没有循环节了，那一小撮长这样：1 2 3 4 … 也就是初始序列的前缀，提前累计到 ans[] 里</li><li>复杂度分析：余数部分处理，每次对一个比自己小的循环节长度取模，至少减小一半，即 $logn$; 二分找小于余数部分长度的最大循环节，$logn$，所以最后是 $O(n log^2 n)$</li></ol><p>其实想想，就好像一个序列不断被打乱，把它复原就可以了。。很抽象了</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有没有思路都先分析完样例！！！说不定会有启发！！！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, Q, m, q[N], x, f[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = upper_bound(q + <span class="number">1</span>, q + m + <span class="number">1</span>, x) - q - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">        ans[<span class="number">1</span>] += v, ans[x + <span class="number">1</span>] -= v;  <span class="comment">// 提前累计</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[k] += v * (x / q[k]), solve(x % q[k], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    q[++m] = n;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (m &amp;&amp; q[m] &gt;= x) --m;</span><br><span class="line">        q[++m] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">2</span>; i--)</span><br><span class="line">        f[i - <span class="number">1</span>] += f[i] * (q[i] / q[i - <span class="number">1</span>]), solve(q[i] % q[i - <span class="number">1</span>], f[i]);</span><br><span class="line"></span><br><span class="line">    ans[<span class="number">1</span>] += f[<span class="number">1</span>], ans[q[<span class="number">1</span>] + <span class="number">1</span>] -= f[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans[i] += ans[i - <span class="number">1</span>], <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2004]-Anticube</title>
      <link href="2020/02/10/%5BAT2004%5D-Anticube/"/>
      <url>2020/02/10/%5BAT2004%5D-Anticube/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/AtCoder-2004" target="_blank" rel="noopener">传送门</a></p><p>题意：从 n 个数中选最多的数使得它们两两相乘不是立方数。</p><p><a href="https://blog.csdn.net/WerKeyTom_FTD/article/details/78361615" target="_blank" rel="noopener">大佬博客</a></p><p>大致思路就是 <strong>质因数分解 + 贪心</strong> 了，本题重点在质因数分解！！</p><p>首先，将每个 $s_i$ 看作 $prod{p_i ^ {a_i}}$. 立方数 ✖️ 立方数 = 立方数，这启发我们简化指数，即 $a_i$ 对 $3$ 取模</p><p>但是质因数分解理论上时间复杂度太大了！！怎么办！！！</p><p>设 $s_i <em> s_j = x^3$, $s_i </em> s_j \leq 10^{20}$, $x \leq 10^{20/3}$。$x$ 可能有一个 $[10^{10/3}, 10^{20/3}]$ 的质因子，但是如果这个质因子大于 $10^5$, $s_i$ 和 $s_j$ 总共也不可能有 $3$ 个，<strong>所以 $x$ 的每个质因子都是 $[2, 10^5]$ 范围内的，其中 $[10^{10/3}, 10^5]$ 以内的数最多只有一个。</strong></p><p>对于大佬最后一行，我的理解是，$s_i$ 中 $&gt; 10^{10/3}$ 的质因子，在 $[10^{10/3}, 10^5]$ 范围内的部分 指数只会是 $1$ 或 $2$，而 $&gt; 10^5$ 的部分最多只有 $1$ 个，不影响大局。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, s[N], a[N], b[N], ans;  <span class="comment">// a[i] 存的是 s[i] 的最简数，b[i] 是 a[i] 的补数</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line"><span class="keyword">int</span> mark[N], p[N], tot;</span><br><span class="line"><span class="comment">// 拓展：10^&#123;10/3&#125; 以内质数有 326 个，10^&#123;10/3&#125;~10^5 以内质数有 9267 个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) p[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; p[j] * i &lt;= n; j++) &#123;</span><br><span class="line">            mark[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    euler(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line">    ll k, tmp;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        k = s[i]; a[i] = b[i] = <span class="number">1</span>;</span><br><span class="line">        rep(o, <span class="number">1</span>, tot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ll j = p[o];</span><br><span class="line">            <span class="keyword">if</span> (j * j * j &gt;= <span class="number">1e10</span>) <span class="keyword">break</span>;  <span class="comment">// 10^&#123;10/3&#125; 以内</span></span><br><span class="line">            <span class="keyword">if</span> (mark[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            tmp = <span class="number">1l</span>l * j * j * j;</span><br><span class="line">            <span class="keyword">while</span> (k % tmp == <span class="number">0</span>) k /= tmp;  <span class="comment">// 简化</span></span><br><span class="line">            tmp = <span class="number">1l</span>l * j * j;</span><br><span class="line">            <span class="keyword">if</span> (k % tmp == <span class="number">0</span>) a[i] *= tmp, b[i] *= j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k % j == <span class="number">0</span>) a[i] *= j, b[i] *= tmp;</span><br><span class="line">            <span class="keyword">while</span> (k % j == <span class="number">0</span>) k /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = (ll)<span class="built_in">sqrt</span>(k);</span><br><span class="line">            <span class="keyword">if</span> (tmp * tmp == k) a[i] *= k, b[i] *= tmp;</span><br><span class="line">            <span class="keyword">else</span> a[i] *= k, b[i] *= k * k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) num[a[i]]++;  <span class="comment">// a[i] 是 s[i] 去掉指数是 3 倍数质因子的结果</span></span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a[i]] = vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">        ans += (a[i] == b[i] ? <span class="number">1</span> : max(num[a[i]], num[b[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT1984]-Wide Swap</title>
      <link href="2020/02/09/%5BAT1984%5D-Wide%20Swap/"/>
      <url>2020/02/09/%5BAT1984%5D-Wide%20Swap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/AtCoder-1984" target="_blank" rel="noopener">传送门</a></p><p>这题太神了！！！我爱死 atcoder 了！！！！！</p><p><a href="https://www.cnblogs.com/cjoierShiina-Mashiro/p/12233486.html" target="_blank" rel="noopener">这位大佬讲的好，我再补充些自己的理解</a></p><p>总结出来解题的常用步骤，也就是最重要的技能是 <strong>转化</strong> 和 <strong>找性质</strong>。</p><p>好！本题必须转化。本来必须满足两条限制（见题目），但大佬这么一转化就限定好只能交换相邻位置，两条限制一下变成一条了！</p><p>求 $p$ 最小字典序等同于求 $q$ 最小字典序，为什么？$q_{p_i}$ 表达的是什么？$q_{p_i}$ 表示 $p_i$ 目前放的位置。</p><p>$q$ 的下标从小到大递增。对于 $p_i &lt; p_j$, $q_{p_i} &lt; q_{p_j}$（即更小的值位置更前）显然是比较优的。所以求 $p$ 最小字典序等同于求 $q$ 最小字典序。</p><p>$q$ 中，如果 $1 \leq i, j \leq n$, $|qi - qj| &lt; K$, 显然 $q_i$ 和 $q_j$ 的相对位置不会发生变化。存在着很多诸如此类的限制，我们又想要 $q$ 字典序最小，怎么办呢？</p><p>最小拓扑序。对于 $1 \leq i &lt; j \leq n$, $|qi - qj| &lt; K$, 从 $q_i$ 向 $q_j$ 连一条边，这样不仅满足了所有限制，也使 $q$ 的字典序最小了。<strong>这是套路，一定要掌握！！！</strong></p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题常用步骤：转化 找性质</span></span><br><span class="line"><span class="comment">// 本题第一步转化起到了简化的作用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], x, ans[N];</span><br><span class="line"><span class="keyword">int</span> mn[N &lt;&lt; <span class="number">2</span>], deg[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;q;  <span class="comment">// 用 pq 来求最小拓扑序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; mn[x] = min(mn[x &lt;&lt; <span class="number">1</span>], mn[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; mn[x] = v; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(x &lt;&lt; <span class="number">1</span>, l, mid, pos, v);</span><br><span class="line">    <span class="keyword">else</span> modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, v);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rx &lt; l || lx &gt; r) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> mn[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> min(query(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx), query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), a[x] = i;</span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j = query(<span class="number">1</span>, <span class="number">1</span>, n, a[i] + <span class="number">1</span>, a[i] + K - <span class="number">1</span>)) != inf)</span><br><span class="line">            ++deg[a[j]], e[a[i]].push_back(a[j]);</span><br><span class="line">        <span class="keyword">if</span> ((j = query(<span class="number">1</span>, <span class="number">1</span>, n, a[i] - K + <span class="number">1</span>, a[i] - <span class="number">1</span>)) != inf)</span><br><span class="line">            ++deg[a[j]], e[a[i]].push_back(a[j]);</span><br><span class="line">        modify(<span class="number">1</span>, <span class="number">1</span>, n, a[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!deg[i]) q.push(i);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        a[++tot] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[x][i];</span><br><span class="line">            <span class="keyword">if</span> (!(--deg[y])) q.push(y); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans[a[i]] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco20Jan (Gold)</title>
      <link href="2020/02/02/Usaco20Jan%20(Gold)/"/>
      <url>2020/02/02/Usaco20Jan%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.usaco.org/index.php?page=jan20results" target="_blank" rel="noopener">传送门</a></p><p>题都很好，我太菜了，加油！冲冲冲</p><h3 id="A-Time-is-Mooney"><a href="#A-Time-is-Mooney" class="headerlink" title="A. Time is Mooney"></a>A. Time is Mooney</h3><hr><p>可以发现，点权最大是 1000，C 最小是 1，也就意味着 1000t - t^2 &gt;= 0, t &lt;= 1000!!</p><p>那么枚举 t 就可以啦，ans = max(从 1 出发，经过 t 步走回 1 的 maxval)</p><p>设 dp[t, i] 表示走 t 步到 i 节点的最大点权和，这样就能求括号里的那个东西啦。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">ll dp[<span class="number">2</span>][N], n, m, C, a[N], ans;  <span class="comment">// 滚动</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"time.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"time.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; C;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edges.push_back(make_pair(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    ans = <span class="number">-1e18</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(t, <span class="number">1</span>, <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = t % <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp[p], <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp[p]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line">            <span class="keyword">if</span> (dp[p ^ <span class="number">1</span>][x] != <span class="number">-1</span>)</span><br><span class="line">                dp[p][y] = max(dp[p][y], dp[p ^ <span class="number">1</span>][x] + a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[p][<span class="number">1</span>] - C * t * t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Farmer-John-Solves-3SUM"><a href="#B-Farmer-John-Solves-3SUM" class="headerlink" title="B. Farmer John Solves 3SUM"></a>B. Farmer John Solves 3SUM</h3><hr><p>n = 5000，妥妥 n^2。如果能做到 n^2 预处理就好啦！</p><p>滴—！用 pbds 库里的 hash，O(1) 超快，用 set 或 map 会超时der。。。</p><p>具体用法下面有👇</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map, set, multimap, and multiset: log(n)</span></span><br><span class="line"><span class="comment">// hash_map, hash_set, hash_multimap, and hash_multiset: best O(1), worst O(n)</span></span><br><span class="line"><span class="comment">// pb_ds库里的hash: 1. 需要头文件(line 5,6,8) 2. 函数声明(line 23) 3. 使用方式(line 25~28)</span></span><br><span class="line"><span class="comment">// C++11!</span></span><br><span class="line"><span class="comment">// C++11!!</span></span><br><span class="line"><span class="comment">// C++11!!!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, Q, a[N];</span><br><span class="line">ll ans[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"threesum.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"threesum.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        gp_hash_table&lt;int, int&gt; g(&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;1 &lt;&lt; 13&#125;);</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = g.find(-a[i] - a[j]);</span><br><span class="line">            <span class="keyword">if</span> (it != end(g)) ans[i][j] = it-&gt;second;</span><br><span class="line">            g[a[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        rep(j, i, n)</span><br><span class="line">            ans[i][j] += ans[i + <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>] - ans[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Springboards"><a href="#C-Springboards" class="headerlink" title="C. Springboards"></a>C. Springboards</h3><hr><p>将特殊点按 x、y 坐标排序。设 ans[i] 表示到第 i 个落地点的最短距离。</p><p>第 i 个点之前的点是第 j 个的话，ans[i] = xi + yi - xj - yj + ans[j]</p><p>所以我们碰到落地点就计算 ans[i], 碰到起跳点就将 ans[i] - xi - yi 加入 map，map 维护之前经过的所有点的答案。map 第一维是 y 坐标，第二维是 val。</p><p>显然，对于两个入 map 顺序 i &lt; j 的点，若 yi &lt; yj 且 vali &lt; valj，那么 j 显然没有必要入 map。本着这个原则。显然 map 最后是 y 越大，val 越小的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, p, ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = prev(mp.upper_bound(y));</span><br><span class="line">    <span class="keyword">if</span> ((*it).se &lt;= v) <span class="keyword">return</span>;  <span class="comment">// (*it).se = it-&gt;se</span></span><br><span class="line">    it++;</span><br><span class="line">    <span class="keyword">while</span> (it != mp.end() &amp;&amp; it-&gt;se &gt; v) mp.erase(it++);</span><br><span class="line">    mp[y] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"boards.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"boards.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;pii, pii&gt;&gt; v;</span><br><span class="line">    rep(i, <span class="number">1</span>, p) &#123;</span><br><span class="line">        pii a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a.fi &gt;&gt; a.se &gt;&gt; b.fi &gt;&gt; b.se;</span><br><span class="line">        v.push_back(&#123;a, &#123;i, <span class="number">-1</span>&#125;&#125;);</span><br><span class="line">        v.push_back(&#123;b, &#123;i, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].se.se == <span class="number">-1</span>) &#123;</span><br><span class="line">            ans[v[i].se.fi] = v[i].fi.fi + v[i].fi.se + prev(mp.upper_bound(v[i].fi.se))-&gt;se;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(v[i].fi.se, ans[v[i].se.fi] - v[i].fi.fi - v[i].fi.se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mp.rbegin()-&gt;se + <span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】虚树</title>
      <link href="2020/02/01/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%99%9A%E6%A0%91/"/>
      <url>2020/02/01/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%99%9A%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>虚树，没那么玄乎，针对的是“多次树上询问一些点”的题目。比如下面这道题，题面中就有这样的表述：sigma(ki)&lt;=500000 那么我们的算法一定不和 n 有关，而是和 k 有关啦！</p><p>虚树的时间复杂度就是 O(sigma(ki))！下面是练习时间~</p><h3 id="SDOI2011-消耗战"><a href="#SDOI2011-消耗战" class="headerlink" title="[SDOI2011]-消耗战"></a>[SDOI2011]-消耗战</h3><hr><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2286" target="_blank" rel="noopener">传送门</a></p><p>很容易想到树形DP，但那样就是 O(nm)，太大了！肿么办 ಠ_ಠ 上虚树！</p><p>每次把询问点及它们的 LCA 摘出来重新建一棵树，也就是虚树，虚树上树形 DP，单次 O(ki)。</p><p>注意，本题特殊性在于，一条链若是 根-&gt;a-&gt;b-&gt;c，那么只要保留 根-&gt;a 这段路径就可以了！这个很明显吧</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], idx;</span><br><span class="line"><span class="keyword">int</span> dep[N], son[N], fa[N], tp[N], sz[N], dfn[N];</span><br><span class="line"><span class="keyword">int</span> lnk[N], nxt[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line">ll mn[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; v[x].push_back(y); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    fa[x] = father;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    dep[x] = dep[father] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == father) <span class="keyword">continue</span>;</span><br><span class="line">        mn[y] = min(mn[x], (ll)val[i]);</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; sz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    tp[x] = top;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tp[x] != tp[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[tp[x]] &lt; dep[tp[y]]) swap(x, y);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">1</span>) &#123; stk[++top] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (lca == stk[top]) <span class="keyword">return</span>;  <span class="comment">// 直接 return 的原因是 一条链上只要存除根结点以外最上面的那个点！！！</span></span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top - <span class="number">1</span>]] &gt;= dfn[lca])</span><br><span class="line">        addedge(stk[top - <span class="number">1</span>], stk[top]), --top;</span><br><span class="line">    <span class="keyword">if</span> (lca != stk[top])</span><br><span class="line">        addedge(lca, stk[top]), stk[top] = lca;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[x].size() == <span class="number">0</span>) <span class="keyword">return</span> mn[x];</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        sum += DP(v[x][i]);</span><br><span class="line">    v[x].clear();</span><br><span class="line">    <span class="keyword">return</span> min(mn[x], sum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    mn[<span class="number">1</span>] = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">        stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) insert(a[i]);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            addedge(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, DP(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HEOI2014-大工程"><a href="#HEOI2014-大工程" class="headerlink" title="[HEOI2014]-大工程"></a>[HEOI2014]-大工程</h3><hr><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3611" target="_blank" rel="noopener">传送门</a></p><p>树形DP。一开始的思路是 求代价 sigma(边ab的val ✖️ a子树中选中节点数 ✖️ b子树中选中节点数)，这样应该也可以？。看 hzwer 求代价和的方法是不断合并，设 f[x] 表示在遍历 y 子树前遍历的选中节点到 x 的距离和，反正搞一搞就出来了。最大最小代价也挺好求的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bzoj_3611</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, Q, idx, top;</span><br><span class="line">ll sz[N], son[N], fa[N], tp[N], id[N], dep[N];</span><br><span class="line">ll h[N], v[N], stk[N], siz[N], f[N], mn[N], mx[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], val[N];</span><br><span class="line">ll tot, ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    fa[x] = fat;</span><br><span class="line">    dep[x] = dep[fat] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fat) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; sz[y])</span><br><span class="line">            mx = sz[y], son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    id[x] = ++idx;</span><br><span class="line">    tp[x] = rt;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x], rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> id[a] &lt; id[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    val[x].push_back(dep[y] - dep[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tp[x] != tp[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[tp[x]] &lt; dep[tp[y]]) swap(x, y);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (lca == stk[top]) &#123; stk[++top] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; id[stk[top - <span class="number">1</span>]] &gt;= id[lca])</span><br><span class="line">        addedge(stk[top - <span class="number">1</span>], stk[top]), --top;</span><br><span class="line">    <span class="keyword">if</span> (lca != stk[top])</span><br><span class="line">        addedge(lca, stk[top]), stk[top] = lca;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    siz[x] = v[x];</span><br><span class="line">    mn[x] = v[x] ? <span class="number">0</span> : inf;</span><br><span class="line">    mx[x] = v[x] ? <span class="number">0</span> : -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i], z = val[x][i];</span><br><span class="line">        dfs(y);</span><br><span class="line">        tot += (f[x] + siz[x] * z) * siz[y] + f[y] * siz[x];</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[x] += f[y] + siz[y] * z;</span><br><span class="line">        ans1 = min(ans1, mn[x] + mn[y] + z);</span><br><span class="line">        ans2 = max(ans2, mx[x] + mx[y] + z);</span><br><span class="line">        mn[x] = min(mn[x], mn[y] + z);</span><br><span class="line">        mx[x] = max(mx[x], mx[y] + z);</span><br><span class="line">    &#125;</span><br><span class="line">    g[x].clear(), val[x].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">cin</span> &gt;&gt; h[i], v[h[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"0 0 0"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        sort(h + <span class="number">1</span>, h + k + <span class="number">1</span>, cmp);</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!v[<span class="number">1</span>]) stk[++top] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) insert(h[i]);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            addedge(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">0</span>, ans1 = inf, ans2 = -inf;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld\n"</span>, tot, ans1, ans2);</span><br><span class="line">        rep(i, <span class="number">1</span>, k) v[h[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HNOI2014-世界树"><a href="#HNOI2014-世界树" class="headerlink" title="[HNOI2014]-世界树"></a>[HNOI2014]-世界树</h3><hr><p><a href="https://www.luogu.com.cn/problem/P3233" target="_blank" rel="noopener">传送门</a></p><p><a href="http://hzwer.com/6804.html" target="_blank" rel="noopener">hzwer大神写得好</a></p><p>真的，太难调了orz。。。两遍 dfs 求出每个虚树上的点对应的管理点，虚树上每条边 ab 对应在树上的区域涵盖的点，它们的管理点不是 a 的管理点就是 b 的管理点。确定范围，其实可以倍增跳到 ab 的中点。size 的加加减减要注意，很容易出错 ಥ_ಥ</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], Q, k, m[N], b[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">22</span>], dfn[N], idx, dep[N], sz[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, q[N], id, ans[N], bel[N], siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">        f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[LCA(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = b, mid = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt; dep[a]) x = f[x][i];</span><br><span class="line">    siz[a] -= sz[x];</span><br><span class="line">    <span class="keyword">if</span> (bel[a] == bel[b]) &#123; ans[bel[a]] += sz[x] - sz[b]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = f[mid][i];</span><br><span class="line">        <span class="keyword">if</span> (dep[tmp] &lt;= dep[a]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[a], tmp), t2 = dis(bel[b], tmp);</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt; t2 || (t1 == t2 &amp;&amp; bel[b] &lt; bel[a])) mid = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[bel[a]] += sz[x] - sz[mid];</span><br><span class="line">    ans[bel[b]] += sz[mid] - sz[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++id] = x;</span><br><span class="line">    siz[x] = sz[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        dfs1(y);</span><br><span class="line">        <span class="keyword">if</span> (!bel[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[y], x), t2 = dis(bel[x], x);</span><br><span class="line">        <span class="keyword">if</span> ((t1 == t2 &amp;&amp; bel[y] &lt; bel[x]) || t1 &lt; t2 || !bel[x])</span><br><span class="line">            bel[x] = bel[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[x], y), t2 = dis(bel[y], y);</span><br><span class="line">        <span class="keyword">if</span> ((t1 == t2 &amp;&amp; bel[y] &gt; bel[x]) || t1 &lt; t2 || !bel[y])</span><br><span class="line">            bel[y] = bel[x];</span><br><span class="line">        dfs2(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(m + <span class="number">1</span>, m + k + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">if</span> (bel[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = m[i], lca = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!top) &#123; stk[++top] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        lca = LCA(stk[top], x);</span><br><span class="line">        <span class="keyword">if</span> (lca == stk[top]) &#123; stk[++top] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top - <span class="number">1</span>]] &gt;= dfn[lca]) &#123;</span><br><span class="line">            add(stk[top - <span class="number">1</span>], stk[top]); top--;  <span class="comment">// 不能写 stk[top--], 不然会 WA。。。不知道为啥</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lca != stk[top]) &#123;</span><br><span class="line">            add(lca, stk[top]); stk[top] = lca;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span>) add(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        top = id = cnt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m[i]), b[i] = m[i], bel[m[i]] = m[i];</span><br><span class="line">        build();</span><br><span class="line"></span><br><span class="line">        dfs1(<span class="number">1</span>), dfs2(<span class="number">1</span>);</span><br><span class="line">        rep(o, <span class="number">1</span>, id)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[q[o]]; i; i = nxt[i])</span><br><span class="line">                solve(q[o], to[i]);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, id)</span><br><span class="line">            ans[bel[q[i]]] += siz[q[i]];</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[b[i]]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, id)</span><br><span class="line">            ans[q[i]] = bel[q[i]] = siz[q[i]] = lnk[q[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2149]-Snuke&#39;s Coloring 2</title>
      <link href="2020/01/13/%5BAT2149%5D-Snuke&#39;s%20Coloring%202/"/>
      <url>2020/01/13/%5BAT2149%5D-Snuke&#39;s%20Coloring%202/</url>
      
        <content type="html"><![CDATA[<p>ARC 的 D 啊这是！！！毒瘤 qwq。。不过挺有意思的</p><p><a href="https://vjudge.net/problem/AtCoder-2149" target="_blank" rel="noopener">传送门！飞</a></p><p><a href="https://www.cnblogs.com/coco-night/p/9677691.html" target="_blank" rel="noopener">这位dalao说得好，我若讲不清楚可看ta的！</a></p><p>首先，一切的一切之前！要先公布一个性质。。（什么时候才能自己找啊qwq），就是这个矩形周长一定大于等于 $2 <em> max(w, h) + 2$, 那么这个矩形<em>*一定</em></em>过 $x = \frac{w}{2}$ 或 $y = \frac{h}{2}$ 中的一条，接下来以后者为例。（别忘记做完后将图翻转再做一次前者）</p><p>有了<strong>过中线</strong>的保证，我们就可以把点分成中线上下两部分处理。</p><p>找！定！量！这个定量就是一条竖着的扫描线，身份是矩形的右边界。。$O(n ^ 2)$的朴素算法就是从右边界往左扫，单调栈维护<strong>最</strong>值。考虑如何优化。</p><p>用线段树<strong>帮助</strong>维护扫描线左边（即扫过区域）每个点所在直线为左边界时的最大矩形周长，加加减减具体可看 dalao 博客链接，其核心就是线段的和差。。显然是可以维护的！！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (long long i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> w, h, n, ans;</span><br><span class="line"><span class="keyword">int</span> tag[N &lt;&lt; <span class="number">2</span>], mx[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">pii p[N], a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span>] += tag[x];</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x];</span><br><span class="line">        mx[x &lt;&lt; <span class="number">1</span>] += tag[x];</span><br><span class="line">        mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x];</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rx &lt; l || r &lt; lx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        tag[x] += val, mx[x] += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    update(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    mx[x] = max(mx[x &lt;&lt; <span class="number">1</span>], mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx, <span class="number">0</span>, <span class="keyword">sizeof</span>(mx));</span><br><span class="line">    <span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="keyword">sizeof</span>(tag));</span><br><span class="line"></span><br><span class="line">    sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].y &lt;= h / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &amp;&amp; p[i].y &gt; a[l].y) &#123;</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, a[l].x, nxt, a[l].y - p[i].y);</span><br><span class="line">                nxt = a[l].x - <span class="number">1</span>;</span><br><span class="line">                --l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt != i - <span class="number">1</span>) a[++l] = make_pair(nxt + <span class="number">1</span>, p[i].y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r &amp;&amp; p[i].y &lt; b[r].y) &#123;</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, b[r].x, nxt, p[i].y - b[r].y);</span><br><span class="line">                nxt = b[r].x - <span class="number">1</span>;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt != i - <span class="number">1</span>) b[++r] = make_pair(nxt + <span class="number">1</span>, p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        a[++l] = make_pair(i, <span class="number">0</span>);</span><br><span class="line">        b[++r] = make_pair(i, h);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, i, i, h - p[i].x);</span><br><span class="line">        ans = max(ans, p[i + <span class="number">1</span>].x + mx[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; h &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    p[++n] = make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    p[++n] = make_pair(w, h);</span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) swap(p[i].x, p[i].y);  <span class="comment">// 翻转</span></span><br><span class="line">    swap(w, h);</span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我发现做题找定量是非常重要的！本题的精髓就在于找定量。上次 usaco 12月月赛 T1 也是找定量，这个真的很有用哇！</p><p>（一上来看到矩形肯定头都大啦，哪知道定量是啥啊。。</p><p>反正这题 <strong>性质</strong> 和 <strong>定量思想</strong> 缺一不可啊。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco19Dec (Gold)</title>
      <link href="2019/12/21/Usaco19Dec%20(Gold)/"/>
      <url>2019/12/21/Usaco19Dec%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.usaco.org/index.php?page=dec19results" target="_blank" rel="noopener">传送门</a></p><p>Usaco Gold round 第一次！！做出了 T1，个人感觉 usaco 题目质量十分的高啊~ 都不是毒瘤题，但本人过于菜鸡了 qaq</p><h3 id="A-Milk-Pumping"><a href="#A-Milk-Pumping" class="headerlink" title="A. Milk Pumping"></a>A. Milk Pumping</h3><hr><p>一句话题解：最短路变形。</p><p>以前好像做过类似的。只要按照边的流量从大到小排序，一一加边，每加一次跑一遍最短路即可！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dis[N], inq[N], ansx, ansy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, c, f; &#125;e[N];</span><br><span class="line">ll cur;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; nxt[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.f &gt; b.f; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">            edge now = nxt[x][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[now.y] &gt; dis[x] + now.c) &#123;</span><br><span class="line">                dis[now.y] = dis[x] + now.c;</span><br><span class="line">                <span class="keyword">if</span> (!inq[now.y]) inq[now.y] = <span class="number">1</span>, q.push(now.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"pump.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pump.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].c, &amp;e[i].f);</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    cur = <span class="number">-1e18</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        nxt[e[i].x].push_back(e[i]);</span><br><span class="line">        swap(e[i].x, e[i].y);</span><br><span class="line">        nxt[e[i].x].push_back(e[i]);</span><br><span class="line">        spfa();</span><br><span class="line">        <span class="keyword">if</span> (dis[n] != inf)</span><br><span class="line">            cur = max(cur, (<span class="number">1l</span>l * <span class="number">1000000</span> * e[i].f / dis[n]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Milk-Visits"><a href="#B-Milk-Visits" class="headerlink" title="B. Milk Visits"></a>B. Milk Visits</h3><hr><p>很妙的题！首先把询问离线。对于 (x, y, c) 这组询问（设 lca(x, y) = L）显然可以分解为 x ~ L 这段和 y ~ L 这段。</p><p>dfs。用栈 (实际操作可用vector) 储存经过的点的颜色和点的位置（实际操作储存深度），到达点 x 时看看栈中是否有 c 颜色的，以及离 x 最近的（深度最大的）点是不是 L 的祖先，如果不是，(x, y, c) 这个询问的答案就是 1.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, col[N], id[N][<span class="number">2</span>], c[N], cur, ok[N];</span><br><span class="line">pii range[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; stor[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; todo[N], v[N], ord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    range[x].fi = ++cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (v[x][i] != fa) pre(v[x][i], x);</span><br><span class="line">    range[x].se = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">anc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// is_ancestor ?</span></span><br><span class="line">    <span class="keyword">return</span> (range[x].fi &lt;= range[y].fi &amp;&amp; range[y].se &lt;= range[x].se);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    stor[col[x]].push_back(make_pair(x, ord.size()));</span><br><span class="line">    ord.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt; todo[x].size(); o++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = todo[x][o];</span><br><span class="line">        <span class="keyword">if</span> (stor[c[i]].size()) &#123;</span><br><span class="line">            pii y = stor[c[i]].back();</span><br><span class="line">            <span class="keyword">if</span> (y.fi == x) ok[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> son = ord[y.se + <span class="number">1</span>];  <span class="comment">// 下一个 (想想为什么)</span></span><br><span class="line">    <span class="comment">// x is one of endpoints for query t</span></span><br><span class="line">                <span class="keyword">if</span> (!anc(son, id[i][<span class="number">0</span>] + id[i][<span class="number">1</span>] - x)) ok[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (v[x][i] != fa) dfs(v[x][i], x);</span><br><span class="line">    stor[col[x]].pop_back();</span><br><span class="line">    ord.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"milkvisits.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"milkvisits.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        v[x].push_back(y), v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pre(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;id[i][<span class="number">0</span>], &amp;id[i][<span class="number">1</span>], &amp;c[i]);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">1</span>) todo[id[i][j]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ok[i] ? <span class="number">1</span> : <span class="number">0</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Moortal-Cowmbat"><a href="#C-Moortal-Cowmbat" class="headerlink" title="C. Moortal Cowmbat"></a>C. Moortal Cowmbat</h3><hr><p>DP 大法好….</p><p>DP 还是弱啊。。其实不是很难</p><p>首先跑一遍 Floyd！。设 f[i] 表示前 i 个合法的最小值。</p><p>f[i] = min(f[j] + calc(j + 1, i, c)) (j &lt;= i - k)，其中 calc(l, r, c) 表示区间 [l, r] 全变为 c 的价值和。</p><p>发现每次只加进去 i - k 的贡献。用 mn[j] 数组维护当前取 j 颜色且合法的最小值，O(1)。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>][<span class="number">30</span>], cost[N][<span class="number">30</span>], mn[N], f[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> cost[r][c] - cost[l - <span class="number">1</span>][c]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cowmbat.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"cowmbat.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    --m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, m)</span><br><span class="line">        rep(j, <span class="number">0</span>, m)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line">    rep(k, <span class="number">0</span>, m)</span><br><span class="line">        rep(i, <span class="number">0</span>, m)</span><br><span class="line">            rep(j, <span class="number">0</span>, m)</span><br><span class="line">                c[i][j] = min(c[i][j], c[i][k] + c[k][j]);</span><br><span class="line">    rep(i, <span class="number">0</span>, m)</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            cost[j][i] = cost[j - <span class="number">1</span>][i] + c[s[j] - <span class="string">'a'</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, K, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, m) &#123;</span><br><span class="line">            mn[j] = min(mn[j] + c[s[i] - <span class="string">'a'</span>][j], f[i - K] + calc(i - K + <span class="number">1</span>, i, j));  <span class="comment">// mn[j] 表示当前 i 位置为 j 时的最小花费</span></span><br><span class="line">            f[i] = min(f[i], mn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要多打比赛！等考完 看我不屠它个百来道题 (♯｀∧´) 哼</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019前的做题记录 &amp; 每日小结</title>
      <link href="2019/11/16/CSP2019%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95&amp;%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
      <url>2019/11/16/CSP2019%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95&amp;%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这里是 CSP2019 前的做题记录 &amp; 每日小结！</p><p>每天计划如下：</p><ol><li>订正monisai！</li><li>ATC一套（2 ~ 3道）</li><li>随即开题 &gt;= 3 道</li><li>算法针对 &gt;= 3 道</li><li>博客总结</li><li>博客回顾 &gt;= 10 篇</li><li>后期安排 NOIp 真题体验</li></ol><p>日拱一卒无有尽，功不唐捐终入海！加油加油~</p><h2 id="——"><a href="#——" class="headerlink" title="——-"></a>——-</h2><hr><h3 id="10-29"><a href="#10-29" class="headerlink" title="10.29"></a>10.29</h3><ul><li>⚠️monisai T2 模数有一重没加，全wa丢40+。。</li></ul><p>luogu3586, agc037C, abc144D+E+F, bzoj1016</p><h3 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h3><ul><li>⚠️monisai T1 无向边建成有向的了凉凉。。（奇怪，以前从来不犯的错误啊 o(╥﹏╥)o</li></ul><p>luogu3317, luogu1131, luogu1879</p><h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><p>abc137E, bzoj4805, bzoj2005, bzoj2671, luogu2219, luogu2569, luogu2709</p><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><ul><li>⚠️用着可以 O(n^2 + Q) 的部分分写法，写了 O(n^2 + Qn) 的。。虽然也不会太凉，但是正式比赛一定要小心啊！（别想出正解写了暴力就是了qwq</li></ul><p>luogu3172, luogu3830, luogu2613, bzoj1531</p><h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><ul><li>今日份快乐：monisai烤了10.17日的模拟赛T3，然鹅我并没订正过这道清真的斜率优化。。然后我调出来了，耶。</li><li>形如 a = b 的东西可以化成 a - b = 0, 也许可以用数据结构维护呢。</li><li>⚠️monisai T1 矩阵加速丢 30 pts，原来是 ll 类型的 n 被我用 %d 输入了。。。检查 long long 🈶️🈚️开不只是检查定义处，还有输入输出处哇。。。两个字母三十分 o(╥﹏╥)o 超贵</li></ul><p>luogu2915, luogu2150</p><h3 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h3><ul><li>今日份快乐：在家休息哦！补觉啦【快快乐乐】然后复习了dp！</li></ul><p>bzoj1037, bzoj1042, bzoj1084, bzoj2431, bzoj1190</p><h3 id="11-4"><a href="#11-4" class="headerlink" title="11.4"></a>11.4</h3><ul><li>今天早上音乐抽到我了，，于是就没有去训练，在家 vp 了 CF round 597 (Div2)</li></ul><p>bzoj1833</p><h3 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h3><ul><li>⚠️今！天！又！爆！int！了！下次用 <code>#define ing long long</code> 吧</li><li>T2 可以 AC 的。。vector 定义成 int 类型了，爆了，什么都不想说了，T2 没有了还活个什么劲啊</li><li>以下是一些牢骚：诶为什么人家 fst 都是小 f 啊，就我是大 f ？一次 f 100 的那种？水逆特别眷顾我吗 qaq… 要么脑子少一块了🧠</li></ul><p>cf997e, bzoj3209, luogu4999</p><h3 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h3><p>对于二分图：</p><ul><li>最小点覆盖 = 最大匹配</li><li>最大独立集 = 最小边覆盖 = 顶点数 - 最小点覆盖（最大匹配）</li></ul><p>对于DAG：</p><ul><li>最小不相交路径覆盖 = 原图顶点数 - 转为二分图后的最大匹配数</li><li>最小可相交路径覆盖 转化转化能变成上面那个。转化方法：用 floyd 求出原图传递闭包，如果 a 到 b 有路径，就加边 a-&gt; b, 就行了。（这样就不用经过中间点了，如果经过中间点有可能会与其它路径相交。）</li></ul><p>概念：</p><ul><li>最大匹配：二分图中边集的数目最大的那个匹配；</li><li>最小点覆盖：用最少的点，让每条边都至少和其中一个点关联；</li><li>最小边覆盖：用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点；</li><li>最大独立集：在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边的点中，m的最大值。</li></ul><p>bzoj1082, bzoj1179</p><h3 id="11-7"><a href="#11-7" class="headerlink" title="11.7"></a>11.7</h3><p>bzoj1143, bzoj3175, bzoj2783, bzoj3190</p><h3 id="11-8"><a href="#11-8" class="headerlink" title="11.8"></a>11.8</h3><ul><li>⚠️给 trick 坑了！（这算 trick 吗）：对于每个质因数 p，将所有能被它分解的 a[i] 提到 vector 里。这样处理每个 p 就只会用到 vector 里的 a[i] 了。每个 a[i] 最多被提 sqrt(a[i]) 次（其实远远达不到），复杂度就由 O(质数个数 ✖️n) 变为 O(n ✖️根号n) 了（哭倒。。。</li></ul><p>agc036A</p><h3 id="11-9"><a href="#11-9" class="headerlink" title="11.9"></a>11.9</h3><ul><li>⚠️T2 想打的部分分没写出来，提交时还没删掉那部分程序，居然 CE 了。。30 分啊。。唯一一次能比 xyr 高的机会。。。被我自己作没了。。。。 </li></ul><p>agc036B, bzoj1027, </p><h3 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h3><ul><li>打了 xj 的一场模拟赛 + ez dalao 出的一场 comet。感想：bitset 真是个好东西 + 我好菜啊qwq</li></ul><h3 id="11-11"><a href="#11-11" class="headerlink" title="11.11"></a>11.11</h3><ul><li>双十一块乐！</li></ul><p>bzoj1027, luogu2680, 然后切了一些历年真题的水题啦</p><h3 id="11-12"><a href="#11-12" class="headerlink" title="11.12"></a>11.12</h3><ul><li>⚠️每日一fst：二分要注意答案是否有机会为 0 或有可能超过 int 范围！</li><li>今日份块乐：有生之年订完了monisai（其实不是第一回qwq）220pts信心赛可 🌊🌟</li></ul><p>bzoj1295, luogu3960</p><h3 id="11-13"><a href="#11-13" class="headerlink" title="11.13"></a>11.13</h3><ul><li>调代码的时候被一些 傻【数据删除】手误给坑了一个多小时。。ㆁᴗㆁ绝了</li><li>判断一些东西的时候可以借用另一些比较有用的有特征的东西（我在说什么啊），比如 tarjan 题就离不开 dfn 和 low。</li></ul><p>luogu1600, loj114, luogu2827, </p><h3 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h3><ul><li>今日份加倍快乐：monisai登顶，有生之年系列（其实只是 1 pts 都没 fst 而已 qwq</li><li>后天的 CSP 信心瞬间加满！CSP 2019 RP += (inf) ^ {inf} !!!</li><li>CSP 时要仔细啊，别 fst 了！</li><li>读完题后一定会懵的，此时不妨写写画画，模拟一些小样例，说不定就看破出题人的意思了。</li></ul><p>luogu2679, luogu1155, bzoj1823, bzoj1718</p><h3 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h3><p>bzoj1305, bzoj2424, bzoj1923, </p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF997E]-Good Subsegments</title>
      <link href="2019/11/05/%5BCF997E%5D-Good%20Subsegments/"/>
      <url>2019/11/05/%5BCF997E%5D-Good%20Subsegments/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/997/problem/E" target="_blank" rel="noopener">传送门</a></p><p>这题太神了！！真是好题！！！</p><p>显然：区间 $[l, r]$ 是好的，当且仅当 $(Max - Min) - (r - l) = 0$.</p><p>我们可以将询问区间按右端点从小到大排序，依次作为“当前的右端点”。</p><p>于是我们维护每个位置到“当前右端点”的 $(Max - Min) - (r - l)$，维护它们的最小值和最小值个数。</p><p>重要的 trick：一个区间 $[l, r]$ 所有子区间的答案可以随着“当前右端点” $r0$ 的增加而实时统计，累加 $query(l, r0)$.</p><p>仅仅这样做，线段树操作后存储的就只是当前的答案，所以我们还需要用标记，每次 $psd$ 的时候为线段树累加上前一次的答案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120010</span>;</span><br><span class="line"><span class="keyword">int</span> n, Q, a[N], s1[N], s2[N], top1, top2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> r &lt; x.r; &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> tag[N &lt;&lt; <span class="number">2</span>], tg[N &lt;&lt; <span class="number">2</span>], mn[N &lt;&lt; <span class="number">2</span>], t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">ll sum[N &lt;&lt; <span class="number">2</span>], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    mn[x] = l;  <span class="comment">// at first: (mx - mn) - (r - l) = 0 - (0 - l) = l</span></span><br><span class="line">    t[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls, l, mid), build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[x] = min(mn[ls], mn[rs]);</span><br><span class="line">    t[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    t[x] = (mn[x] == mn[ls] ? t[x] + t[ls] : t[x]);</span><br><span class="line">    t[x] = (mn[x] == mn[rs] ? t[x] + t[rs] : t[x]);</span><br><span class="line"></span><br><span class="line">    sum[x] = sum[ls] + sum[rs];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        mn[ls] += tag[x], mn[rs] += tag[x];</span><br><span class="line">        tag[ls] += tag[x], tag[rs] += tag[x];</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tg[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mn[x] == mn[ls])</span><br><span class="line">            sum[ls] += <span class="number">1l</span>l * t[ls] * tg[x], tg[ls] += tg[x];</span><br><span class="line">        <span class="keyword">if</span> (mn[x] == mn[rs])</span><br><span class="line">            sum[rs] += <span class="number">1l</span>l * t[rs] * tg[x], tg[rs] += tg[x];</span><br><span class="line">        tg[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        mn[x] += val; tag[x] += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(ls, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(rs, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> sum[x];</span><br><span class="line">    psd(x);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) ret = query(ls, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) ret += query(rs, mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    rep(tr, <span class="number">1</span>, n) &#123;</span><br><span class="line">        mn[<span class="number">1</span>]--, tag[<span class="number">1</span>]--;  <span class="comment">// 随着 r 的增加，最小值减小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top1 &amp;&amp; a[s1[top1]] &gt; a[tr])</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, s1[top1 - <span class="number">1</span>] + <span class="number">1</span>, s1[top1], a[s1[top1]] - a[tr]), --top1;</span><br><span class="line">        s1[++top1] = tr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top2 &amp;&amp; a[s2[top2]] &lt; a[tr])</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, s2[top2 - <span class="number">1</span>] + <span class="number">1</span>, s2[top2], a[tr] - a[s2[top2]]), --top2;</span><br><span class="line">        s2[++top2] = tr;</span><br><span class="line"></span><br><span class="line">        sum[<span class="number">1</span>] += t[<span class="number">1</span>], tg[<span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= Q &amp;&amp; q[pos].r == tr) &#123;</span><br><span class="line">            ans[q[pos].id] = query(<span class="number">1</span>, <span class="number">1</span>, n, q[pos].l, tr);</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 144</title>
      <link href="2019/10/30/Atcoder%20Beginner%20Contest%20144/"/>
      <url>2019/10/30/Atcoder%20Beginner%20Contest%20144/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc144" target="_blank" rel="noopener">传送门</a></p><h3 id="D-Water-Bottle"><a href="#D-Water-Bottle" class="headerlink" title="D - Water Bottle"></a>D - Water Bottle</h3><hr><p>分类讨论 + 三角函数</p><p>正切是我们平时说的直线的斜率，反正切（c++中的atan函数）的意义大概是这样的：若 A 为角，tanA = x / y, 则 A = arctan x / y. 而 c++ 中计算使用的是弧度制，所得的要转化为角度，还需乘以 180 / PI.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535897923</span>;</span><br><span class="line"><span class="keyword">double</span> a, b, x, v, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">    v = a * a * b;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= v / <span class="number">2</span>) &#123;</span><br><span class="line">        t = <span class="number">2</span> * (v - x) / (a * a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, <span class="built_in">atan</span>(t / a) * <span class="number">180</span> / PI);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = <span class="number">2</span> * x / a / b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, <span class="number">90</span> - <span class="built_in">atan</span>(t / b) * <span class="number">180</span> / PI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Gluttony"><a href="#E-Gluttony" class="headerlink" title="E - Gluttony"></a>E - Gluttony</h3><hr><p>贪心 + 二分</p><p>根据贪心策略很容易想到：将 A 从小到大排，F 从大到小排，Ai 与 Fi 配。然后本题的实质就变成了“最大值最小”，二分妥妥的！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, K, a[N], f[N], l, r, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll lim)</span> </span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        cnt += max(<span class="number">0l</span>l, a[i] - lim / f[i]);</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;f[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    sort(f + <span class="number">1</span>, f + n + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) r = max(r, a[i] * f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值最小！最大值最小！最大值最小！重要的事情汪三遍</span></span><br></pre></td></tr></table></figure></p><h3 id="F-Fork-in-the-Road"><a href="#F-Fork-in-the-Road" class="headerlink" title="F - Fork in the Road"></a>F - Fork in the Road</h3><hr><p>一开始思路是枚举断边，每次拓扑一遍计算 f[x] 表示 x 到 n 的期望步数，这样复杂度是 $O(m(n + m))$ 的，不太ok。</p><p>注意到 m 挺大，n 比较小，我们可以枚举断哪个点 x 周围的边（假设该边连接 x 和 y，必然断的是 f[y] 最大的边），复杂度是 $O(n(n+m))$ 的，可以切了此题。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// si &lt; ti !!! si &lt; ti !!! si &lt; ti !!! 条件还能漏的啊？你眼睛呢？？！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">605</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = (<span class="keyword">double</span>)<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sons;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">double</span> ans, f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> s, t; &#125;e[N * N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = n - <span class="number">1</span>; x &gt;= <span class="number">1</span>; x--) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nxt[x].size();</span><br><span class="line">        <span class="keyword">if</span> (pos == x &amp;&amp; num == <span class="number">1</span>) &#123; f[x] = inf; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1.0</span> / (num - (pos == x)), mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">            f[x] += (f[y] + <span class="number">1</span>) * t;</span><br><span class="line">            mx = max(mx, (f[y] + <span class="number">1</span>) * t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == x) f[x] -= mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;e[i].s, &amp;e[i].t);</span><br><span class="line">        nxt[e[i].s].push_back(e[i].t);</span><br><span class="line">        <span class="keyword">if</span> (e[i].s == <span class="number">1</span>) sons++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = calc(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = min(ans, calc(i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2015]-LOG</title>
      <link href="2019/10/29/%5BPOI2015%5D-LOG/"/>
      <url>2019/10/29/%5BPOI2015%5D-LOG/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P3586" target="_blank" rel="noopener">传送门</a></p><p>“每次选 $a$ 个正数并将它们都减去 $1$，判断能否进行 $s$ 次操作” 这一类题有个小技巧：</p><blockquote><p>设大于等于 $s$ 有 $x$ 个，判定就转化为 $[ x <em> s + (小于 s 的数字之和) &gt;= a </em> s ]$</p></blockquote><p>用树状数组要对 $s$ 离散化即可。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, C[N], cnt[N], a[N], h[N &lt;&lt; <span class="number">1</span>], num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">char</span> opt; ll x, y; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += lowbit(x)) C[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += lowbit(x)) cnt[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += cnt[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    ll x = ask1(num) - ask1(s - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> x * h[s] + ask2(s - <span class="number">1</span>) &gt;= <span class="number">1l</span>l * c * h[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].opt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        h[++num] = q[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    h[++num] = <span class="number">0</span>;</span><br><span class="line">    sort(h + <span class="number">1</span>, h + num + <span class="number">1</span>);</span><br><span class="line">    num = unique(h + <span class="number">1</span>, h + num + <span class="number">1</span>) - h - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        q[i].y = lower_bound(h + <span class="number">1</span>, h + num + <span class="number">1</span>, q[i].y) - h;</span><br><span class="line">    </span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch; <span class="keyword">int</span> x, y;</span><br><span class="line">        ch = q[i].opt, x = q[i].x, y = q[i].y;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x])</span><br><span class="line">                add1(a[x], <span class="number">-1</span>), add2(a[x], -h[a[x]]);</span><br><span class="line">            a[x] = y;</span><br><span class="line">            add1(a[x], <span class="number">1</span>);</span><br><span class="line">            add2(a[x], h[a[x]]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(calc(x, y) ? <span class="string">"TAK"</span> : <span class="string">"NIE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的题目还有 <a href="https://atcoder.jp/contests/abc143/tasks/abc143_f" target="_blank" rel="noopener">ATC143F - Distinct Numbers</a>, 只是将 $s$ 替换为二分值 $mid$ 了。二分做法复杂度是 $O(nlog^2n)$, 但这里是利用答案单调性的 $O(n)$ 做法（容易发现，随着 $K$ 的减小，答案只会增加不会减少），然后前缀的预处理还是非常神仙的（从网上贺来的qwq），实在不懂可以模拟输出中间过程（其实也不难理解）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, x, a[N], K, cnt[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll k, ll x)</span> </span>&#123; <span class="keyword">return</span> sum[x] &gt;= k * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; x, ++sum[++cnt[x]];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (now &lt; n &amp;&amp; chk(k, now + <span class="number">1</span>)) ++now;</span><br><span class="line">        ans[k] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[LG4551]-最长异或路径</title>
      <link href="2019/10/12/%5Bluogu4551%5D-%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/"/>
      <url>2019/10/12/%5Bluogu4551%5D-%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P4551" target="_blank" rel="noopener">传送门</a></p><p>【 新技能get√￣ 】</p><p>首先有个很重要的常识：$x$ 到 $y$ 的异或值为 $x$ 到根的异或值异或上 $y$ 到根的异或值。其正确性显然。</p><p>那么题目就变为：选两个点，使得它们的异或值异或起来最大。</p><p>（我居然还想到线性基了。。智商不行呀，不是什么异或都是线性基的，线性基是多个异或，不是两个异或。。</p><p>重点来了：$01$ 字典树是处理异或问题的利器，对于一个值 $x$，为了使它与另一个值 $y$ 异或后最大，根据贪心的思想，显然尽量使它们的二进制最高位不同，然后次高位不同…blabla</p><p>那么把所有节点到根结点的异或值建成一棵 $01$ 字典树就行啦。复杂度 $O(NlogV)$</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, dis[N], ch[<span class="number">31</span> * N][<span class="number">2</span>], idx, mark[<span class="number">31</span> * N], ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    nxt[x].push_back(y), val[x].push_back(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[y] = dis[x] ^ val[x][i];</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ch[u][c]) ch[u][c] = ++idx;</span><br><span class="line">        u = ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    mark[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (((x &gt;&gt; i) &amp; <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch[u][c]) u = ch[u][c], ret += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="keyword">else</span> u = ch[u][c ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) insert(dis[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = max(ans, query(dis[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Grand Contest 038</title>
      <link href="2019/10/09/Atcoder%20Grand%20Contest%20038/"/>
      <url>2019/10/09/Atcoder%20Grand%20Contest%20038/</url>
      
        <content type="html"><![CDATA[<h3 id="A-01-Matrix"><a href="#A-01-Matrix" class="headerlink" title="A - 01 Matrix"></a>A - 01 Matrix</h3><hr><p>想了一会儿。。qwq</p><p>显然，令 mp[1 ~ b, 1 ~ a] = 1, mp[b + 1 ~ n, a + 1 ~ m] = 1 即可。</p><h3 id="B-Sorting-a-Segment"><a href="#B-Sorting-a-Segment" class="headerlink" title="B - Sorting a Segment"></a>B - Sorting a Segment</h3><hr><p>我们发现，若排序 (l1, r1) 得到的序列与排序 (l2, r2) 得到的序列相同(r1 &lt; l2)，那么排序 (l1, r1), (l1 + 1, r1 + 1), (l1 + 2, r1 + 2) … (l2 - 1, r2 - 1), (l2, r2) 得到的序列也是相同的。</p><p>排序 (l, r) 与 (l + 1, r + 1) 得到的序列相同当且仅当在 [l, r + 1] 中，a[l] 是最小值，a[r + 1] 是最大值。这个用单调队列判断即可，最后用方案总数减去相同的方案数得出答案！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], q[N], ans, mark[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ans = n - K + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>]) b[i] = b[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= K) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &lt; i - K) ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] == i - K) mark[i]++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r]] &gt; a[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n - K + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &gt; i + K) ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] == i + K) mark[i + K]++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r]] &lt; a[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    rep(i, K, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= K) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ff) ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tot++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark[i] == <span class="number">2</span>) tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-LCMs"><a href="#C-LCMs" class="headerlink" title="C - LCMs"></a>C - LCMs</h3><hr><p>数论题！Atcoder真全</p><p>$\sum\limits_{i=1}^{n}\sum\limits_{j=i + 1}^n\frac{A_iA_j}{gcd(A_i,A_j)}$</p><p>= $\sum\limits_{d=1}^N\frac{1}{d}\sum\limits_{i=1}^n\sum\limits_{j=i+1}^nA_iA_j\sum\limits_{kd|A_i,kd|A_j}\mu(k)$</p><p>= $\sum\limits_{d=1}^N\frac{1}{d}\sum\limits_{k=1}^{N/d}\mu(k)(\sum\limits_{kd|A_i}\sum\limits_{kd|A_j}A_iA_j)$</p><p>右边这个 “()” 里的部分可以调和级数复杂度预处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (long long i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>, mod = <span class="number">998244353</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[M], inv[N + <span class="number">5</span>], bin[N + <span class="number">5</span>], ans, f[N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> mu[N + <span class="number">5</span>], prime[N + <span class="number">5</span>], tot, mark[N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            mark[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, N) inv[i] = inv[mod % i] * (mod - mod / i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prework();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i], bin[a[i]]++;  <span class="comment">// 小技巧</span></span><br><span class="line">    rep(i, <span class="number">1</span>, N) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = i; j &lt;= N; j += i) &#123;</span><br><span class="line">            sum = (sum + bin[j] * j % mod) % mod;</span><br><span class="line">            f[i] = (f[i] + j * j * bin[j] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = (sum * sum % mod - f[i] + mod) * inv[<span class="number">2</span>] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(k, <span class="number">1</span>, N)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= N; i += k) <span class="comment">// i = k * d</span></span><br><span class="line">            ans = (ans + inv[k] * mu[i / k] % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2007]-上升序列</title>
      <link href="2019/10/08/%5BHAOI2007%5D-%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97/"/>
      <url>2019/10/08/%5BHAOI2007%5D-%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2215" target="_blank" rel="noopener">传送门</a></p><p>aaaaaaaa我居然不会二分求最长上升/下降子序列！！！</p><p>所以今天涨姿势了 qaq</p><ul><li>题意划重点：字典序最小指 $x_i$ 最小。</li></ul><p>先判断下最长上升子序列长度是否 $\geq$ 询问的 $L$。</p><p>$O(nm)$ 的复杂度完全可以过，所以我们枚举 $x_i$ 看是否符合条件，若符合则立刻输出 $a_{x_i}$，保证字典序最小。</p><p>符合条件是什么意思呢？假设还剩下 $x$ 的长度没有分配，若 $x_i$ 符合要求，则 $x_i$ ~ $n$ 这段中有 $\geq x$ 个后续位置。由于是 $x_i$ ~ $n$ ，我们预处理的是下降而不是上升子序列。</p><p>大概是这样：维护最长下降子序列 $b$ 数组，对于每个 $a_i$ 二分求出 $b$ 中第一个 &gt; $a_i$ 的 $b_j$，令 $i$ 位置的后续长度为 $j + 1$.<br>同时，若 $b[j + 1] &lt; a[i]$, 则令 $b[j + 1] = a[i]$（并不会使子序列更劣，反而有可能更优，因为下降的幅度减小了嘛）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], x, b[N], f[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = tot, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &gt; x) ret = max(ret, mid), l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(a[i]);</span><br><span class="line">        f[i] = tmp + <span class="number">1</span>;</span><br><span class="line">        tot = max(tot, tmp + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (b[tmp + <span class="number">1</span>] &lt; a[i]) b[tmp + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; tot) <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; lst &amp;&amp; f[i] &gt;= x) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">                    x--;</span><br><span class="line">                    lst = a[i];</span><br><span class="line">                    <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO2009open]-干草堆tower</title>
      <link href="2019/09/25/%5BUSACO2009open%5D-%E5%B9%B2%E8%8D%89%E5%A0%86tower/"/>
      <url>2019/09/25/%5BUSACO2009open%5D-%E5%B9%B2%E8%8D%89%E5%A0%86tower/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1233" target="_blank" rel="noopener">传送门</a></p><p>是一道非常神奇的单调队列优化 DP！</p><p>首先，我们发现这题非常不好做（没有入手点，但发现可以用二维 $n^3$ DP：$f[i, j]$ 表示 $i$ ~ $j - 1$ 是 $j$ 左边的一段的最大高度。我们想想怎么优化。</p><p>zkw 大神证出，最优的方案必定底层宽度最小。大概是这样证的：有 $A$ 和 $B$ 两个塔，$A$ 的高度最大，$B$ 按从低到高的顺序的每层宽度最小。那么 $A$ 的底层宽度必然大于等于 $B$，$B$ 的高度必然小于等于 $A$。必定存在一个位置 $pos$，该位置 $A$ 的宽度小于 $B$（因为 $A$ 不可能层层都比 $B$ 宽），那么对于 $B$ 来说，只要把 $pos$ 以上的部分换成 $A$ 塔中 $pos$ 以上的部分，就能变成更优的方案。</p><p>如果从底层到顶层 DP，会发现状态不好设计（反正我没想出来qvq），而且没有单调性（比如 $n = 3$，$w = \{2, 1, 4\}$，前两个最大高度是 $2$，加入第三个就变成 $1$ 了。。），而从顶层到底层 DP 是有单调性的（自己想一想）。</p><p>设 $f[i]$ 表示该层编号最小为 $i$ 时的宽度。 $f[i] = \min\limits_{sum[j - 1] - sum[i - 1] &gt;= f[j]}\{sum[j - 1] - sum[i - 1]\}$</p><p>即 $sum[j - 1] - f[j] &gt;= sum[i - 1]$</p><p>显然只有 $sum[j - 1] - f[j] &gt;= sum[i - 1]$ 且离 $i$ 最近的 $j$ 才能转移给 $i$。维护一个 $sum[j - 1] - f[j]$ 单调递减（因为 $i$ 从 $n$ 到 $1$，$sum[i - 1]$ 是递减的）的单调队列就可以了。</p><p>山路十八弯 ~ 思维难度还是很大的！【单调队列难.jpg】</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], q[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    a[n + <span class="number">1</span>] = a[n];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    q[l] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l + <span class="number">1</span>] - <span class="number">1</span>] - f[q[l + <span class="number">1</span>]] &gt;= a[i - <span class="number">1</span>]) ++l;</span><br><span class="line">        f[i] = a[q[l] - <span class="number">1</span>] - a[i - <span class="number">1</span>];</span><br><span class="line">        g[i] = g[q[l]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r] - <span class="number">1</span>] - f[q[r]] &lt;= a[i - <span class="number">1</span>] - f[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, g[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 141</title>
      <link href="2019/09/17/Atcoder%20Beginner%20Contest%20141/"/>
      <url>2019/09/17/Atcoder%20Beginner%20Contest%20141/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc141/tasks" target="_blank" rel="noopener">传送门</a></p><p>ABC皆为水题。。。略过</p><h3 id="D-Powerful-Discount-Tickets"><a href="#D-Powerful-Discount-Tickets" class="headerlink" title="D - Powerful Discount Tickets"></a>D - Powerful Discount Tickets</h3><hr><p>a/b/c(下取整) 竟然等于 a/(bc)(下取整)。。。比赛时想到正解做法，但由于无法证明前面那句也举不出反例而不了了之了。。。</p><p>正解就是堆优化啦</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], f[N][<span class="number">2</span>];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        q.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        ans += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Who-Says-a-Pun"><a href="#E-Who-Says-a-Pun" class="headerlink" title="E - Who Says a Pun?"></a>E - Who Says a Pun?</h3><hr><p>后缀数组 + 二分经典好题（套路题），可见 POJ1743</p><h3 id="F-Xor-Sum-3"><a href="#F-Xor-Sum-3" class="headerlink" title="F - Xor Sum 3"></a>F - Xor Sum 3</h3><hr><p>一句话题意：设序列的异或值为 sum，求分两堆，一堆异或值为 res，使得 res + (sum ^ res) 最大。</p><p>一看到就觉得是线性基。。。然鹅并不会做，果然还是太弱了。。。</p><p>位运算的题十有八九要按位讨论！来一起想想，若 sum 的第 i 位为 1，那么分的两堆中必一堆为 1 一堆为 0，也就是说应忽略 i 位为 1 的位；若 i 位为 0，那么两堆中这一位的贡献是相同的，也就是说我们只要找 i 位为 0 的数的最大异或值就好啦。线性基可以胜任。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, q[<span class="number">65</span>];</span><br><span class="line">ll a[N], sum, tot, p[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; (<span class="number">1l</span>l &lt;&lt; q[i]))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p[i]) &#123; p[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">        x ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), sum ^= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!((<span class="number">1l</span>l &lt;&lt; i) &amp; sum)) q[++tot] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) insert(a[i]);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="keyword">if</span> (!(res &amp; (<span class="number">1l</span>l &lt;&lt; q[i]))) res ^= p[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res + (sum ^ res));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[WC2011]-最大XOR和路径</title>
      <link href="2019/08/18/%5BWC2011%5D-%E6%9C%80%E5%A4%A7XOR%E5%92%8C%E8%B7%AF%E5%BE%84/"/>
      <url>2019/08/18/%5BWC2011%5D-%E6%9C%80%E5%A4%A7XOR%E5%92%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P4151" target="_blank" rel="noopener">传送门</a></p><p>学了线性基、、挺友好的、、、</p><p>首先很容易得出，一个环走两遍没有意义，走过一个子树也没有意义（因为任意一条边都会走过去再走回来），所以路径可以表示为一条链 + 一些环。</p><p>我们把每一个环的 XOR 和丢进一个线性基里，答案就是链与线性基的最大异或和。</p><p>ps：链不一定要是最长链。假设有链 A 和链 B，两者构成了 1 ~ n ~ 1 的一个环，也就是这个环异或链 A 就能得到链 B。</p><p>最近有进步呀！自己都能想想了（。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, vis[N], mark[N];</span><br><span class="line">ll to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line">ll val[N &lt;&lt; <span class="number">1</span>], p[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(x &amp; (<span class="number">1l</span>l &lt;&lt; i))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!p[i]) &#123; p[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">x ^= p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> ((ret ^ p[i]) &gt; ret) ret ^= p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll res)</span> </span>&#123;</span><br><span class="line">mark[x] = res, vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) dfs(y, res ^ val[i]);</span><br><span class="line"><span class="keyword">else</span> insert(res ^ mark[y] ^ val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y; ll z; <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">addedge(x, y, z), addedge(y, x, z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(mark[n]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ARC087]-E. Prefix-free game</title>
      <link href="2019/08/10/%5BARC087%5D-E.%20Prefix-free%20game/"/>
      <url>2019/08/10/%5BARC087%5D-E.%20Prefix-free%20game/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/arc087/tasks/arc087_c" target="_blank" rel="noopener">传送门</a></p><p>很妙啊！早知道 ARC 这么启发思维的话就去做了啊 qaqaq</p><p>对字符串玩博弈好像的确不太可能，但移到字典树上就不一样了。我们发现，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 65</title>
      <link href="2019/07/30/Educational%20Codeforces%20Round%2065/"/>
      <url>2019/07/30/Educational%20Codeforces%20Round%2065/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1167" target="_blank" rel="noopener">传送门</a></p><h3 id="A-Telephone-Number"><a href="#A-Telephone-Number" class="headerlink" title="A. Telephone Number"></a>A. Telephone Number</h3><hr><p>签到题</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'8'</span>) &#123; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (n - (pos - <span class="number">1</span>) &lt; <span class="number">11</span> || !pos) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] != <span class="string">'8'</span>) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Lost-Numbers"><a href="#B-Lost-Numbers" class="headerlink" title="B. Lost Numbers"></a>B. Lost Numbers</h3><hr><p>第一次 B 题是交互诶。。</p><p>很暴力</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y, z, w, ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) <span class="keyword">if</span> (a[i] == x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 2\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 3 4\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 3\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 5\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) tot *= a[i];</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % a[i] == <span class="number">0</span> &amp;&amp; z % a[i] == <span class="number">0</span> &amp;&amp; w % a[i] == <span class="number">0</span> &amp;&amp; find(x / a[i]) &amp;&amp; find(z / a[i]) &amp;&amp; find(w / a[i])) &#123;</span><br><span class="line">            ans[<span class="number">1</span>] = a[i];</span><br><span class="line">            ans[<span class="number">2</span>] = x / a[i];</span><br><span class="line">            ans[<span class="number">3</span>] = z / a[i];</span><br><span class="line">            ans[<span class="number">4</span>] = y / ans[<span class="number">3</span>];</span><br><span class="line">            ans[<span class="number">5</span>] = w / a[i];</span><br><span class="line">            ans[<span class="number">6</span>] = tot / x / y / ans[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d %d %d\n"</span>, ans[<span class="number">1</span>], ans[<span class="number">2</span>], ans[<span class="number">3</span>], ans[<span class="number">4</span>], ans[<span class="number">5</span>], ans[<span class="number">6</span>]);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-News-Distribution"><a href="#C-News-Distribution" class="headerlink" title="C. News Distribution"></a>C. News Distribution</h3><hr><p>题目看到一半。。嗯？？冰茶姬？？？</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], fa[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y)</span><br><span class="line">        fa[x] = y, sum[y] += sum[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i, sum[i] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (lst) merge(x, lst);</span><br><span class="line">            lst = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, sum[getfa(i)]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Bicolored-RBS"><a href="#D-Bicolored-RBS" class="headerlink" title="D. Bicolored RBS"></a>D. Bicolored RBS</h3><hr><p>比较暴力的思想：维护红色和蓝色括号序列的前缀和，然后 ‘(‘ 优先给前缀和小的，’)’ 优先给前缀和大的</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) x++, ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> y++, ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) x--, ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> y--, ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Range-Deleting"><a href="#E-Range-Deleting" class="headerlink" title="E. Range Deleting"></a>E. Range Deleting</h3><hr><p>赛后补题！挺妙滴</p><p>发现，删除的区间若左区间固定，右区间呈单调性。设对于不同的左区间 l_i, 都有右区间 r_i, 则 r_1 &lt;= r_2 &lt;= … &lt;= r_n, 所以可以用二分或 two-pointers 找 r_i.</p><p>可以预处理每个 a_i 最左和最右的位置，预处理 1 ~ i 最右的位置 和 i ~ x 最左的位置，用于在查找 r_i 时判断某部分数是否呈非递减。</p><p>若区间 [l, r] 都可以删除，那么 [l, r + 1] 也可以删除，所以此时对答案产生贡献 (n - r + 1).</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, x, a[N], l[N], r[N], L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(L, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(L));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        l[a[i]] = min(l[a[i]], i);</span><br><span class="line">        r[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        L[i] = min(L[i + <span class="number">1</span>], l[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, x)</span><br><span class="line">        R[i] = max(R[i - <span class="number">1</span>], r[i]);</span><br><span class="line">    <span class="keyword">int</span> k = x;</span><br><span class="line">    <span class="keyword">for</span> (; k &gt; <span class="number">1</span> &amp;&amp; r[k] &lt;= L[k + <span class="number">1</span>]; --k);  <span class="comment">// 要删除的区间是 [1, k]</span></span><br><span class="line">    ll ans = x - k + <span class="number">1</span>;  <span class="comment">// 产生贡献</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x &amp;&amp; R[i - <span class="number">2</span>] &lt;= l[i - <span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; i || R[i - <span class="number">1</span>] &gt; L[k + <span class="number">1</span>]; ++k);  <span class="comment">// 要删除的区间是 [i, k]</span></span><br><span class="line">        ans += x - k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Scalar-Queries"><a href="#F-Scalar-Queries" class="headerlink" title="F. Scalar Queries"></a>F. Scalar Queries</h3><hr><p>因为是 vp 的，，到点儿了就要吃饭去，，抵不住十三香大虾🍤的诱惑 [捂脸] F 题只是有了初步思路，，，，，</p><p>后来是看题解的。。好题。。。</p><p>变相理解题意就是：如果 a 和 b 在一个区间 [l, r] 里且 a &lt; b, 那么就会对 f(l, r) 产生 b 的贡献（a 和 b 对 f(l, r) 的初始贡献分别是 a 和 b</p><ul><li>a[i] 和 a[j] 在一个区间的情况数 共有 $i * (n - j + 1)$ 种</li></ul><p>如果在 a[i] 的前面有个比 a[i] 小的数 a[j]，那么 a[j] 对 a[i] 系数的贡献应该等于包含 a[i] 和 a[j] 的区间数量，即 $j*(n-i+1)$</p><p>如果在 a[i] 的前面有个比 a[i] 小的数 a[j]，同上，贡献等于 $i*(n-j+1)$</p><p>所以我们现在需要维护比 a[i] 小的数的信息，那么对 a[i] 权值排序，可以用两个树状数组实现，分别维护上述两种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一点儿收获：对于这样的题，肯定要 O(n) 或 O(n <span class="built_in">log</span> n) 解决，只能数据结构出场，比如树状数组。为了保持 “值小的优先处理” 的顺序，我们需要按照值的大小排序。</span><br></pre></td></tr></table></figure><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll w, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> C[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) &#123;</span><br><span class="line">            C[x] += val;</span><br><span class="line">            <span class="keyword">if</span> (C[x] &gt;= mod) C[x] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= lowbit(x)) &#123;</span><br><span class="line">            ret += C[x];</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= mod) ret -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].w);</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll sum = a[i].id * (n - a[i].id + <span class="number">1</span>) % mod;</span><br><span class="line">        sum = (sum + l.query(a[i].id) * (n - a[i].id + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        sum = (sum + (r.query(n) - r.query(a[i].id) + mod) % mod * a[i].id % mod) % mod;</span><br><span class="line">        l.add(a[i].id, a[i].id);</span><br><span class="line">        r.add(a[i].id, n - a[i].id + <span class="number">1</span>);</span><br><span class="line">        ans = (ans + a[i].w * sum % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 561 Div2</title>
      <link href="2019/07/28/Codeforces%20Round%20561%20Div2/"/>
      <url>2019/07/28/Codeforces%20Round%20561%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1166" target="_blank" rel="noopener">传送门</a></p><h3 id="A-Silent-Classroom"><a href="#A-Silent-Classroom" class="headerlink" title="A. Silent Classroom"></a>A. Silent Classroom</h3><hr><p>签到题</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">30</span>], ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), num[s[<span class="number">1</span>] - <span class="string">'a'</span>]++;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = num[i] / <span class="number">2</span>, y = num[i] - x;</span><br><span class="line">        ans += (x * (x - <span class="number">1</span>) / <span class="number">2</span>) + (y * (y - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-All-the-Vowels-Please"><a href="#B-All-the-Vowels-Please" class="headerlink" title="B. All the Vowels Please"></a>B. All the Vowels Please</h3><hr><p>题意：每行每列都得有 a e i o u</p><p>稍微构造下就好啦</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) x = i, y = n / i;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span> || y &lt; <span class="number">5</span>) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"aeiou"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"eioua"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"e"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"iouae"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"i"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ouaei"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"o"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"uaeio"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"u"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-A-Tale-of-Two-Lands"><a href="#C-A-Tale-of-Two-Lands" class="headerlink" title="C. A Tale of Two Lands"></a>C. A Tale of Two Lands</h3><hr><p>推不等式</p><p>(x2 = x^2)</p><p>min(|x - y|, |x + y|) &lt;= |x|, |y| &lt;= max(|x - y|, |x + y|)</p><p>|x|2 + |y|2 - 2|x||y| &lt;= |x|2, |y|2 &lt;= |x|2 + |y|2 + 2|x||y|</p><p>2|x| &gt;= |y|, |x| &gt;= -2|y|</p><p>总而言之就是 2|x| &gt;= |y|, upper_bound() 搞一搞就 AC，，</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), a[i] = <span class="built_in">fabs</span>(a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = upper_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">2</span> * a[i]) - a;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; n) tmp = n;</span><br><span class="line">        <span class="keyword">if</span> (a[tmp] &gt; <span class="number">2</span> * a[i]) tmp--;</span><br><span class="line">        ans += tmp - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Cute-Sequences"><a href="#D-Cute-Sequences" class="headerlink" title="D. Cute Sequences"></a>D. Cute Sequences</h3><hr><p>有趣又恶心的构造！是赛后补的</p><p>主要看 <a href="https://www.cnblogs.com/megalovania/p/10888493.html" target="_blank" rel="noopener">这位大佬</a> 的，这边补充说明下：</p><ul><li><p>r_i 对 x_j (j &gt;= i) 的贡献我们发现是 1，2，4，8，… 这样的</p></li><li><p>此处的贡献可以理解为：在位置 i 加一，位置 j (j &gt;= i) 会加上多少？</p></li><li><p>在 “减回来” 的时候，我们从数列中靠前的位置开始，因为越靠前，对后面的影响力越大</p></li></ul><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">ll l[N], r[N], prel[N], prer[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">50</span>) rep(j, <span class="number">0</span>, i - <span class="number">1</span>) pre[i] += pre[j];  <span class="comment">// 预处理影响</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a, b, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line">        prel[<span class="number">1</span>] = l[<span class="number">1</span>] = prer[<span class="number">1</span>] = r[<span class="number">1</span>] = a;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1 %lld\n"</span>, a); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; ; i++) &#123;</span><br><span class="line">            l[i] = prel[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            r[i] = prer[i - <span class="number">1</span>] + m;</span><br><span class="line">            prel[i] = prel[i - <span class="number">1</span>] + l[i];</span><br><span class="line">            prer[i] = prer[i - <span class="number">1</span>] + r[i];</span><br><span class="line">            <span class="keyword">if</span> (r[i] &gt;= b) &#123; n = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l[n] &gt; b) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, n);</span><br><span class="line">        rep(i, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (r[n] &gt; b) &#123;</span><br><span class="line">                ll d = min(m - <span class="number">1</span>, (r[n] - b) / pre[n - i]);</span><br><span class="line">                rep(j, i, n) r[j] -= d * pre[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, r[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-The-LCMs-Must-be-Large"><a href="#E-The-LCMs-Must-be-Large" class="headerlink" title="E. The LCMs Must be Large"></a>E. The LCMs Must be Large</h3><hr><p>结论题好哇！</p><p>很容易证明，如果有两天的购买物品的集合完全不同，答案不存在：lcm(Si) &gt; lcm(U - Si) &gt;= lcm(Sj) &gt; lcm(U - Sj) &gt;= lcm(Si) （其中 Sx 表示一个集合） 这是不可能滴！</p><p>如何证明若任意两天购买集合都有交集，则必然存在答案呢？可以这样：先把数组 a 置为 1，把 a 中第一天购买集合乘以质数 p1，把 a 中第二天购买集合乘以质数 p2，就是一组符合要求的数字。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s[<span class="number">55</span>], mark[<span class="number">55</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        rep(j, <span class="number">1</span>, s[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            mark[i][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j, <span class="number">1</span>, i - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, m) <span class="keyword">if</span> (mark[i][k] &amp;&amp; mark[j][k]) cnt++;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) &#123; <span class="built_in">puts</span>(<span class="string">"impossible"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"possible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 574 Div2</title>
      <link href="2019/07/25/Codeforces%20Round%20574%20Div2/"/>
      <url>2019/07/25/Codeforces%20Round%20574%20Div2/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Drinks-Choosing"><a href="#A-Drinks-Choosing" class="headerlink" title="A. Drinks Choosing"></a>A. Drinks Choosing</h3><hr><p>就是本着尽量别浪费的原则。。</p><p>签到题硬是读了 N 遍题意。。英语不行啊</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        num[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = (n + <span class="number">1</span>) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        ans += num[i] / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">        tot -= num[i] / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += tot;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Sport-Mafia"><a href="#B-Sport-Mafia" class="headerlink" title="B. Sport Mafia"></a>B. Sport Mafia</h3><hr><p>解了个二元一次方程（噗</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll a = <span class="number">1</span>, b = -(n + <span class="number">1</span> + n) - <span class="number">2</span>, c = (n + <span class="number">1</span>) * n - <span class="number">2</span> * k;</span><br><span class="line">    ll tmp = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">    tmp = (ll)<span class="built_in">sqrt</span>(tmp);</span><br><span class="line">    ll ans1 = (-b + tmp) / (<span class="number">2</span> * a), ans2 = (-b - tmp) / (<span class="number">2</span> * a);</span><br><span class="line">    <span class="keyword">if</span> (ans2 &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans2);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Basketball-Exercise"><a href="#C-Basketball-Exercise" class="headerlink" title="C. Basketball Exercise"></a>C. Basketball Exercise</h3><hr><p>DP? 很简单</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], b[N], dp[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">        dp[i][<span class="number">2</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(dp[n][<span class="number">0</span>], max(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D1-Submarine-in-the-Rybinsk-Sea-easy-edition"><a href="#D1-Submarine-in-the-Rybinsk-Sea-easy-edition" class="headerlink" title="D1. Submarine in the Rybinsk Sea (easy edition)"></a>D1. Submarine in the Rybinsk Sea (easy edition)</h3><hr><p>考虑按位处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], num[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            num[pos * <span class="number">2</span> - <span class="number">1</span>] = (num[pos * <span class="number">2</span> - <span class="number">1</span>] + (x % <span class="number">10</span>) * n) % mod;</span><br><span class="line">            num[pos * <span class="number">2</span>] = (num[pos * <span class="number">2</span>] + (x % <span class="number">10</span>) * n) % mod;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]) len = i;</span><br><span class="line">        num[i + <span class="number">1</span>] += num[i] / <span class="number">10</span>;</span><br><span class="line">        num[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num[len + <span class="number">1</span>]) ++len;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        ans = (ans * <span class="number">10</span> + num[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D2-Submarine-in-the-Rybinsk-Sea-hard-edition"><a href="#D2-Submarine-in-the-Rybinsk-Sea-hard-edition" class="headerlink" title="D2. Submarine in the Rybinsk Sea (hard edition)"></a>D2. Submarine in the Rybinsk Sea (hard edition)</h3><hr><p>预处理第 i 个数和长度为 j 的串在一起的贡献，还是按位处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], num[<span class="number">30</span>], len[<span class="number">15</span>], pw[<span class="number">35</span>], f[N][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % mod;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            x /= <span class="number">10</span>; pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        len[pos]++;</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= j) &#123;</span><br><span class="line">                ll tmp = a[i];</span><br><span class="line">                rep(k, <span class="number">0</span>, j - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (((f[i][j] + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span>] % mod) % mod) + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span> + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> p = <span class="number">2</span> * j;</span><br><span class="line">                rep(k, j, pos - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (f[i][j] + <span class="number">2l</span>l * x * pw[p] % mod) % mod;</span><br><span class="line">                    ++p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">                rep(k, <span class="number">0</span>, pos - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (((f[i][j] + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span>] % mod) % mod) + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span> + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            ans = (ans + <span class="number">1l</span>l * f[i][j] * len[j] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-OpenStreetMap"><a href="#E-OpenStreetMap" class="headerlink" title="E. OpenStreetMap"></a>E. OpenStreetMap</h3><hr><p>基础套路题！单调队列就可以</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line">ll g, x, y, z, mp[N][N], f[N][N];</span><br><span class="line"><span class="built_in">deque</span>&lt;pii&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; g &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        mp[i][j] = g; g = (<span class="number">1l</span>l * g * x % z + y) % z;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) q.pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; mp[i][j] &lt; q.front().first) q.pop_front();</span><br><span class="line">            q.push_front(make_pair(mp[i][j], j));</span><br><span class="line">            f[i][j] = q.back().first;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().second &gt;= j + b - <span class="number">1</span>) q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) mp[i][j] = f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) q.pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; mp[i][j] &lt; q.front().first) q.pop_front();</span><br><span class="line">            q.push_front(make_pair(mp[i][j], i));</span><br><span class="line">            f[i][j] = q.back().first;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; q.back().second &gt;= i + a - <span class="number">1</span>) q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - a + <span class="number">1</span>) rep(j, <span class="number">1</span>, m - b + <span class="number">1</span>) ans += f[i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Geometers-Anonymous-Club"><a href="#F-Geometers-Anonymous-Club" class="headerlink" title="F. Geometers Anonymous Club"></a>F. Geometers Anonymous Club</h3><hr><p>补了 F！</p><p>题意就是让你对一个区间内的凸包进行闵可夫斯基求和。</p><p>有一个闵可夫斯基求和的定理，就是 n 个方向不同的向量形成的凸包有 n 个顶点。</p><p>离线处理，用树状数组维护。注意，多点一线这种情况要处理！见代码。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, q, l[N], r[N], C[N], ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;pii, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; ve, tmp, query;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">get_dir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 处理多点一线的情况</span></span><br><span class="line">    <span class="keyword">int</span> gcd = __gcd(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">    <span class="keyword">if</span> (gcd) x /= gcd, y /= gcd;</span><br><span class="line">    <span class="keyword">return</span> make_pair(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= N; x += lowbit(x)) C[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ve.push_back(make_pair(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        rep(j, <span class="number">1</span>, x) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            tmp.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">        l[i] = ve.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp.size(); j++)</span><br><span class="line">            ve.push_back(get_dir(tmp[j].first - tmp[(j + <span class="number">1</span>) % tmp.size()].first, tmp[j].second - tmp[(j + <span class="number">1</span>) % tmp.size()].second));</span><br><span class="line">        tmp.clear();</span><br><span class="line">        r[i] = ve.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    rep(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        pii temp = make_pair(l[a], r[b]);</span><br><span class="line">        query.push_back(temp);</span><br><span class="line">        t[temp.second].push_back(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ve.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.count(ve[i])) add(mp[ve[i]], <span class="number">-1</span>);</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">        mp[ve[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t[i].size(); j++)</span><br><span class="line">            ans[t[i][j]] = get_sum(query[t[i][j]].second) - get_sum(query[t[i][j]].first - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, q - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2019同步赛体验&amp;感想</title>
      <link href="2019/07/24/NOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C&amp;%E6%84%9F%E6%83%B3/"/>
      <url>2019/07/24/NOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C&amp;%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>(&gt;﹏&lt;) 今年暴力分比去年足诶！！（暴力选手真心话</p><hr><p>来补题解啦，由于咕咕了很久所以已经忘记题目顺序啦</p><h2 id="回家路线"><a href="#回家路线" class="headerlink" title="$回家路线$"></a>$回家路线$</h2><p>同步赛时写了以边为点的 $O(m^2)$ 最短路。听说数据很水，emm</p><p>$p &lt; q$，显然不会构成环，dp 就行了</p><p>正解是斜率优化 dp，$f[i]$ 表示走了第 $i$ 条边的最小烦躁值。$f[i] = min(f[j] + calc(p_i - q_j)(y_j = x_i, q_j \leq p_i))$</p><p>对于最优解 $j$, $f[j] + Ap_j^2 - Bq_j = 2Ap_iq_j + f[i] - Ap_i^2 - Bp_i - C$</p><p>其中 $y = f[j] + Ap_j^2 - Bq_j$, </p><p>$k = 2Ap_i$, </p><p>$x = q_j$, </p><p>$b = f_i - Ap_i^2 - Bp_i - C$</p><p>要 $f_i$ 小就是要截距小，因此维护一个下凸包</p><p>以时间为阶段，维护 $t$ 时间内的凸包集合，即集合内决策点满足 $q_i \leq t$. 桶排，将决策点 $j$ 在时刻 $q_j$ 加入凸包 $y_j$ 中。每个凸包满足 $q$ 递增。</p><p>RE 调半天，发现数组没开足。。。</p><h2 id="序列"><a href="#序列" class="headerlink" title="$序列$"></a>$序列$</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】一些「有趣」的计数题</title>
      <link href="2019/07/12/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E4%B8%80%E4%BA%9B%E3%80%8C%E6%9C%89%E8%B6%A3%E3%80%8D%E7%9A%84%E8%AE%A1%E6%95%B0%E9%A2%98/"/>
      <url>2019/07/12/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E4%B8%80%E4%BA%9B%E3%80%8C%E6%9C%89%E8%B6%A3%E3%80%8D%E7%9A%84%E8%AE%A1%E6%95%B0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>都是 2019 暑期训练题～</p><h2 id="燕归巢-swalllow"><a href="#燕归巢-swalllow" class="headerlink" title="燕归巢(swalllow)"></a>燕归巢(swalllow)</h2><hr><p>枚举不同形态的树显然不可能，所以我们可以考虑一条边的贡献（这在之后的计数题是很常用的技巧，可以说是套路了，一定要掌握！</p><p>先将结点分为左右两个集合，枚举左边集合点数 i，那么右边集合点数则为 n - i；</p><p>选择左边点集共有 C(n - 1, i - 1) 种方法（注意要减一！因为连接两个集合的边，也就是被考虑贡献的边，它的一端是不被计入的）；</p><p>左边形成的树有 i ^ {i - 2} 种形态，右边形成的树有 (n - i) ^ {n - i - 2} 种形态；</p><p>选择连接左集合和右集合的边 共有 i(n - i) 种方法；</p><p>选择包含这条边的路径 共有 i(n - i) 种方法。</p><p>所以就是: </p><h2 id="sum-limits-i-1-nC-n-1-i-1-i-i-2-n-i-n-i-2-i-n-i-i-n-i"><a href="#sum-limits-i-1-nC-n-1-i-1-i-i-2-n-i-n-i-2-i-n-i-i-n-i" class="headerlink" title="$\sum\limits_{i = 1}^nC(n - 1, i - 1)  i^{i - 2}  (n - i)^{n - i - 2}  i  (n - i)  i  (n - i)$"></a>$\sum\limits_{i = 1}^nC(n - 1, i - 1) <em> i^{i - 2} </em> (n - i)^{n - i - 2} <em> i </em> (n - i) <em> i </em> (n - i)$</h2><h2 id="头皮屑-Venus"><a href="#头皮屑-Venus" class="headerlink" title="头皮屑(Venus)"></a>头皮屑(Venus)</h2><hr><p>（有趣的标题</p><p>实质是数论题。考试时找到了性质：</p><ol><li>至少一个是质数且至少一个数 &gt; n / 2，无边相连，为 0</li><li>gcd &gt; 1，有直接边，为 1</li><li>互质，最小质因数之和 &lt;= n，为 2</li><li>互质，两个数都 &lt;= n / 2，为 3</li></ol><p>我们在讨论中忽略数字 1。</p><p>4）直接用总边数减去 0）1）2）就好了。</p><p>建议看 CF 原题解：<a href="http://codeforces.com/blog/entry/55200" target="_blank" rel="noopener">传送门</a></p><h2 id="坐等memset0-memset"><a href="#坐等memset0-memset" class="headerlink" title="坐等memset0(memset)"></a>坐等memset0(memset)</h2><hr><p>非常妙的 CF 题！</p><p>我们发现，f(l, r) = l ~ r 的点数 - l ~ r 的边数。</p><p>那么我们可以拆开 sigma，计算每一个点的贡献和每一条边的贡献，就可以 AC。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2014]-序列分割</title>
      <link href="2019/07/06/%5BAPIO2014%5D-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/"/>
      <url>2019/07/06/%5BAPIO2014%5D-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3675" target="_blank" rel="noopener">题目链接</a></p><p>啊。。。好恶心。。最后逼着我去对拍【面孔扭曲】也算很有意义了！趁机复习一波斜率优化。。</p><p>可以发现，答案和分割顺序好像并没有关系，所以我们可以默认为从左向右分割（这样最方便</p><p>设 f[i, j] 表示前 j 个分割了 i 次。那么方程就是：f[i, j] = max{f[i - 1][k] + s[k]·(s[j]·s[k])}<br>(其中 s[i] 表示 a[1] ~ a[i] 的和)</p><p>如果决策 k1 &lt; k2（k2更优：</p><script type="math/tex; mode=display">f[i, k1] + s[k1]*(s[j]*s[k1]) < f[i, k2] + s[k2]*(s[j]*s[k2])</script><p>=&gt;</p><script type="math/tex; mode=display">s[j] > \frac{f[i, k1] - f[i, k2] + (s[k1] ^ 2) - (s[k2] ^ 2)}{s[k2] - s[k1]}</script><p>这是一个斜率优化的式子，然后就是套路了。祝玩耍愉快。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], q[N], r;</span><br><span class="line">ll sum[N], f[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[j] == sum[k]) <span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(sum[k] * sum[k] - sum[j] * sum[j] + f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j] - f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][k]) / (<span class="keyword">double</span>)(sum[k] - sum[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt;= K; r++) &#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[head], q[head + <span class="number">1</span>]) &lt; sum[i]) head++;</span><br><span class="line">            <span class="keyword">int</span> t = q[head];</span><br><span class="line">            f[r &amp; <span class="number">1</span>][i] = f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][t] + (sum[i] - sum[t]) * sum[t];</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[tail - <span class="number">1</span>], q[tail]) &gt; slope(q[tail], i)) tail--;</span><br><span class="line">            q[++tail] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[K &amp; <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 572 Div2</title>
      <link href="2019/07/05/Codeforces%20Round%20572%20Div2/"/>
      <url>2019/07/05/Codeforces%20Round%20572%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1189" target="_blank" rel="noopener">比赛链接</a></p><p>VP 的～</p><h3 id="A-Keanu-Reeves"><a href="#A-Keanu-Reeves" class="headerlink" title="A. Keanu Reeves"></a>A. Keanu Reeves</h3><hr><p>H2O 签到题～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        c[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>], b[i] = b[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (c[i]) a[i]++; <span class="keyword">else</span> b[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[n] != b[n]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                rep(j, <span class="number">1</span>, i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                rep(j, i + <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[j]);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Number-Circle"><a href="#B-Number-Circle" class="headerlink" title="B. Number Circle"></a>B. Number Circle</h3><hr><p>尽量保持 大-&gt;小-&gt;大 的顺序～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = n + <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) b[++r] = a[i];</span><br><span class="line">        <span class="keyword">else</span> b[--l] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l) l = n;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; n) r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[l] + b[r] &lt;= b[i]) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Candies"><a href="#C-Candies" class="headerlink" title="C. Candies!"></a>C. Candies!</h3><hr><p>当时暴力模拟是 T 了一发，然后才想到 ST 表。。（这种题应该首选 ST 啊！</p><p>不是很难，复习一波！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, q, l, r, pre[N], ans, f[N][<span class="number">20</span>], g[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">log</span>(n + eps) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tmp; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> k = n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            f[i][j] = (f[i][j - <span class="number">1</span>] + f[i + len][j - <span class="number">1</span>]) % <span class="number">10</span>;</span><br><span class="line">            g[i][j] = (g[i][j - <span class="number">1</span>] + g[i + len][j - <span class="number">1</span>]) + (f[i][j - <span class="number">1</span>] + f[i + len][j - <span class="number">1</span>] &gt;= <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        tmp = <span class="built_in">log</span>(r - l + <span class="number">1</span> + eps) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g[l][tmp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D1-Add-on-a-Tree"><a href="#D1-Add-on-a-Tree" class="headerlink" title="D1. Add on a Tree"></a>D1. Add on a Tree</h3><hr><p>发现，有 3 个以上分支的点，它连接的边可以任意+。</p><p>所以如果有 2 个分支的点就不可以！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        d[x]++, d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (d[i] == <span class="number">2</span>) &#123; ff = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="built_in">puts</span>(<span class="string">"no"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"yes"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Count-Pairs"><a href="#E-Count-Pairs" class="headerlink" title="E. Count Pairs"></a>E. Count Pairs</h3><hr><p>这种题肯定得 i 归一边，j 归另一边，各管各的才好～</p><p>因式分解党表示强迫症发作～</p><p>两边同乘 (ai - aj)，就是 ai^4 - aj^4 恒等于 (ai - aj)k (mod p)</p><p>整理得 ai^4 - aiK 恒等于 aj^4 - ajK (mod p)</p><p>那么就很 easy 惹～ E题 AC～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mod, K, a[N], ans;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a - b;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += mod;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1l</span>l * a * b) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mul(mul(x, x), mul(x, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        a[i] = sub(p(a[i]), mul(K, a[i]));</span><br><span class="line">        ans += mp[a[i]];</span><br><span class="line">        mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>有进步！暑假拼了 (ง •̀灬•́)ง</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态DP</title>
      <link href="2019/06/27/%E5%8A%A8%E6%80%81DP/"/>
      <url>2019/06/27/%E5%8A%A8%E6%80%81DP/</url>
      
        <content type="html"><![CDATA[<p>神仙芝士= =</p><p>恐怕讲不好，还是挂别人 dalao 的 blog 吧！</p><p><a href="https://www.cnblogs.com/RabbitHu/p/9112811.html" target="_blank" rel="noopener">这个超好</a></p><p>再挂个板子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu4719</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dfn;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>], g[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[N], w2[N], sz[N], top[N], ed[N], bel[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], son[N], id[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) m[i][j] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ans[N &lt;&lt; <span class="number">2</span>], val[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    <span class="keyword">int</span> Mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; Mx) Mx = sz[y], son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    top[x] = f;</span><br><span class="line">    id[x] = ++dfn;</span><br><span class="line">    bel[dfn] = x, ed[f] = x;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x], f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[x] = ed[f]; <span class="comment">// !!!!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    g[x][<span class="number">1</span>] = w[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == son[x] || y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs3(y);</span><br><span class="line">        g[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        g[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>] += g[x][<span class="number">0</span>], f[x][<span class="number">1</span>] += g[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        dfs3(son[x]);</span><br><span class="line">        f[x][<span class="number">0</span>] += max(f[son[x]][<span class="number">1</span>], f[son[x]][<span class="number">0</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += f[son[x]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mul</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.cl();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; k++)</span><br><span class="line">                res.m[i][j] = max(res.m[i][j], x.m[i][k] + y.m[k][j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[x].l = l, tr[x].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[bel[l]].m[<span class="number">0</span>][<span class="number">0</span>] = g[bel[l]][<span class="number">0</span>], val[bel[l]].m[<span class="number">0</span>][<span class="number">1</span>] = g[bel[l]][<span class="number">0</span>];</span><br><span class="line">        val[bel[l]].m[<span class="number">1</span>][<span class="number">0</span>] = g[bel[l]][<span class="number">1</span>], val[bel[l]].m[<span class="number">1</span>][<span class="number">1</span>] = -inf;</span><br><span class="line">        ans[x] = val[bel[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, l, mid), build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    ans[x] = mul(ans[x &lt;&lt; <span class="number">1</span>], ans[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[x].l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> ans[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= r) <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; l) <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> mul(query(x &lt;&lt; <span class="number">1</span>, l, r), query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l == tr[x].r &amp;&amp; tr[x].l == pos) &#123;</span><br><span class="line">        ans[x] = val[bel[pos]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) upd(x &lt;&lt; <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">else</span> upd(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos);</span><br><span class="line">    ans[x] = mul(ans[x &lt;&lt; <span class="number">1</span>], ans[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    val[x].m[<span class="number">1</span>][<span class="number">0</span>] += f - w[x];</span><br><span class="line">    w[x] = f;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = top[x];</span><br><span class="line">        node lst = query(<span class="number">1</span>, id[y], id[ed[y]]);</span><br><span class="line">        upd(<span class="number">1</span>, id[x]);</span><br><span class="line">        node now = query(<span class="number">1</span>, id[y], id[ed[y]]);</span><br><span class="line">        x = fa[y];</span><br><span class="line">        val[x].m[<span class="number">0</span>][<span class="number">0</span>] += max(now.m[<span class="number">0</span>][<span class="number">0</span>], now.m[<span class="number">1</span>][<span class="number">0</span>]) - max(lst.m[<span class="number">0</span>][<span class="number">0</span>], lst.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        val[x].m[<span class="number">0</span>][<span class="number">1</span>] = val[x].m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[x].m[<span class="number">1</span>][<span class="number">0</span>] += now.m[<span class="number">0</span>][<span class="number">0</span>] - lst.m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs3(<span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        modify(x, y);</span><br><span class="line">        node res = query(<span class="number">1</span>, id[<span class="number">1</span>], id[ed[<span class="number">1</span>]]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(res.m[<span class="number">0</span>][<span class="number">0</span>], res.m[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRT&amp;EXCRT中国剩余定理与扩展中国剩余定理</title>
      <link href="2019/06/02/CRT&amp;EXCRT%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>2019/06/02/CRT&amp;EXCRT%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这真的超容易忘。。。所以特此记录一篇博客！</p><h2 id="CRT（中国剩余定理）"><a href="#CRT（中国剩余定理）" class="headerlink" title="CRT（中国剩余定理）"></a>CRT（中国剩余定理）</h2><hr><ul><li>前言：必须是模数两两互质的情况哦！</li></ul><p>中国剩余定理，又称孙子定理（古人好厉害哇</p><p>是用来解决下面这种同余方程组的：</p><script type="math/tex; mode=display">\begin{cases}x\equiv a_1(mod\ m_1)\\x\equiv a_2(mod\ m_2)\\\ \vdots\\x\equiv a_k(mod\ m_k)\end{cases}</script><p>可以假设 $n_1 \equiv a_1(mod m_1)$, $n_2 \equiv a_2(mod m_2)$, $\cdots$, $n_k \equiv a_k(mod m_k)$</p><p>设 $M = m_1 <em> m_2 </em> … * m_k$. $M_i = M / m_i$.</p><p>为了使得 $n_1 + n_2 \equiv a_1(mod m_1)$, n2 必须是 m1 的倍数。同理可得：</p><ul><li>n1 是 m2 和 m3 的倍数（是 M1 的倍数</li><li>n2 是 m1 和 m3 的倍数（是 M2 的倍数</li><li>n3 是 m1 和 m2 的倍数（是 M3 的倍数</li></ul><p>这样的话，为 n1 + n2 + n3 的解就满足上述方程啦！</p><p>设 $M_1t_1 \equiv 1(mod m_1)$，则 $a_1M_1t_1 \equiv a_1(mod m_1)$，我们可以用扩欧求出 t1. 所以 $n_1 = a_1M_1t_1$.</p><p>$x = \sum_{i = 1}^k n_i = \sum_{i = 1}^ka_iM_it_i$. 求完啦！就这样~</p><h2 id="EXCRT（扩展中国剩余定理）"><a href="#EXCRT（扩展中国剩余定理）" class="headerlink" title="EXCRT（扩展中国剩余定理）"></a>EXCRT（扩展中国剩余定理）</h2><hr><p>说是扩展，其实这俩玩意儿半分钱关系也木有。。</p><p>两个问题唯一的区别就是：EXCRT 模数不互质</p><p>怎么做捏？假设有 n 个方程。$x \equiv a_1(mod m_1)$，即 $x = m_1 <em> k_1 + a_1$; $x \equiv a_2(mod m_2)$, 即 $x = m_2 </em> k_2 + a_2$.</p><p>联立：$m_2 <em> k_2 - m_1 </em> k_1 = r_1 - r_2$. 其中只有 k1 和 k2 是未知的，我们可以用扩欧判断有无解，求出 k1, 求出 x。</p><p>我们把这个 x 叫做 x0. x 的通解就是 $x_0 + k * lcm(m_1, m_2)$, 即 $x \equiv x_0(mod lcm(m_1, m_2))$</p><p>就这样，我们把前两个方程变为一个方程了。</p><p>用这样的方法做 n - 1 次扩欧，就可以求出最终的 x 了。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exGCD</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exGCD(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exCRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll M = m[<span class="number">1</span>], R = r[<span class="number">1</span>], x, y, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        d = exGCD(m[i], M, y, x);</span><br><span class="line">        <span class="keyword">if</span> ((R - r[i]) % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = (R - r[i]) / d * x % m[i];</span><br><span class="line">        R -= M * x;</span><br><span class="line">        M = M / d * m[i];</span><br><span class="line">        R %= M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (R % M + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;m[i], &amp;r[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, exCRT());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 同余方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2011]-观光公交</title>
      <link href="2019/05/18/%5BNOIP2011%5D-%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/"/>
      <url>2019/05/18/%5BNOIP2011%5D-%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1315" target="_blank" rel="noopener">题目链接</a></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><hr><p>就是每次找一条 “如果使用加速器，能影响的人最多” 的边！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, d[N], pre[N], on[N], off[N], arri[N], use[N], ans;</span><br><span class="line"><span class="comment">// use[i] ��ʾ d[i]-- ���ж����������� </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("bus.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("bus.out", "w", stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;a, &amp;b);</span><br><span class="line">        ans -= t;</span><br><span class="line">        on[a] = max(on[a], t);</span><br><span class="line">        off[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            arri[i] = max(arri[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// if (!d[i - 1]) use[i - 1] = 0;</span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">                use[i - <span class="number">1</span>] = off[i];</span><br><span class="line">                <span class="keyword">if</span> (arri[i] &gt; on[i]) use[i - <span class="number">1</span>] += use[i];</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (use[i] &gt; use[id] &amp;&amp; d[i] &gt; <span class="number">0</span>) id = i;</span><br><span class="line">        d[id]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        arri[i] = max(arri[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += arri[i] * off[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><hr><p>网上只有一个费用流题解 T^T 那位大神也是超级厉害！</p><p>首先由 $S$ 向 $S’$ 连一条流量为 $K$，费用为 $0$ 的边（限制总流量为 $K$）</p><p>把每个点 $i$ 拆为 $i’$ 和 $i’’$。</p><ol><li><p>$(i’, i’’, max(tim[i] - on[i], 0), 0)$，其中 $tim[i]$ 表示不加任何加速器时车到达 $i$ 点的时间，$on[i]$ 表示 $i$ 点最晚上车的时间。一旦加速器使用超过 $tim[i] - on[i]$ 了，多余的部分就会没用，所以就别浪费了</p></li><li><p>$(i’’, (i + 1)’, \infty, -off[i])$，其中 $off[i]$ 表示 $i$ 点下车的人</p></li><li><p>$(S’, i’’, D[i]（这应该也是在限制该边总流量不超过 D[i]）, 0)$</p></li><li><p>$(i’, T, \infty, 0)$</p></li></ol><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">1e4</span> + <span class="number">10</span>, T = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, ans, s, t;</span><br><span class="line"><span class="keyword">int</span> D[N], on[T], off[T], tim[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> t, a, b; &#125;p[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> u, v, c, cost; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dis[N &lt;&lt; <span class="number">1</span>], inq[N &lt;&lt; <span class="number">1</span>], pre[N &lt;&lt; <span class="number">1</span>], fl[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edges.push_back((edge)&#123;s, t, c, v&#125;);</span><br><span class="line">    edges.push_back((edge)&#123;t, s, <span class="number">0</span>, -v&#125;);</span><br><span class="line">    <span class="keyword">int</span> tot = edges.size();</span><br><span class="line">    G[s].push_back(tot - <span class="number">2</span>);</span><br><span class="line">    G[t].push_back(tot - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    q.push(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>, inq[s] = <span class="number">1</span>, fl[s] = inf, pre[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            edge e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.c &amp;&amp; dis[e.v] &gt; dis[e.u] + e.cost) &#123;</span><br><span class="line">                dis[e.v] = dis[e.u] + e.cost;</span><br><span class="line">                pre[e.v] = G[u][i];</span><br><span class="line">                fl[e.v] = min(fl[e.u], e.c);</span><br><span class="line">                <span class="keyword">if</span> (!inq[e.v]) &#123;</span><br><span class="line">                    inq[e.v] = <span class="number">1</span>; q.push(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[t] == inf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += fl[t];</span><br><span class="line">    cost += fl[t] * dis[t];</span><br><span class="line">    <span class="keyword">int</span> pos = t;</span><br><span class="line">    <span class="keyword">while</span> (pos != s) &#123;</span><br><span class="line">        edges[pre[pos]].c -= fl[t];</span><br><span class="line">        edges[pre[pos] ^ <span class="number">1</span>].c += fl[t];</span><br><span class="line">        pos = edges[pre[pos]].u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mincost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s, t, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;D[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p[i].t, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">        on[p[i].a] = max(on[p[i].a], p[i].t);</span><br><span class="line">        off[p[i].b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tim[i] = max(tim[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + D[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans += tim[p[i].b] - p[i].t;</span><br><span class="line"></span><br><span class="line">    s = n * <span class="number">2</span> + <span class="number">1</span>, t = n * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> s1 = n * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    add(s, s1, K, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        add(i, i + n, max(tim[i] - on[i], <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">        add(i + n, i + <span class="number">1</span>, inf, -off[i + <span class="number">1</span>]);</span><br><span class="line">        add(s1, i + n, D[i], <span class="number">0</span>);</span><br><span class="line">        add(i + <span class="number">1</span>, t, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + Mincost());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好鬼畜啊。。。是目前做过最奇技淫巧的网络流。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1030]-文本生成器</title>
      <link href="2019/05/05/%5BBZOJ1030%5D-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2019/05/05/%5BBZOJ1030%5D-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1030" target="_blank" rel="noopener">题目链接</a></p><p>如果要计算可读文本的数量，那就要用到容斥（没尝试过。。应该不好算，或者不能算）</p><p>不如计算不可读文本数量，再用总数减去它！（这叫逆向思维还是啥</p><p>这样就比较美滋滋了，只要不让 AC 自动机上走到单词节点就好了。DP 的话，设 $f[i, j]$ 表示文本长度为 $i$，匹配到自动机上第 $j$ 个节点时的情况数。同时要记得排除一个模式串包含另一个模式串，第一个没走到单词节点，第二个却走到了的情况。代码中也有注释。</p><p>Hint！$f[0, 0]$ 也是一种不可读的情况哦，不能舍。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>, M = <span class="number">110</span>, mod = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sz, ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], f[M][N], fail[N];</span><br><span class="line"><span class="keyword">bool</span> val[N];</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> ch - <span class="string">'A'</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (!trie[u][c]) trie[u][c] = ++sz;</span><br><span class="line">        u = trie[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = trie[r][c];</span><br><span class="line">            <span class="keyword">if</span> (u) &#123;</span><br><span class="line">                fail[u] = trie[fail[r]][c];</span><br><span class="line">                q.push(u);</span><br><span class="line">            &#125; <span class="keyword">else</span> trie[r][c] = trie[fail[r]][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val[fail[r]]) val[r] = <span class="number">1</span>;  <span class="comment">// 这边跟传统的自动机有些不同，是为了不让 “一个模式串包含另一个模式串，一个没走到单词节点但另一个走到了” 的情况出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    getfail();</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz; j++) &#123;  <span class="comment">// j 从 0 号节点开始！</span></span><br><span class="line">            <span class="keyword">if</span> (val[j] || !f[i][j]) <span class="keyword">continue</span>;  <span class="comment">// 只要碰到任意单词节点就不走</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trie[j][k];</span><br><span class="line">                <span class="comment">// 这里 u 即使 == 0 也没有关系！可以理解为文本第 i + 1 个位置与自动机的根结点（0 号节点）匹配</span></span><br><span class="line">                f[i + <span class="number">1</span>][u] = (f[i + <span class="number">1</span>][u] + f[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) ans = ans * <span class="number">26</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz; i++)  <span class="comment">// 不要忘记算上 f[0, 0]</span></span><br><span class="line">        <span class="keyword">if</span> (!val[i]) <span class="comment">// !!!</span></span><br><span class="line">            ans = (ans + mod - f[m][i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1009]-GT考试</title>
      <link href="2019/05/05/%5BBZOJ1009%5D-GT%E8%80%83%E8%AF%95/"/>
      <url>2019/05/05/%5BBZOJ1009%5D-GT%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1009" target="_blank" rel="noopener">题目链接</a></p><p>一直在想组合数学，容斥怎么做。。。看了题解发现是矩阵乘法 + 字符串。。。</p><p>一般矩阵乘法的题都得先找递推式。这题的转移方程是:</p><script type="math/tex; mode=display">f[i, j] = \sum\limits_{k = 0}^{m - 1} f[i - 1, k] * g[k][j]\ (0 \leq j < m)</script><p>（$0 \leq j &lt; m$ 是因为题目要求准考证号不完全出现 A 的方案数）</p><p>其中, $f[i, j]$ 表示准考证号前 $i$ 位中的后 $j$ 位与 $A$ 的前 $j$ 位相同的方案数, $g[k, j]$ 表示准考证号匹配 $A$ 的前 $k$ 位时，准考证号增加一个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$ 的方案数（计算 $g$ 时要从 $0$ 到 $9$ 枚举增加的那个字符是啥）。</p><p>我们发现，$f[i, ]$ 每次都是由 $f[i - 1, ]$ 转移来的，所以对 $g$ 矩阵做快速幂就行，$O(m^3 log n)$。</p><p>最后的答案就是 $\sum\limits_{i = 0}^{m - 1}g[0, i]$ 。为啥呢？</p><p>根据矩阵乘法，我们可知：转移 $k$ 次，$g[k, j]$ 就表示一开始准考证号匹配 $A$ 的前 $k$ 位时，准考证号增加 $k$ 个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$（算上新匹配的 $k$ 位）的方案数。</p><p>同理，转移 $n$ 次，$g[i, j]$ 就表示一开始准考证号匹配 $A$ 的前 $i$ 位时，准考证号增加 $n$ 个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$（算上新匹配的 $n$ 位）的方案数。</p><p>我们又知道，一开始准考证号匹配 $A$ 的 $0$ 位，所以最后的答案就是 $\sum\limits_{i = 0}^{m - 1}g[0, i]$ 。</p><p>有一定的思维难度，重要的还是转移方程式吧。。额，对于我这个 DP 渣渣来说，DP 题还要切很多。。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mod;</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">30</span>], b[<span class="number">30</span>][<span class="number">30</span>], a[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[<span class="number">30</span>][<span class="number">30</span>], <span class="keyword">int</span> b[<span class="number">30</span>][<span class="number">30</span>], <span class="keyword">int</span> ans[<span class="number">30</span>][<span class="number">30</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            tmp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">                tmp[i][j] = (tmp[i][j] + a[i][k] * b[k][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            ans[i][j] = tmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = nxt[j];</span><br><span class="line">        nxt[i] = (s[j + <span class="number">1</span>] == s[i] ? ++j : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">while</span> (t &amp;&amp; s[t + <span class="number">1</span>] - <span class="string">'0'</span> != j) t = nxt[t];</span><br><span class="line">            <span class="keyword">if</span> (s[t + <span class="number">1</span>] - <span class="string">'0'</span> == j) ++t;</span><br><span class="line">            <span class="keyword">if</span> (t != m)</span><br><span class="line">                b[i][t] = (b[i][t] + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) a[i][i] = <span class="number">1</span>;  <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (; n ; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(a, b, a);</span><br><span class="line">        mul(b, b, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) res = (res + a[<span class="number">0</span>][i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯函数求法</title>
      <link href="2019/05/04/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E6%B1%82%E6%B3%95/"/>
      <url>2019/05/04/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E6%B1%82%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="O-n-线性求法"><a href="#O-n-线性求法" class="headerlink" title="O(n) 线性求法"></a>O(n) 线性求法</h3><hr><p>不难理解，就是在欧拉线性筛的时候顺便求的。不过有个酷炫的名字，叫“O(n) 递推求解”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N], prime[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobius</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++m] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sqrt-n-单独求解"><a href="#sqrt-n-单独求解" class="headerlink" title="sqrt(n) 单独求解"></a>sqrt(n) 单独求解</h3><hr><p>这个基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">get_mu</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            mu = -mu;</span><br><span class="line">            n /= i;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) mu = -mu;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogn-调和级数复杂度求法"><a href="#O-nlogn-调和级数复杂度求法" class="headerlink" title="O(nlogn) 调和级数复杂度求法"></a>O(nlogn) 调和级数复杂度求法</h3><hr><p>这个有点妙！<br>（目前不知道原理，留坑待填）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) mu[j] -= mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于交互的一些解题姿势</title>
      <link href="2019/05/04/%E5%85%B3%E4%BA%8E%E4%BA%A4%E4%BA%92%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/"/>
      <url>2019/05/04/%E5%85%B3%E4%BA%8E%E4%BA%A4%E4%BA%92%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>· 把交互操作包成函数（如果忘写 fflush(stdout) 就不至于绝望透顶。。）</p><p>· 交互中，scanf 和 printf 是和交互库的 stdout 和 stdin 接上的，所以你并不能看到输出的信息</p><p>· 交互操作中，只有输出后才需要 fflush(stdout)</p><p>· 如果你想看到输出信息，那么用 fprintf(stderr, “blabla\n”) 吧</p><p>· 交互题让人感到 “踏空而行”。如果不想这样，就写一个 interactor.cpp，自己造数据和进行交互！</p><p>打了一场 CodeJam，收获了一个优质的 interactive_runner.py! （在我的电脑中的 Workspace - Programs - Template 文件夹中）</p><p>终端中怎么运行呢？python interactive_runner.py ./interactor — ./main</p><p>⬆️其中，interactive_runner.py 是运行程序，interactive.cpp 是你自己写的交互程序，main.cpp 是你自己写的主程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeJam2019-R1c</title>
      <link href="2019/05/04/CodeJam2019-R1c/"/>
      <url>2019/05/04/CodeJam2019-R1c/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Robot-Programming-Strategy"><a href="#A-Robot-Programming-Strategy" class="headerlink" title="A. Robot Programming Strategy"></a>A. Robot Programming Strategy</h3><hr><p>分类讨论每一位 pos：</p><p>如果 pos 这位，只有一种字符，那么显然有解；</p><p>如果有三种字符，不管答案串当前位为什么，都会被某种字符克制，显然无解；</p><p>如果有两种字符，那么当前只有一种选择，即：打平一种字符，赢过另一种字符。</p><p>dfs！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, len[N], S[<span class="number">505</span>], a[<span class="number">505</span>], L;</span><br><span class="line"><span class="built_in">string</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> pos)</span> </span>&#123; <span class="keyword">return</span> c[i][pos % len[i]]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">500</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 莫忘</span></span><br><span class="line">    L++;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (S[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'R'</span>) cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'S'</span>) cnt[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'P'</span>) cnt[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">if</span> (cnt[i]) num++;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">            a[pos] = (i + <span class="number">2</span>) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] &amp;&amp; cnt[(i + <span class="number">1</span>) % <span class="number">3</span>]) &#123;</span><br><span class="line">            a[pos] = i;</span><br><span class="line">            <span class="keyword">int</span> k = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'R'</span> &amp;&amp; !k) S[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'S'</span> &amp;&amp; k == <span class="number">1</span>) S[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'P'</span> &amp;&amp; k == <span class="number">2</span>) S[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dfs(pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) S[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">            len[i] = c[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, cas);</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i] == <span class="number">0</span> ? <span class="string">'R'</span> : (a[i] == <span class="number">1</span> ? <span class="string">'S'</span> : <span class="string">'P'</span>));</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Power-Arrangers"><a href="#B-Power-Arrangers" class="headerlink" title="B. Power Arrangers"></a>B. Power Arrangers</h3><hr><p>是交互题！</p><p>总共 595 个数字。分三轮。</p><ol><li><p>询问 119 个序列的首位，我们发现 A B C D E 的数量必定有一个是比别人少一的，那么答案序列的首位就是它。</p></li><li><p>询问 23（23 = (119 + 1) / 5 - 1）个序列的次位，bla…bla…bla</p></li><li><p>询问 5（5 = (23 + 1) / 4 - 1）个序列的第三位，bla…bla…bla</p></li><li><p>询问 1 (1 = (5 + 1) / 3 - 1) 个。。。诶？只有一个了？那么直接询问它的第四位，顺便也能得出第五位了！</p></li></ol><p>这边有个易错点：假设询问的第四位是 C，第五位是 D，这个 <em> </em> <em> C D 序列是还存在的，没有被删除的！所以答案序列是 </em> <em> </em> D C! 这个一定要注意</p><p>然后我们算一发… 119 + 23 + 5 + 1 + 1 = 149 ！离 150 次只有一步之遥… 卡的好紧…</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, F;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">700</span>], ans[<span class="number">10</span>], cnt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getn</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    _count ++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>] - <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;F);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        _count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">119</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[(j - <span class="number">1</span>) * <span class="number">5</span> + k] != ans[k]) &#123;</span><br><span class="line">                        ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ff) &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = (j - <span class="number">1</span>) * <span class="number">5</span> + i;</span><br><span class="line">                    a[p] = getn(p);</span><br><span class="line">                    cnt[a[p]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (!cnt[id]) id = j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cnt[id] &gt; cnt[j] &amp;&amp; cnt[j]) id = j;</span><br><span class="line">            <span class="comment">// fprintf(stderr, "%d\n", cnt[id]);</span></span><br><span class="line">            ans[i] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">119</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (i - <span class="number">1</span>) * <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[p + j] != ans[j]) &#123;</span><br><span class="line">                    ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ff == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[<span class="number">5</span>] = getn(p + <span class="number">4</span>);</span><br><span class="line">                ans[<span class="number">4</span>] = getn(p + <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, ans[i] + <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// fprintf(stderr, "%d\n", _count);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Bacterial-Tactics"><a href="#C-Bacterial-Tactics" class="headerlink" title="C. Bacterial Tactics"></a>C. Bacterial Tactics</h3><hr><p>是博弈！</p><p>我们发现 R 和 C 都非常小！可以用 SG 函数 + 记忆化搜索。</p><p>可以把横向或纵向放细菌，形象看成 横着或竖着 pia 刀。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">---------------</span><br><span class="line">图 <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如图 1，我们在中间竖着 pia 了一刀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|------|      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">---------------</span><br><span class="line">图 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如图 2，我们在左边那块横着 pia 了一刀。我们发现，刀痕有可能会被之前的刀痕半路拦截。所以左边的操作对右边半块毫无影响。</p><p>这样好办了：左右半块分别可视为两个子问题。我们用 SG[x1, y1, x2, y2] 表示左上角为 (x1, y1)，右下角为 (x2, y2) 的矩阵的 SG 函数值。枚举竖着 pia 哪一列，横着 pia 哪一行，加上神奇的 mex 函数，就是一个像模像样的博弈解法。别忘判当前操作合法性！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, SG[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x0 &gt; x2 || y0 &gt; y2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (SG[x0][y0][x2][y2] != <span class="number">-1</span>) <span class="keyword">return</span> SG[x0][y0][x2][y2];  <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">bool</span> c[<span class="number">60</span>];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x0; i &lt;= x2; i++) &#123;</span><br><span class="line">        <span class="comment">// 判合法性</span></span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y0; j &lt;= y2; j++) <span class="keyword">if</span> (s[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        c[dfs(x0, y0, i - <span class="number">1</span>, y2) ^ dfs(i + <span class="number">1</span>, y0, x2, y2)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y0; i &lt;= y2; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = x0; j &lt;= x2; j++) <span class="keyword">if</span> (s[j][i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        c[dfs(x0, y0, x2, i - <span class="number">1</span>) ^ dfs(x0, i + <span class="number">1</span>, x2, y2)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) <span class="keyword">if</span> (!c[i]) &#123;</span><br><span class="line">        SG[x0][y0][x2][y2] = i; <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(SG, <span class="number">-1</span>, <span class="keyword">sizeof</span>(SG));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, n, m);</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (s[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((dfs(<span class="number">1</span>, <span class="number">1</span>, i - <span class="number">1</span>, m) ^ dfs(i + <span class="number">1</span>, <span class="number">1</span>, n, m)) == <span class="number">0</span>) ans += m;  <span class="comment">// 对于对手是必败态，则对于我是必胜态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (s[j][i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((dfs(<span class="number">1</span>, <span class="number">1</span>, n, i - <span class="number">1</span>) ^ dfs(<span class="number">1</span>, i + <span class="number">1</span>, n, m)) == <span class="number">0</span>) ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF600E]-Lomsat gelral</title>
      <link href="2019/04/02/%5BCF600E%5D-Lomsat%20gelral/"/>
      <url>2019/04/02/%5BCF600E%5D-Lomsat%20gelral/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">题目链接</a></p><p>大概意思就是让你求每个子树内颜色数最多的颜色总和（有点绕。。</p><p>其实是个模版题！我先用树上启发式合并 (dsu on tree) 过的。</p><p>树上启发式合并其实就是暴力的优化版！大概步骤为：</p><p>处理轻儿子(清除轻儿子信息) -&gt; 处理重儿子(不清除重儿子信息) -&gt; 再加入轻儿子信息，计算父亲信息 -&gt; 如果当前父亲为祖父的轻儿子，清除父亲及其子树信息.</p><p>其实就是将 $size$ 较小的（此处体现为轻儿子）合并到 $size$ 较大的（此处体现为重儿子）上，从而达到降低复杂度的效果。如何分析复杂度呢？一个轻儿子子树里的点至多会被消除 $logN$ 次（因为这点上面最多有 $logN$ 条边），利用轻重链剖分的思想，就能 $O(nlogn)$ 解决问题。（此处假设合并信息是 $O(1)$ 的）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dsu on tree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mx;</span><br><span class="line"><span class="keyword">int</span> a[N], f[N], sz[N], son[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], tot;</span><br><span class="line">ll sum, ans[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x] = fa;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; sz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]] += val;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == mx) sum += a[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt[a[x]] &gt; mx) sum = a[x], mx = cnt[a[x]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> (to[i] != f[x] &amp;&amp; !vis[to[i]])</span><br><span class="line">            calc(to[i], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != f[x] &amp;&amp; y != son[x]) dfs2(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x]), vis[son[x]] = <span class="number">1</span>;</span><br><span class="line">    calc(x, <span class="number">1</span>);</span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="comment">// = if (son[x] &amp;&amp; son[f[x]] != x)</span></span><br><span class="line">        vis[son[x]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (son[f[x]] != x) calc(x, <span class="number">-1</span>), sum = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一种方法：线段树合并。顾名思义，也是一种合并。这是在每个节点上开一棵线段树，每次将儿子的线段树合并到父亲的线段树里。假设合并操作是 logN 的。线段树合并复杂度取决于重合节点个数，而现实中一般重合较少，可以视为 logN，因此复杂度嘛，，O(nlogn)?</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> * <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, c[N], id;</span><br><span class="line"><span class="keyword">int</span> to[N], nxt[N], lnk[N], tot;</span><br><span class="line"><span class="keyword">int</span> ls[N], rs[N], mx[N], rt[N];</span><br><span class="line">ll sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    x = ++id;</span><br><span class="line">    sum[x] = val, mx[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= mid) insert(ls[x], l, mid, val);</span><br><span class="line">    <span class="keyword">else</span> insert(rs[x], mid + <span class="number">1</span>, r, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = ls[x], r = rs[x];</span><br><span class="line">    mx[x] = mx[l], sum[x] = sum[l];</span><br><span class="line">    <span class="keyword">if</span> (mx[r] == mx[x]) sum[x] += sum[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mx[r] &gt; mx[x]) sum[x] = sum[r], mx[x] = mx[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; mx[x] += mx[y]; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ls[x] = merge(ls[x], ls[y], l, mid);</span><br><span class="line">    rs[x] = merge(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    insert(rt[x], <span class="number">1</span>, n, c[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        rt[x] = merge(rt[x], rt[y], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = sum[rt[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这题两种都很好写啊！(x</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
            <tag> 树上启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF1C]-Ancient Berland Circus</title>
      <link href="2019/03/03/%5BCF1C%5D-Ancient%20Berland%20Circus/"/>
      <url>2019/03/03/%5BCF1C%5D-Ancient%20Berland%20Circus/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1/C" target="_blank" rel="noopener">题目链接</a></p><p>平生第一道计算几何 ( *｀ω´) 有点被吓到了，创世纪初的 CF T3 都是这种风格的嘛 ∑(ﾟДﾟ)</p><p>其实题目还挺友好。这个多边形中心到给定的三个点距离相等，设这个距离为 dis、多边形中心为 O，我们以 O 为圆心，以 dis 为半径作圆，这就是俗称的“外接圆”啦。三个点也都在这个外接圆上。</p><p>我们发现，多边形边数越少，其面积越小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1123]-BLO</title>
      <link href="2019/03/03/%5BBZOJ1123%5D-BLO/"/>
      <url>2019/03/03/%5BBZOJ1123%5D-BLO/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1123" target="_blank" rel="noopener">题目链接</a></p><p>根据割点的定义，若节点 $i$ 不是割点，则把与 $i$ 相连的边删除后，只有 $i$ 与其他 $n - 1$ 个点不连通，而其他 $n - 1$ 个点之间还都是连通的，（注意是有序点对！）则此时答案为 $2(n - 1)$.</p><p>否则，去掉 $i$ 后，会分成若干个连通块，我们应求出每个连通块的大小，两两相乘再相加。</p><p>我们可以在 Tarjan 算法执行深度优先遍历的过程中，顺便求出搜索树每棵子树的大小，这样，如果 $y \in Son(x)$, $low[y] \geq dfn[x]$, 关于 $x$ 的边全部断了后 $y$ 及 $y$ 的子树就是一个连通分量，它的大小应该很好求吧？</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> lnk[N], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], size[N], cut[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, tot, num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt;= dfn[x]) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                ans[x] += (ll)size[y] * (n - size[y]);</span><br><span class="line">                sum += size[y];</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">1</span> || flag &gt; <span class="number">1</span>) cut[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cut[x])</span><br><span class="line">        ans[x] += (ll)(n - sum - <span class="number">1</span>) * (sum + <span class="number">1</span>) + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ans[x] = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图的连通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 541 Div2</title>
      <link href="2019/02/24/Codeforces%20Round%20541%20Div2/"/>
      <url>2019/02/24/Codeforces%20Round%20541%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1131" target="_blank" rel="noopener">题目链接</a></p><p>唉，还是有很大的进步空间啊。做了 A 和 C，B 和 D 都调不出来。。</p><h3 id="A-Sea-Battle"><a href="#A-Sea-Battle" class="headerlink" title="A. Sea Battle"></a>A. Sea Battle</h3><hr><p>签到题。</p><h3 id="B-Draw"><a href="#B-Draw" class="headerlink" title="B. Draw!"></a>B. Draw!</h3><hr><p>是 min(a[i], b[i]) - max(a[i - 1], b[i - 1]) + 1 没错了。。但是要考虑 a[i - 1] = b[i - 1] 的情况！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll aa, bb; <span class="built_in">cin</span> &gt;&gt; aa &gt;&gt; bb;</span><br><span class="line">        <span class="keyword">if</span> (aa == a &amp;&amp; bb == b) <span class="keyword">continue</span>;</span><br><span class="line">        ans += max(<span class="number">0L</span>L, min(aa, bb) - max(a, b) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) ans--;</span><br><span class="line">        swap(a, aa), swap(b, bb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Birthday"><a href="#C-Birthday" class="headerlink" title="C. Birthday"></a>C. Birthday</h3><hr><p>说实话没想到居然一下就 A 了(<em>ˉ︶ˉ</em>)</p><p>记得以前 CF 上见到过 C 题出这种构造方式的，觉得很新奇🤔</p><p>给 a[] 排序，然后 i 从 1 开始枚举，每次 += 2。i 和 i + 1 一个放在 ans[] 中 i 位置，一个放在 n - i + 1 的位置，具体放哪要看哪种最优（即使最大差值增加得最慢）。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>], ans[<span class="number">105</span>], maxn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[l] = a[n]; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        ans[l] = a[i], ans[r] = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp = max(x - ans[l - <span class="number">1</span>], y - ans[r + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; maxn) &#123;</span><br><span class="line">            l++, r--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - ans[l - <span class="number">1</span>] &lt; tmp &amp;&amp; x - ans[r + <span class="number">1</span>] &lt; tmp)</span><br><span class="line">            swap(ans[l], ans[r]);</span><br><span class="line">        maxn = max(maxn, max(ans[l] - ans[l - <span class="number">1</span>], ans[r] - ans[r + <span class="number">1</span>]));</span><br><span class="line">        l++, r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Gourmet-choice"><a href="#D-Gourmet-choice" class="headerlink" title="D. Gourmet choice"></a>D. Gourmet choice</h3><hr><p>一开始是想到了拓扑，但没想到缩点来着，后来越敲越乱，弃疗了。。</p><p>没错，正解就是暴力拓扑 + 缩点。缩点其实不可怕，就是并查集啦（此题不用 Tarjan）。aij = ‘=’ 时，将 i 和 j 并一下；aij = ‘&gt;’ 时，建立一条 i 指向 j 的边；’&lt;’ 时，建立 j 指向 i 的边。</p><p>检查有没有自环（即自己大于自己）和环（a1 &gt; a2 &gt; … &gt; ak &gt; a1），如果有，输出 No，否则根据拓扑结果输出答案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> fa[N], deg[N], vis[N], len[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; len[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (v == u) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) &#123;  <span class="comment">// 有环</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v] == <span class="number">2</span>) &#123;</span><br><span class="line">            len[u] = max(len[u], len[v] + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            len[u] = max(len[u], len[v] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span> (s[i][j] == <span class="string">'='</span>) fa[getfa(i)] = getfa(j + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i][j] == <span class="string">'&gt;'</span>) g[getfa(i)].push_back(getfa(j + n)), deg[getfa(j + n)]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">'&lt;'</span>) g[getfa(j + n)].push_back(getfa(i)), deg[getfa(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="keyword">if</span> (!deg[i]) dfs(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="keyword">if</span> (vis[i] != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, len[getfa(i)]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, len[getfa(i + n)]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-String-Multiplication"><a href="#E-String-Multiplication" class="headerlink" title="E. String Multiplication"></a>E. String Multiplication</h3><hr><p>首先应该想到 DP：f[i, j] 表示 $p_1 <em> p_2 </em> … * p_i$ 的结果中 j 字母的最长串的长度。</p><p>设 $S_i = p_1 <em> … </em> p_i$，最后一定是 $S_{n - 1} * p_n$。按照 pn 分类讨论，一共有三种情况：</p><p>设 pn 的开头字符是 c0, 结尾字符是 c1，包含开头的连续段的长度是 pre，包含结尾的连续段的长度是 suf。</p><ol><li><p>$c0 \neq c1$，答案可以是三个：(1). 可以是 pn 中最长的连续子段；(2). 如果 $S_{n - 1}$ 中存在 c0，pre + 1；(3). 如果 $S_{n - 1}$ 中存在 c1，suf + 1。</p></li><li><p>c0 = c1, 并且整个串不只有一种字符：如果 $S_{n - 1}$ 中存在 c0，那么答案可以是 pre + suf + 1.</p></li><li><p>如果 pn 只由一种字符构成，那么求 $S_{n - 1}$ 中最长的字符是 c0 连续段的，设为 t，答案就是 $pre * (t + 1) + t$.</p></li></ol><p>注意记录输出方案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">30</span>], pre[<span class="number">30</span>], suf[N];  <span class="comment">// pre:前缀 suf:后缀</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;  <span class="comment">// p[1] 的最长相同子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= l; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) mx = max(mx, ++cnt);</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">        f[j] = mx, pre[j] = suf[j] = <span class="number">0</span>;  <span class="comment">// 不要忘记置 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) ++pre[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i; i--)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) ++suf[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    solve(f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        solve(f[i]);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">if</span> (pre[j] != l) <span class="comment">// 判断 pi 是否全由 j 组成</span></span><br><span class="line">                    f[i][j] = max(f[i][j], pre[j] + suf[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = max(f[i][j], l * (f[i - <span class="number">1</span>][j] + <span class="number">1</span>) + f[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) ans = max(ans, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Asya-And-Kittens"><a href="#F-Asya-And-Kittens" class="headerlink" title="F. Asya And Kittens"></a>F. Asya And Kittens</h3><hr><p>这道看很多人一开始就去 A 了呀，果然比 E 题简单 🤔 并查集模拟就好啦。</p><p>对于每次的 (x, y), “并” 其实是并 x 所在的块的最右边一个和 y 所在的块的最左边一个，就像真的合并一样。记录某个块的最右端和最左端就可以了。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n, d[N], pre[N], nxt[N], fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    g[u].push_back(v), g[v].push_back(u);</span><br><span class="line">    d[u]++, d[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (g[x][i] != fa) print(g[x][i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = nxt[i] = fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        x = getfa(x), y = getfa(y);</span><br><span class="line">        add(nxt[x], pre[y]);</span><br><span class="line">        nxt[x] = nxt[y];</span><br><span class="line">        fa[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (d[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        root = i; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要加油！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG4314]-CPU监控</title>
      <link href="2019/02/22/%5Bluogu4314%5D-CPU%E7%9B%91%E6%8E%A7/"/>
      <url>2019/02/22/%5Bluogu4314%5D-CPU%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4314" target="_blank" rel="noopener">题目链接</a></p><p>AC之旅真是坎坷啊。。一上来，咦，这不是模版题嘛，深蓝题是群众误评嘛 qwq</p><p>然后敲完一交，哎哟啧，爆零哇。。。去翻了翻题解，发现这个问题还真是隐蔽。</p><p>题解里是这样说的：</p><p>“按原来的方法会有一点 bug  ，就是很有可能会出现这样的情况：对于某个结点 i ，在它的标记还没有下放的时候，它的父亲又下放了新的标记给它，于是就将原来的标记覆盖了，丢失了原来的那一次修改的值，这样在查询历史最大值的时候就有可能出现错误的答案。</p><p>“如果只记录区间历史最大值显然不能下放，如果单纯更新区间加，区间赋值最大值，可能会出现历史最大值更新不及时的情况。如先赋值很大值，未来得及下放，又赋值很小，导致子区间历史最大值不能更新。又如如果区间加只取最大值，可能会只取最大值，导致实际上忽视了一些使区间加变小的操作。”</p><p>如果次次下放标记，那显然复杂度太高了。</p><p>为了不错过每一次操作产生的贡献，我们对于每一个区间 $x$ 存储它从上一次 pushdown 到现在的最大加法操作和最大赋值操作，这样显然是正确的。</p><p>总之还是很棒的啊，至少比之前的所以模版题好！！！就是要做这样的（虐）题 ( ´▽｀)</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll add, c;</span><br><span class="line">    ll mx, hx;</span><br><span class="line">    ll ha, hc;  <span class="comment">// h = history</span></span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].mx = max(t[x &lt;&lt; <span class="number">1</span>].mx, t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    t[x].hx = max(t[x &lt;&lt; <span class="number">1</span>].hx, t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].hx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = x &lt;&lt; <span class="number">1</span> | i;  <span class="comment">// s = son</span></span><br><span class="line">        t[s].hx = max(t[s].hx, max(t[s].mx + t[x].ha, t[x].hc));</span><br><span class="line">        <span class="keyword">if</span> (t[s].c != -inf)</span><br><span class="line">            t[s].hc = max(t[s].hc, t[s].c + t[x].ha);</span><br><span class="line">        <span class="keyword">else</span> t[s].ha = max(t[s].ha, t[s].add + t[x].ha);</span><br><span class="line">        <span class="keyword">if</span> (t[x].add) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[s].c != -inf) t[s].c += t[x].add;</span><br><span class="line">            <span class="keyword">else</span> t[s].add += t[x].add;</span><br><span class="line">            t[s].mx += t[x].add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[x].c != -inf) &#123;</span><br><span class="line">            t[s].mx = t[s].c = t[x].c;</span><br><span class="line">            t[s].add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t[s].hc = max(t[s].hc, max(t[s].c, t[x].hc));</span><br><span class="line">        t[s].ha = max(t[s].ha, t[s].add);</span><br><span class="line">    &#125;</span><br><span class="line">    t[x].hc = t[x].c = -inf;</span><br><span class="line">    t[x].add = t[x].ha = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[x].add = t[x].ha = <span class="number">0</span>;</span><br><span class="line">    t[x].c = t[x].hc = -inf;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ll tmp; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;tmp);</span><br><span class="line">        t[x].mx = t[x].hx = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        t[x].mx += val;</span><br><span class="line">        t[x].add += val;</span><br><span class="line">        t[x].ha += val;</span><br><span class="line">        t[x].hx = max(t[x].hx, t[x].mx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l != r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        t[x].c = val;</span><br><span class="line">        t[x].mx = val;</span><br><span class="line">        t[x].hc = val;</span><br><span class="line">        t[x].hx = max(t[x].hx, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) change(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) change(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">queryhis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> t[x].hx;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) sum = queryhis(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) sum = max(sum, queryhis(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">querynow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> t[x].mx;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) sum = querynow(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) sum = max(sum, querynow(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, queryhis(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, querynow(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'P'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">            change(<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 538 Div2</title>
      <link href="2019/02/11/Codeforces%20Round%20538%20Div2/"/>
      <url>2019/02/11/Codeforces%20Round%20538%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1114" target="_blank" rel="noopener">比赛链接</a></p><p>Div2怎么这么难呀，趋于数学化了 🤔️</p><h3 id="A-Got-Any-Grapes"><a href="#A-Got-Any-Grapes" class="headerlink" title="A. Got Any Grapes?"></a>A. Got Any Grapes?</h3><hr><p>签到题，然而第一次提交把紫葡萄和黑葡萄的顺序看错了。。。成功 -50。。。</p><h3 id="B-Yet-Another-Array-Partitioning-Task"><a href="#B-Yet-Another-Array-Partitioning-Task" class="headerlink" title="B. Yet Another Array Partitioning Task"></a>B. Yet Another Array Partitioning Task</h3><hr><p>这题看着有点眼熟，好像 Global Round 1 的 B 题呀 🤔</p><p>一开始想各种贪心，好像都不大可行。其实注意到了 Input 数据范围里有个 $m <em> k \leq n$, 但不知道有啥用。后来才知道，是因为首先你得选前 $m </em> k$ 大的吧！这样，你将前 $m * k$ 大的记录下来，每隔 k 个分一组，既满足了每组数量 &gt;= m, 又是最优解。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], mark[N], ret[N], cnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, num;</span><br><span class="line">&#125;b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.num &gt; b.num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[i].num = a[i], b[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * k; i++) &#123;</span><br><span class="line">        mark[b[i].id] = <span class="number">1</span>; tot += b[i].num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[i]) sum++;</span><br><span class="line">        <span class="keyword">if</span> (sum == m) ret[++cnt] = i, sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ret[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Trailing-Loves-or-L’oeufs"><a href="#C-Trailing-Loves-or-L’oeufs" class="headerlink" title="C. Trailing Loves (or L’oeufs?)"></a>C. Trailing Loves (or L’oeufs?)</h3><hr><p>啊！这是个玄学题！</p><p>首先我们来看看 10 进制：10 进制下求 n! 末尾 0 的个数很容易吧，找出 1 ～ n 中 2 和 5 作为因子的个数 a 和 b，答案就是 min(a, b).</p><p>由此我们可以大胆猜想，b 进制下求 n! 末尾 0 的个数是同样做法。我们把 b 写成 $b = p_1^{a_1} <em> p_2^{a_2} </em> … * p_k^{a_k}$ 的形式.</p><p>众所周知，1 ～ n 中 p 的倍数的个数为 n / p 下取整。这里我们要找出对于每一个 p，它作为因子的个数，即 f(n, p). f(n, p) = n / p + n / (p ^ 2) + n / (p ^ 3). 注意求 f(n, p) 的时候不能先算 (p ^ k), 而应该用不断除的形式，避免精度误差，这一段下面代码中有具体方法。</p><p>f(n, pi) 记入答案时要除以 ai, 这个自己理解一下就可以。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, b, ans;</span><br><span class="line">ll ok[<span class="number">1000010</span>], prime[<span class="number">1000010</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Is</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok[i]) prime[++cnt] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= <span class="number">1000000</span>; j++) ok[i * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll tmpN = x, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmpN) tmpN /= y, res += tmpN;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;b);</span><br><span class="line">    Is();</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    ll tmp = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        ll p = prime[i];</span><br><span class="line">        <span class="keyword">if</span> (p &gt; b) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (b % p) <span class="keyword">continue</span>;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, tot++;</span><br><span class="line">        ll now = f(n, p) / tot;</span><br><span class="line">        ans = min(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = min(ans, f(n, tmp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Flood-Fill"><a href="#D-Flood-Fill" class="headerlink" title="D. Flood Fill"></a>D. Flood Fill</h3><hr><p>这个题是区间的问题，肯定不是线性的，这时候应该考虑一下区间DP啦。一想到区间DP就会有想法了！是不是很像烤乐滋打虎  🤔</p><p>设 f[i, j, k] 表示区间[i, j]已经是同一个颜色 p 了，其中如果 k = 0，p = c[i], 否则 p = c[j]. 因为一段区间的改变颜色的操作肯定是为了像滚雪球一样扩大同一颜色的区间嘛，所以颜色不是左端点的就是右端点的。</p><p>转移看代码。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, c[N], f[N][N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[l][r][sta] != <span class="number">-1</span>) <span class="keyword">return</span> f[l][r][sta];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (sta == <span class="number">0</span>) &#123;</span><br><span class="line">        res = min(res, dp(l + <span class="number">1</span>, r, <span class="number">0</span>) + (c[l] != c[l + <span class="number">1</span>]));</span><br><span class="line">        res = min(res, dp(l + <span class="number">1</span>, r, <span class="number">1</span>) + (c[l] != c[r]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = min(res, dp(l, r - <span class="number">1</span>, <span class="number">0</span>) + (c[r] != c[l]));</span><br><span class="line">        res = min(res, dp(l, r - <span class="number">1</span>, <span class="number">1</span>) + (c[r] != c[r - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[l][r][sta] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(dp(<span class="number">1</span>, n, <span class="number">0</span>), dp(<span class="number">1</span>, n, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 1</title>
      <link href="2019/02/08/Codeforces%20Global%20Round%201/"/>
      <url>2019/02/08/Codeforces%20Global%20Round%201/</url>
      
        <content type="html"><![CDATA[<p>做了 A 和 B，也算不错啦</p><p><a href="http://codeforces.com/contest/1110" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Parity"><a href="#A-Parity" class="headerlink" title="A. Parity"></a>A. Parity</h3><hr><p>奇偶性判断，注意 $a_k$ 的情况就好啦。（即 $b^0$ ）.</p><h3 id="B-Tape"><a href="#B-Tape" class="headerlink" title="B. Tape"></a>B. Tape</h3><hr><p>老了，脑子不好使啦… 想了半天，最开始想到的是隔板法，放 k - 1 个板，但是后来发现只要稍加转换就能变为，b[n] - b[1] + 1 - sum, 其中 sum 为最大的 k - 1 个间隔长度之和。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> b[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> tot = b[n] - b[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) c[i] = b[i + <span class="number">1</span>] - b[i] - <span class="number">1</span>;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) tot -= c[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Meaningless-Operations"><a href="#C-Meaningless-Operations" class="headerlink" title="C. Meaningless Operations"></a>C. Meaningless Operations</h3><hr><p>设 a 的最高位是第 x 位，则 $2^x \leq a$, $a_{max} = 2^x - 1$. 设 $b = 2^x - 1\oplus a$, 则 $f(a) = max\{gcd(2^x - 1, 0)\}$ , 即 $2^x - 1$，为最大值。</p><p>若 $a = 2^x - 1$，因为 b &lt; a = $2 ^ x - 1$, 所以 $f(a) = max\{gcd(2^x - 1 - b, b)\}$, 因为 $gcd(x, y) = gcd(x, x + y)$, 所以 $f(a) = max\{gcd(2^x - 1, b)\}$，这时找到 $2^x - 1$ 的最小质因子 t，答案就是 $\frac{2^x - 1}{t}$.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> q, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxn &lt;= x) maxn &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        maxn--;</span><br><span class="line">        <span class="keyword">if</span> (x == maxn) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= maxn; i++) <span class="keyword">if</span> (maxn % i == <span class="number">0</span>) &#123; flag = maxn / i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Jongmah"><a href="#D-Jongmah" class="headerlink" title="D. Jongmah"></a>D. Jongmah</h3><hr><p>一个挺暴力的题，但官方正解是 DP。</p><p>首先！因为 [x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2] 总能被三组 [x, x + 1, x + 2] 所代替，我们设这时就尽量用 [x, x + 1, x + 2].</p><p>这时可以这样：设 dp[i, t1, t2] 表示前 i 种数字，有 t1 组 [i - 1, i, i + 1], t2 组 [i, i + 1, i + 2], 我们枚举 t3 表示有 t3 组 [i + 1, i + 2, i + 3], 然后转移到 dp[i + 1, t2, t3].</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, x, a[N], dp[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j + k + l &gt; a[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i][k][l] = max(dp[i][k][l], dp[i - <span class="number">1</span>][j][k] + l + (a[i] - j - k - l) / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Magic-Stones"><a href="#E-Magic-Stones" class="headerlink" title="E. Magic Stones"></a>E. Magic Stones</h3><hr><p>可以这样看：设 $d_i = c_{i + 1} - c_i$, $c_i^, = c_{i + 1} + c_{i - 1} - c_{i}$.</p><p>当将 $c_i$ 变为 $c_i^,$ 时：</p><p>· $d_{i - 1} = c_i - c_{i - 1} = c_{i + 1} - c_i = d_i$</p><p>· $d_i = c_{i + 1} - c_i = c_i - c_{i - 1} = d_{i - 1}$</p><p>发现了吗？$d_i$ 与 $d_{i - 1}$ 交换了！</p><p>所以不管序列 c 怎么变，序列 d 总是不变的。所以只要判断两个序列的序列 d 是否相同就可以了。</p><p>注意！需要判断 s[1] 是否等于 t[1]。因为第一个位置是变不了的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, c[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">1</span>] != t[<span class="number">1</span>]) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    per(i, n, <span class="number">1</span>) c[i] -= c[i - <span class="number">1</span>];</span><br><span class="line">    per(i, n, <span class="number">1</span>) t[i] -= t[i - <span class="number">1</span>];</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (c[i] != t[i]) &#123; ok = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ4542]-大数</title>
      <link href="2019/02/07/%5BBZOJ4542%5D-%E5%A4%A7%E6%95%B0/"/>
      <url>2019/02/07/%5BBZOJ4542%5D-%E5%A4%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4542" target="_blank" rel="noopener">题目链接</a></p><p>首先！我们要提到一个模运算的性质：</p><script type="math/tex; mode=display">(a + b)\ mod\ p = (a\ mod\ p + b\ mod\ p)\ mod\ p</script><p>然后就可以开始了。</p><h2 id="P-neq-2-5-的情况："><a href="#P-neq-2-5-的情况：" class="headerlink" title="$P \neq 2, 5$ 的情况："></a>$P \neq 2, 5$ 的情况：</h2><p>要计算一个区间能否整除 P，是不可能的，我们可以这么转化：</p><p>首先，可以 $O(n)$ 预处理出 $S[i … n] % P$, 这要用到上面的性质。</p><p>如果 $S[l … n] - S[r + 1 … n] \equiv 0 (mod P)$, 那么 $S[l … r] \equiv 0 (mod P)$.</p><p>这样，问题就转化成了：求在 [L, R] 这个区间内，有多少个 S[i … n] % P 是相同的，其中 L &lt;= i &lt;= R. 莫队套路，是吧？</p><h2 id="P-2-5-的情况："><a href="#P-2-5-的情况：" class="headerlink" title="$P = 2, 5$ 的情况："></a>$P = 2, 5$ 的情况：</h2><p>特判。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll P, a = <span class="number">0</span>, b[N], c[N], sum, cnt[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, unit;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l / unit == b.l / unit ? a.r &lt; b.r : a.l / unit &lt; b.l / unit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    sum -= cnt[b[x]] * (cnt[b[x]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) cnt[b[x]]++;</span><br><span class="line">    <span class="keyword">else</span> cnt[b[x]]--;</span><br><span class="line">    sum += cnt[b[x]] * (cnt[b[x]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>];</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>];  <span class="comment">// 此处的 cnt[i] 表示 1 ～ i 中有多少个 s[i] 是 P 的倍数</span></span><br><span class="line">        <span class="keyword">if</span> ((s[i] - <span class="string">'0'</span>) % p == <span class="number">0</span>) ans[i] += i, cnt[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[r] - ans[l - <span class="number">1</span>] - (cnt[r] - cnt[l - <span class="number">1</span>]) * (l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;P);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="number">2</span> || P == <span class="number">5</span>) &#123;</span><br><span class="line">        solve(P); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll Fac = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        b[i] = c[i] = a = (a + Fac * (s[i] - <span class="string">'0'</span>)) % P;</span><br><span class="line">        Fac = Fac * <span class="number">10</span> % P;</span><br><span class="line">    &#125;</span><br><span class="line">    b[++n] = c[n] = <span class="number">0</span>;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(c + <span class="number">1</span>, c + n + <span class="number">1</span>) - c - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = lower_bound(c + <span class="number">1</span>, c + tot + <span class="number">1</span>, b[i]) - c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    unit = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        ++q[i].r;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; q[i].r) update(++R, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (R &gt; q[i].r) update(R--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (L &gt; q[i].l) update(--L, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; q[i].l) update(L++, <span class="number">0</span>);</span><br><span class="line">        ans[q[i].id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ4160]-Exclusive Access 2</title>
      <link href="2019/02/05/%5BBZOJ4160%5D-Exclusive%20Access%202/"/>
      <url>2019/02/05/%5BBZOJ4160%5D-Exclusive%20Access%202/</url>
      
        <content type="html"><![CDATA[<p>题意：给出 $N$ 个点 $M$ 条边的无向图，定向得到有向无环图，使得最长路最短。$N \leq 15$, $M \leq 100$.</p><p>这题真好啊！</p><p>是比赛 $T2$。一开始觉得没想法，然后码了个暴力，结果一个子任务中有一个点T了，一分都没有……</p><p>现在要正经地讲正解了！首先，有向无环图是一个切入点。我们对于第 i 个点，设它的深度为 $di$. 因为“无环”，所以对于每一条边 $&lt; v1, v2 &gt;$, $d1$ 永远小于 $d2$。</p><p>假设，这样的图存在环，那么 $d1 &lt; d2 &lt; d3 &lt; … &lt; dk &lt; d1$, 这不成立，所以该图不存在环。</p><p>在这样的图中，最长链为 $dmax - dmin$. Hint！要输出 $ans - 1$ 哦。</p><p>为了使 $dmax - dmin$ 最小，我们要使图的深度最小。怎么办呢？二进制DP。</p><p>我们设 $f(node)$ 为选择了一些点时的最小深度，其中 $node$ 为 $N$ 位二进制数表示每个点是否取。设 $leaves$ 为该图的叶子结点，那么，$f(node) = min{f(node - leaves) + 1}$.</p><p>叶子结点彼此之间是不连边的，所以可以预处理出 $ok(node)$ 表示当 $node$ 这些点能否为 $leaves$。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, mp[<span class="number">30</span>], cnt, G[<span class="number">30</span>][<span class="number">30</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">15</span>], ok[<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>], s2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">if</span> (mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>] == <span class="number">-1</span>) mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>] = cnt++;</span><br><span class="line">        <span class="keyword">if</span> (mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>] == <span class="number">-1</span>) mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>] = cnt++;</span><br><span class="line">        G[mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>]][mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>]] = G[mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>]][mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++) &#123;</span><br><span class="line">        ok[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cnt; k++)</span><br><span class="line">                <span class="keyword">if</span> (j != k &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; j)) &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; k)) &amp;&amp; G[j][k]) &#123;</span><br><span class="line">                    ok[i] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = i; t; t = (t - <span class="number">1</span>) &amp; i)</span><br><span class="line">            <span class="keyword">if</span> (ok[t])</span><br><span class="line">                f[i] = min(f[i], f[i - t] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算(bits)</title>
      <link href="2019/01/31/%E4%BD%8D%E8%BF%90%E7%AE%97(bits)/"/>
      <url>2019/01/31/%E4%BD%8D%E8%BF%90%E7%AE%97(bits)/</url>
      
        <content type="html"><![CDATA[<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>定义 G(x) 为 x 的二进制表示中 1 的个数。</p><p>小C有一个奇妙的方程</p><script type="math/tex; mode=display">x_1\ opt_1\ x_2\ opt_2\ x_3\ ...\ x_{n - 1}\ opt_{n - 1}\ x_n\ =\ c</script><p>其中 $opt_i$ 为 AND, OR, XOR 三种位运算中的一种。我们定义优先级是相同的，即计算顺序为从左到右。</p><p>此外，对于 $x_i$, 须满足 $0 \leq x_i &lt; 2^m$ 且 $G(x_i) = a_i$, 保证 $0 \leq c &lt; 2^m$.</p><p>求一组 $x_i$ 的取值满足上述所有约束。若不存在，输出 OvO。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>A掉了这道巨题，窝很开心啊( ´▽｀)</p><p>这道题嘛，首先要熟悉三种位运算的性质啦。</p><p>虽然要给出一组 x 的解，但只要知道了 $G(x_i)$, 就能造出 $x_i$. 所以我们先搞出 $G(x_i)$! 选择DP啦～</p><p>设 $f[i, j]$ 表示前 i 个 x 位运算后的结果中的为 1 的二进制位为 j 个。为了方便计算答案，设 $g[i, j]$ 存储前 i 个 x 位运算后的结果中的为 1 的二进制位为 j 个时，设前 i - 1 位个 x 位运算后的结果为 t，G(t) = p ，和 t 与 a[i] 共同有 q 位是同为 1 的。我们可以用 pair 型的来存 (p, q).</p><p>转移的时候枚举 $x_i$ 和 $x_{i + 1}$ 共有 k 位同为 1 的，那么分开来讨论就好啦，即从 $f[i, j]$ 转移到 $f[i + 1, ?]$.</p><p>统计答案。可以通过结果和第一个加数将第二个加数二进制位上的 1 补齐，即根据结果分三种情况讨论。</p><p>挺好的一道题呀，不适合普及组的难度qwq</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c, c_num;</span><br><span class="line"><span class="keyword">int</span> a[N], ans[N], f[N][<span class="number">60</span>], tmp[N];</span><br><span class="line">pii g[N][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;c);</span><br><span class="line">    c_num = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'X'</span>) tmp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) tmp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'O'</span>) tmp[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c_num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_num &amp; <span class="number">1</span>) cnt++; c_num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j, a[i + <span class="number">1</span>]); k++) &#123;  <span class="comment">// 枚举 j 和 a[i + 1] 共同为 1 的位数（k）</span></span><br><span class="line">                    <span class="keyword">if</span> (j + a[i + <span class="number">1</span>] - k &lt;= m) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tmp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - <span class="number">2</span> * k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - <span class="number">2</span> * k] = make_pair(j, k);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][k] = make_pair(j, k);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - k] = make_pair(j, k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f[n][cnt]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"OvO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = cnt, result = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        pii u = g[i][now];</span><br><span class="line">        <span class="keyword">int</span> numlst = <span class="number">0</span>, numnow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntlst = u.first, cntnow = a[i], both = u.second;</span><br><span class="line">        cntlst -= both, cntnow -= both;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = numnow;</span><br><span class="line">        result = numlst;</span><br><span class="line">        now = u.first;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018普及组题解</title>
      <link href="2018/11/26/NOIP2018%E6%99%AE%E5%8F%8A%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
      <url>2018/11/26/NOIP2018%E6%99%AE%E5%8F%8A%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="A-标题统计"><a href="#A-标题统计" class="headerlink" title="A. 标题统计"></a>A. 标题统计</h3><hr><p>用gets<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>], ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">        ch = s[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-龙虎斗"><a href="#B-龙虎斗" class="headerlink" title="B. 龙虎斗"></a>B. 龙虎斗</h3><hr><p>全开longlong！！全！！！开！！！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, c[<span class="number">100005</span>], m, p1, s1, s2, l, r;</span><br><span class="line">ll ans, minn = <span class="number">1e9</span>, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; p1 &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    c[p1] += s1;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; m; i++) l += c[i] * (m - i);</span><br><span class="line">    <span class="keyword">for</span> (ll i = m + <span class="number">1</span>; i &lt;= n; i++) r += c[i] * (i - m);</span><br><span class="line">    ll s = <span class="built_in">abs</span>(l - r);</span><br><span class="line">    minn = s, ans = m;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = m + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(s - s2 * (i - m)) &lt; minn) &#123;</span><br><span class="line">                minn = <span class="built_in">abs</span>(s - s2 * (i - m)), ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(s - s2 * (m - i)) &lt;= minn) &#123;</span><br><span class="line">                minn = <span class="built_in">abs</span>(s - s2 * (m - i)), ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-摆渡车"><a href="#C-摆渡车" class="headerlink" title="C. 摆渡车"></a>C. 摆渡车</h3><hr><p>第一次是70分——大概就是DP方程对叻但没有优化那种。</p><p>说实话这个DP真的有点晕啊！下标琢磨了半天，导致T4时间严重不够。【以后拿到题目先全部看一遍喔</p><p>记 f[i] 表示第 i 分钟刚好从一趟回来的最小等待时间，转移也可以表示成 $f[i] = \min_{i - 2m &lt; j \leq i - m}\{f[j] + k\}$, 其中 k 是 j 在路上时等待的时间之和加上 j 回来后的等待时间之和。注意是完全背包！！所以从小往大枚举 i。还有最后答案不是 f[t[n]] 而是 f[t[n] + m - 1]!! </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t[<span class="number">505</span>], f[<span class="number">4000005</span>], T[<span class="number">4000005</span>];</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) sum += (r - i) * T[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; t[i], T[t[i]]++;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t[n] + m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = max(<span class="number">0</span>, i - <span class="number">2</span> * m + <span class="number">1</span>), r = max(<span class="number">0</span>, i - m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt;= f[j] + calc(max(<span class="number">0</span>, j - m + <span class="number">2</span>), max(<span class="number">0</span>, i - m + <span class="number">1</span>))) &#123;</span><br><span class="line">                f[i] = f[j] + calc(max(j - m + <span class="number">2</span>, <span class="number">0</span>), max(<span class="number">0</span>, i - m + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[t[n] + m - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>100分明天补。</p><h3 id="D-对称二叉树"><a href="#D-对称二叉树" class="headerlink" title="D. 对称二叉树"></a>D. 对称二叉树</h3><hr><p>然而，，，暴力就好了！</p><p>为什么呢？</p><p>每一次 chk 操作，当二叉树为完全二叉树时，时间复杂度最大，为树高，即为 $log_2 n$；进行 n 次，时间复杂度为 $n log_2 n$。</p><p>非完全二叉树时就更快了，因为很容易不满足对称要求，就被剪枝剪掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa, l, r, w, num;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> n, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p[x].num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[x].l &gt; <span class="number">0</span>) upd(p[x].l), p[x].num += p[p[x].l].num;</span><br><span class="line">    <span class="keyword">if</span> (p[x].r &gt; <span class="number">0</span>) upd(p[x].r), p[x].num += p[p[x].r].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">0</span> &amp;&amp; v &gt; <span class="number">0</span> &amp;&amp; p[u].w == p[v].w &amp;&amp; chk(p[u].l, p[v].r) &amp;&amp; chk(p[u].r, p[v].l))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[i].l = x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) p[x].fa = i;</span><br><span class="line">        p[i].r = y;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) p[y].fa = i;</span><br><span class="line">    &#125;</span><br><span class="line">    upd(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (chk(p[i].l, p[i].r)) ans = max(ans, p[i].num);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG1365]-WJMZBMR打osu!</title>
      <link href="2018/11/01/%5Bluogu1365%5D-WJMZBMR%E6%89%93osu%EF%BC%81/"/>
      <url>2018/11/01/%5Bluogu1365%5D-WJMZBMR%E6%89%93osu%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1365" target="_blank" rel="noopener">题目链接</a></p><p>期望DP！</p><p>设 f[i] 表示到了第 i 位的总期望，g[i] 表示到了第 i 位结尾的连续 o 的期望长度，那么：</p><ol><li>当 s[i] = x, 则 f[i] = f[i - 1], g[i] = 0.</li><li>当 s[i] = o, 则 f[i] = f[i - 1] + 2g[i - 1] + 1, g[i] = g[i - 1] + 1(这一步可以根据完全平方公式推出)</li><li>当 s[i] = ?, 则 f[i] = f[i - 1] + g[i - 1] + 0.5, g[i] = (g[i - 1] + 1) / 2.</li></ol><p>我们发现转移时的状态只与上一轮的状态有关，所以可以使用滚动数组节省空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, now;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">2</span>], g[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'x'</span>) f[now ^ <span class="number">1</span>] = f[now], g[now ^ <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'o'</span>) f[now ^ <span class="number">1</span>] = f[now] + <span class="number">2</span> * g[now] + <span class="number">1</span>, g[now ^ <span class="number">1</span>] = g[now] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[now ^ <span class="number">1</span>] = f[now] + g[now] + <span class="number">0.5</span>, g[now ^ <span class="number">1</span>] = g[now] / <span class="number">2</span> + <span class="number">0.5</span>;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, f[now]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 518 Div2</title>
      <link href="2018/10/28/Codeforces%20Round%20518%20Div2/"/>
      <url>2018/10/28/Codeforces%20Round%20518%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1068" target="_blank" rel="noopener">比赛链接</a></p><p>是vp的</p><h3 id="A-Birthday"><a href="#A-Birthday" class="headerlink" title="A. Birthday"></a>A. Birthday</h3><hr><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k, l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k + l &gt; n || m &gt; n) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tmp;</span><br><span class="line">        <span class="keyword">if</span> ((l + k) % m == <span class="number">0</span>) tmp = (l + k) / m;</span><br><span class="line">        <span class="keyword">else</span> tmp = (l + k) / m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp * m &gt; n) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-LCM"><a href="#B-LCM" class="headerlink" title="B. LCM"></a>B. LCM</h3><hr><p>数学妙题，$\frac{[a, b]}{a}=\frac{b}{gcd(a, b)}$, 所以其实就是求 b 的约数个数。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll vis[N], prime[N], cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">()</span> </span>&#123;  <span class="comment">// 筛质数</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (ll j = i * i; j &lt;= <span class="number">100000</span>; j += i) vis[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 计算约数个数</span></span><br><span class="line">    ll ans, sum;</span><br><span class="line">    ans = <span class="number">0</span>, sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++; n /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum *= (ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) sum *= (<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Prime();</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; work(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Colored-Rooks"><a href="#C-Colored-Rooks" class="headerlink" title="C. Colored Rooks"></a>C. Colored Rooks</h3><hr><p>构造题，应该要用尽量简单的方式。比如说这题，可以在 (i, i) 上放第 i 种颜色的车，这样保证每种颜色都占据一格且互不相连。接下来可以在互不相连的基础上添加相连颜色的车，即如果颜色 a 和颜色 b 是一对，那么就在 (a, j) 和 (b, j) 上放一对车。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pos[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pos[i].push_back(make_pair(i, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        pos[x].push_back(make_pair(x, n + i));</span><br><span class="line">        pos[y].push_back(make_pair(y, n + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pos[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)pos[i].size(); j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; pos[i][j].first &lt;&lt; <span class="string">' '</span> &lt;&lt; pos[i][j].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 514 Div2</title>
      <link href="2018/10/21/Codeforces%20Round%20514%20Div2/"/>
      <url>2018/10/21/Codeforces%20Round%20514%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1059" target="_blank" rel="noopener">比赛链接</a></p><p>这场因为第一题题意不懂，就卡在第一题上了，导致爆零。</p><h3 id="A-Cashier"><a href="#A-Cashier" class="headerlink" title="A. Cashier"></a>A. Cashier</h3><hr><p>这题的意思是两个时间段之间能休息多少个a。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], n, L, a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        r[i] += l[i];</span><br><span class="line">        ret += (l[i] - r[i - <span class="number">1</span>]) / a;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += (L - r[n]) / a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Forgery"><a href="#B-Forgery" class="headerlink" title="B. Forgery"></a>B. Forgery</h3><hr><p>B题需要转化一步。我们可以顺思逆想：对于 (i, j)，若它的八个方向都为 #，表示 (i, j) 这个位置有一步染色操作；否则没有。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">7</span>) <span class="keyword">if</span> (s[x + d[i][<span class="number">0</span>]][y + d[i][<span class="number">1</span>]] != <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) a[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (chk(i, j))</span><br><span class="line">                rep(k, <span class="number">0</span>, <span class="number">7</span>) a[i + d[k][<span class="number">0</span>]][j + d[k][<span class="number">1</span>]] = <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != s[i][j]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Sequence-Transformation"><a href="#C-Sequence-Transformation" class="headerlink" title="C. Sequence Transformation"></a>C. Sequence Transformation</h3><hr><p>因为两个奇数的gcd肯定是1，我们第一轮要先删掉所有奇数，然后接下来每一轮都删掉2的幂次方，这样使gcd序列变大的速度是最快的，而且增大的幅度也是最大的。</p><p>唯一一个特例就是 = 3的时候，是 1 1 3.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">4</span> &gt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> &gt; n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i * <span class="number">3</span> &gt; n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, i * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, i, i * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += (i &lt;&lt; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 516 Div2</title>
      <link href="2018/10/15/Codeforces%20Round%20516%20Div2/"/>
      <url>2018/10/15/Codeforces%20Round%20516%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1064" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Make-a-triangle"><a href="#A-Make-a-triangle" class="headerlink" title="A. Make a triangle!"></a>A. Make a triangle!</h3><hr><p>学过三角形就行了～</p><h3 id="B-Equations-of-Mathematical-Magic"><a href="#B-Equations-of-Mathematical-Magic" class="headerlink" title="B. Equations of Mathematical Magic"></a>B. Equations of Mathematical Magic</h3><hr><p>a - (a ^ x) - x = 0 ===&gt; a ^ x = a - x, 即 x 二进制位中的 1 是 a 中的子集。这也可以通过打表发现。所以就是记 cnt 为 a 中二进制位为 1 的个数，答案就是 $2^{cnt}$.</p><h3 id="C-Oh-Those-Palindromes"><a href="#C-Oh-Those-Palindromes" class="headerlink" title="C. Oh Those Palindromes"></a>C. Oh Those Palindromes</h3><hr><p>可以发现，将相同的数字排列在一起，回文字串数目最大。</p><h3 id="D-Labyrinth"><a href="#D-Labyrinth" class="headerlink" title="D. Labyrinth"></a>D. Labyrinth</h3><hr><p>裸的BFS应该过不去，可以用双端队列优化。因为我们希望左右的步数尽量不要减少，我们把左右的走步push_back，上下的走步push_front。对deque又有了深一层的了解！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, r, c, nx, ny;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, nx, ny;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node now = q.front(); q.pop_front();</span><br><span class="line">        <span class="keyword">int</span> x = now.x, y = now.y;</span><br><span class="line">        <span class="keyword">int</span> nx = now.nx, ny = now.ny;</span><br><span class="line">        <span class="keyword">if</span> (vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[x - <span class="number">1</span>][y] != <span class="string">'*'</span>) q.push_front((node)&#123;x - <span class="number">1</span>, y, nx, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; s[x + <span class="number">1</span>][y] != <span class="string">'*'</span>) q.push_front((node)&#123;x + <span class="number">1</span>, y, nx, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[x][y - <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; nx) q.push_back((node)&#123;x, y - <span class="number">1</span>, nx - <span class="number">1</span>, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; s[x][y + <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; ny) q.push_back((node)&#123;x, y + <span class="number">1</span>, nx, ny - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c &gt;&gt; nx &gt;&gt; ny;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    q.push_front((node)&#123;r, c, nx, ny&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 513 Div2</title>
      <link href="2018/10/04/Codeforces%20Round%20513%20Div2/"/>
      <url>2018/10/04/Codeforces%20Round%20513%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1060" target="_blank" rel="noopener">比赛链接</a></p><p>这次打了两道，但T2虽然思路没错，但细节处理错误，GG了。。。不过这次题目还是很有趣的！！补了4道！！</p><h3 id="A-Phone-Numbers"><a href="#A-Phone-Numbers" class="headerlink" title="A. Phone Numbers"></a>A. Phone Numbers</h3><hr><p>H2O题。ans = min(n / 11, sum)，其中 sum 是 8 的个数。</p><h3 id="B-Maximum-Sum-of-Digits"><a href="#B-Maximum-Sum-of-Digits" class="headerlink" title="B. Maximum Sum of Digits"></a>B. Maximum Sum of Digits</h3><hr><p>暴力找一下规律，发现如果 n 有 x 位，那么 a 就是 x 位的：(n 最高位数字 - 1) + 9 + 9 + 9 … + 9. 其中有 x - 1 个 9. b = n - a.</p><p>不要忘了判断，如果 n 本身就是 k + 9 + 9 … + 9 形式的，a = k, b = 0. (啊啊啊在这里玩脱了。。。直接输出 n 了。。。应该是 S(n) 啊</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum *= <span class="number">10</span>; x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum / <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>; x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll bound = get(n);</span><br><span class="line">        ll x = n - (n % bound);</span><br><span class="line">        <span class="keyword">if</span> (n == x + bound - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S(n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll a = n - (n % bound) - <span class="number">1</span>, b = n - a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S(a) + S(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Maximum-Subrectangle"><a href="#C-Maximum-Subrectangle" class="headerlink" title="C. Maximum Subrectangle"></a>C. Maximum Subrectangle</h3><hr><p>比赛时想到了 $c_{i, j}$ 是个摆设，要拆的，但一直在想怎么枚举 x1, x2, y1, y2, 实际不用这样的。</p><p>首先拆公式：</p><script type="math/tex; mode=display">\sum\limits_{i = x1}^{x2} \sum\limits_{j = y1}^{y2} c_{i, j} = (\sum\limits_{i = x1}^{x2}a_i) * (\sum\limits_{j = y1}^{y2}b_j)</script><p>然后我们可以 $O(n^2)$ 预处理出每一段 a 的区间 [l, r]。记 $\sum\limits_{i = l}^r a_i$ 为 S，则我们开一个 $2000 ^ 2$ 的数组 A，A[S] = max(A[S], r - l + 1). 即以区间和为下标，长度为数值。对于 b 数组一样的操作。</p><p>然后用 two pointers，i 从 $2000 ^ 2$ 开始往小扫，pos只会越来越大。应该是 O(n)。同时统计答案。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], A[N * N], B[N * N];</span><br><span class="line">ll x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            sum += a[j], A[sum] = max(A[sum], j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j++)</span><br><span class="line">            sum += b[j], B[sum] = max(B[sum], j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> MAXSUM = <span class="number">2000</span> * <span class="number">2000</span>, pos = <span class="number">1</span>, ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXSUM; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= MAXSUM &amp;&amp; <span class="number">1l</span>l * i * pos &lt;= x) now = max(now, B[pos++]);</span><br><span class="line">            ans = max(ans, A[i] * now);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Social-Circles"><a href="#D-Social-Circles" class="headerlink" title="D. Social Circles"></a>D. Social Circles</h3><hr><p>这题超好玩！！</p><p>是这样的，每个人的 $l_i$ 必定要和自己或另一个人的 $r_i$ 匹配，贡献是 $max(l_i, r_i)$. 所以我们要最小化 $max(l_i, r_i)$. 这时候就不要将第 i 个人的 l 和 r 绑定了。</p><p>分别排序 l 和 r。答案就是 $\sum_{i = 1}^n max(l_i, r_i)$.</p><p>我们可以这样考虑：若 $l_n$ 是 l 数组和 r 数组中的最大值，它的匹配值必然是尽量大的、接近它的，即 $r_n$。剩下的 $2 * (n - 1)$ 个元素又是这样一个子问题，用数学归纳法即可证明。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, l[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">    sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>);</span><br><span class="line">    sort(r + <span class="number">1</span>, r + n + <span class="number">1</span>);</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += max(l[i], r[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Sergey-and-Subway"><a href="#E-Sergey-and-Subway" class="headerlink" title="E. Sergey and Subway"></a>E. Sergey and Subway</h3><hr><p>这题的意思很好理解。是一道树形DP，还没有涉及过的。</p><p>首先来考虑一个基础问题：给定一棵树，求其中每对节点的距离只和，即 $\sum\limits_{i = 1}^n \sum\limits_{j = 1}^n dist(i, j)$.</p><p>我们先定义一些量：sum[x] 表示 x 子树中的点到 x 的距离之和，cnt[x] 表示 x 子树中的点的数量，ans即答案，v即 x 的儿子节点。</p><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(进入 x 子树)</span><br><span class="line"><span class="number">1.</span> sum[x] = <span class="number">0</span>, cnt[x] = <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> dfs(v)</span><br><span class="line"><span class="number">3.</span> sum[v] += cnt[v]  <span class="comment">// v 到 x 之间有一步之差，先统计到 sum[v] 上去</span></span><br><span class="line"><span class="number">4.</span> ans += sum[x] * cnt[v] + sum[v] * cnt[x]  <span class="comment">// sum[x] 此时是 x 一部分儿子的距离之和。这一步可以视为两个集合合并的过程</span></span><br><span class="line"><span class="number">5.</span> sum[x] += sum[v], cnt[x] += cnt[v]</span><br></pre></td></tr></table></figure><p>那么 E 题是一道进阶版的。对于点 (u, v), 现在的 dist(u, v) (表示为 Now)等于基础问题中 dist(u, v) (表示为 Bef)除以二上取整。有的 Bef = 2Now，有的 Bef = 2Now - 1.</p><p>不可能整体除以二上取整，但正因为是除以二，数据少，可以手动处理。我们新建一些量：sum[x, 0] 表示 x 子树中到 x 的距离为偶数的点到 x 的距离，sum[x, 1] 对应的就是奇数；cnt[x, 0] 表示 x 子树中到 x 的距离为偶数的点数，cnt[x, 1] 对应的就是奇数；ans[0] 表示距离为偶数的点对的距离之和，ans[1] 对应的就是奇数。</p><p>由于答案 = (ans[0] / 2) + (ans[1] + 距离为奇数的点对数量) / 2，我们再开一个数组 C[], C[1] 表示距离为奇数的点对数量，方便最后计算。</p><p>五步分别对应：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> sum[x][<span class="number">0</span>] = sum[x][<span class="number">1</span>] = cnt[x][<span class="number">1</span>] = <span class="number">0</span>, cnt[x][<span class="number">0</span>] = <span class="number">1.</span></span><br><span class="line"><span class="number">2.</span> dfs(v)</span><br><span class="line"><span class="number">3.</span> sum[v][<span class="number">0</span>] += cnt[v][<span class="number">0</span>], sum[v][<span class="number">1</span>] += cnt[v][<span class="number">1</span>].</span><br><span class="line">   swap(sum[v][<span class="number">0</span>], sum[v][<span class="number">1</span>]), swap(cnt[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>])  <span class="comment">// 因为增加了 v 到 x 的一步之差，路径奇偶改变</span></span><br><span class="line"><span class="number">4.</span> ans[(j + k) &amp; <span class="number">1</span>] += sum[x][j] * cnt[v][k] + sum[x][k] * cnt[v][j]</span><br><span class="line">   C[(j + k) &amp; <span class="number">1</span>] += cnt[x][j] * cnt[v][k]</span><br><span class="line"><span class="number">5.</span> sum[x][j] += sum[v][j], cnt[x][j] += cnt[v][j].</span><br></pre></td></tr></table></figure></p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, lnk[N], tot;</span><br><span class="line">ll sum[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>], ans[<span class="number">2</span>], C[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++tot].to = v, e[tot].nxt = lnk[u], lnk[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    cnt[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = e[i].nxt) <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        dfs(v, x);</span><br><span class="line">        sum[v][<span class="number">0</span>] += cnt[v][<span class="number">0</span>], sum[v][<span class="number">1</span>] += cnt[v][<span class="number">1</span>];</span><br><span class="line">        swap(sum[v][<span class="number">0</span>], sum[v][<span class="number">1</span>]);</span><br><span class="line">        swap(cnt[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                ans[(j + k) &amp; <span class="number">1</span>] += sum[x][j] * cnt[v][k] + cnt[x][j] * sum[v][k];</span><br><span class="line">                C[(j + k) &amp; <span class="number">1</span>] += cnt[x][j] * cnt[v][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) sum[x][j] += sum[v][j], cnt[x][j] += cnt[v][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans[<span class="number">1</span>] + C[<span class="number">1</span>]) / <span class="number">2</span> + ans[<span class="number">0</span>] / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 512 Div2</title>
      <link href="2018/10/01/Codeforces%20Round%20512%20Div2/"/>
      <url>2018/10/01/Codeforces%20Round%20512%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1058" target="_blank" rel="noopener">比赛链接</a></p><p>题目比较简单，做了四道喔哈哈哈～</p><h3 id="A-In-Search-of-an-Easy-Problem"><a href="#A-In-Search-of-an-Easy-Problem" class="headerlink" title="A. In Search of an Easy Problem"></a>A. In Search of an Easy Problem</h3><hr><p>$H_2O$ 签到题</p><h3 id="B-Vasya-and-Cornfield"><a href="#B-Vasya-and-Cornfield" class="headerlink" title="B. Vasya and Cornfield"></a>B. Vasya and Cornfield</h3><hr><p>不知道有没有优美的方法～不过我的比较容易想到，就是把 {(0, d), (d, 0), (n, n - d), (n - d, n)} 区域染色，然后 O(1) 回答询问～</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d, m, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;d, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> dx, dy;</span><br><span class="line">    dx = dy = <span class="number">1</span>;</span><br><span class="line">    x = <span class="number">-1</span>, y = d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        x++, y--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - d; j++) mark[x + j][y + j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x != d &amp;&amp; y != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - d; j++) mark[x + j + <span class="number">1</span>][y + j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (mark[x][y]) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Vasya-and-Golden-Ticket"><a href="#C-Vasya-and-Golden-Ticket" class="headerlink" title="C. Vasya and Golden Ticket"></a>C. Vasya and Golden Ticket</h3><hr><p>因为数据很小，$\sum_{i = 1}^n a_i$ 最多是 900，所以可以从 0 到 tot 枚举单块的数值和，chk函数判断。虽然不能用二分，但暴力枚举也可以过！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">110</span>], tot;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (sum == limit) sum -= limit, ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; limit) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        tot += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; tot % i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(i)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Vasya-and-Triangle"><a href="#D-Vasya-and-Triangle" class="headerlink" title="D. Vasya and Triangle"></a>D. Vasya and Triangle</h3><hr><p>因为存在多个答案，是构造题，所以挑最容易构的直角三角形就可以过。</p><p>首先—三角形向量面积公司—叉积公式了解一下：$S = \frac{1}{2} |x_1y_2 - x_2y_1|$, 其中 $(x_1, y_1)$ $(x_2, y_2)$ 分别是三角形两边所表示向量的坐标。</p><p>首先，根据叉积公式算出来的 2S 一定是整数，那么 $\frac{nm}{k}$ 一定是 0.5 的倍数，即 $\frac{2nm}{k}$ 应该是整数，反之若 $2 <em> n </em> m mod k \neq 0$, 无解.</p><p>接下来是有解的情况。</p><p>构造直角三角形，相当于构造一个 (0, 0) (X, 0) (Y, 0) 形式的直角三角形，那么 XY = 2S = 2nm / k = nm / (k / 2). 令 d = gcd(n, k), x1 = n / d, y1 = 0, x2 = 0, y2  = m / (k / d), x3 = y3 = 0.</p><p>但是因为 k % 2 不一定 = 0, 所以如果 k % 2 = 0, k /= 2; 否则，如果 x1 &lt;= n / 2, x1 = 2x1, 否则 y2 = 2y2.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> !b ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * n * m % k != <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) k /= <span class="number">2</span>, flag = <span class="literal">true</span>;</span><br><span class="line">    ll d = gcd(n, k), x, y, x2, y2, x3, y3;</span><br><span class="line">    x = n / d, y = <span class="number">0</span>, x2 = <span class="number">0</span>, y2 = m / (k / d), x3 = y3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= n / <span class="number">2</span>) x *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> y2 *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n%lld %lld\n%lld %lld\n"</span>, x, y, x2, y2, x3, y3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 511 Div2</title>
      <link href="2018/09/24/Codeforces%20Round%20511%20Div2/"/>
      <url>2018/09/24/Codeforces%20Round%20511%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1047" target="_blank" rel="noopener">比赛链接</a></p><p>emmmm，这次做了两道，但由于手速脑速不够以及 WA 了几发，成功凉凉，，，，</p><p>感觉很活！！要多打！！</p><h3 id="A-Little-C-Loves-3-I"><a href="#A-Little-C-Loves-3-I" class="headerlink" title="A. Little C Loves 3 I"></a>A. Little C Loves 3 I</h3><hr><p>啊，有个很清楚的做法：a = b = c = n / 3（下取整），如果 b % 3 == 0 或 c % 3 == 0, a++, b/c —.</p><p>这样就先保证了 b 和 c 不是 3 的倍数，然后再处理 a，判断 b 和 c % 3 = 1 还是 2 就行了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = a[<span class="number">2</span>] = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = n - (n / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">0</span>] += sum;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span>) a[<span class="number">1</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">0</span>) a[<span class="number">2</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">1</span>) a[<span class="number">1</span>]++, a[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">1</span>) a[<span class="number">2</span>]++, a[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">2</span>) a[<span class="number">1</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">2</span>) a[<span class="number">2</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Cover-Points"><a href="#B-Cover-Points" class="headerlink" title="B. Cover Points"></a>B. Cover Points</h3><hr><p>可以发现，答案就是 $max_{1 \leq i \leq n}\{x_i + y_i\}$.</p><h3 id="C-Enlarge-GCD"><a href="#C-Enlarge-GCD" class="headerlink" title="C. Enlarge GCD"></a>C. Enlarge GCD</h3><hr><p>要看清题目要求，只要比整体gcd大就行了。</p><p>设整体gcd为 G。对于每个 &gt; G 的质数 x，记 cnt 为 ai 中 % x = 0 的数的个数，ans 对 n - cnt 取 min。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], G, x;</span><br><span class="line"><span class="keyword">bool</span> pri[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        <span class="keyword">if</span> (!G) G = x;</span><br><span class="line">        <span class="keyword">else</span> G = gcd(G, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G + <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pri[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">                pri[j] = <span class="number">1</span>, cnt += a[j];</span><br><span class="line">            ans = min(ans, n - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; n) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Little-C-Loves-3-II"><a href="#D-Little-C-Loves-3-II" class="headerlink" title="D. Little C Loves 3 II"></a>D. Little C Loves 3 II</h3><hr><p>首先，$1 <em> 6$, $2 </em> 4$, $2 <em> 5$, $3 </em> 4$ 都是能被构造出来的。</p><p>如果 n = 1， 那么答案就是 $6 <em> \lfloor \frac{m}{6} \rfloor + 2 </em> max((m mod 6) - 3, 0)$.</p><p>如果 n = 2，只有 $2 <em> 2$，$2 </em> 3$ 和 $2 <em> 7$ 不能被构造，其他的都可以用 $1 </em> 6$，$2 <em> 4$ 和 $2 </em> 5$ 构造出来。</p><p>否则，$4 <em> x$ 可以用 $2 </em> 4$ 和 $3 <em> 4$ 构造，$6 </em> x$ 可以用 $1 <em> 6$ 构造。$x </em> y$ 可以用 $4 <em> x$ 和 $6 </em> y$ 构造，其中 y 是偶数且 x、y &gt; 2.</p><p>也就是说，如果 $n <em> m mod 2 = 0$, 那么答案就是 $n </em> m$. 否则，我们可以用一些 $x <em> y$ 的矩阵（其中 x 或 y 是偶数）将 $n </em> m$ 的矩阵变为如下三个之一： $3 <em> 3$, $3 </em> 5$, $5 <em> 5$。而这三个都是有一个空的。即答案为 $n </em> m - 1$.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (m / <span class="number">6</span> * <span class="number">3</span> + max(m % <span class="number">6</span> - <span class="number">3</span>, <span class="number">0</span>)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m == <span class="number">2</span> ? <span class="number">0</span> : m == <span class="number">3</span> ? <span class="number">4</span> : m == <span class="number">7</span> ? <span class="number">12</span> : m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * n * m / <span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 102</title>
      <link href="2018/09/09/Atcoder%20Regular%20Contest%20102/"/>
      <url>2018/09/09/Atcoder%20Regular%20Contest%20102/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc102.contest.atcoder.jp/assignments" target="_blank" rel="noopener">比赛链接</a></p><h3 id="C-Triangular-Relationship"><a href="#C-Triangular-Relationship" class="headerlink" title="C. Triangular Relationship"></a>C. Triangular Relationship</h3><hr><p>因为只是两个数相加，所以可以分成两种情况：</p><ol><li>a 和 b 都是 k 的倍数。即，!(a % k) &amp;&amp; !(b % k).</li><li>a 和 b 之和是 k 的倍数。即，(a + b) % k = 0, </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 502 Div2</title>
      <link href="2018/08/29/Codeforces%20Round%20502%20Div2/"/>
      <url>2018/08/29/Codeforces%20Round%20502%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1017" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-The-Rank"><a href="#A-The-Rank" class="headerlink" title="A. The Rank"></a>A. The Rank</h3><hr><p>水题，struct 排序。</p><h3 id="B-The-Bits"><a href="#B-The-Bits" class="headerlink" title="B. The Bits"></a>B. The Bits</h3><hr><p>题意：给两个01字符串 a、b，只能交换第一个字符串中的两个字母，问有多少种交换方案使得交换后 a | b 不同于交换前的 a | b.</p><p>只需要考虑运算或的性质就好了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a1, a0;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100005</span>], b[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'1'</span>) a1++;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'1'</span>) a0++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ans += a0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ans += a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-The-Phone-Number"><a href="#C-The-Phone-Number" class="headerlink" title="C. The Phone Number"></a>C. The Phone Number</h3><hr><p>题意：给定 n，要求构造一个长度为 n 的序列使得这个序列的 LIS + LDS 长度最小。</p><p>分块思想，分成 k 块时答案为 n / k + k, 因此 k 取 sqrt(n) 最优。</p><p>也就是说图大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">1</span></span><br><span class="line">              <span class="number">1</span></span><br><span class="line">                <span class="number">1</span></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">          <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> S = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">int</span> ps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ps &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = min(ps + S - <span class="number">1</span>, n); j &gt;= ps; --j) a[++a[<span class="number">0</span>]] = j;</span><br><span class="line">        ps += S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 101</title>
      <link href="2018/08/26/Atcoder%20Regular%20Contest%20101/"/>
      <url>2018/08/26/Atcoder%20Regular%20Contest%20101/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc101.contest.atcoder.jp/assignments" target="_blank" rel="noopener">比赛链接</a></p><h3 id="C-Candles"><a href="#C-Candles" class="headerlink" title="C. Candles"></a>C. Candles</h3><hr><p>分三种情况讨论：</p><ol><li><p>选的位置全部 &gt;= 0。</p></li><li><p>选的位置全部 &lt;= 0。</p></li><li><p>选的位置包含 &lt; 0 的和 &gt; 0 的。</p></li></ol><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, a[<span class="number">100005</span>], flag;</span><br><span class="line">ll sum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] &lt; <span class="number">0</span>) flag = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) flag = n + <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag + k - <span class="number">1</span> &lt;= n) ans = min(ans, a[flag + k - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (flag - k &gt; <span class="number">0</span>) ans = min(ans, -a[flag - k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; flag; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; flag || j &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, min(-a[i] - a[i] + a[j], a[j] * <span class="number">2</span> - a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Median-of-Medians"><a href="#D-Median-of-Medians" class="headerlink" title="D. Median of Medians"></a>D. Median of Medians</h3><hr><p>我感觉我用了一个小时的思考证明了这题不是中位数。。。。（好像中位数最低复杂度也要 $n^2$ 呢）只能在不求解 m 的情况下求出中位数了。</p><p>观摩了大神的解题思路觉得很妙！转化非常自然，但是也很难想到。。。</p><p>首先二分最后答案 x（这一步想到了！｡ì _ í｡）</p><h3 id="问题转化为：有多少个区间的中位数小于等于-x"><a href="#问题转化为：有多少个区间的中位数小于等于-x" class="headerlink" title="问题转化为：有多少个区间的中位数小于等于 x"></a><strong>问题转化为：有多少个区间的中位数小于等于 x</strong></h3><p>将区间中所有 &lt;= x 的赋为 1，&gt; x 的赋为 -1. </p><h3 id="问题转化为：有多少个区间至少有（区间长度-2-1）个-1"><a href="#问题转化为：有多少个区间至少有（区间长度-2-1）个-1" class="headerlink" title="问题转化为：有多少个区间至少有（区间长度/2 + 1）个 1"></a><strong>问题转化为：有多少个区间至少有（区间长度/2 + 1）个 1</strong></h3><h3 id="等价于：有多少个区间的和是正数"><a href="#等价于：有多少个区间的和是正数" class="headerlink" title="等价于：有多少个区间的和是正数"></a><strong>等价于：有多少个区间的和是正数</strong></h3><p>即，对于 1/-1 序列求前缀和 sum[], 若 sum[r] - sum[l - 1] &gt; 0，则这就是一个符合要求的区间。</p><p>那么对于所有的 sum[x] &gt; sum[y], 如果再满足 x &gt; y, 则 [y + 1, x] 就是一个合法区间。我们可以用树状数组求顺序对的方法解决此题。</p><p>若二分判定函数 chk(x) 的返回值为 true，仅当区间和为正数的区间数量 &gt; n <em> (n + 1) / 4. 因为区间总数共有 n </em> (n + 1) / 2 个，（位置 0 也算进去），这些区间中位数组成的序列的中位数就要再除以 2.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], sum[N * <span class="number">10</span>], C[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= <span class="number">2</span> * N; x += lowbit(x)) C[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N; i++) C[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + (a[i] &lt;= x ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tot += query(sum[i] + N - <span class="number">1</span>);</span><br><span class="line">        add(sum[i] + N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot &gt; <span class="number">1l</span>l * n * (n + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> l = inf, r = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        l = min(l, a[i]), r = max(r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Ribbons-on-Tree"><a href="#E-Ribbons-on-Tree" class="headerlink" title="E. Ribbons on Tree"></a>E. Ribbons on Tree</h3><hr><p>这题还是很想弄懂。。。然而目前官方题解日文版看不懂，网上题解找不到。。。打算留坑待填了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 504 Div2</title>
      <link href="2018/08/23/Codeforces%20Round%20504%20Div2/"/>
      <url>2018/08/23/Codeforces%20Round%20504%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1023" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Single-Wildcard-Pattern-Matching"><a href="#A-Single-Wildcard-Pattern-Matching" class="headerlink" title="A. Single Wildcard Pattern Matching"></a>A. Single Wildcard Pattern Matching</h3><hr><p>啊啊啊，这题被 hack 了很痛苦，重申题意后发现星号部分只能用小写英文字母代替。重新写了代码又交，交了两发，过不去就弃疗了。现在看来，是没有判断非星号部分是否完全相同的原因。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (s1[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        flag = i; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">-1</span> &amp;&amp; s1 == s2) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">-1</span> || m &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, j = m - <span class="number">1</span>; i &gt; flag; i--, j--) <span class="keyword">if</span> (s1[i] != s2[j]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="keyword">if</span> (s2[i] &lt; <span class="string">'a'</span> || s2[i] &gt; <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Pair-of-Toys"><a href="#B-Pair-of-Toys" class="headerlink" title="B. Pair of Toys"></a>B. Pair of Toys</h3><hr><p>首先数据非常大，必须 O(1). 若所有方案都小于 n，那么答案就是 (k - 1) / 2.</p><p>否则在此基础上再减去 min(k - n - 1, (k - 1) / 2)。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    ll tmp = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) tmp -= min(k - n - <span class="number">1</span>, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Bracket-Subsequence"><a href="#C-Bracket-Subsequence" class="headerlink" title="C.Bracket Subsequence"></a>C.Bracket Subsequence</h3><hr><p>真是道假题。。。直接删去头 k / 2 个左括号和头 k / 2 个右括号就行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash题目选讲</title>
      <link href="2018/08/20/Hash%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"/>
      <url>2018/08/20/Hash%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="POJ3349-Snowflake-Snow-Snowflakes"><a href="#POJ3349-Snowflake-Snow-Snowflakes" class="headerlink" title="[POJ3349]-Snowflake Snow Snowflakes"></a>[POJ3349]-Snowflake Snow Snowflakes</h3><hr><p>题意：给你 n 个雪花，求解其中是否存在 2 个雪花从任意位置顺时针或逆时针形状是相同的。</p><p>定义 Hash 函数 $H(a_{i, 1}, a_{i, 2}, … a_{i, 6}) = (\sum_{j = 1}^6a_{i, j} + \prod_{j = 1}^6a_{i, j} mod P$, 其中 P 是一个大质数。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">99991</span>;</span><br><span class="line"><span class="keyword">int</span> n, tot, snow[N][<span class="number">10</span>], head[N], next[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        sum = (sum + a[i]) % P;</span><br><span class="line">        mul = (ll)mul * a[i] % P;</span><br><span class="line">    &#125; <span class="keyword">return</span> (sum + mul) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> eq = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (a[(i + k) % <span class="number">6</span>] != b[(j + k) % <span class="number">6</span>]) eq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (eq) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            eq = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (a[(i + k) % <span class="number">6</span>] != b[(j - k + <span class="number">6</span>) % <span class="number">6</span>]) eq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (eq) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = Hash(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[val]; i; i = next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equal(snow[i], a)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) snow[tot][i] = a[i];</span><br><span class="line">    next[tot] = head[val];</span><br><span class="line">    head[val] = tot;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[j]);</span><br><span class="line">        <span class="keyword">if</span> (insert(a)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Twin snowflakes found."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No two snowflakes are alike."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="兔子与兔子"><a href="#兔子与兔子" class="headerlink" title="兔子与兔子"></a>兔子与兔子</h3><hr><p>题意：有 1 个DNA序列，每次询问其中的两段，求这两段是否相同。</p><p>裸的字符串Hash。需要了解的是，若字符串 S 的 Hash 值是 H(S), 字符串 S + T 的 Hash 值是 H(S + T), 那么字符串 T 的 Hash 值就是 $H(T) = (H(S + T) - H(S) * P^{length(T)}) mod M$, 其中乘 P 就相当于 P 进制下的左移运算。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000010</span>], p[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * <span class="number">131</span> + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * <span class="number">131</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span> (f[r1] - f[l1 - <span class="number">1</span>] * p[r1 - l1 + <span class="number">1</span>] == f[r2] - f[l2 - <span class="number">1</span>] * p[r2 - l2 + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="POJ3974-Palindrome"><a href="#POJ3974-Palindrome" class="headerlink" title="[POJ3974]-Palindrome"></a>[POJ3974]-Palindrome</h3><hr><p>题意：寻找一个长度为 N 的字符串 S 的最长回文字串。</p><p>最长回文字串分为长度为奇数的和长度为偶数的，我们可以分情况讨论，正着倒着分别处理一遍 Hash 前缀和。假设最长回文字串的长度为 len，二分一半长度。最后取 max。时间复杂度 $O(N log N)$. 据说有个叫 Manacher 的算法可以 $O(N)$.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>, N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ull p[N], h1[N], h2[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> len, Case;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    ull val1 = h1[r1] - h1[l1 - <span class="number">1</span>] * p[r1 - l1 + <span class="number">1</span>];</span><br><span class="line">    ull val2 = h2[r2] - h2[l2 + <span class="number">1</span>] * p[l2 - r2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> val1 == val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) &amp;&amp; s[<span class="number">1</span>] != <span class="string">'E'</span>) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        h1[<span class="number">0</span>] = h2[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) h1[i] = h1[i - <span class="number">1</span>] * P + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) h2[i] = h2[i + <span class="number">1</span>] * P + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans, l, r, maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            l = <span class="number">1</span>, r = min(len - i, i - <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (chk(i - mid, i - <span class="number">1</span>, i + mid, i + <span class="number">1</span>))</span><br><span class="line">                    l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn = max(maxn, <span class="number">2</span> * ans + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            l = <span class="number">1</span>, r = min(i - <span class="number">1</span>, len - (i + <span class="number">1</span>)), ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (chk(i - mid, i - <span class="number">1</span>, i + <span class="number">1</span> + mid, i + <span class="number">2</span>))</span><br><span class="line">                    ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn = max(maxn, <span class="number">2</span> * ans + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++Case, maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 505 Div2</title>
      <link href="2018/08/20/Codeforces%20Round%20505%20Div2/"/>
      <url>2018/08/20/Codeforces%20Round%20505%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1025" target="_blank" rel="noopener">比赛链接</a></p><p>在比赛前睡了一会，果然精神不少！据说这是场数学大赛？比较考思维！B题差一点做出来啦！specialist后的第1场比赛！</p><h3 id="A-Doggo-Recoloring"><a href="#A-Doggo-Recoloring" class="headerlink" title="A. Doggo Recoloring"></a>A. Doggo Recoloring</h3><hr><p>题意：有一个字符串，包含小写英文字母。每次你可以选择一种个数大于1的字母将它们统统变为另一种字母，求能否统一字符串。</p><p>只要有一种个数大于1的字母就行了，可以26种字母统计数量后排序判断。</p><h3 id="B-Weakened-Common-Divisor"><a href="#B-Weakened-Common-Divisor" class="headerlink" title="B. Weakened Common Divisor"></a>B. Weakened Common Divisor</h3><hr><p>题意：有 n 对数字，要求求出一个WCD，要大于1，而且每对数字里有至少一个是它的倍数。</p><p>一开始想了一个质因数分解，是将每对数字都分解一下，T掉了。后来知道如果根据第一对数字的质因数分解应该也是可以的。</p><p>第二次想了<strong>接近</strong>正解的方法。就是求出每队数字lcm的gcd，然后找出这个gcd的最小质因子。一提交就发现错了，自己都能造出数据来hack。。（后来果然被hack啦）—— gcd是 $10^{18}$ 级别的，质因子最大是 $10^9$ 的，怎么找？</p><p>后来发现自己傻了。。。gcd是 $10^{18}$ 的，但每对数字是 $10^9$ 的呀，而那个最小质因子必定是第一对数字其中之一的约数，考虑第一对数字就好了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[<span class="number">150010</span>], b[<span class="number">150010</span>], sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[<span class="number">1</span>], &amp;b[<span class="number">1</span>]);</span><br><span class="line">    sum = a[<span class="number">1</span>] / (__gcd(a[<span class="number">1</span>], b[<span class="number">1</span>])) * b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        sum = __gcd(sum, a[i] / (__gcd(a[i], b[i])) * b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans &amp;&amp; sum % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[<span class="number">1</span>] % i == <span class="number">0</span>) a[<span class="number">1</span>] /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans &amp;&amp; a[<span class="number">1</span>] &gt; <span class="number">1</span> &amp;&amp; sum % a[<span class="number">1</span>] == <span class="number">0</span>) ans = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= b[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans &amp;&amp; sum % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b[<span class="number">1</span>] % i == <span class="number">0</span>) b[<span class="number">1</span>] /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans &amp;&amp; b[<span class="number">1</span>] &gt; <span class="number">1</span> &amp;&amp; sum % b[<span class="number">1</span>] == <span class="number">0</span>) ans = b[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Plasticine-zebra"><a href="#C-Plasticine-zebra" class="headerlink" title="C. Plasticine zebra"></a>C. Plasticine zebra</h3><hr><p>题意：有一个由 ‘b’ ‘w’ 两种字母组成的字符串，每次你可以选择一个位置 x，翻转 1 ~ x 和 x + 1 ~ n, 求能达到的最长交错字串（即一个 b 一个 w）长度。</p><p>一个长度为 8 的字符串，位置分别为 12345678，可以发现如果在第 4 个位置翻转，变成了 43218765，在第 5 个位置翻转变成了 81234567，有没有发现，这是一个 12345678 的变形，即把 8 移到首位？</p><p>同样第一次翻转时我们也可以将 43218765 倒过来，看作 56781234， 又是 12345678 的变形。</p><p>这样我们可以将字符串复制一份接在末尾，然后寻找最长交错字串。不要忘记与 n 取 max。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), tmp = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i + n] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) tmp++;</span><br><span class="line">        <span class="keyword">else</span> ans = max(ans, tmp), tmp = <span class="number">1</span>;</span><br><span class="line">    ans = max(ans, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(ans, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Recovering-BST"><a href="#D-Recovering-BST" class="headerlink" title="D. Recovering BST"></a>D. Recovering BST</h3><hr><p>题意：求用给定的数字，能否做成一棵“有边相邻的两个节点都不互质”的二叉搜索树。</p><p>可以发现，若 i 号是根，根的左子树就是 1 ~ i - 1 号，右子树就是 i + 1 ~ n 号。所以说，二叉搜索树中的子树是可以和区间划上等号的。</p><p>我们设 f[l, r, 0] 表示 l ~ r 这个区间是 l - 1 号的右子树，f[l, r, 1] 表示 l ~ r 这个区间是 r + 1 号的左子树。f[l, r, 0/1] 的取值为 0 或 1，分别表示 不存在/存在。</p><p>需要注意的是，我第一次T了，但 n &lt;= 700, $n^3$ 没问题的啊。那么就是常数大了，需要卡常。</p><p>我们知道，c++ algorithm 库中的 __gcd() 函数是 log 的，$n^3 log n$ 可能太大了，我们将每一对点的gcd先预处理出来，$n^2 log n$ 就可以过了，美滋滋！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">710</span>], f[<span class="number">710</span>][<span class="number">710</span>][<span class="number">2</span>], g[<span class="number">710</span>][<span class="number">710</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            g[i][j] = g[j][i] = (__gcd(a[i], a[j]) &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][i][<span class="number">0</span>] = g[i][i - <span class="number">1</span>];</span><br><span class="line">        f[i][i][<span class="number">1</span>] = g[i][i + <span class="number">1</span>];</span><br><span class="line">        f[i][i - <span class="number">1</span>][<span class="number">1</span>] = f[i + <span class="number">1</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[k][l - <span class="number">1</span>] &amp;&amp; f[l][k - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[k + <span class="number">1</span>][r][<span class="number">0</span>])</span><br><span class="line">                    f[l][r][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (g[k][r + <span class="number">1</span>] &amp;&amp; f[l][k - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[k + <span class="number">1</span>][r][<span class="number">0</span>])</span><br><span class="line">                    f[l][r][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">1</span>][i - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[i + <span class="number">1</span>][n][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018“百度之星”程序设计大赛 - 复赛</title>
      <link href="2018/08/19/2018%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/"/>
      <url>2018/08/19/2018%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=827" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-没有兄弟的舞会"><a href="#A-没有兄弟的舞会" class="headerlink" title="A. 没有兄弟的舞会"></a>A. 没有兄弟的舞会</h3><hr><p>一看这题目就让我想到‘cv-没有上司的舞会’。。。</p><p>看完题目第一反应是树形DP吗？</p><p>好像是贪心。。。先不考虑兄弟节点，最小值是所有点的子节点中最小的 vi 的和，最大值是所有点的子节点中最大的 vi 的和。然后枚举兄弟节点，计算并输出。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line">ll T, n, a[<span class="number">100005</span>], fa[<span class="number">100005</span>], maxn, minn;</span><br><span class="line">ll Max[<span class="number">100005</span>][<span class="number">2</span>], Min[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; nxt[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;fa[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nxt[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            nxt[fa[i]].push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sort(nxt[i].begin(), nxt[i].end());</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">        maxn = -inf, minn = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>)nxt[i].size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxn &lt; nxt[i][size - <span class="number">2</span>])</span><br><span class="line">                    maxn = nxt[i][size - <span class="number">2</span>], pos1 = i;</span><br><span class="line">                <span class="keyword">if</span> (minn &gt; nxt[i][<span class="number">1</span>])</span><br><span class="line">                    minn = nxt[i][<span class="number">1</span>], pos2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>)nxt[i].size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans1 = max(ans1, ans1 + nxt[i][size - <span class="number">1</span>]);</span><br><span class="line">                ans2 = min(ans2, ans2 + nxt[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos1) &#123;</span><br><span class="line">            ans1 = max(ans1, ans1 + maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos2) &#123;</span><br><span class="line">            ans2 = min(ans2, ans2 + minn);</span><br><span class="line">        &#125;</span><br><span class="line">        ans1 = max(ans1, ans1 + a[<span class="number">1</span>]);</span><br><span class="line">        ans2 = min(ans2, ans2 + a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-序列期望"><a href="#B-序列期望" class="headerlink" title="B. 序列期望"></a>B. 序列期望</h3><hr><p>$(\prod_{l_i \le h \le r_i} \sum_{x_i = l_i}^{h} h - x_i) (\prod_{r_i &lt; h} \sum_{x_i = l_i}^{r_i} h - x_i)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 “百度之星”程序设计大赛 - 初赛（B）</title>
      <link href="2018/08/13/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89/"/>
      <url>2018/08/13/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826" target="_blank" rel="noopener">比赛链接</a></p><p>因为初赛A没过，所以也来体验了B组，感觉还要难一些，也更妙一些。很有收获！</p><h3 id="A-degree"><a href="#A-degree" class="headerlink" title="A. degree"></a>A. degree</h3><hr><p>首先确定是森林，也就是多棵树。我们枚举作为答案的那个点，首先可以在原来的基础上向剩余的连通块各连一条（即 n - 1 - m，可以脑补一下，如果将剩余的原来是连接连通块的边加上，那么就是一棵 n - 1 条边的树，而每个连通块必然只有一条边连出来，故 n - 1 - m 是可连的连通块数量）。最后再加上别处被移除的边的数量。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, a, b, T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) nxt[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            nxt[a].push_back(b);</span><br><span class="line">            nxt[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nxt[i].size();</span><br><span class="line">            ans = max(ans, x + (n - <span class="number">1</span>) - m + min(k, m - x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-hex"><a href="#B-hex" class="headerlink" title="B. hex"></a>B. hex</h3><hr><p>扛了扛，样例未过，不了了之，留坑待填。</p><h3 id="C-odds"><a href="#C-odds" class="headerlink" title="C. odds"></a>C. odds</h3><hr><p>没仔细看过，留坑待填。</p><h3 id="D-p1m2"><a href="#D-p1m2" class="headerlink" title="D. p1m2"></a>D. p1m2</h3><hr><p>二分答案！！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, a[<span class="number">300005</span>], tmp[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll limit)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i] &lt; limit) &#123;</span><br><span class="line">            t += limit - tmp[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += (tmp[i] - limit) / <span class="number">2</span>;  <span class="comment">// attention!!不是 sum += tmp[i] - limit.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        ll l = <span class="number">0</span>, r = (<span class="keyword">int</span>)<span class="number">1e8</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (chk(mid + <span class="number">1</span>))   <span class="comment">// ATTENTION!! WA 3 times for this mistake -- "mid + 1"</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-ratio"><a href="#E-ratio" class="headerlink" title="E. ratio"></a>E. ratio</h3><hr><p>并没有做，留坑待填。</p><h3 id="F-rect"><a href="#F-rect" class="headerlink" title="F. rect"></a>F. rect</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">|\            /|</span><br><span class="line">| \     <span class="number">1</span>    / |</span><br><span class="line">|  \        /  |</span><br><span class="line">|   \      /   |</span><br><span class="line">|    \    /    |</span><br><span class="line">|     \  /     |</span><br><span class="line">|  <span class="number">2</span>   \/   <span class="number">3</span>  |</span><br><span class="line">|      /\      |</span><br><span class="line">|     /  \     |</span><br><span class="line">|    /    \    |</span><br><span class="line">|   /      \   |</span><br><span class="line">|  /    <span class="number">4</span>   \  |</span><br><span class="line">| /          \ |</span><br><span class="line">|/            \|</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure><p>如图，位于 1 区的线段答案是 x，位于 2 区的线段答案是 y，位于 3 区的线段答案是 my - y，位于 4 区的线段答案是 mx - x，可以证明，绝对不会相交。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mx, my, n, T, x, y, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;mx, &amp;my, &amp;n);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;y);</span><br><span class="line">            ans += min(x, min(y, min(mx - x, my - y)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前500可以进复赛。在还有约30分钟时我是448名左右。当时大概大脑犯抽，一直在想“啊还有12名”，直到我发现了490这个数字的存在。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 “百度之星”程序设计大赛 - 初赛（A）</title>
      <link href="2018/08/12/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89/"/>
      <url>2018/08/12/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825</a></p><p>AC一道。。。rank1959。。。又参加了有趣的B场，还是很值得一记的！</p><h3 id="A-度度熊拼三角"><a href="#A-度度熊拼三角" class="headerlink" title="A. 度度熊拼三角"></a>A. 度度熊拼三角</h3><hr><p>题意略。</p><p>三角形，两边之和大于第三边，两边之差小于第三边。</p><p>那么我们把边的长度排序，枚举最小的两条边 l, r, 找到最大的一条小于两边之和的边。用 two-pointers.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">1005</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">            r = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; n &amp;&amp; a[i] + a[j] &gt; a[r + <span class="number">1</span>]) ++r;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] &gt; a[r])</span><br><span class="line">                    ans = max(ans, a[i] + a[j] + a[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-度度熊学队列"><a href="#B-度度熊学队列" class="headerlink" title="B. 度度熊学队列"></a>B. 度度熊学队列</h3><hr><p>题意略。</p><p>可以用STL中的map模拟双向链表。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q, flag, u, v, w, val;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &gt;a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;=<span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q) &#123;</span><br><span class="line">        a.clear();</span><br><span class="line">        <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">            read(flag);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                read(u), read(w), read(val);</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span>) a[u].push_front(val);</span><br><span class="line">                <span class="keyword">else</span> a[u].push_back(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">                read(u), read(w);</span><br><span class="line">                <span class="keyword">if</span> (!a[u].empty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; a[u].front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        a[u].pop_front();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; a[u].back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        a[u].pop_back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                read(u), read(v), read(w);</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">                    a[u].insert(a[u].end(), a[v].begin(), a[v].end());</span><br><span class="line">                    a[v].clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[u].insert(a[u].end(), a[v].rbegin(), a[v].rend());</span><br><span class="line">                    a[v].clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-度度熊剪纸条"><a href="#C-度度熊剪纸条" class="headerlink" title="C. 度度熊剪纸条"></a>C. 度度熊剪纸条</h3><hr><p>题意略。</p><p>官方题解很有道理！对于每一段连续的1，如果左边右边都有数字，那就是二元组 [1, 1]，含义是左边切一刀、右边切一刀；如果只有左边有数字，那就是 [1, 0], 反之是 [0, 1]， 或者是 [0, 0]。</p><p>现在，我们要在这些集合里挑选一些段，使得中括号里代价和不超过 K，排序后从大到小选，O(N log N).</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, cnt, cnt1, ans, b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> d, w;&#125;kk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.d == b.d ? a.w &lt; b.w : a.d &gt; b.d;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= kk[i].w) &#123;</span><br><span class="line">            tmp += kk[i].d, k -= kk[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = max(ans, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ans++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        cnt = cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> (i == n) b[++cnt1] = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> == num) b[++cnt1] = num;</span><br><span class="line">                <span class="keyword">else</span> kk[++cnt].d = num, kk[cnt].w = <span class="number">2</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        sort(kk + <span class="number">1</span>, kk + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == <span class="number">2</span>) &#123;</span><br><span class="line">            work(k, <span class="number">0</span>), work(k - <span class="number">1</span>, b[<span class="number">1</span>]), work(k - <span class="number">1</span>, b[<span class="number">2</span>]), work(k - <span class="number">2</span>, b[<span class="number">1</span>] + b[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">1</span>) &#123;</span><br><span class="line">            work(k, <span class="number">0</span>), work(k - <span class="number">1</span>, b[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> work(k, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-度度熊看球赛"><a href="#D-度度熊看球赛" class="headerlink" title="D. 度度熊看球赛"></a>D. 度度熊看球赛</h3><hr><p>题意略。</p><p>这是一个伪的概率。(2N)! 指的是情况数，每种情况对ans的贡献是 $D^K$，其中 k 表示该情况下有 K 对情侣座位相邻。</p><p>设 $F_{i, j}$ 表示共有 i 对情侣，且正好有 j 对是挨着坐的。每次考虑把第 i + 1 对放进去：</p><p>(1). 这对情侣合在一起放。</p><p>① 拆散一对情侣：$F_{i + 1, j} += F_{i, j} * j$</p><p>② 放在情侣之间的空隙间：$F_{i + 1, j + 1} += F_{i, j} <em> (2 </em> i + 1 - j)$</p><p>(2). 这对情侣分开放。</p><p>① 他们各自拆散了一对情侣：$F_{i + 1, j - 2} += F_{i, j} <em> (j </em> \frac{(j - 1)}{2})$</p><p>② 只有一个人拆散了一对情侣：$F_{i + 1, j - 1} += F_{i, j} <em> (2 </em> i + 1 - j)$</p><p>③ 没有情侣被拆散：$F_{i + 1, j} += F_{i, j} <em> ((2 </em> i + 1 - j) <em> \frac{2 </em> i - j}{2})$</p><p>$O(N^2)$ 预处理。对于每一组询问，我们只要 O(N) 扫一遍计算一下答案即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N], n, d;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(ll a, ll b = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * (a - <span class="number">1</span>) % mod * quick_pow(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ycl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span> * f[i][<span class="number">0</span>] % mod * C(<span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span>) % mod +</span><br><span class="line">                      <span class="number">2</span> * f[i][<span class="number">1</span>] % mod * <span class="number">2</span> * i % mod + </span><br><span class="line">                      <span class="number">2</span> * f[i][<span class="number">2</span>] % mod;</span><br><span class="line">        f[i + <span class="number">1</span>][<span class="number">0</span>] %= mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = <span class="number">2</span> * f[i][j - <span class="number">1</span>] % mod * (<span class="number">2</span> * i + <span class="number">1</span> - (j - <span class="number">1</span>)) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j] % mod * (j + C(<span class="number">2</span> * i + <span class="number">1</span> - j, <span class="number">2</span>)) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j + <span class="number">1</span>] % mod * ((j + <span class="number">1</span>) * (<span class="number">2</span> * i + <span class="number">1</span> - (j + <span class="number">1</span>)) % mod) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j + <span class="number">2</span>] % mod * C(j + <span class="number">2</span>, <span class="number">2</span>) % mod;</span><br><span class="line">            f[i + <span class="number">1</span>][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ycl();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;d)) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">2</span> * d % mod);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + f[n][i] * quick_pow(d, i) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 503 Div2</title>
      <link href="2018/08/12/Codeforces%20Round%20503%20Div2/"/>
      <url>2018/08/12/Codeforces%20Round%20503%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1020" target="_blank" rel="noopener">http://codeforces.com/contest/1020</a></p><h3 id="A-New-Building-for-SIS"><a href="#A-New-Building-for-SIS" class="headerlink" title="A. New Building for SIS"></a>A. New Building for SIS</h3><hr><p>题意略。</p><p>要注意同幢楼的情况！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, h, a, b, k, t1, t2, f1, f2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>, &amp;n, &amp;h, &amp;a, &amp;b, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;t1, &amp;f1, &amp;t2, &amp;f2);</span><br><span class="line">        <span class="keyword">if</span> (f1 &gt; f2) swap(f1, f2);</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt; t2) swap(t1, t2);</span><br><span class="line">        ll dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == t2) &#123;</span><br><span class="line">            dis += (f2 - f1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f1 &lt; a) dis += a - f1, f1 = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f1 &gt; b) dis += f1 - b, f1 = b;</span><br><span class="line">            <span class="keyword">if</span> (f2 &lt; a) dis += a - f2, f2 = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f2 &gt; b) dis += f2 - b, f2 = b;</span><br><span class="line">            dis += (f2 - f1) + (t2 - t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Badge"><a href="#B-Badge" class="headerlink" title="B. Badge"></a>B. Badge</h3><hr><p>题意略。</p><p>无脑 n^2 模拟（？？）</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p[<span class="number">1005</span>], mark[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        mark[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!mark[p[start]]) &#123;</span><br><span class="line">            start = p[start], mark[start] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = p[start];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Elections"><a href="#C-Elections" class="headerlink" title="C. Elections"></a>C. Elections</h3><hr><p>题意略。</p><p>此题卡了好久！后来干脆弃疗。。。</p><p>我一直在想是不是要设什么性价比，或者应该挑当前票最多的对手，拿ta一张票相等于两张之类，但由于很容易证明是错的，也就gg了。。。</p><p>正解在此：必定存在一个 x，使得 1 的票数 &gt;= x, 2 ～ m 的票数 &lt; x. 1 &lt;= x &lt;= 3000，枚举就行。n^2。</p><p>使所有 2 ～ m 的数量都降至 x 以下，最后若 1 的票数还是不 &gt;= x，就挑剩下来最小的补上。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c[<span class="number">3010</span>], b[<span class="number">3010</span>];</span><br><span class="line">ll ans, sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> p; ll c;&#125;a[<span class="number">3010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.c &gt; b.c;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;a[i].p, &amp;a[i].c);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    ans = inf;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) c[j] = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) b[j] = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j].p == <span class="number">1</span>) c[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[a[j].p] + <span class="number">1</span> &gt;= i) sum += a[j].c, c[<span class="number">1</span>]++, b[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> c[a[j].p]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (a[j].p != <span class="number">1</span> &amp;&amp; b[j] == <span class="number">0</span> &amp;&amp; c[<span class="number">1</span>] &lt; i) b[j] = <span class="number">1</span>, sum += a[j].c, c[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">1</span>] &gt;= i) ans = min(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-The-hat"><a href="#D-The-hat" class="headerlink" title="D. The hat"></a>D. The hat</h3><hr><p>是个交互题？？坑先留着</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1737]-Connected Graph</title>
      <link href="2018/08/10/%5BPOJ1737%5D-Connected%20Graph/"/>
      <url>2018/08/10/%5BPOJ1737%5D-Connected%20Graph/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1737" target="_blank" rel="noopener">传送门</a></p><p>题意：求 $N$ 个节点的无向连通图有多少个，节点有标号，为 $1$ ～ $N$，$1 \leq N \leq 50$.</p><p>（诶我记得有一年的初赛问题求解 $T2$ 是这个！）</p><p>当时那道初赛，4 个点，我是先算出了 $C_6^3 + C_6^4 + C_6^5 + C_6^6$，再减去三个点之间有三条边、一个点孤立的三种情况，共是38，与题例4相同。</p><p>那么我们也可以用类似容斥的方法，来做这题。</p><p>$N$ 个点的无向图总数是 $2^{N * (N - 1) / 2}$。</p><p>接下来计算 $N$ 个点的不连通无向图的数量。一个不连通无向图必定由若干连通块组成。根据 “根据围绕基准点构造一个整体” 的思想，我们可以枚举标号为 $1$ 的节点所在的连通块包含的节点个数 $k$，从 $2$ ~ $i$ 这 $i - 1$ 个节点中选出 $k - 1$ 个节点构成任意无向图，有 $2 ^ {(i - k) * (i - k - 1) / 2}$ 种方法。</p><p>综上所述，设 $F[i]$ 表示 $i$ 个节点的无向连通图个数：</p><script type="math/tex; mode=display">F[i] = 2^{i * (i - 1) / 2} - \sum\limits_{j = 1}^{i - 1} F[j] * C_{i - 1}^{j - 1} * 2^{(i - j) * (i - j - 1) / 2}</script><p>可是，这题需要高精度，所以目前我还未AC，以上只是此题主要思路！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll f[<span class="number">60</span>], C[<span class="number">60</span>][<span class="number">60</span>], sum[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l &lt;&lt; (x * (x - <span class="number">1</span>) / <span class="number">2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            sum[i] += C[i - <span class="number">1</span>][j - <span class="number">1</span>] * f[j] * calc(i - j);</span><br><span class="line">        f[i] = calc(i) - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩展题目：<a href="https://vjudge.net/problem/HDU-5729" target="_blank" rel="noopener">$HDU5729-Rigid Frameworks$</a></p><p>题意：因为矩形是不稳定的，会变成平行四边形，但是可以在矩形对角线加边，通过构成三角形使这个矩形稳定下来。给一 $n <em> m$ 的矩形，可以在单位矩形里加两种对角线（从左上到右下，从左下到右上两种），或者不加对角线，或者两条。问使这个 $n </em> m$ 的矩形稳定下来的方案数。</p><p>原问题等价于求左边有 $n$ 个点，右边有 $m$ 个点的连通的二分图的数目，可以用类似连通图计数的方法 dp 得到。</p><p>每个单位矩阵可以加两种对角线（从左上到右下，从左下到右上两种），或者不加对角线，共 $3$ 种选择，则一个 $n * m$ 矩阵的总方案数是 $3^{nm}$。</p><p>我们设 $f[i, j]$ 表示使 $i * j$ 矩阵固定下来的合法方案数。</p><p>与 POJ1737 类似，该题转移方程为：</p><script type="math/tex; mode=display">f[n, m] = 3^{n * m} - C_{n - 1}^{i - 1} * C_m^j * f[i, j] * 3^{(n - i) * (m - j)}</script><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll C[N][N], g[N * N], f[N][N], inv[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">110</span>; i++) g[i] = g[i - <span class="number">1</span>] * <span class="number">3</span> % mod;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">            f[i][j] = g[i * j];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">0</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= i; n++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= j; m++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == n &amp;&amp; j == m) <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][j] -= C[i - <span class="number">1</span>][n - <span class="number">1</span>] * C[j][m] % mod * f[n][m] % mod * g[(i - n) * (j - m)] % mod;</span><br><span class="line">                    f[i][j] = (f[i][j] % mod + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
            <tag> 计数DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SPOJ-CMPLS]-Complete the Sequence!</title>
      <link href="2018/08/08/%5BSPOJ-CMPLS%5D-Complete%20the%20Sequence!/"/>
      <url>2018/08/08/%5BSPOJ-CMPLS%5D-Complete%20the%20Sequence!/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/SPOJ-CMPLS" target="_blank" rel="noopener">https://vjudge.net/problem/SPOJ-CMPLS</a></p><p>题意：给出了一个数列的前 s 项，要求推出后面的 c 项。</p><p>很像找规律，不要被那个 P(x) 的式子唬住了哈。。。</p><p>这个办法就是，差分求多项式值。</p><p>给定 f(x) 是关于 x 的一个多项式，设 f(x) 的次数是 n。</p><p>则规定:</p><p>$a_x = f(x) - f(x - 1)$, 称为一阶差分.</p><p>$b_x = a_x - a_{x - 1}$, 称为二阶差分.</p><p>$c_x = b_x - b_{x - 1}$, 称为三阶差分.</p><p>以此类推，直至 n 阶差分。</p><p>根据以上定义，给定 n + 1 组初始的 x 和 f(x) 的映射，即可通过差分法得到往后的所有多项式值。</p><p>例：$f(x) = x^3 + x^2 + x + 1$.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">x  <span class="title">f</span><span class="params">(x)</span>   ax   bx   cx</span></span><br><span class="line"><span class="function">0    1</span></span><br><span class="line"><span class="function">1    4    3</span></span><br><span class="line"><span class="function">2    15   11   8</span></span><br><span class="line"><span class="function">3    40   25   14   6</span></span><br><span class="line"><span class="function">4    85   45   20   6</span></span><br><span class="line">5   156   71   26   5   &lt;- f(x) = f(x - 1) + a_&#123;x - 1&#125; + b_&#123;x - 1&#125; + c_&#123;x - 1&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个三次的多项式在三阶差分时相等。</p><p>如上所述，这是个模板题。我们根据前 s 项逆推回去。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> T, S, C, X[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;S, &amp;C);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S - i; j++)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] - f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) f[S - <span class="number">1</span>][i] = f[S - <span class="number">1</span>][i - <span class="number">1</span>];  <span class="comment">// 逆推至此</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = S - i; j &lt; S - i + C; j++)</span><br><span class="line">                f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= S + C - <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, f[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IPSC2016C]-Counting Swaps</title>
      <link href="2018/08/07/%5BIPSC2016C%5D-Counting%20Swaps/"/>
      <url>2018/08/07/%5BIPSC2016C%5D-Counting%20Swaps/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4778#sub" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4778#sub</a></p><p>题意：给定一个 $1$ ~ $n$ 的排列 $p_1, p_2, … p_n$，可进行若干次操作，每次选择两个整数 $x$，$y$，交换 $p_x, p_y$。设把 $p_1, p_2, … p_n$ 变成单调递增的排列 $1$, $2$, … $n$ 至少需要 $m$ 次交换，求有多少种操作方法可以只用 $m$ 次交换达到上述目标。答案对 $10^9 + 9$ 取模。</p><p>对于一个排列，如果从每个 $i$ 到 $p_i$ 连一条边，那么可以得到一张 $n$ 个点 $n$ 条边的图，且由若干个环组成。</p><p>可以证明，把一个长度为 $n$ 的环变成 $n$ 个自环，至少需要 $n - 1$ 次交换。</p><p>证明：<br>首先，把一个长度为 $2$ 的环变成 $2$ 个自环显然需要一次。假设 $\forall k \leq n - 1$，把长度不超过 $k$ 的环变成 $k$ 个自环最少需要 $k - 1$ 次操作。当 $k = n$ 时，把该环拆成长度为 $j - i$ 和 $n - (j - i)$ 的两个环($i &lt; j &lt; n$) 。把二者分别拆成自环所需的最小交换次数为 $(j - i - 1) + (n - (j - i) - 1) = n - 2$，再加上第一次的拆开，共需 $n - 1$. 通过数学归纳法可知，原命题成立。</p><p>证毕。</p><p>设 $F_n$ 表示用最少的步数把一个长度为 $n$ 的环变成 $n$ 个自环，共有多少种操作方法。由上证明可知，可以将长度为 $n$ 的环拆成长度为 $x$ 和 $y$ 的两个环，其中 $x + y = n$。设 $T(x, y)$ 表示有多少种交换方法可以把长度为 $n$ 的环变成长度为 $x$ 和 $y$ 的两个环，容易发现，$T(x, y)$ 在 $n$ 是偶数且 $x = y$ 时是 $n / 2$, 在 $n$ 是奇数或 $x \neq y$ 时等于 $n$。</p><p>两者变为自环的步数为 $x - 1$ 和 $y - 1$.</p><p>根据多重集的排列数、加法原理和乘法原理：</p><script type="math/tex; mode=display">F_n = \sum_{x + y = n} T(x, y) * F_x * F_y * \frac{(n - 2)!}{(x - 1)!(y - 1)!}</script><p>如果最初的排列 $p_1, p_2, … p_n$ 由长度为 $l_1, l_2, … l_k$ 的 k 个环构成，其中 $l_1 + l_2 + … + l_k = n$，那么最终的答案就是：</p><script type="math/tex; mode=display">F_{l_1} * F_{l_2} * ... * F_{l_k} * \frac{(n - k)!}{(l_1 - 1)!(l_2 - 1)! * ... * (l_k - 1)!}</script><p>1e9 + 9 是质数，可以用乘法逆元处理公式中的除法。$O(n^2)$。</p><p>事实上，我们通过找规律可以发现通项公式 $F_n = n^{n - 2}$，从而优化到 $O(n log n)$。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, lnk[N], cnt, to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], T, colo[N], d, F[N];</span><br><span class="line">ll Fac[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v, nxt[cnt] = lnk[u], lnk[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    colo[x] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!colo[y]) dfs(y, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b || p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ret = ret * b % mod;</span><br><span class="line">        b = b * b % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    Fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i ++) Fac[i] = Fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">        <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">        <span class="built_in">memset</span>(colo, <span class="number">0</span>, <span class="keyword">sizeof</span>(colo));</span><br><span class="line">        cnt = d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u;</span><br><span class="line">            add(i, u), add(u, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!colo[i]) dfs(i, ++d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) F[colo[i]]++;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            ans = ans * quick_pow(F[i], F[i] - <span class="number">2</span>) % mod;</span><br><span class="line">        ans = ans * Fac[n - d] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            ans = ans * quick_pow(Fac[F[i] - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1013]-球形空间产生器</title>
      <link href="2018/08/07/%5BBZOJ1013%5D-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/"/>
      <url>2018/08/07/%5BBZOJ1013%5D-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1013" target="_blank" rel="noopener">传送门</a></p><p>题意略。</p><p>对于每个点，他们到球心的距离都是相等的。</p><p>根据欧几里得距离，此时只需求出一点 $(x_1, x_2, … x_n)$，使得：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n (a_{i, j} - x_j) ^ 2 = C</script><p>其中 $C$ 为常数。该方程组是由 $n + 1$ 个 $n$ 元二次方程组成的，不是线性方程组（线性方程组要求均为一次），但我们可以通过相邻两个方程作差，把它变成 $n$ 个 $n$ 元一次方程，同时消去常数 $C$：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n (a_{i, j}^2 - a_{i + 1, j}^2 - 2x_j(a_{i, j} - a_{i + 1, j})) = 0\ \ \ \ (i = 1, 2, ... , n)</script><p>把变量放在左边，常数放在右边：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n 2(a_{i, j} - a_{i + 1, j})x_j = \sum\limits_{j = 1}^n (a_{i, j}^2 - a_{i + 1, j}^2)\ \ \ \ (i = 1, 2, ... , n)</script><p>这就是一个线性方程组了，题目保证方程组有唯一解，我们直接对下面的增广矩阵进行高斯消元，变为简化阶梯形矩阵。</p><script type="math/tex; mode=display">\begin{bmatrix}2(a_{1, 1} - a_{2, 1}) & 2(a_{1, 2} - a_{2, 2}) & \cdots & 2(a_{1, n} - a_{2, n}) & \sum_{j = 1}^n(a_{1, j}^2 - a_{2, j}^2) \\2(a_{2, 1} - a_{3, 1}) & 2(a_{2, 2} - a_{3, 2}) & \cdots & 2(a_{2, n} - a_{3, n}) & \sum_{j = 1}^n(a_{2, j}^2 - a_{3, j}^2) \\\vdots & \vdots & \ddots & \vdots & \vdots \\2(a_{n, 1} - a_{n + 1, 1}) & 2(a_{n, 2} - a_{n + 1, 2}) & \cdots & 2(a_{n, n} - a_{n + 1, n}) & \sum_{j = 1}^n(a_{n, j}^2 - a_{n + 1, j}^2) \\\end{bmatrix}</script><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>], b[<span class="number">20</span>], c[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            c[i][j] = <span class="number">2</span> * (a[i][j] - a[i + <span class="number">1</span>][j]);</span><br><span class="line">            b[i] += a[i][j] * a[i][j] - a[i + <span class="number">1</span>][j] * a[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(c[j][i]) &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) swap(c[i][k], c[j][k]);</span><br><span class="line">                swap(b[i], b[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> rate = c[j][i] / c[i][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; k++) c[j][k] -= c[i][k] * rate;</span><br><span class="line">            b[j] -= b[i] * rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%.3lf "</span>, b[i] / c[i][i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高斯消元不怎么好写，重点是怎么把题意转化为式子，还有推式子的时候要勤快！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 097</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20097/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20097/</url>
      
        <content type="html"><![CDATA[<h3 id="C-K-th-Substring"><a href="#C-K-th-Substring" class="headerlink" title="C. K-th Substring"></a>C. K-th Substring</h3><hr><p>数据很小，暴力即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="built_in">string</span> str[N * <span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; k;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, T; i &lt; n; i++) &#123;</span><br><span class="line">        str[++cnt] = s[i];</span><br><span class="line">        T = min(k, n - i);  <span class="comment">// 这里很重要！没有就会TLE！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; T; j++, cnt++) str[cnt + <span class="number">1</span>] = str[cnt] + s[i + j];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(str + <span class="number">1</span>, str + cnt + <span class="number">1</span>);</span><br><span class="line">    unique(str + <span class="number">1</span>, str + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Equals"><a href="#D-Equals" class="headerlink" title="D. Equals"></a>D. Equals</h3><hr><p>用并查集维护：$x_j$ 和 $y_j$ 是在同一连通块里的。</p><p>若 i 和 p[i] 在同一连通块里，那么 ans + 1，即同一连通块里的元素是可以随意调换位置的。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N], fa[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(x), fy = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (getfa(i) == getfa(p[i])) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 098</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20098/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20098/</url>
      
        <content type="html"><![CDATA[<h3 id="C-Attention"><a href="#C-Attention" class="headerlink" title="C. Attention"></a>C. Attention</h3><hr><p>很简单的前缀和，不讲，</p><h3 id="D-Xor-Sum-2"><a href="#D-Xor-Sum-2" class="headerlink" title="D. Xor Sum 2"></a>D. Xor Sum 2</h3><hr><p>由题意可以得到，根据xor的消去律，连续子序列，如果 $a_i$ 这个数不符合，之后的对数中将不再需要这个元素，即从 $a_{i + 1}$ 开始。根据消去律可得，异或等效于加法与减法，可据此计算区间的异或和。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, f[N], s[N], x, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + x;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; f[r] - f[l - <span class="number">1</span>] != (s[r] ^ s[l - <span class="number">1</span>]); l++);</span><br><span class="line">        ans += r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 099</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20099/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20099/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc099.contest.atcoder.jp/assignments" target="_blank" rel="noopener">https://arc099.contest.atcoder.jp/assignments</a></p><p>一如既往地简洁！</p><h3 id="C-Minimization"><a href="#C-Minimization" class="headerlink" title="C. Minimization"></a>C. Minimization</h3><hr><p>题意：给定 n 的排列，每次选择连续的 k 个元素，赋为这 k 个元素的最小值，重复此操作，直到所有元素相同。</p><p>即所有元素都是 1 咯！</p><p>显然我们每次操作的区间都会包含 1。因此 $Ans = 1 + \lceil \frac{N - K}{K - 1} \rceil$。$O(1)$</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    n -= k;</span><br><span class="line">    ans += n / (k - <span class="number">1</span>);</span><br><span class="line">    n %= (k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 100</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20100/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20100/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc100.contest.atcoder.jp/assignments" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/assignments</a></p><p>话说 atcoder 的题目都超短易懂有没有！</p><h3 id="C-Linear-Approximation"><a href="#C-Linear-Approximation" class="headerlink" title="C. Linear Approximation"></a>C. Linear Approximation</h3><hr><p>题意略。</p><p>$A_i - (b + i)$ 几何意义就是 $A_i - i$ 在数轴上到 b 的距离啦。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[<span class="number">200005</span>], num, tot;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">iabs</span><span class="params">(ll a)</span> </span>&#123;<span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], a[i] -= i;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    num = a[(n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tot += iabs(a[i] - num);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Equal-Cut"><a href="#D-Equal-Cut" class="headerlink" title="D. Equal Cut"></a>D. Equal Cut</h3><hr><p>题意：给你 N 个数，存为 Ai，切三刀，分为四组，每一组的和分别为 b、c、d、e，要求这四个数的极差（最大数和最小数的差）最小，输出这个最小值。</p><p>先预处理出前缀和，暴力中间的断点，在循环中找一前一后两个断点，如果移动能使得前后两个区域之间的差变小便移动，否则不移动。用一个变量存储所有循环中间断点时出现的最小值，输出即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], pre[N], t[<span class="number">5</span>], ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">iabs</span><span class="params">(ll a)</span> </span>&#123;<span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], pre[i] = pre[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; i &amp;&amp; iabs(pre[l] - pre[<span class="number">0</span>] - (pre[i] - pre[l])) &gt;= iabs(pre[l + <span class="number">1</span>] - pre[<span class="number">0</span>] - (pre[i] - pre[l + <span class="number">1</span>])))</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; iabs(pre[r] - pre[i] - (pre[n] - pre[r])) &gt;= iabs(pre[r + <span class="number">1</span>] - pre[i] - (pre[n] - pre[r + <span class="number">1</span>])))</span><br><span class="line">            r++;</span><br><span class="line">        t[<span class="number">1</span>] = pre[l] - pre[<span class="number">0</span>];</span><br><span class="line">        t[<span class="number">2</span>] = pre[i] - pre[l];</span><br><span class="line">        t[<span class="number">3</span>] = pre[r] - pre[i];</span><br><span class="line">        t[<span class="number">4</span>] = pre[n] - pre[r];</span><br><span class="line">        ans = min(ans, max(t[<span class="number">1</span>], max(t[<span class="number">2</span>], max(t[<span class="number">3</span>], t[<span class="number">4</span>]))) - min(t[<span class="number">1</span>], min(t[<span class="number">2</span>], min(t[<span class="number">3</span>], t[<span class="number">4</span>]))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1101]-Zap</title>
      <link href="2018/08/01/%5BBZOJ1101%5D-Zap/"/>
      <url>2018/08/01/%5BBZOJ1101%5D-Zap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1101" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1101</a></p><p>题意略。</p><p>求 $gcd(x, y) = d$, 相当于求 $gcd(x / d, y / d) = 1$ 的个数。相当于求 $1 \leq x \leq a / d$, $1 \leq y \leq b / d$ 中 $x$, $y$ 互质对数。</p><p>令 $n = \lfloor a / d \rfloor$, $m = \lfloor b / d \rfloor$.</p><p>即</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^a \sum\limits_{j = 1}^b [gcd(i, j) == d]</script><script type="math/tex; mode=display">= \sum\limits_{i = 1}^n \sum\limits_{j = 1}^m [gcd(i, j) == 1]</script><p>现在必须提到一个莫比乌斯函数的性质：<br>当 $n &gt; 1$ 时，<br>$\sum\limits_{d | n} \mu(d) = 0$；$n = 1$ 时，$\sum\limits_{d | n} \mu(d) = 1$。</p><p>证明：</p><p>$n = 1$ 时显然。</p><p>$n &gt; 1$ 时，设 $n = p_1^{c_1} <em> p_2^{c_2} </em> p_3^{c_3} <em> … </em> p_k^{c_k}$ ，$d$ 有其中一部分。</p><p>显然根据莫比乌斯函数的定义，$d$ 的每个质因子指数为 $1$ 才有贡献，否则 $\mu(d) = 0$。</p><p>那么设 $d$ 中有 $r$ 个质因子。</p><p>$\mu(d) = (-1)^r$ ，这样的 $d$ 有 $C_m^r$ 个。</p><p>所以</p><script type="math/tex; mode=display">\sum\limits_{d | n} \mu(d) = \sum\limits_{r = 0}^m (-1)^rC_m^r</script><p>我们根据二项式定理，逆推回去：</p><script type="math/tex; mode=display">\sum\limits_{r = 0}^m(-1)^rC_m^r = \sum\limits_{r = 0}^mC_m^r(-1)^r1^{m - r} = (-1 + 1)^m = 0</script><p>证毕。</p><p>我们用这个性质把求和的式子变成：</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n \sum\limits_{j = 1}^m \sum\limits_{d | gcd(i, j)} \mu(d)</script><p>其中 $d | gcd(i, j)$ 可以变为 $d | i  and  d | j$ ，更换求和指标，</p><script type="math/tex; mode=display">= \sum\limits_{d = 1}^n \mu(d) * \lfloor \frac{n}{d} \rfloor * \lfloor \frac{m}{d} \rfloor</script><p>容易知道 $\lfloor n / d \rfloor$ 单调不上升，根据整数分块的知识，最多有 $2\sqrt{n}$ 种不同的取值。所以按取值分成 $O(\sqrt{n})$ 个段分别处理，一个连续的段内的和可以用预处理出的莫比乌斯函数前缀和求出。</p><p>初次涉及，觉得非常妙，自己想是绝不可能想到的，只能看题解，但据说是套路题，多做做，要有信心。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, a, b, d, tot;</span><br><span class="line"><span class="keyword">int</span> miu[N], sum[N], pri[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    miu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pri[++tot] = i, miu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pri[j] &lt;= <span class="number">50000</span>; j++) &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                miu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> miu[i * pri[j]] = -miu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50000</span>; i++) sum[i] = sum[i - <span class="number">1</span>] + miu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i = pos + <span class="number">1</span>) &#123;</span><br><span class="line">        pos = min(n / (n / i), m / (m / i));</span><br><span class="line">        ans += (sum[pos] - sum[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    get_prefix();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cal(a / d, b / d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 500 Div2</title>
      <link href="2018/07/31/Codeforces%20Round%20500%20Div2/"/>
      <url>2018/07/31/Codeforces%20Round%20500%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1013" target="_blank" rel="noopener">http://codeforces.com/contest/1013</a></p><h3 id="A-Piles-With-Stones"><a href="#A-Piles-With-Stones" class="headerlink" title="A. Piles With Stones"></a>A. Piles With Stones</h3><hr><p>题意：有 n 堆石子，每次你可以移走任意一堆里的一颗石子或将一堆里的部分石子移到另一堆。给出操作前的石子堆和操作后的石子堆，判断操作是否合理。</p><p>因为操作不能增加石子的总数，所以如果操作后的石子数大于操作前的就输出”No”，否则输出”Yes”。</p><h3 id="B-And"><a href="#B-And" class="headerlink" title="B. And"></a>B. And</h3><hr><p>题意：有 n 个数，x，每个数可以 xor x，求至少需要多少次异或，才能有至少两个数相等。</p><p>只存在 4 种情况：-1，0，1，2. 对于每个数 ai，如果异或后等于异或前，那么 C[ai]++ ; 否则 C[ai]++, D[ai ^ x]++。</p><p>从 0 到 100000 枚举 i，如果 C[i] &gt;= 2, ans 最小，是 0；如果 C[i] = 1, D[i] &gt; 0, ans 可能是 1；如果 C[i] = 0, D[i] &gt;= 2, ans 可能是 2.</p><h3 id="C-Photo-of-The-Sky"><a href="#C-Photo-of-The-Sky" class="headerlink" title="C. Photo of The Sky"></a>C. Photo of The Sky</h3><hr><p>题意：有 n 个坐标系上的点，这些点都在一个矩阵里。小 A 记录了它们的 x 坐标和 y 坐标，但顺序打乱了，现在要求你根据这些记录确定矩阵可能的最小面积。</p><p>有 2n 个数据，其中必定有 n 个 x 坐标，n 个 y 坐标。先排序。两种坐标必定各自在给出数据的一个区间内，设 x 坐标的区间为 [l, r], y 坐标的区间为 [p, q]。</p><p>若 l &gt; 1, r &lt; 2n, 那么 y 坐标的距离就是 a[2n] - a[1]，x 坐标的距离就是 a[r] - a[l]。因为 y 坐标的距离已经确定了，l 和 r 必然是越近越好，即 r = l + n - 1.</p><p>若 l = 1, 肯定是 r = l + n - 1, p = r + 1, q = 2n 最优。</p><p>比赛时还剩40分钟的样子，还是想出了关于区间的道理的，但打挂了：“l 和 r 必然是越近越好”的最优性没有考虑，导致了一系列奇奇怪怪无法分析的问题。。。</p><p>code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    ll ans = (a[n] - a[<span class="number">1</span>]) * (a[<span class="number">2</span> * n] - a[n + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) ans = min(ans, (a[i + n - <span class="number">1</span>] - a[i]) * (a[<span class="number">2</span> * n] - a[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Chemical-table"><a href="#D-Chemical-table" class="headerlink" title="D. Chemical table"></a>D. Chemical table</h3><hr><p>题意：给出一个 $n * m$ 的表格，表格上有一些初始点。若有这样的三个点：(r1, c1), (r1, c2), (r2, c1)，则由这三个点能生成出点 (r2, c2)。现问在初始点的基础上最少添加多少个点，能使得初始点和添加的点及它们生成出来的点能填满整个表格。</p><p>可以将每一个点看成是将所在的行和列联系起来。如此一来，对于 (r1, c1) + (r1, c2) + (r2, c1) ⇒ (r2, c2)，我们可以理解为：因为 r1 和 c1，r1 和 c2，r2 和 c1 都相应地联系起来了，那么 r2 和 c2 也联系起来了。所以我们只要把所有的行和列都联系起来，生成出来的点就能填满整个表格。那么问题就转换成问最少建立多少联结，能将所有的行和列都联系起来。可以用并查集解决。</p><p>code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">int</span> fr = getfa(r), fc = getfa(c + n);</span><br><span class="line">        <span class="keyword">if</span> (fr != fc) fa[fr] = fc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root = getfa(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = getfa(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp != root) ans++, fa[tmp] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Hills"><a href="#E-Hills" class="headerlink" title="E. Hills"></a>E. Hills</h3><hr><p>题意：有一座城市，城市中有 n 座山，是从左到右按一行排列的，每座山有一个已知的高度 h，一座房子能在第 i 座山上建造，当且仅当 $h_{i - 1} &lt; h_i$ 且 $h_i &gt; h_{i + 1}$，现在这座城市的市长想对这些山进行修整，他们可以花一天的时间将某一座山的高度减掉1。现在，对于所有的k($1 \leq k \leq \lceil \frac{n}{2} \rceil$)，他们想知道最少需要多少天可以建造出 k 幢房子（除了调整山的高度外，其他时间一律不计）。</p><p>DP，设 $f[i][j][k]$ 表示现在 DP 到第 i 座山，前 i 座山里有 j 座可以建房子，状态为 k。</p><p>k = 0，表示第 i 座山和第 i - 1 座山都不建房子；</p><p>k = 1，表示第 i 座不建，第 i - 1 建；</p><p>k = 2，表示第 i 座建，第 i - 1 不建或第 i 座建。</p><p>不过为了方便编写，当我们在第 i 座山建房子时，对第 i + 1 座山的影响放在第 i + 1 位进行计算。</p><p>$f_{i, j, 0} = min(f_{i - 1, j, 0}, f_{i - 1, j, 1})$ 如果这一座山和前一座山都不是山峰的转移。 </p><p>$f_{i, j, 1} = f_{i - 1, j, 2} + max(0, h_i - (h_{i - 1} - 1))$ 这里是计算第 i − 1 座建房子是对第 i 座山的影响。 </p><p>$f_{i, j, 2} = min(f_{i - 1, j - 1, 0} + max(0, h_{i - 1} - (h_i - 1)), f_{i - 1, j - 1, 1} + max(0, min(h_{i - 2} - 1, h_{i - 1}) - (h_i - 1)))$ 这里是分两种情况考虑，当第 i − 2 座山也被拿来建房子时，要考虑第 i − 2 座山对第 i − 1 座山的影响与第 i 座山拿来建房子是对第 i − 1 座山的影响。如果第 i − 2 座山不拿来建房子，那就不用考虑了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N], f[N][N][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = min(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = f[i - <span class="number">1</span>][j][<span class="number">2</span>] + max(<span class="number">0</span>, h[i] - (h[i - <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                f[i][j][<span class="number">2</span>] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] + max(<span class="number">0</span>, h[i - <span class="number">1</span>] - (h[i] - <span class="number">1</span>)), f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + max(<span class="number">0</span>, min(h[i - <span class="number">2</span>] - <span class="number">1</span>, h[i - <span class="number">1</span>]) - (h[i] - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n + <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, min(f[n][i][<span class="number">0</span>], min(f[n][i][<span class="number">1</span>], f[n][i][<span class="number">2</span>])));</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1951]-古代猪文</title>
      <link href="2018/07/27/%5BBZOJ1951%5D-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"/>
      <url>2018/07/27/%5BBZOJ1951%5D-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1951" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1951</a></p><p>题意：给定整数 q, n($1 \leq q, n \leq 10^9$)，计算 $q^{\sum_{d | n} C_{n}^d} mod 999911659$ 。</p><p>数论经典题！出现了很多知识点，值得回顾！</p><p>若 q = 999911659, 则上式结果为 0. 否则，因为 999911659 是质数，所以 q, 999911659 互质。由欧拉定理的推论得：</p><script type="math/tex; mode=display">q^{\sum_{d | n} C_n^d}\ mod\ 999911659 \equiv q^{\sum_{d | n} C_n^d\ mod\ 999911658}\ (mod\ 999911659)</script><p>因此，本题的关键是计算 $q^{\sum_{d | n} C_n^d mod 999911658} (mod 999911659)$</p><p>尝试分解质因数，可以发现 $999911658 = 2 <em> 3 </em> 4679 * 35617$ 。</p><p>我们可以枚举 n 的约数 d，然后运用 Lucas 定理求组合数 $C_n^d$ ，分别计算出 $\sum_{d | n} C_n^d$ 对 2, 3, 4679, 35617 四个质数的取模结果，记为 a1, a2, a3, a4。求组合数时，可以对于质数 p，预处理 p 以内的所有阶乘以及阶乘的模 p 乘法逆元，就能快速计算。</p><p>最后用中国剩余定理求解线性同余方程组：</p><script type="math/tex; mode=display">\left\{\begin{aligned}x\ mod\ 2\ =\ a1 \\x\ mod\ 3\ =\ a2 \\x\ mod\ 4679\ =\ a3 \\x\ mod\ 35617\ =\ a4 \\\end{aligned}\right.</script><p>再用快速幂求 $q^x$ 即可。</p><p>想了想还真是用了不少定理啊公式的！快速幂，Lucas 定理，扩展欧几里得，中国剩余定理，费马小定理求乘法逆元，惊叹❗️</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">999911659</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Q, n, Fac[<span class="number">4</span>][N], r[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % c;</span><br><span class="line">        a = a * a % c;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (Fac[p][m] * quick_pow(Fac[p][n] * Fac[p][m - n], T[p] - <span class="number">2</span>, T[p])) % T[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(a % T[p], b % T[p], p) * Lucas(a / T[p], b / T[p], p) % T[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exGcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exGcd(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll M = <span class="number">999911658</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ll x, y, Mi = M / T[i];</span><br><span class="line">        exGcd(Mi, T[i], x, y);</span><br><span class="line">        ans = (ans + Mi * x * r[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (Q == mod) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Fac[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T[i]; j++) Fac[i][j] = Fac[i][j - <span class="number">1</span>] * j % T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (n % j == <span class="number">0</span>) &#123;</span><br><span class="line">                r[i] = (r[i] + Lucas(j, n, i)) % T[i];</span><br><span class="line">                <span class="keyword">if</span> (j * j != n) r[i] = (r[i] + Lucas(n / j, n, i)) % T[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, quick_pow(Q, CRT(), mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1733]-Parity game</title>
      <link href="2018/07/17/%5BPOJ1733%5D-Parity%20game/"/>
      <url>2018/07/17/%5BPOJ1733%5D-Parity%20game/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1733" target="_blank" rel="noopener">传送门</a></p><p>如果我们用 $sum$ 数组表示序列 $S$ 的前缀和， 那么在每个回答中：</p><ol><li>$S[l ~ r]$ 有偶数个 $1$，等价于 $sum[l - 1]$ 与 $sum[r]$ 奇偶性相同。</li><li>$S[l ~ r]$ 有奇数个 $1$，等价于 $sum[l - 1]$ 与 $sum[r]$ 奇偶性不同。</li></ol><p>好了，又是“相同”和“不同”，可以联系到“程序自动分析”那题，都是给定若干个变量和关系。</p><p>序列长度 $N$ 很大，但问题数 $M$ 较小，我们可以将每句话的两个整数 $l - 1$ 和 $r$ 离散化，缩小到等价的 $1$ ～ $2M$ 以内的范围。</p><p>解决本题有两种很好的方法，第一种解决方法是使用“边带权”的并查集。<br>边权 $d[x]$ 为 $0$，表示 $x$ 与 $fa[x]$ 奇偶性相同；为 $1$，表示 $x$ 与 $fa[x]$ 奇偶性不同。在路径压缩时，对 $x$ 到树根路径上的所有边权做异或操作，即可求出 $x$ 与树根的奇偶性关系。</p><p>对于每句话，设在离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$，设 $ans$ 表示这句话的奇偶性。</p><p>先检查 $x$ 和 $y$ 是否在同一个集合内（奇偶关系是否已知）、$getfa(x)$、$getfa(y)$ 都执行完成后，$d[x]$ xor $d[y]$ 即为 $x$ 和 $y$ 的奇偶性关系。若 $d[x]$ xor $d[y]$ 不等于 $ans$，则在该问题之后即可确定是假话。</p><p>若 $x$ 和 $y$ 不在同一个集合内，那么我们要合并。设两个集合的树根为 $p$ 和 $q$，要令 $p$ 为 $q$ 的子节点。已知 $d[x]$ 与 $d[y]$ 分别表示路径 $x$ ~ $p$ 与 $y$ ~ $q$ 之间所有边权的 xor 和，$p$ ~ $q$ 之间的 $d[p]$ 是待求的值，那么我们就用 $ans$ 去异或 $d[x]$ xor $d[y]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ans;</span><br><span class="line">&#125; query[N];</span><br><span class="line"><span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], fa[N &lt;&lt; <span class="number">1</span>], d[N &lt;&lt; <span class="number">1</span>], n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == fa[w]) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> root = getfa(fa[w]);</span><br><span class="line">    d[w] ^= d[fa[w]];</span><br><span class="line">    <span class="keyword">return</span> fa[w] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;query[i].l, &amp;query[i].r, str);</span><br><span class="line">        query[i].ans = (str[<span class="number">0</span>] == <span class="string">'o'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        a[++t] = query[i].l - <span class="number">1</span>;</span><br><span class="line">        a[++t] = query[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + t + <span class="number">1</span>);</span><br><span class="line">    n = unique(a + <span class="number">1</span>, a + t + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read_discrete();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].l - <span class="number">1</span>) - a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].r) - a;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(x), fy = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((d[x] ^ d[y]) != query[i].ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[fx] = fy, d[fx] = d[x] ^ d[y] ^ query[i].ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法更直观，是“扩展域”的并查集。</p><p>把每个变量的信息拆成两个节点 $x_{odd}$ 和 $x_{even}$ ，其中 $x_{odd}$ 表示 sum[x] 是奇数，$x_{even}$ 表示 sum[x] 是偶数。它俩也分别称为 x 的奇数域和偶数域。</p><p>对于每句话，设在离散化后 l - 1 和 r 的值分别是 x 和 y，设 ans 表示这句话的奇偶性。</p><p>若 ans = 0，则合并 $x_{odd}$ 与 $y_{odd}$ 、$x_{even}$ 与 $y_{even}$ ，表示 “x 为偶数” 与 “y 为偶数”、“x 为奇数” 与 “y 为奇数” 可以互相推出。</p><p>若 ans = 1，则合并 $x_{odd}$ 与 $y_{even}$ 、$x_{even}$ 与 $y_{odd}$ ，表示 “x 为奇数” 与 “y 为偶数”、“x 为偶数” 与 “y 为奇数” 可以互相推出。</p><p>考虑矛盾的话，跟上面一样的咯。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ans;</span><br><span class="line">&#125; query[N];</span><br><span class="line"><span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], fa[N &lt;&lt; <span class="number">1</span>], d[N &lt;&lt; <span class="number">1</span>], n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;<span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;query[i].l, &amp;query[i].r, str);</span><br><span class="line">        query[i].ans = (str[<span class="number">0</span>] == <span class="string">'o'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        a[++t] = query[i].l - <span class="number">1</span>;</span><br><span class="line">        a[++t] = query[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + t + <span class="number">1</span>);</span><br><span class="line">    n = unique(a + <span class="number">1</span>, a + t + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read_discrete();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].l - <span class="number">1</span>) - a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].r) - a;</span><br><span class="line">        <span class="keyword">int</span> x_odd = x, x_even = x + n;</span><br><span class="line">        <span class="keyword">int</span> y_odd = y, y_even = y + n;</span><br><span class="line">        <span class="keyword">if</span> (query[i].ans == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getfa(x_odd) == getfa(y_even)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fa[getfa(x_odd)] = getfa(y_odd);</span><br><span class="line">            fa[getfa(x_even)] = getfa(y_even);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getfa(x_odd) == getfa(y_odd)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fa[getfa(x_odd)] = getfa(y_even);</span><br><span class="line">            fa[getfa(x_even)] = getfa(y_odd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 47</title>
      <link href="2018/07/15/Educational%20Codeforces%20Round%2047/"/>
      <url>2018/07/15/Educational%20Codeforces%20Round%2047/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1009" target="_blank" rel="noopener">http://codeforces.com/contest/1009</a></p><p>总结：codeforces比赛打得挺少，这次有几个问题，一是时间分配，二是心态。T3后来在比赛结束一分钟左右敲好了，但事后想起来因为太紧张导致好几次提交错误，浪费时间。还有因为是英文题面，不能像中文题面那样很快地来回反复找信息，在预览题目时忽略了部分信息导致我对题目难度预估出错，在T2上花了大量的时间后才意识到T3是水题。</p><h3 id="A-Game-Shopping"><a href="#A-Game-Shopping" class="headerlink" title="A. Game Shopping"></a>A. Game Shopping</h3><hr><p>题意不想放。。傻题，两个指针从左到右就好了。</p><h3 id="B-Minimum-Ternary-String"><a href="#B-Minimum-Ternary-String" class="headerlink" title="B. Minimum Ternary String"></a>B. Minimum Ternary String</h3><hr><p>题意：有一个三进制的字符串由 ‘0’ ，’1’， ‘2’ 组成。我们每次可以交换相邻的两个字符的条件是这两个为 ‘0’, ‘1’ 或为 ‘1’, ‘2’。<br>求该字符串的最小字典序。例如，201 的最小字典序为 120。</p><p>被题目绕了差不多一个小时？。。。。。总时间只有2小时啊。。。。。<br>这种贪心题目容易产生很多具有误导性的错误贪心算法，一开始我想的是找到连续的一个块由 ‘0’, ‘1’ 组成或 ‘1’, ‘2’ 组成，将块里所有较小的字符归到左边，较大的字符归到右边。</p><p>这题还有一个坑点就是，如果不找到正确贪心算法，那么思考时，区间会被多次进行找块、换位的操作，这个弯绕不过去，这应该也是多数贪心具有的特点。我根据一开始的想法写，多次区间的操作这点达不到，就wa了。。。</p><p>正解非常优美，发现 1 畅通无阻，可以任意移动，0 和 2 不可能交换相对位置，例如 0 在 2 前面，那么就不可能通过移动达到 0 在 2 后面。</p><p>为了达到字典序最小，第一个 2 前的 0 们应该移到最前面，所有的 1 都要移到第一个 2 前面，第一个 2 前面的 0 们的后面，第一个 2 后面的 0 和 2 保持不变。</p><p>然后，要注意整个序列没有 2 的情况。</p><p>结果，知道算法还写挂了。。。。被 hack 的感觉就是这样的吗？（因为我判断，如果序列里有 2 ，就在输出第一个 2 前面的元素后输出一个 2。有无 2 都从第一个 2 的位置（如果没有就是 n）开始 for 到 n，输出所有不是 1 的元素，但如果序列里没有 2，n 的位置上又是 0，岂不是多输了一个 0。）</p><h3 id="C-Annoying-Present"><a href="#C-Annoying-Present" class="headerlink" title="C. Annoying Present"></a>C. Annoying Present</h3><hr><p>题意：一个长度为 n 的数组（初始全为0），进行 m 次操作。<br>操作：给你 m 个 x、d，你任意挑选一个 i (1~n)，每个数字加上 x + |i - j| * d（ j 表示对应数字的下标）<br>问 m 次操作后的最大算术平均值为多少？</p><p>水题，一看就有想法（。。。）首先每个位置的数组都应加上 $\sum_{i = 1}^n x_i$ ，然后考虑 1 ～ m 的 d，若 &lt; 0 ，那么只能对整个序列的平均值产生不好的影响，我们应该把这种影响降到最低，也就是 $d * (\sum_{j = 1}^n |pos - j|)$ 最小，那么 pos 肯定是越靠中间越好，即 n 或 1；若 d &gt; 0 ，那么肯定 pos 越靠两边越好。提前记录 n 到每个位置的距离和与 (n + 1) / 2 到每个位置的距离和即可。注意 long long。</p><h3 id="D-Relatively-Prime-Graph"><a href="#D-Relatively-Prime-Graph" class="headerlink" title="D. Relatively Prime Graph"></a>D. Relatively Prime Graph</h3><hr><p>题意：构造一个 n 个点 m 条边的图，要求：图联通，GCD(u，v) = 1， u 、 v之间才可以建边。节点分别为 1 ～ n。</p><p>由欧拉函数表 $\phi(n)$ 可得，573以内互质的对数就已经超过 1e5 了，暴力枚举即可。</p><p>首先 1 到任何点都可以连一条边，这样就能保证图连通了。接着再根据上面的结论，确定该算法不会超时。</p><p>当然这需要足够的数感和估算技巧(?)</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; ans.size() &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; ans.size() &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (__gcd(i, j) == <span class="number">1</span>)</span><br><span class="line">                ans.push_back(make_pair(i, j));</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n - <span class="number">1</span> || ans.size() &lt; m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Possible\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)ans.size(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i].first, ans[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Intercity-Travelling"><a href="#E-Intercity-Travelling" class="headerlink" title="E. Intercity Travelling"></a>E. Intercity Travelling</h3><hr><p>题意：Leha从数轴的 0 到 n ，中间的整数点都有可能有休息点也可能没有休息点。当你连续坐 k 站时，每两站间的疲劳值为 a1, a2 …… ak，如果第 k 站有休息点，那么你可以在此处休息，然后接下来的站点的疲劳值又从 a1 开始，否则继续为 ak + 1。题目给你 n 和 ai，每个站点有休息点的概率都是 1/2，问你期望值 * 2 ^ (n - 1) 的值。</p><p>我们知道从 0 到 1 的疲劳值必定为 a1，从 1 到 2 的疲劳值为 a1(1 / 2) 或 a2(1 / 2) ，从 2 到 3 的疲劳值为 a1(1 / 2) , a2(1 / 4), </p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1201]-Intervals</title>
      <link href="2018/07/11/%5BPOJ1201%5D-Intervals/"/>
      <url>2018/07/11/%5BPOJ1201%5D-Intervals/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1201" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1201</a></p><p>题意：从 0 ～ 50000 中选出尽量少的整数，使每个区间 $[a_i, b_i]$ 内都有至少 $c_i$ 个数被选。</p><p>分析条件：<br>设 $s[k]$ 表示 0 ～ k 之间最少选出多少个数，那么：</p><script type="math/tex; mode=display">s[b_i] - s[a_i - 1] \geq c_i</script><p>超级明显的差分约束系统？</p><p>那么，我们还要创造一些初始化的条件，可以根据题目中隐含的条件来：</p><ol><li>$s[k] - s[k - 1] \geq 0$</li><li>$s[k] - s[k - 1] \leq 1$</li></ol><p>因此，我们把 -1 ～ 50000 这 50002 个整数分别作为图中的节点，从每个 k - 1 到 k 连长度为 0 的有向边， k 到 k - 1 连长度为 -1 的有向边，从每个 $a_i - 1$ 到 $b_i$ 连长度为 $c_i$ 的有向边。</p><p>当然，我们也可以取 $a_i - 1$ 的最小值 Min，$b_i$ 的最大值 Max，然后从 Min 到 Max 连初始边。求完后，s[Max] 即为答案。</p><p>不过，既然与区间有关，应该也可以用贪心求解，并用数据结构进行优化，可以考虑一下。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dis[N], inq[N], Min = inf, Max = -inf;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v, nxt[cnt] = lnk[u], lnk[u] = cnt, val[cnt] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Min; i &lt;= Max; i++) dis[i] = -inf;</span><br><span class="line">    dis[Min] = <span class="number">0</span>;</span><br><span class="line">    inq[Min] = <span class="number">0</span>;</span><br><span class="line">    q.push(Min);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &lt; dis[u] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[u] + val[i];</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) &#123;</span><br><span class="line">                    q.push(y);</span><br><span class="line">                    inq[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b + <span class="number">1</span>, c);</span><br><span class="line">        Min = min(Min, a);</span><br><span class="line">        Max = max(Max, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Min; i &lt; Max; i++) &#123;</span><br><span class="line">        add(i, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[Max]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2012]-疫情控制</title>
      <link href="2018/07/10/%5BNOIP2012%5D-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/"/>
      <url>2018/07/10/%5BNOIP2012%5D-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>挺妙（烦）的！</p><p>大致思路很好构建：二分答案，贪心上跳。跳不到根的就让它停在那，能跳到的就要考虑互相救助了。</p><p>但是怎么知道，如果我选择救助别的子树，情况会不会变劣？</p><p>有个很重要的结论：如果我到根后剩余的步数小于我从根走回到所在子树的距离，那我就不跳到根，留在差一步的子树顶。这个还挺容易 yy，因为会使后面更大的剩余步数浪费掉。否则那我就跳呗。</p><p>可是为什么我跳，答案不会变劣？</p><p>其实是要分类讨论的。将需要救助的子树顶到根的距离排序，将剩余步数排序。剩余步数排名和需要救助的步数排名一一对应，显然不劣；错开，发现就影响中间一段；而前者比后者好的时候显然不劣；前者比后者差的情况根本就不存在，因为大小关系不对劲。</p><p>所以就跳！</p><p>证明还挺容易，但是怎么想到啊 /kk</p><p><a href="https://www.luogu.com.cn/record/42699241" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1977]-次小生成树</title>
      <link href="2018/07/10/%5BBZOJ1977%5D-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>2018/07/10/%5BBZOJ1977%5D-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1977" target="_blank" rel="noopener">传送门</a></p><p>题意：给定一张 $n$ 点 $m$ 边的无向图，求无向图的严格次小生成树的边权之和。</p><p>首先求出最小生成树的边权之和 $sum$。我们称最小生成树的 $n - 1$ 条边为树边，剩余 $m - n + 1$ 条边为非树边。</p><p>把一条非树边 $(x, y, z)$ 加入到最小生成树中，会与树上 $x$, $y$ 之间的路径形成一个环。设树上 $x$, $y$ 之间的路径上的最大边权为 $val1$，严格次大边权为 $val2$。</p><p>若 $z &gt; val1$, 则把 $val1$ 对应的那条边替换成 $(x, y, z)$ 这条边，就得到了严格次小生成树的一个候选答案，边权之和为 $sum - val1 + z$ 。</p><p>若 $z = val1$, 则把 $val2$ 对应的那条边替换成 $(x, y, z)$ 这条边，就得到了严格次小生成树的一个候选答案，边权之和为 $sum - val2 + z$ 。</p><p>如上述枚举所有非树边，计算出所有候选答案，取最小值即为本题所求。</p><p>那么现在的问题就是：如何快速求出一条路径上的最大边权与严格次大边权。</p><p>可以用树上倍增算法来进行预处理。设 $F[x, k]$ 表示 $x$ 的 $2^k$ 祖先，$G[x, k, 0]$ 与 $G[x, k, 1]$ 分别表示 $x$ 到 $F[x, k]$ 的路径上的最大边权和严格次大边权。于是 $k \in [1, log N]$ 有：</p><script type="math/tex; mode=display">F[x, k] = F[F[x, k - 1], k - 1]</script><script type="math/tex; mode=display">G[x, k, 0] = max(G[x, k - 1, 0], G[F[x, k - 1], k - 1, 0])</script><script type="math/tex; mode=display">G[x, k, 1] = max(G[x, k - 1, 1], G[F[x, k - 1], k - 1, 1])</script><p>如果 $G[x, k - 1, 0] \neq G[F[x, k - 1], k - 1, 0]$ ， 那么：</p><script type="math/tex; mode=display">G[x, k, 1] = max(G[x, k, 1], min(G[x, k - 1, 0], G[F[x, k - 1], k - 1, 0]))</script><p>当 $k = 0$ 时，有初值：</p><script type="math/tex; mode=display">F[x, 0] = father(x)</script><script type="math/tex; mode=display">G[x, 0, 0] = edge(x, father(x))</script><script type="math/tex; mode=display">G[x, 0, 1] = -\infty</script><p>接下来，我们考虑每条非树边 $(x, y, z)$ ，采用倍增 LCA 的框架，$x$、$y$ 每向上移动一段路径，就将该路径对应的最大边权和严格次大边权按照与求 $G$ 数组类似的方法合并到答案中。</p><p>$O(M log N)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, o, minn = inf;</span><br><span class="line"><span class="keyword">int</span> to[M &lt;&lt; <span class="number">1</span>], nxt[M &lt;&lt; <span class="number">1</span>], val[M &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> fa[N], d[N], f[N][<span class="number">20</span>], G[N][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, val[cnt] = z, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">    to[++cnt] = x, val[cnt] = z, nxt[cnt] = lnk[y], lnk[y] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;<span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;<span class="keyword">return</span> a.z &lt; b.z;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(e[i].x), fy = getfa(e[i].y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        sum += e[i].z;</span><br><span class="line">        add(e[i].x, e[i].y, e[i].z);</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">            G[y][<span class="number">0</span>][<span class="number">0</span>] = val[i];</span><br><span class="line">            G[y][<span class="number">0</span>][<span class="number">1</span>] = -inf;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beizeng</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            G[j][i][<span class="number">0</span>] = max(G[j][i - <span class="number">1</span>][<span class="number">0</span>], G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            G[j][i][<span class="number">1</span>] = max(G[j][i - <span class="number">1</span>][<span class="number">1</span>], G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (G[j][i - <span class="number">1</span>][<span class="number">0</span>] != G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                G[j][i][<span class="number">1</span>] = max(G[j][i][<span class="number">1</span>], min(G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>], G[j][i - <span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> t = d[x] - d[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; t) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> xy, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx1 = <span class="number">0</span>, mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dis = d[x] - d[xy];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[x][i][<span class="number">0</span>] &gt; mx1) mx2 = mx1, mx1 = G[x][i][<span class="number">0</span>];</span><br><span class="line">            mx2 = max(mx2, G[x][i][<span class="number">1</span>]);</span><br><span class="line">            x = f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx1 != v) minn = min(minn, v - mx1);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        minn = min(minn, v - mx2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    kruskal();</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    beizeng();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].x, y = e[i].y, xy = lca(x, y);</span><br><span class="line">        calc(x, xy, e[i].z), calc(y, xy, e[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum + minn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唉，话说这篇代码真让我调得够呛。。。WA了六发不止。。。最后发现大概是计算 F 数组和 G 数组还有 beizeng() 预处理函数的问题，另外 lca 刚开头深度的比较与调换也错了。。。</p><p>不过！趁机学习了一发对拍～～～还是很有收获滴～～～</p><p>调试变难了不仅是错误百出的原因，还有最近图论不是很熟悉，因为图论本就是抽象的概念，但多做题一定会有所改善的！已经感觉到了= =</p>]]></content>
      
      
      
        <tags>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2007]-树网的核</title>
      <link href="2018/07/10/%5BNOIP2007%5D-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/"/>
      <url>2018/07/10/%5BNOIP2007%5D-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1999" target="_blank" rel="noopener">传送门</a></p><p>题意：说不清。。。看原题吧?</p><p>NOIP 数据可以直接上朴素算法，$O(n^3)$ 。首先通过两次 BFS 或 DFS 求出树的直径，然后在直径上枚举距离不超过 $s$ 的两个点 $p$ 和 $q$ ，$p$、$q$ 之间的路径就是树网的核。先将核上的每个节点标记为“已访问”，然后从核上的每个节点出发，执行深搜，求出偏心距最大值即为偏心距。</p><p>稍加观察，$p$、$q$ 之间的距离肯定是越大越好，所以只要枚举 $p$ 就行了，$q = p + s$。 $O(n^2)$ 。</p><p>然鹅这样还是过不了 BZ 的数据。。</p><p>发现，本题的答案具有单调性，可以二分答案，把问题转化为“验证是否存在一个核，其偏心距不超过二分的值 $mid$” 。</p><p>设直径的两个端点为 $u$ 和 $v$ ，在直径上找到与 $u$ 的距离不超过 $mid$ 的前提下，距离最远的节点，作为节点 $p$。类似地找到与 $v$ 的距离不超过 $mid$ 的前提下，距离最远的节点，作为节点 $q$。</p><p>根据直径的最长性（标黑加粗！），任何从 $u$、$p$ 之间分叉离开直径的子树，其最远点与 $p$ 的距离都不会比 $u$ 更远。所以 $p$、$q$ 就是满足直径两侧的那部分节点偏心距不超过 $mid$ 的前提下、尽量靠近树网中心的节点。</p><p>接下来就是检查 $p$、$q$ 的距离是否不超过 $$s ，同时用深搜检查离核最远的点的距离是否也不超过 $s$。如果两个条件都满足，$p$、$q$ 之间的路径就是偏心距不超过 $mid$ 的一个合法的核。</p><p>该算法 $O(n log SUM)$ ，其中 $SUM$ 表示树网所有边的长度之和。</p><p>据说还有一个 $O(n)$ 的算法。算出 $d[u_i]$ ，表示从每一个直径上的节点 $u1$ ~ $ut$ ，不经过直径上的其他节点，能够到达的最远点的距离。</p><p>所以实际上答案是：</p><script type="math/tex; mode=display">max(max_{i \leq k \leq j}\{d[u_k]\}, dist(u_1, u_i), dist(u_j, u_t))</script><p>由于直径的最长性（标黑加粗！），上式其实可简化为：</p><script type="math/tex; mode=display">max(max_{1 \leq k \leq t}\{d[u_k]\}, dist(u_1, u_i), dist(u_j, u_t))</script><p>$max_{1 \leq k \leq t}\{d[u_k]\}$ 是定值，可以直接算出。</p><p>所以最后只要用指针计算后两项，单调递增，$O(n)$ ！！</p><p>所以说，算法从某种程度上，设计、优化是永无止境的啊，一定要多动脑，不要满足于AC。</p><p>$O(n log SUM)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, cnt, fa[N], fc[N], dep[N], idx[N], sum[N];</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, val;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; nxt[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nxt[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[nxt[u][i].to] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dep[nxt[u][i].to] = dep[u] + nxt[u][i].val;</span><br><span class="line">                fa[nxt[u][i].to] = u, fc[nxt[u][i].to] = nxt[u][i].val;</span><br><span class="line">                q.push(nxt[u][i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_dia</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">    q.push(x), dep[x] = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &lt; dep[i]) x = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = x; l &lt; cnt &amp;&amp; y &gt;= sum[l + <span class="number">1</span>] - sum[l]; l++)</span><br><span class="line">        y -= sum[l + <span class="number">1</span>] - sum[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = x; r &gt; <span class="number">1</span> &amp;&amp; y &gt;= sum[r] - sum[r - <span class="number">1</span>]; r--)</span><br><span class="line">        y -= sum[r] - sum[r - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum[r] - sum[l] &lt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        nxt[u].push_back((edge)&#123;v, w&#125;), nxt[v].push_back((edge)&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = find_dia(<span class="number">1</span>), t = find_dia(s), k = t;</span><br><span class="line">    <span class="keyword">for</span> (idx[++cnt] = k; k != s; k = fa[k]) &#123;</span><br><span class="line">        idx[++cnt] = fa[k], sum[cnt] = sum[cnt - <span class="number">1</span>] + fc[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = dep[t];</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) q.push(idx[i]), dep[idx[i]] = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l = max(l, dep[i]);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2010]-巡逻</title>
      <link href="2018/07/10/%5BAPIO2010%5D-%E5%B7%A1%E9%80%BB/"/>
      <url>2018/07/10/%5BAPIO2010%5D-%E5%B7%A1%E9%80%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1912" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1912</a></p><p>题意：有 n 个村庄编号 1 ～ n ，有 n - 1 条双向道路连接它们，长度均为 1 个单位。编号为 1 的村庄里设立了警察局，巡警车每天从警察局出发，到所有的路上巡逻，最后回到警察局。每条道路都需要经过两次。现在为了减少总的巡逻距离，该地区准备在这些村庄之间建立 K 条新的道路，一条新道路甚至可以是一个环。由于资金有限，K 只能是 1 或 2。巡警车必须经过新建的道路正好一次。</p><p>不建立新的道路时，路线总长度为 2(n - 1) 。建立一条新道路后，因为新道路必须经过刚好一次，所以在沿着新道路 (x, y) 巡逻后，就必须沿着树上从 y 到 x 的路径巡逻一遍，最终形成一个环。相当于树上 x 与 y 之间的两条路径都只需经过一次了。</p><p>因此，当 K = 1 时，我们找到树的最长链（$L_1$），在两个端点之间加一条新道路，就是答案。若树的直径为 L ，答案就是 2(n - 1) - (L - 1) 。</p><p>当 K = 2 时，我们要再找一条最长链（$L_2$）。但这时如果两条新道路形成的环重叠，重叠部分就不会被巡逻到。但由于题目说每条道路必须被巡逻，所以在恰当的时刻重叠部分会被巡逻两遍，对答案没有贡献。</p><p>综上所述，我们得到如下算法：</p><ol><li>再最初的树上求直径，记为 $L_1$ ，然后把直径上的标记取反（从 1 改为 -1）；</li><li>再最长链标记取反的树上再次求直径，记为 $L_2$ 。</li></ol><p>答案就是 $2(n - 1) - (L_1 - 1) - (L_2 - 1)$ 。</p><p>为什么取反能正确处理重叠部分呢？</p><p>因为如果 $L_2$ 包含 $L_1$ 取反的部分，就相当于两个环重叠，最初重叠的部分需要经过两次；减掉 $L_1 - 1$ 后，重叠的部分变成了只需经过一次；减掉 $L_2 - 1$ 后，负负得正，相当于把重叠的部分加回来，变回了“需要经过两次”。</p><p>$O(n)$</p><p>这题主要是注意 dfs 取树直径部分的代码，还有记录直径的方法，思维上注意取反抵消的方法。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, tot, cnt = <span class="number">1</span>, dia, mx;</span><br><span class="line"><span class="keyword">int</span> lnk[N];</span><br><span class="line"><span class="keyword">int</span> s1[N], s2[N];  <span class="comment">// 存第一次树直径的路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v;</span><br><span class="line">&#125;e[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = v, e[cnt].next = lnk[u], lnk[u] = cnt, e[cnt].v = <span class="number">1</span>;</span><br><span class="line">    e[++cnt].to = u, e[cnt].next = lnk[v], lnk[v] = cnt, e[cnt].v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx1 = <span class="number">0</span>, mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v + dfs(e[i].to, x);</span><br><span class="line">            <span class="keyword">if</span> (v &gt; mx1) mx2 = mx1, mx1 = v, s2[x] = s1[x], s1[x] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; mx2) mx2 = v, s2[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx1 + mx2 &gt; dia) dia = mx1 + mx2, mx = x;</span><br><span class="line">    <span class="keyword">return</span> mx1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    tot = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    tot = tot - dia + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">2</span>) &#123;</span><br><span class="line">        dia = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1[mx]; i; i = s1[e[i].to]) e[i].v = e[i ^ <span class="number">1</span>].v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s2[mx]; i; i = s1[e[i].to]) e[i].v = e[i ^ <span class="number">1</span>].v = <span class="number">-1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tot = tot - dia + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018 Training 2</title>
      <link href="2018/07/02/NOIP%202018%20Training%202/"/>
      <url>2018/07/02/NOIP%202018%20Training%202/</url>
      
        <content type="html"><![CDATA[<h3 id="A-ksum"><a href="#A-ksum" class="headerlink" title="A. ksum"></a>A. ksum</h3><hr><p>题意：有一个大小为 n 的正整数数组，算出这个数组的所有字段和，并将这 n(n + 1) / 2 个数降序排列，输出前 k 个数。</p><p>优先队列存储子段和，因为是正整数，所以用缩减的方法，每次取队首，前缀和算出 (L + 1, R) 和 (L, R - 1)，再次入队。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, tot, a[N];</span><br><span class="line">ll sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll l, r;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> val &lt; x.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(node x)</span> </span>&#123;</span><br><span class="line">    ll num = <span class="number">1l</span>l * x.l + <span class="number">1l</span>l * x.r * <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mp.count(num)) &#123;</span><br><span class="line">        mp[num] = <span class="number">1</span>;</span><br><span class="line">        pq.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;= x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("ksum.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("ksum.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    node x;</span><br><span class="line">    x.l = <span class="number">1</span>, x.r = n, x.val = sum[n];</span><br><span class="line">    push_heap(x);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        node u = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        ans[++tot] = u.val;</span><br><span class="line">        <span class="keyword">if</span> (tot == k) <span class="keyword">break</span>;</span><br><span class="line">        ll l = u.l, r = u.r;</span><br><span class="line">        node x, y;</span><br><span class="line">        x.l = l + <span class="number">1</span>, x.r = r, x.val = sum[x.r] - sum[x.l - <span class="number">1</span>];</span><br><span class="line">        y.l = l, y.r = r - <span class="number">1</span>, y.val = sum[y.r] - sum[y.l - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r &amp;&amp; in(l + <span class="number">1</span>, r)) push_heap(x);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r - <span class="number">1</span> &amp;&amp; in(l, r - <span class="number">1</span>)) push_heap(y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans + <span class="number">1</span>, ans + tot + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-label"><a href="#B-label" class="headerlink" title="B. label"></a>B. label</h3><hr><p>题意：有一棵大小为 n 的树，节点编号为 1 ～ n，我们给树上的每一个节点赋一个 [1, m] 之间的权值，并使得有边直接相连的两个节点的权值之差的绝对值 &gt;= K。求有多少种不同的赋值方法，答案对 $10^9 + 7$ 取模。</p><p>先考虑第一档部分分，很明显的树形DP，$F_{i, j}$ 表示第 i 个节点赋值为 j 的方案数。可得：</p><script type="math/tex; mode=display">F_{i, j} = \prod (\sum F_{Son(i), k})</script><p>其中 $|j - k| \geq K$</p><p>第二档也很好办，前缀和优化，每次减去 (j - K) ~ (j + K) 的不符合区间。</p><p>然而 $m \leq 10^9$ 实在太大了。<br>我们发现，对于叶节点，$F_{i, j}$ 均为 1；对于叶节点的父亲节点，F 的值在下标为 [K, m - K] 范围内相同，而在两边对称。进而发现，每一个节点的 F 值都是这样分布的。两边对称值的个数与它到距离最远的后代叶子节点有关。假设这个距离是 x ，那么对称值的个数不超过 xK。</p><p>于是我们得到了一个优化的方法，j 的范围只要取到 $min(m, (n - 1) * k)$</p><p>$O(n^2*k)$ </p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> T, n, m, k, x, y, l, ans, f[<span class="number">105</span>][<span class="number">10005</span>], u[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * b % mo;</span><br><span class="line">        b = b * b % mo;</span><br><span class="line">    &#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 计算f[x][y],f[x][y + 1]...f[x][m]</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= l; i++) sum = (sum + f[x][i]) % mo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= m - l + <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= l || i &lt; y) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum = (sum + f[x][m - i + <span class="number">1</span>]) % mo;  <span class="comment">// 对称计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = max(y, l + <span class="number">1</span>), R = m - l;</span><br><span class="line">    <span class="keyword">if</span> (R &gt;= L) sum = (sum + <span class="number">1l</span>l * (R - L + <span class="number">1</span>) * f[x][l]) % mo;  <span class="comment">// 中间部分</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) f[x][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(nxt[x][i], x);</span><br><span class="line">        y = calc(nxt[x][i], k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k) y += f[nxt[x][i]][j - k], y %= mo;</span><br><span class="line">            f[x][j] = <span class="number">1l</span>l * f[x][j] * y % mo;</span><br><span class="line">            <span class="keyword">if</span> (j + k &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + k &lt;= l) y -= f[nxt[x][i]][j + k];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + k &gt; m - l) y -= f[nxt[x][i]][m - j - k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    y -= f[nxt[x][i]][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("label.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("label.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        l = min(m, (n - <span class="number">1</span>) * k);</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!k) ans = quick_pow(m, n);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//  将1作为根</span></span><br><span class="line">            ans = calc(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-square"><a href="#C-square" class="headerlink" title="C. square"></a>C. square</h3><hr><p>题意：有一个大小为 $n * m$ 的方格图，有的方格为 1，有的方格为 0。T次询问一个区间，区间左上角(x1, y1) ，右下角(x2, y2) 。求给出区间中最大的全为 1 的正方形的边长。</p><p>分情况讨论，1.正方形四边不靠给定区间 2.正方形两边靠给定区间。用DP，或者二分判定边长，好像是这样。。</p><p>没有写，有想法再回来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018 Training 1</title>
      <link href="2018/06/23/NOIP%202018%20Training%201/"/>
      <url>2018/06/23/NOIP%202018%20Training%201/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Count-Good-Prefixes"><a href="#A-Count-Good-Prefixes" class="headerlink" title="A. Count Good Prefixes"></a>A. Count Good Prefixes</h3><p><a href="https://vjudge.net/problem/CodeChef-GOODPREF" target="_blank" rel="noopener">https://vjudge.net/problem/CodeChef-GOODPREF</a></p><p>给定整数 n 和字符串 s，字符串仅包含‘a’和‘b’两种字符。考虑字符串 t = s + s + · · · + s，即将 s 重复 n 遍得到的字符串。<br>请求出 t 有多少非空前缀满足其中‘a’的出现次数严格多余‘b’的出现次数。$1 \leq n \leq 10^9$ 。</p><p>可以证明代码中的做法是不会超时的：可以发现字符串长度很小，$10^3$ ，如果一遍下来 a 字符数已经大于 b 字符数了，那么长度遍过后 b 字符数无论在字符的哪一个位置都不能赶上 a 了，跳出循环；若 b 字符数大于 a 字符数了，一样操作；若相等，那么只要将字符所有位置中 a 字符数大于 b 字符数的情况数乘上剩下的遍数即可，跳出循环。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, freq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (freq--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            ret *= freq + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a - b &gt; n) &#123;</span><br><span class="line">            ret += <span class="number">1l</span>l * n * freq;  <span class="comment">// freq 在 while 循环中是递减的！</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b - a &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s + <span class="number">1</span>, &amp;freq);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Andryusha-and-Colored-Balloons"><a href="#B-Andryusha-and-Colored-Balloons" class="headerlink" title="B. Andryusha and Colored Balloons"></a>B. Andryusha and Colored Balloons</h3><p><a href="https://vjudge.net/problem/CodeForces-781A" target="_blank" rel="noopener">https://vjudge.net/problem/CodeForces-781A</a></p><p>大概就是用尽量少的颜色给一棵树染色，相邻三个节点颜色不能相同。记录一下父节点和祖父节点的颜色就好了。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="keyword">int</span> color[N], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] != fa) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt == color[x] || cnt == color[fa]) cnt++;</span><br><span class="line">            color[nxt[x][i]] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] != fa) dfs(nxt[x][i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        nxt[u].push_back(v);</span><br><span class="line">        nxt[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    color[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = max(ans, color[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, color[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Median-Sum"><a href="#C-Median-Sum" class="headerlink" title="C. Median Sum"></a>C. Median Sum</h3><p><a href="https://vjudge.net/problem/AtCoder-3857" target="_blank" rel="noopener">https://vjudge.net/problem/AtCoder-3857</a></p><p>有 n 个数，那么考虑每一个数取或不取，共有 $2^n - 1$ 种和，求其中的中值。</p><p>用 bitset 来表示每一个数能否被表示成 n 个数中任意个数的和的形式，能，1；不能，0。<br>例如 n = 2 ，两个数分别为 3 和 5，那么这个 bitset 中第 3 位和第 5 位为 1，第 8 位也为 1，而第 8 位赋值方法是 3 &lt;&lt; 5。</p><p>中位数在 $\lceil \frac{\sum\limits_{i=1}^nA_i}{2} \rceil$ 后面一点点的证明：<a href="https://blog.csdn.net/zzzzone/article/details/79115522" target="_blank" rel="noopener">传送门</a></p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, tot, ans;</span><br><span class="line"><span class="built_in">bitset</span>&lt;4000005&gt; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    bit.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        bit = bit | (bit &lt;&lt; x);</span><br><span class="line">        tot += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ans = (tot + <span class="number">1</span>) / <span class="number">2</span>; !bit[ans]; ans++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Salvage-Robots"><a href="#D-Salvage-Robots" class="headerlink" title="D. Salvage Robots"></a>D. Salvage Robots</h3><p><a href="https://vjudge.net/problem/AtCoder-2045" target="_blank" rel="noopener">https://vjudge.net/problem/AtCoder-2045</a></p><p>有一张 $h <em> w$ 的地图，上面有 $h </em> w$ 个格子，格子里为 o 的表示有机器人，为 E 的表示是出口。每次你可以将所有机器人向上下左右任意一个方向移动一步（注意是所有机器人），碰到出口的机器人获救，碰到墙壁的或在墙壁外面的机器人死亡。求最多可以救多少个机器人，无步数限制。</p><p>因为运动是相互的，所以移动机器人就相当于移动墙壁和出口。</p><p>file:///Users/imily/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-23%20%E4%B8%8B%E5%8D%882.29.45.png</p><p>由此图得：</p><p>file:///Users/imily/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-23%20%E4%B8%8B%E5%8D%882.35.03.png</p><p>红色部分表示已经死亡的区域。最终我们用 $f_{a, b, c, d}$ 表示坐标(a, b) 到坐标(c, d) 得矩阵已经走完获得的机器人，每次转移时向上下左右某个方向扩展一行即可。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> r[N][N], c[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N * N &gt;&gt; <span class="number">2</span>][N * N &gt;&gt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h, w, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> M)</span> </span>&#123;<span class="keyword">return</span> r * M + l;&#125;  <span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    x = max(x, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> lX, <span class="keyword">int</span> rX, <span class="keyword">int</span> lY, <span class="keyword">int</span> rY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cX = encode(lX, rX, X), cY = encode(lY, rY, Y);</span><br><span class="line">    <span class="keyword">if</span> (f[cX][cY] &gt;= <span class="number">0</span>) <span class="keyword">return</span> f[cX][cY];</span><br><span class="line">    f[cX][cY] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lX &lt; X - <span class="number">1</span>)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX + <span class="number">1</span>, rX, lY, rY) + (rX + <span class="number">1</span> &lt;= X - lX - <span class="number">1</span> ? max(<span class="number">0</span>, r[X - lX - <span class="number">1</span>][min(Y + rY, w - lY)] - r[X - lX - <span class="number">1</span>][max(Y - lY, rY + <span class="number">1</span>) - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rX &lt; h - X)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX + <span class="number">1</span>, lY, rY) + (X + rX + <span class="number">1</span> &lt;= h - lX ? max(<span class="number">0</span>, r[X + rX + <span class="number">1</span>][min(Y + rY, w - lY)] - r[X + rX + <span class="number">1</span>][max(Y - lY, rY + <span class="number">1</span>) - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (lY &lt; Y - <span class="number">1</span>)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX, lY + <span class="number">1</span>, rY) + (rY + <span class="number">1</span> &lt;= Y - lY - <span class="number">1</span> ? max(<span class="number">0</span>, c[min(X + rX, h - lX)][Y - lY - <span class="number">1</span>] - c[max(X - lX, rX + <span class="number">1</span>) - <span class="number">1</span>][Y - lY - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rY &lt; w - Y)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX, lY, rY + <span class="number">1</span>) + (Y + rY + <span class="number">1</span> &lt;= w - lY ? max(<span class="number">0</span>, c[min(X + rX, h - lX)][Y + rY + <span class="number">1</span>] - c[max(X - lX, rX + <span class="number">1</span>) - <span class="number">1</span>][Y + rY + <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> f[cX][cY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'E'</span>) X = i, Y = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">            r[i][j] = r[i][j - <span class="number">1</span>] + (s[i][j] == <span class="string">'o'</span>);</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j] + (s[i][j] == <span class="string">'o'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF-Gym-101775B]-Scapegoat</title>
      <link href="2018/06/17/%5BCF-Gym-101775B%5D-Scapegoat/"/>
      <url>2018/06/17/%5BCF-Gym-101775B%5D-Scapegoat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/Gym-101775B" target="_blank" rel="noopener">传送门</a></p><p>题意：有 $N$ 个大点，$M$ 个小点，每个大点可以连多个小点，且至少得连一个小点，每个小点必须被一个大点连。每个大点有一个权值 $c_i$，被这个大点连的小点的权值之和即为大点权值。需要求出怎么连，在满足题意的情况下小点权值方差最小？<br>Hint：方差公式：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{n}\sum(x_i - \frac{1}{n}\sum x_j)^2</script><p>真是惭愧 ◑﹏◐ 当时题意都没读懂…<br>可以发现，小点这么求：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{m}\sum(x_i - \frac{1}{m}\sum x_j)^2</script><p>可以发现，小点的总权值之和即为大点总权值之和，是一个已知的常数，我们用 $S$ 表示。<br>完全平方公式得：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{m}\sum({x_i}^2 - \frac{2}{m}Sx_i + \frac{1}{m^2}S^2)</script><p>拆开来化简得：</p><script type="math/tex; mode=display">\frac{1}{m}\sum{x_i}^2 - \frac{S^2}{m^2}</script><p>由于 $\frac{1}{m}$ 、 $\frac{S^2}{m^2}$ 全是常数，可以直接得到，我们就不去考虑，现在要解决 $\sum{x_i}^2$ 的问题。</p><p>实在是太难考虑了 ◑﹏◐ 那换一个角度吧</p><p>我们发现，一个大点连着小点，每个小点获得的大点分出的权值肯定是越均匀越好（均分咯），设大点权值为 $C$ ，小点个数为 $M$ ，则 $x_i$ 为 $\frac{C}{M}$ 。</p><p>$\sum{x_i}^2$ 则为 $M(\frac{C}{M})^2$ 即为 $\frac{C^2}{M}$ 。</p><p>$C^2$ 我们也知道了，现在我们考虑的局部问题就是不同大点的小点数。对于每个大点来说，$M$ 肯定是越大越好咯，但为了让对答案的减少量更多，我们要考虑的是哪一个大点的 $M$ 变大对答案的贡献越多。</p><p>仔细观察发现，$\frac{C^2}{1}$ 变为 $\frac{C^2}{2}$ 的减少量是 $\frac{C^2}{2}$ ，$\frac{C^2}{2}$ 变为 $\frac{C^2}{3}$ 的减少量是 $\frac{C^2}{2} - \frac{C^2}{3}$ ，也就是说减少量在递减，而我们却要选减少量将会最多的一个，这是一个很优的性质。</p><p>最终做法，每个大点的 $M$ 初始是 $1$，循环 $m - n$ 次，用优先队列给准减少量降序排列，每次取队首，给它的 $M$ 加 $1$。</p><p>最后别忘了加上之前为了方便思考减去的一堆常数。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">double</span> a[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>, S = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">            S += a[i];</span><br><span class="line">            pq.push(make_pair(a[i] * a[i] / <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            pdi x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">double</span> square = x.first * (x.second * (x.second + <span class="number">1</span>));</span><br><span class="line">            x.second += <span class="number">1</span>;</span><br><span class="line">            x.first = (square / x.second) - (square / (x.second + <span class="number">1</span>));</span><br><span class="line">            pq.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            pdi x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans += x.first * x.second * (x.second + <span class="number">1</span>) / x.second;</span><br><span class="line">        &#125;</span><br><span class="line">        ans /= m;</span><br><span class="line">        ans -= S * S / m / m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.12lf\n"</span>, cas, max(<span class="number">0.0</span>, ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结，本题在于展开，然后省略易求的常数，还有一个减少量的规律，也就是逐渐减小，逐渐不符合我们的要求。此外最可借鉴的就是思考策略——局部问题解法推广到整体，比如这道题中很难考虑时我们跳出去，先去发现减少量这个有趣的性质。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CODEVS1172]-Hankson的趣味题</title>
      <link href="2018/06/16/%5BCODEVS1172%5D-Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/"/>
      <url>2018/06/16/%5BCODEVS1172%5D-Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1172/" target="_blank" rel="noopener">传送门</a></p><p>题意：有 n 个询问，每个询问中有四个自然数 a, b, c, d, 然后求有多少个 x 满足 $gcd(a, x) = c$ 且 $lcm(b, x) = d$ 。<br>$n \leq 2000$ , $1 \leq a, b, c, d \leq 2 * 10^9$ 。</p><p>解法一：</p><p>d 的约数个数上界是 $\sqrt{d}$ ，但 1 ~ d 中每个数约数个数大概只有 $log d$ ，所以我们可以预处理出 1～$\sqrt{2 * 10^5}$ 的所有质数，然后用搜索算法组成 d 的所有约数，再判断是否满足题目条件，即可得到100分。<br>——lyd</p><p>而我写的是这个：</p><p>解法二：</p><p>因为 x 是 d 的约数，所以 x 的质因子 p 一定也是 d 的质因子。我们可以对 d 的每个质因子 p 分别计算 x 可能包含多少个 p 。</p><p>设 a, b, c, d, x 分别包含 $m_a$ , $m_b$ , $m_c$ , $m_d$ , $m_x$ 个质因子 p ，其中 $m_x$ 是未知量。</p><p>如果 $m_a == m_c$ 且 $m_b == m_d$ 且 $m_c \leq m_d$ 那么 $m_x$ 只要满足 $m_c \leq m_x \leq m_d$ 就可以了，方案数为 $m_d - m_c + 1$；<br>若 $m_c &gt; m_d$ 那本次询问答案无解，为0。</p><p>若 $m_a \neq m_c$ 且 $m_b \neq m_d$ ，那么 $m_x$ 必须等于 $m_c$ 和 $m_d$ ，若 $m_c \neq m_d$ 则无解。</p><p>我们把 $m_x$ 的取法数记为 $cnt_p$ ，也就是 x 包含质因子 p 的方案有 $cnt_p$ 种。根据乘法原理，满足题意的 x 数量即为连乘积：</p><script type="math/tex; mode=display">\prod_{p | d} cnt_p</script><p>同样我们预处理出 1～$\sqrt{2 * 10^5}$ 的所有质数，因为 d 至多包含 10 个质因子，所以计算量很小，深搜解决，时间复杂度 $O(n\sqrt{d} / logd)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line">ll n, a0, a1, b0, b1, tot, ans;</span><br><span class="line"><span class="keyword">int</span> prime[N];</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            mark[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m0, m1, m2, m3;</span><br><span class="line">    m0 = m1 = m2 = m3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a0 % x == <span class="number">0</span>) &#123;a0 /= x, m0++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (a1 % x == <span class="number">0</span>) &#123;a1 /= x, m1++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (b0 % x == <span class="number">0</span>) &#123;b0 /= x, m2++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (b1 % x == <span class="number">0</span>) &#123;b1 /= x, m3++;&#125;</span><br><span class="line">    <span class="keyword">if</span> (m0 == m1 &amp;&amp; m2 == m3) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m1 &lt;= m3) ans *= (m3 - m1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m0 != m1 &amp;&amp; m2 != m3 &amp;&amp; m1 != m3) ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Euler_prime();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;a0, &amp;a1, &amp;b0, &amp;b1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) solve(prime[i]);</span><br><span class="line">        <span class="keyword">if</span> (b1 != <span class="number">1</span>) solve(b1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最大公约数与最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举子集的飘逸写法</title>
      <link href="2018/05/28/%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86%E7%9A%84%E9%A3%98%E9%80%B8%E5%86%99%E6%B3%95/"/>
      <url>2018/05/28/%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86%E7%9A%84%E9%A3%98%E9%80%B8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>要二进制枚举子集啦（准确地说是先枚举集合 S 再枚举 S 的子集 T），其中 S 最多有 n 个元素。</p><p>很容易想到，每个物体有取（1）和不取（0）两种情况，那么总共有 $2^n$ 种情况。<br>要一次概括所有物体的选择情况，二进制就是很好的选择。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;  <span class="comment">// i 枚举所有物体的选择情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么第二层循环中是 j = (j - 1) &amp; i 呢？<br>这样起到了将 j 中有效位（为1）逐渐删除的效果。<br>例如，当 i = 101000 时，j 初始为 101000，第一轮变为 100111，&amp; i 后变为 100000，成功将最后一个1删除。</p><p>时间复杂度计算很玄学，可以发现 S 有 $\binom{n}{i}$ 种选法，i 个中还有 $2^i$ 种选取情况。<br>所以就是：</p><script type="math/tex; mode=display">\sum_{i=0}^n{\binom{n}{i} * 2^i}</script><p>再通过某种玄学证明可得该式 = $3^n$。(20.02.07upd: 就是二项式定理啦！！！即 (1 + 2) ^ n) </p><p>同样的，若枚举 S 的子集 T，再枚举 T 的子集 T1，时间复杂度就是 $4^n$。</p><p>需要注意的是，O($3^n$) 表示 &lt;= $3^n$，而 $3^n$ 就是 $3^n$，是一个准确值。</p><p>顺带的，若要枚举集合 U 中的子集 S 和 T，其中 S 与 T 无重复元素，只需枚举 S，再在 U 中除 S 的元素中枚举 T。</p><p>这是一种很好的二进制思想，利用位运算，巧妙地将冗余降到了最低，因此是最优的该类算法。尽管最优，因为是指数级算法，n 也只能最多取到15左右。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeJam2018-R1c</title>
      <link href="2018/05/07/CodeJam2018-R1c/"/>
      <url>2018/05/07/CodeJam2018-R1c/</url>
      
        <content type="html"><![CDATA[<h3 id="A-A-Whole-New-Word"><a href="#A-A-Whole-New-Word" class="headerlink" title="A. A Whole New Word"></a>A. A Whole New Word</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard</a></p><p>set记题目给定的字符串出现过，然后dfs枚举字符串，26^L，在找到第一个合法的字符串后立刻返回。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; h;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">int</span> n, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.count(ret)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (c[x][i]) &#123;</span><br><span class="line">        ret[x] = <span class="string">'A'</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L;</span><br><span class="line">    h.clear();</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; ++j) c[j][s[j] - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        h.insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; ++j) ret += <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dfs(<span class="number">0</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Lollipop-Shop"><a href="#B-Lollipop-Shop" class="headerlink" title="B. Lollipop Shop"></a>B. Lollipop Shop</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard</a></p><p>这是一道交互题，给出每种棒棒糖被喜欢的概率，要求最后答案是正解的90%以上。<br>乍一看很不可做。不知道大家喜欢的糖，怎么做呢？<br>贪心思想，将概率最小的糖给他。/不是概率大的：概率大就有很多人喜欢了，怎么给呢？<br>cnt[]记录概率，若概率相同，怎么办呢？<br>概率性的，当然少不了随机啦！/随机大法好<br>在这种各为50%的情况下，我们随一个数，通过奇偶性来决定分给两者中哪一位。<br>最后 fflush(stdout) 刷新输入。<br>这个算法的概率性体现在“随一个数，判断奇偶性”中，如果不是交互题，就不存在概率的问题，就是正确的算法。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">205</span>], mk[<span class="number">205</span>], biu[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(mk, <span class="number">0</span>, <span class="keyword">sizeof</span>(mk));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> K;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; K;</span><br><span class="line">        <span class="built_in">memset</span>(biu, <span class="number">0</span>, <span class="keyword">sizeof</span>(biu));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            ++cnt[x + <span class="number">1</span>], biu[x + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (biu[j] &amp;&amp; !mk[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[j] &lt; cnt[p]) p = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt[j] == cnt[p] &amp;&amp; (rand() &amp; <span class="number">1</span>)) p = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; p - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>, mk[p] = <span class="number">1</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>) * clock());</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Ant-Stack"><a href="#C-Ant-Stack" class="headerlink" title="C. Ant Stack"></a>C. Ant Stack</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard/000000000003e0a8" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard/000000000003e0a8</a></p><p>很显然哇，是LIS的改编，朴素的LIS，Task1可以过。<br>Task2呢？<br>之前我们想到的是表示长度，但重量那一维太大了，我们将长度与重量换一换。<br>f[i][j] 表示，前 i 个中，<br>可以发现，a = 6b 时，a + b = 7b / 6。又因保证 wi &lt;= 10 ^ 9，可以发现 (7 / 6) ^ 150 &gt; 10 ^ 9，因此最多150人。那么我们1～150循环枚举长度。发现每一次循环，DP只需要上一次DP的消息，所以我们使用滚动数组。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)(<span class="number">1e5</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = (LL)(<span class="number">1e18</span>) + <span class="number">100</span>;</span><br><span class="line">LL f[<span class="number">2</span>][maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, lst = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) f[<span class="number">0</span>][j] = f[<span class="number">1</span>][j] = inf;</span><br><span class="line">    f[now][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">150</span>; ++j) &#123;</span><br><span class="line">        now = lst ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)  f[now][i] = inf;</span><br><span class="line">        LL ww = f[lst][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ww &lt;= a[i] * <span class="number">6</span>) f[now][i] = ww + a[i];</span><br><span class="line">            ww = min(ww, f[lst][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (f[now][i] &lt; inf) mx = j;</span><br><span class="line">        lst = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF-Gym-100340A]-Cookies</title>
      <link href="2018/05/01/%5BCF-Gym-100340A%5D-Cookies/"/>
      <url>2018/05/01/%5BCF-Gym-100340A%5D-Cookies/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/Gym-100340A" target="_blank" rel="noopener">传送门</a></p><p>题意：圣诞老人要将 $m$ 个饼干全部分给 $n$ 个孩子，每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g[i]$。如果有 $a[i]$ 个孩子拿到的饼干树比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $a[i]g[i]$ 的怨气。$1 \leq n \leq 30$, $n \leq m \leq 5000$.</p><p>如果要计算第 $i$ 个孩子的怨气值，就必须要知道 $a[i]$。一个孩子的怨气大小与其他孩子获得的饼干数有关。</p><p>仔细思考可以发现，贪婪度大的孩子应该获得更多的饼干。正如「国王游戏」与「皇后游戏」一般，我们可以用邻项交换的方式来证明。因此，可以将孩子按贪婪度降序排列。</p><p>设 $f[i][j]$ 为前 $i$ 个孩子分配 $j$ 块饼干时，怨气总和的最小值。有两种情况：</p><ol><li>第 $i + 1$ 个孩子获得的饼干数比第 $i$ 个孩子少，此时 $a[i + 1] = i$</li><li>第 $i + 1$ 个孩子获得的饼干数与第 $i$ 个孩子相同，此时还需要知道 $i$ 前面有几个孩子与i获得的饼干数相同，才能算出 $a[i + 1]$。</li></ol><p>既要知道第 $i$ 个孩子获得的饼干数，又要知道 $i$ 前面有几个孩子与 $i$ 获得的饼干数相同，很难高效地维护 dp。</p><p>观察 dp，可发现“每个孩子至少分到一块饼干”。</p><ol><li>若第 $i$ 个孩子的饼干数大于$1$，$f[i][j] = f[i][j - i]$（即每个孩子少拿一块饼干）。</li><li>若第 $i$ 个孩子的饼干数等于$1$，则枚举i前面有多少个孩子也获得了一块饼干。</li></ol><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]=min(f[i][j-i], min(f[k, j - (i - k)] + k * {\sum_{p = k + 1}^{i} g[p]}))</script><p>初始：$f[0][0] = 0$， 目标：$f[n][m]$。</p><p>方案转移，就像「I-country」一样，开两个数组记录“转移来源”，一次递归回去，找到最优路径。</p><p>CODE:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>, M = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, pre[N], f[N][M], res[N];</span><br><span class="line"><span class="keyword">int</span> lstN[N][M], lstM[N][M];  <span class="comment">// 记录方案</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum, id;</span><br><span class="line">&#125;g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.sum &gt; b.sum;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> L = lstN[x][y], R = lstM[x][y];</span><br><span class="line">    <span class="keyword">if</span> (x == L) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) res[g[i].id]++;</span><br><span class="line">        record(L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= x; i++) res[g[i].id]++;</span><br><span class="line">        record(L, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cookies.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"cookies.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i].sum);</span><br><span class="line">        g[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g + <span class="number">1</span>, g + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = pre[i - <span class="number">1</span>] + g[i].sum;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = min(f[i][j], f[i][j - i]);</span><br><span class="line">            lstN[i][j] = i, lstM[i][j] = j - i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = f[k][j - (i - k)] + k * (pre[i] - pre[k]);</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &gt; sum) &#123;</span><br><span class="line">                    f[i][j] = sum;</span><br><span class="line">                    lstN[i][j] = k, lstM[i][j] = (j - (i - k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][m]);</span><br><span class="line">    record(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真是一道好题。在数据无序的情况下，我们不知道怎么DP，但可以通过额外的算法（本题中是邻项交换）来确定DP状态的计算顺序，还可以在状态空间中运用等效手法来对状态进行缩放。<br>本题中，我们利用贪心策略，利用相对大小的不变性，将第i + 1个孩子的饼干数先缩放到1，使问题得到简化，容易维护、转移。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP-字符串匹配</title>
      <link href="2018/04/22/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>2018/04/22/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>今天来学KMP算法啦！<br>KMP是用来做字符串匹配的，比如，给定S序列：abababa， T序列：ba，<br>问T序列在S序列里出现的位置，如题则为3、5、7。</p><p>那么，有一种暴力算法，枚举结尾，O(nm)，当然仅限于暴力。。<br>KMP是改进版，简洁好打，O(n + m)!!<br>朴素算法中有许多不必要的枚举，如果失配了，会回归原点，从下一位再次开始；<br>而KMP充分利用匹配失败的信息，尽量减少匹配次数。</p><p>算法中涉及到一个next数组，这也是KMP中最重要的部分。<br>next[i]表示前i位中，前缀与后缀相同的最长部分，<br>比如，序列abcab，next[5] = 2(‘ab’), next[4] = 1(‘a’)。<br>这样，利用next[]，一个序列中后缀匹配不上，就用前缀去匹配。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> next[N];  <span class="comment">// 前缀与后缀相同的最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; t[i] != t[k + <span class="number">1</span>]) k = next[k];  <span class="comment">// 跳回去，往前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[k + <span class="number">1</span>]) k++;  <span class="comment">// 相同的情况下</span></span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;  <span class="comment">// 先处理next[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; s[i] != t[k + <span class="number">1</span>]) k = next[k];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[k + <span class="number">1</span>]) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉KMP充分将时间用在刀刃上了。。好妙的KMP。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】欧几里得与扩展欧几里得</title>
      <link href="2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Gcd"><a href="#Gcd" class="headerlink" title="Gcd"></a>Gcd</h2><hr><p>欧几里得算法又称辗转相除法，用于计算两个整数的最大公约数.</p><p>引理：<br>    求整数 a、b 的最大公约数，表示成 gcd(a,b)，设 r = a % b，则 gcd(a, b) = gcd(b, a % b).</p><p>证明:<br>    a = kb + r, r = a % b.<br>    假设 c 是 a、b 的公约数，则 c | a, c | b, r = a - kb，因此 c | r.<br>    因此 c 也是 (b, a % b) 的公约数.<br>    c | b, c | r, a = kb + r.<br>    所以 c 也是 (a, b) 的公约数.<br>    既然 (a, b）与 (b, a % b) 的公约数相等，其最大公约数也必然相等，得证.<br>    (gcd(a, 0) = a)</p><h2 id="exGcd"><a href="#exGcd" class="headerlink" title="exGcd"></a>exGcd</h2><hr><p>扩展欧几里得算法，一般用来求解不定方程、线性同余方程、模的逆元等.</p><p>可以根据裴蜀定理那一课的证明来学一学，这里就不再多说，不过仍有值得一提的：以下程序求出 ax + by = gcd(a, b) 的一组特解 x0, y0，并返回 a，b 的最大公约数 d。对于更为一般的方程 ax + by = c，它有解当且仅当 d | c。我们可以先求出 x0, y0，然后令 x0, y0 同乘以 c / d，就得到了 ax + by = c 的一组特解 (c / d)x0, (c / d)y0。</p><p>事实上，方程 ax + by = c 的通解可以表示为：x = (c / d)x0 + k(b / d), y = (c / d)y0 + k(a / d)，其中 k 取遍整数集合。</p><p>CODE:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d = exGcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x;</span><br><span class="line">    x = y, y = z - y * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 欧几里得与扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bezout(裴蜀)定理</title>
      <link href="2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
      <url>2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Bezout 定理：对于任意整数 a，b，存在一对整数 x，y，满足 ax + by = gcd(a, b).</p><p>证明：在欧几里得算法的最后一步，即 b = 0 时，显然有一对整数 x = 1, y = 0 ，使得 $a <em> 1 + 0 </em> 0 = gcd(a, 0)$ 。若 b &gt; 0, 则 gcd(a, b) = gcd(b, a mod b)。假设存在一对整数 x，y，满足 $b <em> x + (a mod b) </em> y = gcd(b, a mod b)$ ，因为 $bx + (a mod b)y = bx + (a - b\lfloor{a / b}\rfloor)y = ay - b(x - \lfloor{a / b}\rfloor y)$ ，所以令 $x^{‘} = x$ ，$y^{‘} = x - \lfloor{a / b}\rfloor y$ ，就得到了 $ax^{‘} + by^{‘} = gcd(a, b)$ 。</p><p>证毕。</p><p>Bezout定理是按照欧几里得算法的思路证明的，且上述证明同时给出了整数 x 和 y 的计算方法，即扩展欧几里得算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 欧几里得与扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler线性筛</title>
      <link href="2018/01/21/Euler%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>2018/01/21/Euler%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="欧拉筛法求质数"><a href="#欧拉筛法求质数" class="headerlink" title="欧拉筛法求质数"></a>欧拉筛法求质数</h3><hr><p>当我们知道一个数为质数时，它的倍数肯定不是质数，所以我们可以从 2 开始通过乘积筛掉所有的合数.</p><p>欧拉筛法保证所有合数都是被它的最小质因子筛掉的，时间复杂度 O(N).</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N], prime[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    m = <span class="number">0</span>;  <span class="comment">// 质数数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++m] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// 保证每个数只会被它的最小质因子筛去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="2017/06/06/Hello/"/>
      <url>2017/06/06/Hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><p>数学公式测试</p><script type="math/tex; mode=display">x ^ 2 + 2x + 1 = 0</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
