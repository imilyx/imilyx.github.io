<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【置顶】Ideas &amp; Tricks</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91Ideas%20&amp;%20Tricks/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91Ideas%20&amp;%20Tricks/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】嘴巴</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%98%B4%E5%B7%B4/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%98%B4%E5%B7%B4/</url>
      
        <content type="html"><![CDATA[<p>要锻炼思维就不能每道都写。（然而这并不意味你写就草草写！xml 的赛场调试水平之差有目共睹 qaq…）因 此 开 了 「㗅」坑。</p><p>嘴巴题不会放在「学习计划」里。</p><p>因为是嘴巴题所以低配，一律 details。</p><p>加星号的是打算有时间写写的。</p><h3 id="CF741D"><a href="#CF741D" class="headerlink" title="$CF741D$"></a><a href="https://www.luogu.com.cn/problem/CF741D" target="_blank" rel="noopener">$CF741D$</a></h3><details>「重排」这个条件非常强：所有字符只能有最多一种出现奇数次。奇偶性考虑异或。对于一种 01 路径维护最长的那条。启发式合并每个子树的路径。O(nlogn)</details><h3 id="BZOJ4771-七彩树"><a href="#BZOJ4771-七彩树" class="headerlink" title="$BZOJ4771-$七彩树"></a>$BZOJ4771-$七彩树</h3><details>多次询问子树 x 里深度为 [dep_x, dep_x + d] 有多少种不同的颜色。无脑线段树合并复杂度肯定错了嘛。不考虑深度限制，初始时某颜色 c 的两个点 a、b 各自贡献是 1，到了 lca(a, b) 就要除去 1 个贡献。最后答案是子树和。考虑深度限制：预处理距离每个 x <= 1 d 的答案。[dep_x, dep_x + d] 在 dfs 序上是连续的。 假设我们已经有 <="d" - 的答案，那就把深度为 的答案加进来，按 序插在主席树里就好。（好㗅 details><h3 id="AGC051D"><a href="#AGC051D" class="headerlink" title="$AGC051D$"></a><a href="https://atcoder.jp/contests/agc051/tasks/agc051_d" target="_blank" rel="noopener">$AGC051D$</a></h3><details>巧妙处理。路径的分类标准是什么？我模糊感觉到不同的类别之间应该要有关联。怎么用合适的分类去把 abcd 关联起来呢？官方题解：分三类。1. 过 $T$ 型。$S \rightarrow T \rightarrow U$, $U \rightarrow T \rightarrow S$2. 过 $V$ 型。$S \rightarrow V \rightarrow U$, $U \rightarrow V \rightarrow S$3. 回型。$S \rightarrow T \rightarrow S$, $S \rightarrow V \rightarrow S$, $U \rightarrow T \rightarrow U$, $U \rightarrow V \rightarrow U$枚举过 $T$ 型和过 $V$ 型的数量，列出一个好多组合数的柿子，然后变成阶乘再 FFT。。大概就完了，主要是分类比较神。</details><h3 id="WC2018-即时战略"><a href="#WC2018-即时战略" class="headerlink" title="WC2018-即时战略"></a><a href="https://uoj.ac/problem/349" target="_blank" rel="noopener">WC2018-即时战略</a></h3><details>好像没什么特别妙的= =……？数据范围一眼 log。要一棵树支持：1. 加点 2. 快速跳到一个点方法一：二分！LCT，在实链上不断二分，然后跳到下一个实链。方法二：点分树 + 替罪羊重构。维护已知树的点分树，设 explore(x, y) = z，从 z 开始向上跳 logn 次找到 z 在 x 的哪个点分子树里，跳过去。这样的上跳要点分树深度次即 logn 次，于是是 O(nlog^2n) 的。</details></=></details>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】暂时胜利</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%9A%82%E6%97%B6%E8%83%9C%E5%88%A9/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%9A%82%E6%97%B6%E8%83%9C%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】耻辱柱</title>
      <link href="2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E8%80%BB%E8%BE%B1%E6%9F%B1/"/>
      <url>2099/11/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E8%80%BB%E8%BE%B1%E6%9F%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="开-Wall"><a href="#开-Wall" class="headerlink" title="开 -Wall"></a><em>开 -Wall</em></h1><h1 id="能救你一命"><a href="#能救你一命" class="headerlink" title="能救你一命"></a><em>能救你一命</em></h1><hr><h2 id="多测清空：特别是建图，cnt清否？lnk清否？deg清否？"><a href="#多测清空：特别是建图，cnt清否？lnk清否？deg清否？" class="headerlink" title="多测清空：特别是建图，cnt清否？lnk清否？deg清否？"></a>多测清空：特别是建图，cnt清否？lnk清否？deg清否？</h2><h2 id="set：不能在-it-的-for-循环中-erase-it"><a href="#set：不能在-it-的-for-循环中-erase-it" class="headerlink" title="set：不能在 it 的 for 循环中 erase(it)"></a>set：不能在 it 的 for 循环中 erase(it)</h2><h2 id="dp-要注意如果有-f-i-min-f-i-j-g-j-，注意判-f-i-j-g-j-会不会炸-long-long（初始值是-1e18-的话会炸！！！）"><a href="#dp-要注意如果有-f-i-min-f-i-j-g-j-，注意判-f-i-j-g-j-会不会炸-long-long（初始值是-1e18-的话会炸！！！）" class="headerlink" title="dp 要注意如果有 f[i] = min(f[i - j] + g[j])，注意判 f[i - j] + g[j] 会不会炸 long long（初始值是 1e18 的话会炸！！！）"></a>dp 要注意如果有 f[i] = min(f[i - j] + g[j])，注意判 f[i - j] + g[j] 会不会炸 long long（初始值是 1e18 的话会炸！！！）</h2><p>——wc2020 场外赛 25 pts$</p><h2 id="分母是否为-0？nan！"><a href="#分母是否为-0？nan！" class="headerlink" title="分母是否为 0？nan！"></a>分母是否为 0？nan！</h2><p>——模拟赛 100 -&gt; 0</p><h2 id="取模模-0-了吗？RE！"><a href="#取模模-0-了吗？RE！" class="headerlink" title="取模模 0 了吗？RE！"></a>取模模 0 了吗？RE！</h2><p>——做题，wa 了 inf 次</p><h2 id="取模取对了吗？正负对了吗？最好输出前-ans-mod-mod！"><a href="#取模取对了吗？正负对了吗？最好输出前-ans-mod-mod！" class="headerlink" title="取模取对了吗？正负对了吗？最好输出前 (ans += mod) %= mod！"></a>取模取对了吗？正负对了吗？最好输出前 (ans += mod) %= mod！</h2><p>——noi2020同步赛 D1T2 ？分</p><h2 id="字母打错了吗？"><a href="#字母打错了吗？" class="headerlink" title="字母打错了吗？"></a>字母打错了吗？</h2><p>——noi2020同步赛 D1T3 24 分，r1、r2 打成 c1、c2</p><h2 id="空间开大了吗？哪怕卡着都不行！"><a href="#空间开大了吗？哪怕卡着都不行！" class="headerlink" title="空间开大了吗？哪怕卡着都不行！"></a>空间开大了吗？哪怕卡着都不行！</h2><p>——模拟赛 80 -&gt; 0</p><h2 id="空间开小了吗？2e5-开了-1e5？"><a href="#空间开小了吗？2e5-开了-1e5？" class="headerlink" title="空间开小了吗？2e5 开了 1e5？"></a>空间开小了吗？2e5 开了 1e5？</h2><p>——模拟赛 80 -&gt; 50</p><h2 id="floor-x-是小于等于-x-的最大整数，ceil-x-是大于-x-的最小整数"><a href="#floor-x-是小于等于-x-的最大整数，ceil-x-是大于-x-的最小整数" class="headerlink" title="floor(x) 是小于等于 x 的最大整数，ceil(x) 是大于 x 的最小整数"></a>floor(x) 是小于等于 x 的最大整数，ceil(x) 是<strong>大于</strong> x 的最小整数</h2><p>——模拟赛 fst 了一定分</p><h2 id="C-n-m-里写-if-n-lt-m-return-0-了吗？"><a href="#C-n-m-里写-if-n-lt-m-return-0-了吗？" class="headerlink" title="C(n, m) 里写 if (n &lt; m) return 0; 了吗？"></a>C(n, m) 里写 if (n &lt; m) return 0; 了吗？</h2><h2 id="builtin-popcount-不适宜计算-long-long-类型的答案（不知道为啥）"><a href="#builtin-popcount-不适宜计算-long-long-类型的答案（不知道为啥）" class="headerlink" title="__builtin_popcount() 不适宜计算 long long 类型的答案（不知道为啥）"></a>__builtin_popcount() 不适宜计算 long long 类型的答案（不知道为啥）</h2><p>真要用的话可以用 __builtin_popcountll()</p><h2 id="double-题用-int-计算斜率-坐标了吗？"><a href="#double-题用-int-计算斜率-坐标了吗？" class="headerlink" title="double 题用 int 计算斜率/坐标了吗？"></a>double 题用 int 计算斜率/坐标了吗？</h2><h2 id="输出-0-的输出-1-了吗？输出-1-的输出-0-了吗？"><a href="#输出-0-的输出-1-了吗？输出-1-的输出-0-了吗？" class="headerlink" title="输出 0 的输出 -1 了吗？输出 -1 的输出 0 了吗？"></a>输出 0 的输出 -1 了吗？输出 -1 的输出 0 了吗？</h2><p>——模拟赛 100 -&gt; 60</p><h2 id="变量重名了吗？外面-i-里面也是-i"><a href="#变量重名了吗？外面-i-里面也是-i" class="headerlink" title="变量重名了吗？外面 i 里面也是 i"></a>变量重名了吗？外面 i 里面也是 i</h2><h2 id="SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。"><a href="#SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。" class="headerlink" title="SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。"></a>SG函数使用的前提条件：对于任意局面，两个玩家的决策集合相同。</h2><h2 id="递归函数里的变量（比如数组的项首）别开在全局"><a href="#递归函数里的变量（比如数组的项首）别开在全局" class="headerlink" title="递归函数里的变量（比如数组的项首）别开在全局"></a>递归函数里的变量（比如数组的项首）别开在全局</h2><p>——bzoj3636 调半天</p><h2 id="注意-n、m-等主要变量的最大范围是否出现在同一档分里"><a href="#注意-n、m-等主要变量的最大范围是否出现在同一档分里" class="headerlink" title="注意 n、m 等主要变量的最大范围是否出现在同一档分里"></a>注意 n、m 等主要变量的最大范围是否出现在同一档分里</h2><p>——模拟赛的惨痛遭遇 挂 80pts</p><h2 id="不要再不排序求前缀和了！！！💢💢💢"><a href="#不要再不排序求前缀和了！！！💢💢💢" class="headerlink" title="不要再不排序求前缀和了！！！💢💢💢"></a>不要再不排序求前缀和了！！！💢💢💢</h2><p>——模拟赛 100 -&gt; 0</p><h2 id="线段树要记得-pushdown-和-update。。。"><a href="#线段树要记得-pushdown-和-update。。。" class="headerlink" title="线段树要记得 pushdown 和 update。。。"></a>线段树要记得 pushdown 和 update。。。</h2><h2 id="Tarjan-边双要记录入边"><a href="#Tarjan-边双要记录入边" class="headerlink" title="Tarjan 边双要记录入边"></a>Tarjan 边双要记录入边</h2><h2 id="数组-5e5-开成-1e5"><a href="#数组-5e5-开成-1e5" class="headerlink" title="数组 5e5 开成 1e5"></a>数组 5e5 开成 1e5</h2><p>——模拟赛 100 -&gt; 60</p><h2 id="线段树-if-lx-gt-rx-return"><a href="#线段树-if-lx-gt-rx-return" class="headerlink" title="线段树 if (lx &gt; rx) return;"></a>线段树 <code>if (lx &gt; rx) return;</code></h2><p>——模拟赛 100 -&gt; 30</p><h2 id="链式前向星-i-nxt-i-老是写错。"><a href="#链式前向星-i-nxt-i-老是写错。" class="headerlink" title="链式前向星 i = nxt[i] 老是写错。"></a>链式前向星 <code>i = nxt[i]</code> 老是写错。</h2><p>——虫逢 T 成 sb</p><h2 id="vector-insert-O-n"><a href="#vector-insert-O-n" class="headerlink" title="vector .insert() O(n)"></a>vector .insert() O(n)</h2><h2 id="printf-“-lld”-0"><a href="#printf-“-lld”-0" class="headerlink" title="printf(“%lld”, 0)"></a>printf(“%lld”, 0)</h2><p>——BOOM！</p><h2 id="mul-int-类型写成-void"><a href="#mul-int-类型写成-void" class="headerlink" title="mul() int 类型写成 void"></a>mul() int 类型写成 void</h2><p>——40 分 has gone！</p><h2 id="a-b-c-d"><a href="#a-b-c-d" class="headerlink" title="a = b + c == d"></a>a = b + c == d</h2><p>——boom! 应该是 a = b + (c == d)。括号要勤加！</p><h2 id="AB-AC-gt-0-（叉积）表示三角形-ABC-为逆时针"><a href="#AB-AC-gt-0-（叉积）表示三角形-ABC-为逆时针" class="headerlink" title="$AB * AC &gt; 0$（叉积）表示三角形 ABC 为逆时针"></a>$AB * AC &gt; 0$（叉积）表示三角形 ABC 为逆时针</h2><p>——xml 记错了，浪费一小时，特此记录。</p><h2 id="vector-size-不想被卡常还是-int-siz-xxx-size-吧！"><a href="#vector-size-不想被卡常还是-int-siz-xxx-size-吧！" class="headerlink" title="vector .size() 不想被卡常还是 int siz = xxx.size() 吧！"></a>vector .size() 不想被卡常还是 int siz = xxx.size() 吧！</h2><p>——订正某模拟赛 T3，在 90、95 pts 反复横跳</p><h2 id="c-tot-c-tot-1-x-💥"><a href="#c-tot-c-tot-1-x-💥" class="headerlink" title="c[++tot] = c[tot - 1] + x; 💥"></a>c[++tot] = c[tot - 1] + x; 💥</h2><p>——应该是 c[tot + 1] = c[tot] + x, ++tot;</p><p>——靠，这个地方错了两三次了，每次都灵异事件，本地 AC 交上去 WA 光</p><hr><p>虽然 xml 就快要退役了，但 sb 错误还是要记的！！</p><h2 id="答案可以小于-0-的题，初值赋为-0-了"><a href="#答案可以小于-0-的题，初值赋为-0-了" class="headerlink" title="答案可以小于 0 的题，初值赋为 0 了"></a>答案可以小于 0 的题，初值赋为 0 了</h2><p>——答案文件：-324021706   你的输出：0</p><h2 id="string-operator-和-效率差别很大"><a href="#string-operator-和-效率差别很大" class="headerlink" title="string operator + 和 += 效率差别很大"></a>string operator + 和 += 效率差别很大</h2><p>—— + 要新建一个对象然后赋值，+= 就直接拼过去了</p><h2 id="memset-要写换行"><a href="#memset-要写换行" class="headerlink" title="memset 要写换行"></a>memset 要写换行</h2><p>——某 EC final J 题懒惰没换行，疯狂 TLE on 2……</p><h2 id="传参，传了-vector"><a href="#传参，传了-vector" class="headerlink" title="传参，传了 vector"></a>传参，传了 vector</h2><p>——TLE！要传指针形式的 vector，或者保险起见直接传 vector 的编号。</p><h2 id="void-写成-int，我也有今天"><a href="#void-写成-int，我也有今天" class="headerlink" title="void 写成 int，我也有今天"></a>void 写成 int，我也有今天</h2><p>——noi 2021 同步赛 20 分，花了好大力气写的 20 分就这么 RE 了 呜呜</p><h2 id="accumulate-等函数-没有取模功能"><a href="#accumulate-等函数-没有取模功能" class="headerlink" title="accumulate() 等函数 没有取模功能"></a>accumulate() 等函数 <em>没有取模功能</em></h2><p>——xml 傻傻的不知道 爆负数的原因</p><h2 id="遍历-bitset-复杂度与-bitset-内部-1-的个数无关"><a href="#遍历-bitset-复杂度与-bitset-内部-1-的个数无关" class="headerlink" title="遍历 bitset 复杂度与 bitset 内部 1 的个数无关"></a>遍历 bitset 复杂度与 bitset 内部 1 的个数<em>无关</em></h2><p>——啥也没发生，就是个 xml 的误区</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】卡常小记</title>
      <link href="2099/11/29/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%A1%E5%B8%B8%E5%B0%8F%E8%AE%B0/"/>
      <url>2099/11/29/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%8D%A1%E5%B8%B8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1/KO73EvvIwMN+3pIORpIQiptYRSf6m27NDmcgw2JkXO/mgRrHx6PqkteaoHK6BShklSRNkKEG7YYngs7plVr11fpNQSvtYbsw0zDZh/VbcvLzIu9fAeUt5eTcMfIptHTWQk+A7zpi/fQj3X7LMfMI4dO3B8dt1PtiprwUC7EhqI2Bt7hr/r7fkEX/CnBESZ/5zZgI3QVU0yqXHYYYvQwDhw7N+W8ssGj3WjCMvpOzJx8YhF0OA69VqxT7ts1z3EgHjlK1rtid6U3QOYiBq4ewy+zp6T8fiubXpjKSR4NdS327NRinNUxvVOZdshSFd/6XD5HrgD7lJsM0wvjuIApqhDa0esWMmX8T90T7VwuqLLzAXQLgBfesXAj2oHKh5DVJ1ATDB7LbjYSt9lL4Wl8hnfmA+wGfDQK+GG+lRJgMjFmqSSjXVsujRwCERyhMZbb2AwEqn28O9+SEeaTejEn2PvFa6PKIZ2p3+k6Dws1OL5XjndblPfutG9tkvOcGKGS/d4Ix8w5/xU5teuYX3BVnfm6eBc/XuPyr2Si/Z7erpD6qDDjieavnRLjnsLWe1YaMdrjZgDMvqGcnyWkvqnWDijcfGJuQa8tXsRZChJWNtKpmW2lCRypshD3WQkHfJjV6pVtXegl7rFy2kXmIhqC8OT/Bdf3cHPLmzpnwaOtVFeTnag9inrSK9idv6TyPc4ycI1znYAPAfeIwiS4gxWddQd2kUXqFQybNcJqMqS4ZSQnUG25qzNPe7mUjhZpLo0CoC93w849J2wbPZJE1W2gM4Yxmvw6s28UbqN7STJe/m3h4e0Hu4oKU1XJyCgq7ojch299AgviuipZkBIcY12UcsuMARzegBNjS8pLfnT73v8ftlBDAYrEyjDCuw3rwvqoNvNFaairPycQS8R/PRSJi/ayGrGaNno6vLAcLiGjxyPzZmIBYbVKWWkvYPreof43wyrLYiCHKf1aDK6rdNzSDpyESPQ0OR3D3c8Fy9QIA3DSkBZKRk7dSn/ZmR5JwJXF1dkzWybQjmIQXBe6fKWuY557tqy7CxB3ThTgHqJ0zbp2p+fDPSOJ3UHmI0lLHxVZSLSfLHEFwU9xm5jw1NomoSQKNwwl12ms1sazARM4pWyM4x2IYk9j+eqO4B39kUT48cNWBPp/7rXBZ5NNdz08dFQRitnCnW87qK3OZFQyGJFbt27aqmQWyVjLC7HLscG7W5TAjjrRsQhX2pB2HJ7xDabWFmC77QOaOumjZoI/FSMiTITWbPpJj2wkOBm/RmvTBanoCSUpmroqQLPqXTHnj8k+GUwWEET8Fz+qKN0+46opeMa1V4Ce8DiJuTS/5oRLYPZv4iMOTrstcLuxb3L1ZjiBovBgg2w5S8+VmYg4T+9eW1d+hs0gHlKj9k6wXVF8eSCbFQBp/LrZFG4wJjVRS8RgAnedsD3Lkw4WL/8QeKFL/3i1mVUlaA</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 年度阅读报告</title>
      <link href="2021/12/31/2021%20%E5%B9%B4%E5%BA%A6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/"/>
      <url>2021/12/31/2021%20%E5%B9%B4%E5%BA%A6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+7pjT5jwzmqnD9sIkZqH06IIumIcXjqe5TKgCwqFFQJeMxggpKsBZm+vvicBSfiszxljfyaZaIdOHSLNkMm1YSM0tw2MqCmec+0rgIngRizt5pxTyDZo2c9jCiUIRjsnvuBSTcNsk89v35KNaRH+IUgM9Y5Z0lVwYZVG0hUCNJMWC1qSX0RyprbbLSFo/3cIe832RanGtjndCtcFUWx8srAkRNTehN8L+LcpZp8DXHKNPncw6NEclRr3scwTJI8fHzahm95/8Sy2k6c+JIRmGsMdvI0vaaBCiwepWG4ZMkWHu6eAZzSAx0GZG14Nt+M3dSf/vpTVUuWhtqz0Ugor97HQLtokCwHcFEiDEBa+E7CHHg3HwjWrQ53dPStVg4wW0ETtRimzMJFWBGRtxOdR9kfijEqxFJxTd90CMjSTEsTOa83EARCyETkIIDBRlx+wb6EifuauHZonHR/Acb1SEWYo99P+ipIl7RHMqTwC6PQw2ih1mlO1pPV/ISPc3I4yEcgTuNTw6cBOaB1Ql0ky/IdiIMmf9q6290KMoYD151yBXvGrQ3E/x7DWCtk+yXTtGdm8Ud50sy+6iUHKORWQXI5aPBNUt3JLXB5FUsE/tSB7pMPkqhi1D35b+YXQqxqt1qrG27z5eyS08RoQqcLyQxdSeUrwVbSQzux7X1ZmmFXkT/ZzUXi/qLFwGHt7nIjZXPZZl6/42jDXmzMqamaolulRInPag5B0U+3/BH2H/0nhbqbeZPn2jsMK32F0xndzZKUGTfTiK3qHaMWuA0g1XCxZFV+c2mGMOH5pw5Zhsi6+YC7ABLdYY/VghWCz9ITG045hw4QaIbVKyfJ6XPe3PqWxFp9ucIpHliugDR3Yrxqto6C7E2PP6CNopVongE4UO+ttDOxfLS3vGvEdntPVo8pUCpPyl5g2PzUJSWN1oQGGrwhHwh0Fq97zFq/2OLSofu4X5NCEy5pu0AKL6F8+NlKhVG2k+7NZA7WXhkpwUPYD7elObj/b1R+SJYZg/AAVxLSC4HHU5zbl7geH6LoM8vJ+vklwEzPyOxNkF00cUZ+fkIj9bYVve1puw9Y/S0P9x9uQiiJlqjM7Xh3DmUcVZyayFFFSR2MUDztRAQ4HuPpr82tR5OvjaUAC6lv2viNeMqiENbfYVxvakAvt657IY7cTs+EBlKfKkjtPH/QJjRH/EZ9rGY3J2kXuPdS8DifLwhFMD4f0t4NypNv6BvsqKd8CHgtkg9RKVRa5ohmZYxq+I89CaIbO9Y7F3xMgtCbQc/gkupXw9LpJyqLl2rYnZzqWlKTeLDoY47dCwUMOtYPebiCilAQuVydqWvUeee8cvDg3aUA6HZ7bxu2AJn76zvZMoxeD4sDHh83RRsB5IV4WDlMiUh03yBXHjCs/IeNvzJZaocAbYUmEd/t2HGIjtCHOYsi7y+qwBBYqNCnba4a5uYgf15kNbMpPEutIU+5i+SgKML66W0unFIHF5lYyVB6ItpgJIIrDE1WJLaAC7r/v/TOJooZefprBn1lW3tpkRRWPJm7C99Ag==</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21Aug 训练日志</title>
      <link href="2021/08/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Aug%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/08/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Aug%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】半平面交转凸包</title>
      <link href="2021/08/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4%E8%BD%AC%E5%87%B8%E5%8C%85/"/>
      <url>2021/08/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4%E8%BD%AC%E5%87%B8%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>维护向上的半平面交，即若干形如 $y \geq kx + b$ 的半平面的并，答案形如凸包下凸壳。</p><p>说真的没人写过 $&gt; 1$ 次半平面交吧，因为有更好写更清真拓展性更强的对偶问题——凸包啊！它的对偶问题是将直线 $y = kx + b$ 视为点 $(k, b)$ 然后作凸包上凸壳。</p><p>证明很容易：</p><p>考虑半平面交，已有 $a$、$b$ 两条直线，再加入直线 $c$，能弹走 $b$ 当且仅当 $a$、$b$ 的交点 $(x_0, y_0) = (-\frac{a.b - b.b}{a.k - b.k}, \frac{a.k * b.b - a.b * b.k}{a.k - b.k})$ 在 $c$ 下方，即 $y = c.k * x_0 + c.b &gt; y_0$ ($I$)</p><p>考虑凸包，已有 $A$、$B$ 两个点，加入点 $C$，能弹走 $B$ 当且仅当 $(B - A) * (C - A) \geq 0$，即 $(b.k - a.k) * (c.b - a.b) - (b.b - a.b) * (c.k - a.k) \geq 0$ ($II$)</p><p>而 $I = II$！证明完毕。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://loj.ac/p/3063" target="_blank" rel="noopener">$ROI 2016$ 人烟之山</a></p><p>显然是半平面交。</p><p>向上的半平面交答案形如下凸包，对偶一下变成求上凸包</p><p>判某个点 $(x, y)$ 是否在半平面交内转为切凸包问题</p><p>据说可以李树做到 $O(nlog^2n)$</p><p>我们考虑 SGT 维护凸包，在 SGT 和凸包上二分是两只 $log$，然而只要对询问按 $x$ 排序就优化掉凸包那只 $log$ 了。$O(nlogn)$。</p><p><a href="https://loj.ac/s/1208695" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 百度之星初赛一</title>
      <link href="2021/08/01/2021%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%88%9D%E8%B5%9B%E4%B8%80/"/>
      <url>2021/08/01/2021%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%88%9D%E8%B5%9B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>好诶又能水博客了！</p><h3 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h3><p>拆点，转移关系写成矩阵，$k$ 好大 -&gt; 快速幂，做完。</p><h3 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h3><p>要 按 顺 序 拒 绝 操 作</p><p>$f[i, x]$ 表示到 $i$ 操作，停在 $x$ 的最小拒绝数</p><p>执行交换 $x$、$y$ 的操作时，用彼此的 $f$ 更新一下。滚一维做完了。</p><h3 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h3><p>赛时比较慌张，容易漏讨论怎么办呢？打表，对着表写</p><p>特判 $a = b$</p><p>$a \equiv b \pmod{c}$ -&gt; $a - b \equiv 0 \pmod{c}$</p><p>枚举 $a - b$ 的因数即可。</p><h3 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h3><p>我写的链表，每次假设询问的时候断掉再连上就可以了，轻松愉快</p><p>题解是说维护头俩 $0$ 的位置，填了其中一个就往后找到下一个 $0$，$O(n)$</p><h3 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h3><p>模拟</p><hr><p>以下是全场两位数 AC 嘚！一场初赛三道数数题、其中两道拉反，麻了（是这么用吧</p><h3 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h3><p>枚举填非 $0$ 数字的位置：</p><p>$q(n) = \sum\limits_{k = 0}^n \binom{n}{k} \binom{2n - k}{n - k} 2^k c^k$</p><p>接下来都是化式子 + 多项式科技的事情了，我觉得我可以止于此步。<del>才不会说是因为看不懂官解呢</del></p><h3 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h3><h3 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h3><p>考虑先将 $s$ 个儿子分配给 $m$ 个根 ($I$)，再把剩下的 $n - m$ 个点组合成 $s$ 棵有根树的方案 ($II$)</p><p>考虑 ($II$)，根据广义 cayley 定理（将 $n$ 个有标号节点形成 $k$ 棵有根树的方案数是 $kn^{n - k - 1}$）推得方案数</p><p>$= \binom{n - m}{s} <em> s </em> (n - m)^{n - m - s - 1} = \binom{n - m - 1}{s - 1} (n - m)^{n - m - s}$</p><p>再考虑 ($I$)，显然是 $s! [x^s] ( \sum\limits_{i = 0}^k \frac{x^i}{i!} )^m$</p><p>再往下是拉反和复合逆了，止步于此.jpeg</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21Jul 训练日志</title>
      <link href="2021/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jul%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jul%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOI2021 题解</title>
      <link href="2021/07/28/NOI2021%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/07/28/NOI2021%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>问题：</p><ul><li>「对题意换一种理解角度」真的很实用，但 xml 这个二货老是忘记。</li><li>拿到题目就脑子一热，该冲暴力的刚正解，正解好想的就像魔怔了一样刚暴力（好像是在回避什么？</li><li>调题不开 -Wall</li><li>命名混乱</li></ul><p>这次的 D1T1 和 D1T2 都应当 AC。</p><hr><h3 id="D1T1-轻重边"><a href="#D1T1-轻重边" class="headerlink" title="D1T1 轻重边"></a>D1T1 轻重边</h3><p>看作链上染色，一条边是重边的充要条件是两端颜色相同。</p><p>然后就做完了woc！！！树剖 + SGT 维护合法边个数，SGT 只要记录左右端点颜色即可合并，很套路的做法。</p><p>五味杂陈，所谓的冲高端就是这种套路大杂烩也冲不出来吗？？？</p><p>不过算是锻炼树剖了。</p><h3 id="D1T2-路径交点"><a href="#D1T2-路径交点" class="headerlink" title="D1T2 路径交点"></a>D1T2 路径交点</h3><p>好像是大 sb 题…… 然而我连矩阵行列式都没想到…… 甚至没想到容斥系数之类的…… 偶数 - 奇数，显然是有个 $(-1)^k$ 的容斥系数嘛……</p><p>逆序对数，奇偶，想到矩阵行列式。</p><p>又是和路径有关的。（实际上这就个 LGV 板题）</p><p>$k = 2$ 和 A 性质，答案显然为邻接矩阵行列式的值，等于邻接矩阵相乘后的矩阵行列式的值。</p><p>推广到一般，乘得一个 $n_1 * n_k$ 的矩阵 <del>而 $n_1 = n_k$，题目已经写得很裸了</del></p><p>很打脸了，就在同步赛的前几天还订正了 XJ 一道 LGV 套容斥题，自诩为 LGV 爱好者</p><h3 id="D1T3-庆典"><a href="#D1T3-庆典" class="headerlink" title="D1T3 庆典"></a>D1T3 庆典</h3><p>先缩点。考虑题目里那个性质，它告诉我们缩点后，假设三个块 $x$、$y$、$z$ 之间的关系是 $x$ -&gt; $y$, $y$ -&gt; $z$, $x$ -&gt; $z$</p><p>不妨忽略 $x$ -&gt; $z$，这并不影响连通性/可达性</p><p>剩下一棵外向树。</p><p>$K$ 很小，考虑从起点开始 bfs，扩展到子树里连出去的新边的端点（可以直接枚举新边是哪条），并用树剖记录路径。设扩展次数的阈值为 $4$ 左右能过。</p><p>细节：去除多余 DAG 上边的步骤：每个点在最终外向树上的父亲是它 DAG 上所有父亲中拓扑序最大的那个。</p><p>卡常：无，跑挺快的。</p><h3 id="D2T1-量子通信"><a href="#D2T1-量子通信" class="headerlink" title="D2T1 量子通信"></a>D2T1 量子通信</h3><p>脑筋急转弯一样的题。</p><p>注意到 $a1$、$a2$ 随机，也就是说串随机生成。</p><p>将 $256$ 划为 $16$ 段，某个模式串合法的必要条件是至少一段完全相同，而这就够了因为完全相同的概率是 $\frac{1}{2^{16}}$，这样一次询问需要 check 的模式串个数期望为 $\frac{n}{65536}$ ≈ $7$。</p><p>卡常，要用链表代替 vector。</p><h3 id="D2T2-密码箱"><a href="#D2T2-密码箱" class="headerlink" title="D2T2 密码箱"></a>D2T2 密码箱</h3><p>xml 是 sb……</p><p>互质条件在演你，因为假设当前分数为 $y/z$（$gcd(y, z) = 1$），$x + y/z = (xz + y)/z$, $gcd(xz + y, z) = gcd(y, z) = 1$</p><p>所以分子分母是独立的！可以矩阵维护。那么你会矩乘那 $15$ 分了。【苦痛】</p><p>我们默认矩乘是在序列上从右往左的。</p><p>W：令 $a_n = a_n + 1$, 左乘矩阵即可。E 也是左乘矩阵即可。</p><p>平衡树维护 flip 和 reverse 操作。flip：维护区间 flip 的结果矩阵。</p><h3 id="D2T3-机器人游戏"><a href="#D2T3-机器人游戏" class="headerlink" title="D2T3 机器人游戏"></a>D2T3 机器人游戏</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNR 5 题解</title>
      <link href="2021/07/20/UNR%205%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/07/20/UNR%205%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="提问系统"><a href="#提问系统" class="headerlink" title="提问系统"></a>提问系统</h3><p>暴力 dp 前缀和优化可以做到 $n^5$ 或 $n^4$，再优化则必然要涉及到 $p_r p_b^2$ 的组合意义了：选 $1$ 个 R 和 $1$ 个 B</p><p>这不是「数树」的套路吗…… $dp[x, dr, db, 0/1, 0/1/2]$ 表示 $x$ 子树里，向下的链最大 R 个数为 $dr$，最大 B 个数为 $db$，选了几个 R，选了几个 B，$n^3$ 就是这么容易……</p><p>考虑优化：dr 和 db 意义改为 $x$ 到根的链（不包括 x）中 R 和 B 的个数，$dr + db = dep_x$ 就优化了一维。dp 的时候相当于递归到子树中算出「$x$ 以上<strong>预先占位</strong>占了 $dr$ 个 R」的方案数，再拼上 $x$ 贡献。</p><p>还是觉得很巧妙啊 owo</p><p><a href="https://uoj.ac/submission/497899" target="_blank" rel="noopener">$Code$</a></p><h3 id="答案查重"><a href="#答案查重" class="headerlink" title="答案查重"></a>答案查重</h3><p>神仙计数题？</p><p>两个子树映射过去相同，那么它们形态必然相同。</p><p>枚举一些「作为根，树互不同构」的点染 $1$，变成有根树，</p><p>$f_i(x)$ 表示 $i$ 子树关于染色点个数本质不同方案的 EGF</p><p>$f_u(x) = (1 + x) \prod\limits_{v} f_v(x) \prod ( \sum\limits_{i = 0}^k \frac{ (g(x) - 1)^i }{i!} )$</p><p>其中第一类是子树互不同构的儿子 $v$；第二类是假设有 $k$ 个儿子子树同构，其 $f(x)$ 都为 $g(x)$。若 $k$ 趋近于 $+\infty$, 贡献就是 $e^{g(x) - 1}$，所以贡献是 $\sum\limits_{i = 0}^k \frac{ (g(x) - 1)^i }{i!}$。直接 dp 就是树上背包合并的复杂度，单次 $O(n^2)$。</p><p>枚举根非常笨蛋，把重心当成根显然是正确的，因为对于原来的每一种方案，其中彼此同构的子树（显然 $size \leq n / 2$）在当前树中依然同构。这样你会了 $O(n^2)$</p><p>来来来我们优化。EGF，树——你想到了什么？「花朵」！</p><p>重链剖分。无同构兄弟的 $f$ 直接乘给链顶；同构子树呢——分治 FFT，两只 log 时间内给你跑出来！</p><p>现在你已经得到许多链上点的儿子的 EGF 堆在链顶，就等着全部卷起来算出链顶的答案 EGF<br>那么启发式卷积即可，堆维护。</p><p>三 只 log 1s 过 十 万</p><p>实现细节算少的（？）但 xml 都调傻了。</p><p><a href="https://uoj.ac/submission/499151" target="_blank" rel="noopener">$Code$</a></p><h3 id="获奖名单"><a href="#获奖名单" class="headerlink" title="获奖名单"></a>获奖名单</h3><p>最低档暴力根本不是 $O(n! * 2^n)$ 啊…… $n!$ 确定顺序后从两边往中间确定，有单个直接 chk，否则…… 也是直接 chk。</p><p>考虑正解。显然有两种匹配（指在中轴两边的）：</p><ol><li>相同的长度为 $2$ 的字符串彼此匹配</li><li>嵌在一起的（题解中称为「交替扩展」），例如第一个串为 [ab][cd]，第二个串为 [a][bc][d]</li></ol><p>可以看作图上问题：$m + 1$ 个点，为 $1 ~ m + 1$，对于单个字符 $a$，连边 $(m + 1, a)$；对于字符串 $ab$，连边 $(a, b)$</p><p>有解条件：</p><ul><li><p>$L$ 为偶数</p><p>两种 case：</p><ol><li>两个相同串：$0$ 所在连通块存在欧拉回路，其他连通块（都是 $l = 2$ 的字符串）每条边出现偶数次。</li><li>中间有个 $aa$，两边两个相同串：存在一个边出现奇数次的自环</li></ol></li><li><p>$L$ 为奇数</p><p>$0$ 所在连通块存在欧拉通路，并且一个端点是 $0$，其他连通块每条边出现偶数次</p></li></ul><p>由于题目良<del>凉</del>心的保证有解，你只需根据判定过程构造即可。</p><p>为什么小清新构造题给 xml 写这么 shit（shit 代码可以在 uoj 提交记录里找到）：</p><ol><li>善于运用 STL 让你没有烦恼，map yyds</li><li>邻接表建图，用奇偶表示方向。</li></ol><p><a href="https://uoj.ac/submission/498090" target="_blank" rel="noopener">$Code$</a></p><h3 id="诡异操作"><a href="#诡异操作" class="headerlink" title="诡异操作"></a>诡异操作</h3><p>naive 如你，以为记录区间 Or 和 sum，每次修改递归到叶节点就是两只 $log$ 了，然而它只能过两个特殊性质包！第一个 $3000$ 的包都过不了…… ——因为事实上每除一次都可以再做 $128$ 次 and，所以是 $O(n 128^2 logn)$</p><p>SGT 上每个节点最多被访问 $128$ 次，因此复杂度至少为 $O(128n)$</p><p>打标记下传就是 $O(n 128^2 + 128 qlogn)$</p><p>考虑优化这个标记下推的复杂度。（超妙啊…… 真就全场都被毒杀了，明哥 nb！）</p><p>每个节点维护一个长度 $128$ 的数组表示该区间在每一位为 $1$ 的个数。那么现在把每位展开，变成一个 $128 * log(len)$ 的矩阵。</p><p>我们由维护「每行 1 的个数」变为维护「每列的和」。注意每列的和依旧是一个 $2^{128}$ 以内的二进制数（方便直接与），因为左右儿子合并给父亲的时候进位是进给更高一级的列。不懂画图。</p><p>这样信息上传就是 $O(log(len))$ 的加法，打标记就是 $O(log(len))$ 每列做与。</p><p>锁定区间的复杂度为两只 $log$（除还是要递归到叶子结点做的，然后一路合并上来）</p><p>复杂度 $O(qlog^2n + \sum\limits_{i \in Node(SGT)} log(len_i) * 128 = qlog^2n + 128n)$</p><p><a href="https://uoj.ac/submission/498908" target="_blank" rel="noopener">$Code$</a></p><h3 id="排名预测"><a href="#排名预测" class="headerlink" title="排名预测"></a>排名预测</h3><p>要求构造一个排列 $b$，满足：</p><ol><li>父亲小于儿子</li><li>每次可以交换一对父子当且仅当父亲比儿子小</li><li>通过若干次交换能够变为 $a$</li></ol><p>这边把 b 当成 ddm 序了…… 应该没错吧……</p><p>假设已经确定了 $b$，如何构造交换顺序：从 $b$ 最小的叶子开始做，从它祖先中拉一个给它，并删掉这个叶子，更新 $b$，发现这样不会改变偏序关系，并可以转化为子问题。</p><p>有解情况：$\forall x, b_x &lt; \max_{y \in Subtree(x)} ( b_y )$（注意这里的 b 是时刻更新的）</p><p>如何确定 $b$：$dp_x$ 表示 $b_x$ 至少得是多大。按照 dp 值遍历儿子更新 $dp_x$。最后检查 $dp_1$ 是否为 $1$。</p><p><a href="https://uoj.ac/submission/500647" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CF 快乐板刷之路</title>
      <link href="2021/07/09/CF%20%E5%BF%AB%E4%B9%90%E6%9D%BF%E5%88%B7%E4%B9%8B%E8%B7%AF/"/>
      <url>2021/07/09/CF%20%E5%BF%AB%E4%B9%90%E6%9D%BF%E5%88%B7%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="CF1396E-Distance-Matching"><a href="#CF1396E-Distance-Matching" class="headerlink" title="$CF1396E-Distance Matching$"></a><a href="https://www.luogu.com.cn/problem/CF1396E" target="_blank" rel="noopener">$CF1396E-Distance Matching$</a></h3><p>这种极易停止撕烤的题先考虑有无解。即求答案范围。</p><p>$dist(x, y) = dis_x + dis_y - 2 dis_{lca(x, y)}$</p><p>最小化 lca $dis$ 之和，尽量在浅的点配完</p><p>！根据某经典模型，选重心可以配完并且 lca 都是重心。同理求得 $minans$。</p><script type="math/tex; mode=display">maxans = \sum dis_i = \sum [i \neq root] sz_i</script><script type="math/tex; mode=display">minans = \sum [i \neq root] (sz_i \mod 2)</script><p>$maxans - k$ 显然必须是 $2$ 的倍数。否则设 $rest = (maxans - k) / 2$，显然可以通过不断选大小最大的子树的一对点配对使得 $rest$ 变小。<del>模拟？😅</del></p><p>可以将某些非叶子节点变成 lca。具体来说：</p><ul><li>$rest \geq$ 大小最大的子树深度 $d$ 时，选该子树最深的那对兄弟或父亲，$rest -= d - 1$ (I)</li><li>否则令深度 $rest$ 的点为 lca (II)</li></ul><p>细节：</p><ul><li>set 维护重心所有子树的大小和 id，方便找最大子树</li><li>对每个子树开一个 set 维护子树中点的深度和 id，方便找最深点</li><li>只有一次是 II 情况，其余都是 I，I 显然每次删的都是两个叶子的父亲或一个叶子和它的父亲，所以点匹配掉要记得<strong>将父亲度数减一</strong>（还要从父亲的叶子集合里删掉，但是想要快速删除就要多个 log，还是懒惰删除更香一点，即遇见时删除），父亲成为叶子就把父亲从备选深度集合里踢掉。</li></ul><p><a href="https://codeforces.com/problemset/submission/1396/122195667" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1322E-Median-Mountain-Range"><a href="#CF1322E-Median-Mountain-Range" class="headerlink" title="$CF1322E-Median Mountain Range$"></a><a href="https://www.luogu.com.cn/problem/CF1322E" target="_blank" rel="noopener">$CF1322E-Median Mountain Range$</a></h3><p>中位数问题，想到「01 序列」基本这题就只剩代码难度了。</p><p>我们把长度 $&gt; 1$ 的 0 和 1 称为 0 段和 1 段，0、1 交错出现的称为 01 段。<br>显然 0 段和 1 段是稳定的，<br>01 交错出现部分每次操作会两边各缩进去一个单位。</p><p>拓展，$\leq x$ 为 1，$&gt; x$ 为 0。某位取值为 $a$，当且仅当 $x = a$ 时该位置的终态改变。</p><p>从小到大枚举 $x$。操作次数 $=$ 所有 $x$ 的操作次数 $max$，因为实际操作序列肯定存在最后一步，当 $x =$ 最后一步的中位数时取到 $max$。</p><p>细节：</p><p>每次 0 -&gt; 1 可能会让 0 段和 01 段变为 01 段和 1 段。每次操作只会至多出现一个 01 段需要赋值。</p><ul><li>并查集维护同色块，set 维护同色<strong>对</strong>的位置（这俩方便确定 01 交错段的端点坐标）</li><li>set 维护 0 的位置，防止对 01 交错段中的 0 重复赋值（赋值指 $ans = x$）。</li></ul><p><a href="https://codeforces.com/contest/1322/submission/122324706" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1481F-AB-Tree"><a href="#CF1481F-AB-Tree" class="headerlink" title="$CF1481F-AB Tree$"></a><a href="https://www.luogu.com.cn/problem/CF1481F" target="_blank" rel="noopener">$CF1481F-AB Tree$</a></h3><p>考虑枚举答案。设最大深度为 $l$，那么答案下界为 $l$，当且仅当每个深度颜色相同。</p><p>背包？物品种类 $O(\sqrt{n})$ 级别，也就是说 $O(n \sqrt{n})$ 的复杂度即可判断答案能否为 $l$。$dp[x, i]$ 表示前 $x$ 种物品填了 $i$ 个 a，bitset + 多重背包</p><p>然后呢？</p><p>官解告诉我们上界为 $l + 1$。证明见如下构造过程，有点脑筋急转弯的感jio：</p><p>将点分为叶子节点和非叶子节点，非叶子节点个数 $\leq \frac{n}{2}$ 个，<strong>每层</strong>非叶子节点必然可以同色，考虑从上往下填色，每层的非叶子节点先填同一种颜色，然后同层的叶子节点尽量填该层非叶子节点的颜色，若填完了就填另一种。</p><p><a href="https://codeforces.com/problemset/submission/1481/122535450" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF827F-Dirty-Arkady’s-Kitchen"><a href="#CF827F-Dirty-Arkady’s-Kitchen" class="headerlink" title="$CF827F-Dirty Arkady’s Kitchen$"></a><a href="https://www.luogu.com.cn/problem/CF827F" target="_blank" rel="noopener">$CF827F-Dirty Arkady’s Kitchen$</a></h3><p>策略是反复横跳。设「最小时刻」的 dp 状态是不对的，因为如果来的边 ban 掉，又没有邻边存在，就会挂。</p><p>按出现时间从小到大加边，堆维护，$f[x, 0/1]$ 表示在偶/奇时刻到达 $x$ 点的最大时刻，那么加入的边出现时间只要 $\leq f[x, 0/1]$ 就可以拓展，否则 $&gt; f[x, 0/1]$ 就先放在 $x$ 的 vector 里，等到什么时候 $f[x, 0/1]$ 更新了才拓展（更新 $f[x, 0/1]$ 一定是之后的边的 $r$，一定大于当前边的 $l$，所以一定可以拓展）。因为边有序，vector 也有序。显然你不用考虑删边了。</p><p>这样一条边最多被考虑两次，复杂度 $O(nlogn)$。</p><p><a href="https://codeforces.com/problemset/submission/827/122544419" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1550D-Excellent-Arrays"><a href="#CF1550D-Excellent-Arrays" class="headerlink" title="$CF1550D-Excellent Arrays$"></a><a href="https://codeforces.com/contest/1550/problem/D" target="_blank" rel="noopener">$CF1550D-Excellent Arrays$</a></h3><p>卡点很奇怪的一道题（？</p><p>设 $k_i = a_i - i$，那么 $k_i = -k_j$ 的对贡献 $1$，也就是说按 $|k_i|$ 划分，每个部分内部贡献的和最大</p><p><del>然后我到这儿就卡住了</del></p><p>显然可以划分为一个集合，其中一半 $+k$，一半 $-k$，因此 $F(a) = (n/2)^2$</p><p>不同 $k$ 的贡献计算方式不同。</p><ul><li><p>$k \leq min(1 - l, r - n)$：偶长度序列答案为 $\binom{n}{n/2}$，奇长度序列答案为 $\binom{n}{n/2} + \binom{n}{(n/2) + 1}$，就考虑选了哪些为 $+k$</p></li><li><p>$k &gt; min(1 - l, r - n)$：设 $lf = max(1, l + k) + 1$, $rg = min(n, r - k) - 1$<br>$i \in [1, lf)$ 只能选 $+k$, $i \in (rg, n]$ 只能选 $-k$。稍微推一下得到，偶长度序列答案为 $\binom{rg - lf + 1}{(n/2) - lf + 1}$, 奇长度序列答案为 $\binom{rg - lf + 1}{(n/2) - lf + 1} + \binom{rg - lf + 1}{(n/2) + 1 - lf + 1}$</p><p>这部分复杂度是合法 $k$ 的个数，是多少呢？$k$ 每 $+1$，$lf++$、$rg—$，直到 $rg - lf + 1 \leq 0$，一共是 $O(n)$ 个 $k$。</p></li></ul><p><a href="https://codeforces.com/contest/1550/submission/122626451" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1550E-Stringforces"><a href="#CF1550E-Stringforces" class="headerlink" title="$CF1550E-Stringforces$"></a><a href="https://codeforces.com/contest/1550/problem/E" target="_blank" rel="noopener">$CF1550E-Stringforces$</a></h3><p>满足二分性。check 考虑贪心的把大小为 $lim$（二分值）的块尽量往左放，看能否 fit</p><p>每种字符都要出现，于是状压 dp 加块顺序。预处理每个位置往后每种字符最近的长度合法的连续段的结束位置。<br>若当前位置 $i$ 可以放某种颜色的块，当且仅当其他所有颜色上一次出现位置都 $\geq i + lim$</p><p><a href="https://codeforces.com/contest/1550/submission/122627687" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1550F-Jumping-Around"><a href="#CF1550F-Jumping-Around" class="headerlink" title="$CF1550F-Jumping Around$"></a><a href="https://codeforces.com/contest/1550/problem/F" target="_blank" rel="noopener">$CF1550F-Jumping Around$</a></h3><p>喵题（但似乎没有很大的难点）</p><p>首先肯定不能每次判断。由于能跳到每个位置的最小 $k$ 具有单调性，考虑预处理每个位置被到达的最小 $k$。</p><p>考虑两两连边，边权 $w$ 为互相到达的最小 $k$，显然 $w = | d - | a_u - a_v | |$</p><p>那么两个点可互达的最小 $k$ 就可以用 kruskal 重构树算，其实就是建 MST 啦</p><p>怎么建 MST 啊？这是完全图！kruskal 暴毙，prim $n^2$，而 boruvka 可以，因为这里距离的计算方式比较特殊</p><p>用 set 维护所有点的坐标。处理当前块时，将 set 中当前块的坐标清出去，这样复杂度才对。$O(nlog^2n)$。</p><p><a href="https://codeforces.com/contest/1550/submission/122630068" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF283E"><a href="#CF283E" class="headerlink" title="$CF283E$"></a><a href="https://www.luogu.com.cn/problem/CF283E" target="_blank" rel="noopener">$CF283E$</a></h3><p>不合法的三元组一定是存在一头牛可以打败另外两头</p><p>$d_i$ 表示第 $i$ 头牛能打败 $d_i$ 头牛</p><p>$ans = \binom{n}{3} - \sum\limits_{i = 1}^n \binom{d_i}{2}$</p><p>$d_i$ 的区间一定包含 $i$，因此将区间按左右端点升序排列，依次反转区间（SGT 维护 tag），扫到 $i$ 为左端点时统计 $[i + 1, n]$ 中被反转了奇数次的和 $[1, i - 1]$ 中被反转了偶数次的。</p><h3 id="CF1400F"><a href="#CF1400F" class="headerlink" title="$CF1400F$"></a><a href="https://codeforces.com/problemset/problem/1400/F" target="_blank" rel="noopener">$CF1400F$</a></h3><p>盲猜 x-prime 区间很少，跑一跑</p><p><del>咦为什么我 num = 19 只有 870？题解说 2400</del></p><p>诶不管了，总之就是 dp, $dp[i, j]$ 表示考虑前 $i$ 个字符在 AC 自动机状态 $j$ 的最少删除个数</p><p><a href="https://codeforces.com/problemset/submission/1400/123013668" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1528D"><a href="#CF1528D" class="headerlink" title="$CF1528D$"></a><a href="https://www.luogu.com.cn/problem/CF1528D" target="_blank" rel="noopener">$CF1528D$</a></h3><p>形式化：$u \rightarrow v$，等一秒就变成 $u \rightarrow v + 1$，其实可以看作 $v \rightarrow v + 1$。连边跑 dij 即可。</p><p>注意 dij 扩展到的点，最短路已经确定，要根据最短路的 dis 确定当前边<strong>真正</strong>的终点。</p><p>细节：由于是个边数 $n^2$ 级别的稠密图，dij 不用堆会更快哦。</p><p><a href="https://codeforces.com/problemset/submission/1528/123016914" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF587F"><a href="#CF587F" class="headerlink" title="$CF587F$"></a><a href="https://www.luogu.com.cn/problem/CF587F" target="_blank" rel="noopener">$CF587F$</a></h3><p><a href="https://www.luogu.com.cn/problem/CF547E" target="_blank" rel="noopener">$CF547E$</a> 的孪生姊妹。</p><p>哦说到那题，一种做法是离线询问、建立 AC 自动机并用 BIT 维护 fail 树，另一种做法是直接把串拼起来，就变成询问一个区间内某串出现次数的 SAM + 线段树合并板子题。</p><p>再来看这题，似乎直接思考没有靠谱做法？</p><p>暴力做法是在 ACAM 上跑 $s_k$，统计 fail 树上到根路径上是 $s_{l \cdots r}$ 的结尾的点的个数。</p><p>考虑根号分治：</p><ul><li>长度 $&lt; \sqrt{n}$ 的用暴力做法。</li><li>长度 $&gt; \sqrt{n}$ 的只有 $\sqrt{n}$ 个串，可以预处理每个串在它里面出现的次数。</li></ul><h3 id="CF603E"><a href="#CF603E" class="headerlink" title="$CF603E$"></a><a href="https://www.luogu.com.cn/problem/CF603E" target="_blank" rel="noopener">$CF603E$</a></h3><p>假设你已经知道了判定方法，然后来个删边并查集 + cdq 分治即可。</p><p>现在问题是，判定方法/充要条件是啥？<strong>每个连通块点数为奇</strong>。</p><p>考虑加入一条边会使得奇度点个数 $+2$，不变或 $-2$，必要条件是每个连通块点数都为偶。</p><p>充分性考虑构造一个偶数个点的连通块的合法边集：选个生成树，从下往上删即可！！</p><p>于是你就可以将边升序排序后 cdq 啦！</p><p>当前时间 $[l, r]$，边权 $[x, y]$</p><p>假设当前已经加入了时间在 $[1, l)$ 且边权在 $[1, x)$ 的所有边</p><p>只要求出 $ans_{mid}$ 就可以递归到 $(l, mid - 1, ans_{mid}, y)$ 和 $(mid + 1, r, x, ans_{mid})$</p><p>先将 $[l, mid]$ 中边权 $[1, x)$ 的所有边加入，然后按边权从小往大加到所有连通块点数都为偶为止。</p><p>$O(mlogmlogn)$，每条边被加入删除它的深度次，$logn$ 是删边并查集的复杂度。</p><hr><h1 id="可能要暂时断更了，没有显著成效，noi-同步赛打得稀烂"><a href="#可能要暂时断更了，没有显著成效，noi-同步赛打得稀烂" class="headerlink" title="可能要暂时断更了，没有显著成效，noi 同步赛打得稀烂"></a><em>可能要暂时断更了，没有显著成效，noi 同步赛打得稀烂</em></h1><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21May 训练日志（真·退役冲刺实录）</title>
      <link href="2021/05/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121May%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97%EF%BC%88%E7%9C%9F%C2%B7%E9%80%80%E5%BD%B9%E5%86%B2%E5%88%BA%E5%AE%9E%E5%BD%95%EF%BC%89/"/>
      <url>2021/05/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121May%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97%EF%BC%88%E7%9C%9F%C2%B7%E9%80%80%E5%BD%B9%E5%86%B2%E5%88%BA%E5%AE%9E%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1/StEPwMeHbdAaZb+QvezkCSgIzRRa8N/tF+svGZzPjmWCkVir7p3CKcQU4Wgz7HBPQtuaZd5SOCVL68yQdztH76UcONlfDF1pZG2hYfAA10DaEAdOHY6tUPxwlzZT+smj7bBoPSInqsdJYL5QWE3nMnUWWZ31gZCETf2aT73JxElPLc1zO0Yi4JgUhhXCTBfRzNVqHP5Fj1+ZamIkRce9WdWPf1GoZDmOZKC+JEA+vxpYgXD0DgU52NV4Yw/69QBdMLUcowCPxYiehN7UOsguT06rdXgiLmKI8Ca4YhFeAqGASWHJ+Xn9MaJUWa5Xo2HlUd7myg2mKawX4BsrWlpWH6QC6ur4dgvurL2rDpAedQj9wW1zOX06vhK2iZB4lHlc6ykxP1tTtSh9zjpNn3ZqA8RkrMbLl/IA9GJ9Qm8xbRggVwreUf9L+kHc8GDXozqcFdA/lQdN22lM/qePSWv6wjpsdM8jOUGHIbvhuFBfPOmym/q9wg/7FjLbKK6GfleVqOtPtLfuAlIxk8vPniKEe9AY1e9SDcZeY5k/BAQbDZ3RvGFAS6XARMDFUf7R9nreKh7HxEE8I/5hhbpnBucnYtrkjzwI+vgw9Z0DjhdPPakxDbcJ2nc58xGva2pc1zX71een97foUS6tNZ0VuJ6CIpnTwhyB4zfotAK7BRLmgnN7I65eStavFqnotv1JqBHrSk+zXwCeqOJxA9kA8DuquAD79LmDXWlZrrZHdi+MOKtYYDH0Yi9X/ebO5W6aOcom1AZGldYMZD3UO/aGnR+Py/8CukO5a0SRyJt2nSYRLof3KIZKXouwH6g343QIVyyop7JHTWpYz3+FKmhKv2SPsGJLgRzRnPAwIdGC5dNzOY6qb30yX5ZrpaeEo0ntmncPxL2XuEJOa+1GPUTtMFAiQyGlDg4L0tgEtm9cVgZxQJa3dQJf5fQFPrKYYNpWhqjxY+J0ld0rQfQfKuFig7rgr0QqnYpXymsmugwIjh9H7pJLYIsKtEviZMg1mit0Fegm0/GGzR7A8WapH0Z0ZHzRHPY3ng8Zuom4H+j92+/InuK2HH1zjT2TtW/lMxmGFmoGgVU1Dg1tN2qlaXSMUW80NFVNtAKOuqwKKyxIrhbHF1nccS8J1J7VseiVm/bu1mTGRQZHXTMQ4tHq/rvI41HqOs3Fx5L1SStUcjO89DgkpLagno1dq+xvozx4fHlH1ZdT0ltp1hCZbWlJbYduEbq5defMd8nM5M0ZkKxBvv5mDhR3HEqJV98Pbn3Y8Aq9rTG04FubDF7Oc2ulWosv7SJal3yHJFkTj1nB6mZ9Y7iyBizBaivkRVooex1Bl91Xck3FPq0IpdmIAThA9Y1oOhf8e6LzW7EZy6nxAWMIeH/ArtqeQfO7FCQVbLWyRMSpLOeXUFHzGbvVMGG3wTrYyKXCqEiqAGjBkISIkj3gslYSpVGxNSK7v2YWI1pIvrWhd5lp9LCki3egKC1OHRDRc8sJAM723omPjEvgdN75feso34ThdKSbrXt+RIcRy4hKuUaIWq1DSRaWKkoVqc65Rbtl7AlsgqiG/m4Yt5gb8bAbTGGBZz2HoA2jXIQiCz9YCSrLnP9Ao0lLvvSEU4C6qSuRvDaHTptj8FRNsKP7nYySrD5z0UJvVJVwjVMqljeQGK7IxvIPXm3u2XCq6nH+HgaOk3yu8zalVEso90PiZbVU9+JYhgIozK/SHZ8VHNMygKKDQdOwvzN+lc5AjJ5z5ZqvEOQcWq6N7DA08UuOptd8vn6VeRkxmcUwju2SrFGBvOM4lW9lDTOQxaQwHJpuOWJABLrcdPpx9PqSFO5JQYdTfudJCid2VNwurpOQVTxZ+apMTqlM97NcXUnEIT12dAqrWaHd5bR3Tvgt35RiW0eSxowDkQ0viMCQpLy4xgCLGWI9orsG32iRQmNmhZx3A0XNl+8jY8nLGKgJJvwxouU+3BP0B7vx8/fryyjw/lNxJg0yKsjswe2wOGVaLdzJ9VRJ7LKsNUTLH3qq+iSQusvxnL6BKTnk8jqh34D6SWnCPFqulvGO7TdQfWeacGcCzJ8YvNh6ATuazGxiS9mkaQgnmDctXdZ8tCIQo6GLVGczXme3Ry8jglaFqqE4DpOXMGC1YzqeUQiiYxRKXUEl0DqxpEooBvo/sYnncnY+2rlM5oHkNjbHyDV9U88EXsGpC0gRm85JkYsQOuy6m3z5PKJzEoaxw9rhd5mz61wAHw1eYhH2g3p76oQb+Rs3TFC/Pl5wgpzOr+dionPdox8hKNig8JGUQynpn0Fyrq5xUscA47a7/4Y8rTzasqpd5UvsGmtLPuVR4bhgy0FAytFhdQ7ygBA2DkanYvcDHn8e/V2QE171LNJuFf+kHd34z69FT2ZumkJmsbZgwaSeCnN/IvnkpqRziJ8WyIAZc3xhnsuGqWikPL8dm4nV8SJ6Nju+1O0D52rumhalM0kWjQUQVCGDCrpButtAF7iVignOKp8RLPVZmaNKJ4jmsIgian+lbioMyL+j2iqegdh8SvJu6qLApKrmDFvBj5iintidcLxlhdsw6atFPHp1gC5AxuSxktXitQCRYeY+S1N/OLAD07Cy5Fmq+EAV+GgbRH50h0G8lZSZjkCF3suTifA9y3n5SNNy6BocM3S+LrUdwpx4BM+pB2UDHIN/kYZfFXBzT4BI5afy664lhIKiNPMUp7rBEYZ1Jz4WKKxdR7nSgDA9m7pxMrVA7HDwpsbDdHjO7ANPRMLaTUUcpVItS0DfcAOrQQIaLfyXyw85LXOHxkyNlMPHXYLxx/n3mUyJ9HVYQlhSISjaJtjhw2kOlx7iAw8YdyV9DBKD5o/F3mA38M1FNjvgP+uMnmP4/XAyffnIaiJRgCc4sKyrKso4n2CcR+TfLgnDT4+AAbTrtRJ+D63WlkbSxgwNFi2GKwT3EWAg2ogdzGTbnJbc22KLs5fZQFhpxU+4bF8Elp0WPVlJ6AVkAm4jezhqHxnTLv1KP8pIMKs+Vk5FetZbXRCc4/PyTLUsA6xPDalVN9jKnIsKlwRsvVBvpt0DMc5ZOhJ7VTrNVhGaLEPt+DWwOEngG6T7aVJTqNHoofi82Q7VNknN7An1YbAaHrdJVupUBwrWb3FVGB5eSYkGeFTZkW5WnlNw/nxhriZL4kHSIakGCVqkEJNmQ3MDQYNbK/HZGBzy4TDVNC+kBnvsQKWwjbmyxy5P9Iyy3aDWvwzffGEjrAVQKgn0On1Y38E8/t1ctdtk5AlDf1YrANxsG8GcEN49Bj90C/MT5IPgh1zo6b0rgPwSmgTrdW1sbTL2UYZvLa3dRYxKz8PjdyaQppO4gjiX8wyXeoiy/rq97CMwEBNQ9+H+T0oeBP9g7dHrO2DvVS1HRkyYaFe5QcUwhLSoi9EmBd1SG76out+4VWOGh7GbhWQTHXSvbvRVFkWA3qCiQfhUPm5cNvDWFptmAuW1x0m6PcrY1FjMdLO3L6ngkuaWTSryopfMgCQpkEUUsStlRDEd8uhf4W8cdkL7pVJ+bh6xFN2NipGdrmHSFEt2kdEW+fEEyPpfRD/WP6VYtqSdx9/fMIRny+xDO2iPZTz3Yj/BFti5SBbZ7arrdhYr6SYnE5CRIL+bvkr8w+qpXbPg+IvmMS7o5K2bLeU1eXN/LLj0aiOF5Wc+uJtbkdeYC3O5avUAyDma74J+d34a5Uqpe8Z9AxD6Z3dgtcDo0syd94V7w5DeJVZK/LlT03CX4xG06KqCGfSzkAgXMEPto9nGIoPuqGLt99kkKlt30hqGij4Th3c0V01vFmY7EP3zzHg1LLzobmPZQpOiZ1imDltam5kfKReyXsOhMLBdT6m2kqx402iHuNl5SGqrR84LZffJr/8980gFbpTNAWnBsnhBep+Kl3v0OWXtfbWVR28etGfAR9GZ308Qxs/fmWa8L/gtEYfFy06YWMr9WAHl8PdOuQg5C9ng21MJOjD1kSA/BGT5adFJvszh9shP9e/9yKkUwzrw+xeCDPthKGwS85/R0NRndwj+Ee/eMcyJJv1PNnz7K+17xxFehWya/gLTTRsd73w5s6AjD7fA/eEpr/qllZwxrrJdU/E2Xn9EDFtscep3UfZkhjKB/BAyn9u3+cIdtRbyqoKc0zgxGS57DY4XtECNH8ZMRZR6VXH6zwQVzJC4+tVZKs1HKesLSeD9LDEd8qfBwx+SkMVsNV9RmakBNPhtae1GUNCZXgQ3kD1Wccq/s+0UpNdpmKPvW1qph/ZznKm6mJA/DSk+fj00pTW72+xwXXqlsWquWikY203u0kD2ancPo/+qJUa6CNF5SyhOpnIKq+c+yaL6djsSvG+/KHBnJfCX73dP7jI4iosG6Bn/IeG+ltDP8mId86GrFz+d9eavS86NF+Kpb3fsejcACqw33PPfJo9J7BausmlGN3EQSJgv955vWN84OUQ6+YiRwHsvvDhsxBkrv/r5xWpUmTn7ksfWlwAwYWIZLpXsBD3NOBPtIBzGK9gSR7jcj6oou9M2iy/n6kznIV3gGINfYZmTGdJlPo2kAZ0PyVYNlnRb7+e1pOK7Xfv31AecXzphYp1PLvhIWvN8gqbR5yJ3DrgGBIdeEIVTE3SDUMX+vsfA5GxSCQPHGpItquc5OBqXrIZURHoRU6yPFQz2C96YY9wfYB+BBpiZnKEWyShCyRQWRtXfgwE4ZTWfOakDMiCC85XnG4dGQ+5ul5UOsbjWg9ML3S6wEVga3aUbmMQIPBgRBHyTONcKyW7felGLjbMAiWuDPp/o+Wr0YvyFm/SfbHeXbePqbYV0s/sFH0TKWIg+pZUWSzm7Z4TD/xrWyo6ZTpdbz9izdC4HX3XBjLHiq4rHsfcc/BXOl6uJoqJwE+Zcm8qLE3f2ATkEkeMPn7QjNGtfL5bPLgvXyznzmbFexdyx6/88ZUCd7OEUogdJdhcFBjXkjx/6VacgZ7ei0SpflDZu/mMW8fMvPCM7jZDAFTcHjmBtzZ7g0sRIkFquqtxd2tSkj4A0fMQ+wM8C4n3kkZyZbsXCBj0jGput9+tN7Uy3KqpYL8u0o486oW3RrVwgnz+pCaFRPjG7LPgqtn+NM0aIvslxk2lAtkv7VEG53YS8HHIHssnyvHgAW5ICC6gMWEtQkfsStPbl3221g6kq+3PS/TsHSFc5PJ+DvMwqxUUzVWeXzaVcrrca0vua028sIwQV7+nOAJbrBie91CYxpBzk36ZIdN5/VZ2acnZe7jBAtko7SclyoT2u9z11tvEr4kK5JgAKZwY307HAnNwLYkSZj70+UcYb+OiVrIPkS/C136WBmFv12Lop43rjEZS4jojuFHWlcLtaTjodJtSUjOZhe0dd2NpO0kLOWo1JwZmy9SPNGlpehTJUUQS99BVXoAw8DsDwuvZLhIgdHoWjeG91mLX+zmPwore9bnjZyZ7tnqJLMf7EcYD5VGhuC+UotEr0eAel/j+f6l07PQv9NQGuRSr8aFcubpT03sWpKaOLINjiyt8AI4uFekKxxsoEg1NhNq0WRu9UOGitnekJSrGy/RQF7sEHwaGFA2oO7mYKnTLPY6O658GEbp0WzrVLQ8+7H/dMEoAG5eYN5Aqermv5gwr56DnZWu9S+JWg0yVvKNSe4JMYDP0JB+uOHozcD5I3p8/VXNVDuAFJiJRe/fC2POd8fqBOim02NbQg0jsEt6eJI9xXfzVQQD1xrFz7mtg315UMCGKnRzz3YuxuaILrjMKN7ggCS74HEwp3O3M/enkZO35iBC5P0eo7JgF7WngW0egDvUgVsq3ZNIf40YKCUCzRMweXmr0sQ3kGp+RwM8YP1CDFHa5SnMNbQQIBh1+ce1oImNuLI2rGuX/FRw1gBjwVFuA0UPNht35Rm8svAasjy8MK/ph8gpFja5oEnQCYmYnSAEHLSmhczVVSr3NhMTl+KF8aekSjH6mluki+QRIr2ZgSYfpKIrPaN+ZAF59kx2cHxmWnAVG+SAfgsgin1R+bKr3HE+DCmJQduN9n34CiMB17e27oIxkIficyrv5EYwZnI2/pqb2vc5S5TMNRECVVz3gLI34+SgZey3unnNekqGvXcWbbFaUxx9qTkRpnxTtVrX3xA7r4cxAuwsQk2gmFHIcIFQvKxxXEvwqdvuhpMXqNVMitcfD0MgwEl0iZiXFg69h/Tw2oxCP4ZDQ++HqB7pF11IXYy7hjO5Ktxm8YDvYTM2Mg7FR/+ZCfi7wffkkgJV6tECr6CJPEO8w/v1hlgRMfCSHcLZD++zl3IGJBV+dd3uRFim9drQFiMT9DlHf5VUFGz+IKkxEvUx4POs43FU+VQzI0GF112Wk5TD7hZDHrieYZrcIbta6dL7tC5PCqhanLFFM/SgmvxEdednOV0ZJhF9Rl6UF6zJ7W6Uk8NmGu/eHXMDSsuSpLILQhPe/j5PRU40PW/4ruQ0B4DWgHmYSIXymNBB5v+pGg+xNd5YpLZe65fivzMOK0KjAE6R8sOC+om3u386QHfdp7ExypXHjo9B/LhxZ6DaoODWDRv/xghZEw/p+UrQW/lah5VXjR2QIX6CVpIfN7c8oDCemu/dbaCrWvLI+w1itNPJbSXuVJxlCdya2tTcEvldZbSjNe2rE9uPWufF6RayClAdYTFahRBEwUsGFBYneh8ZeyHlqK0XjIWKKtMs69SX89Gi06uLu0WJr5uA1vJQxHjTNmVXfLsAbMoQXV5PRZbmVB5Lyy/5mYghxWOma9HDZInXmmW2PDE+TadC+AohrPXQ9Cx3BBoabYZKLL8mtSr4XgdRYHT7y+MkJchrhRb1oE6HFhU/EctWemYnuxVFkxBcvjQO1BjoEaJ3TAZbMg1vsl8ucGCTd3IFuxUFhYJ1aYt1P3dDZrJCxqXTMHRp8/6JNDp1tn3YZWaQEoUKJIGWKm+GjCoacSPu0oTL4C8AiU92FqQF7GlJ7d0sEdCmmWe1ZPEE3Q2hz81H05Xmi6WkubEaYdfh4HbNPO7hLe5VQAR0E5+gvgV/4b5HNN4YySFCni+DCZeEjAsvK8NYNdTsgunkdNUNgGQb8q+TG1czZyYKaNgnaBk2cb4ISBZIcOG4RNc93q0RmmJlcX8km1jt3o2bHrYNObPAWzCUf2YrBeEX2GGKRcntxCYgS8KOtvt1xVP9r7YXMut/kLdik4FsNqWzcqiX62i+m5YZGCtDsnSH/Tfm37oW92CcgbkzzWqC8FaB5bW0rcdNw7T0QMbef96fpJcOEaHAOJdkiz9cHOyE8q9rvIyCVXFSOF5vPw3Y41m3c4CdxBztQ3y1hfn8O6ILZstUQZKGZiigW4vcwwa4BRm2eqUHSFey720182xqhaLehGK6s6ZtWxkDd4jeyIiwuSkXa/T/4ySkXYNXSixmdkL9OXlBKPbYROE6qL+bDXFoOcNjuCX4VSG76jikkJUwzATvOOgw3MC79YbIOO7ye9Dpy5PWAOkFkVarS4z7RjYW9Tcch3N+MCM2/8b8oj+nzq7dlDO7rk2WvqA8/7AZfFkEnsO7y23dhoqDZnrwIBmqjheT8NjQhr6L740o/Y/pTw5whbbBvZJAJ1irHokraT8OqcFoXfXrpHMvqOyAO++kRqqSxOoTueUilgtA2F94bHOklJa1WncKbzJCmzW5zpkgemDXtbs/Tl/w5R32fdt9/Kf14Ooo59nPmw9bfZBbm0Ogg2lRFmuuo9w3QW4YanqaNfACyJf7CmMrcZdTRbMn7EZqGH0JhItdb5qdp5OPzZZkkaJrx55u79douISrKCJqJnqGT3NItBVGJeOovEyXmURdTfurtYxPso6sz3fFVr7y4yLow4/vcnJiCyRulVG1YZsBB9ud/ChmOct9ycRrTewAD+wvc41PUfXF9AnuYng1mogTBcA+kermHhd2RWLUnk45sZ7uED4P9Q8bRxiXD7epFPBtvArYPx+kKKe6q2DXqmrk0rCaX3A/50XoWUrYWNycZrJ2d5DOyOABxZ3Jkp8lGy0WfU1TogNoLydRtWfZhjHk+1jwnsiGRmq8wS4hMAYUolVYmCbzEiqOD4yxMUlN/YtGrgsOFYhk15rPVnCZ0NzkUBdGWRaqN3+ECYJm7j/qDa+Kzw84gJ+p9xh0Ejw4vLzhkVXzy60mIfT8+8zpeBrUblPdFW5E4OgWKeHGPbCpsvmuoNSgttxVf/9JWerAuxMqPmaFZ4DLEPdc9i0eQDrHoOhwIAX4d2FFIsy2t90f7lp7LV+Y4ecVRfDNt5SJoTDuG8Wj59oSujCU9+aWEYbOMOcWAoTFv84v+1Hcoq6iispnrH3h8ZjJKXMar0Id/bD5C7Bdx7Ghxwp5bgAncF2IyiCVFI1BCMIkhRMD32RDJnP5G0vShfTmZzsT2Wl49IqVvJQ4I+tvpfVoNrSHILcjPeLF17PLEypu5PAkqThY/B2/vZ0xgMs0nYld5OP0bd0U5twUFRlrIKDyg0+N0byRdboWDICYrtAwW6EPKZlKSjROTSZMHzVMSaVmVP2sAcxikCbSfb0RD4uz9MkOKf/hm4QrQFGd+Jct5zZa7RYw95L783MhpstAg+08XBVwyM7lHOCQk9S6K7PlILuxp4HSndWwwnlQkDw9BzcAXvqc1y70XgxPWbB2GFA5kh5Fzg+LzcMVXvZMqor6NlF88dzQ870PaO6QPGzOip5vDhag99Xwqp1assTO+PIve25pPXJFy1ACuTlDgpfOUdMZevdXywWmIG2whDiHaw6WUapgXbn0h+vUJeVm6WQ/ENuxRWBehq16eo/8CwS9fhd1aio0LaS8r1bJ9HLph+gJtmxXkRJawPyTE17l1e4P+g1ykQNg5tGYv64qC2f+B6m4/q+mpElWGtsh6Up4i0giCJMVkqo5IiuIhLNtzLA4E6learL68W6f9I+C3LGfomDGhtyOtIAgz8zuURh+73iFX0zawNW47S1SN28fep+Gyr+iTLc4FAHuzoaCo/9X4QdTbMO3y87ynbq+1UTPd5jBW9ANUWkRRq6WXF4Z03CW2aBokUTCdzvSj9G5iJzDKRj+KZL4MFsQGWHXaRsaJIsJFNNEUpd1/ss8xsZj8+TNM85VZHOd1dzwxgSs/7TzljEqUoMtgsqsqQsmWnVsGegU3VdupoweYDmH82ZvLmB2WhMAhnWBRaHzP2JOlBKyaAxKlsK5fkQWxXlis8s5UKm6eEWZd2LT/NxJU076/AQ2zSidkzIRbXo5lOkrm/ldZmPA/dNFEeOP6sr+g/N1pA2ZMdGQzaZNTrT0PfpRP+rsyWGpvGFD2MTYRRrVyVMGH7G+dhIkjk+yFlS9tasBK8e04oHzRilukljYUiAJLQDt1ksBUtb2mbnbBoTidyX0hFcEJBy3ZZMewMcVwr24TtktA/4SdFSfHpP+Hc2IU81lrSlh4M+WGmnKe4Bn/z3hnYjd99moAhTNd6tcjh+NDv9g22CGyTihUA6zu90LygyL3MvVVZos1Z0ttPytLL4Eyt+jeLzoVSU+B+WZnoVJVMS9DO5Enhy5XVENSoHnWsRmb+vo0Yn34ZB6df01yzJIh0iybyIwZJqXkPxxs/JCEWBVC/6bLHRT62yEohcYaJdhS1kJHcYyXJ6Q4YIwtBJbWtK+PsFFT0ceSCL7bx/w7vID+70K9lpLB8VLQwHyrdbtIVHqxifWAG8HJ7tTlvnJE8JGDZzCBUKJQTXEX3qYsWDNhNooPiVBx8df8YXDZeOVsov5F6bO8ZqgqpIzfJS7MMdUn26vuh5MRvLQTBiw0JrhpjIvo2z0GOWfCjwPCNcVM36oyVoDhL7WpsIDdLIuIT7+yxwdZPtOeM2Qs5H094Ep0sz7xlmWV9MdcGbKAb2xyK68i0kGj0Pmll0OpyhBhF6gjRJIctuCqTikr1tn6tVSE4tORT3kWkc0nhpoqFN04DcvOZBxSVH0D+f3KRnIVgG3PWvbX77iLNLstLzeF9RQTfnE9fyVVZfbOimHQSdLlLN1LfEHFvB0zZ8U5NHKq9AxN14wbsxElROcSpnbJpjrw55aMgKo6B67MSq+lCpOSxkzyiWq88GsxDgUYARlbNHGvUAkLKjX1Liezy90YQZSpcCPhACob0gNR8k9dKYJrgH5gVTlQ3LotO3mdz4bqpELBx+XzHl0HEgHewX4VIA1bTMXqwjgBWanj3zEiCvIoAIMEvlEMAv7NSqI/TvoJQRTBSwvWQFnIKcvG/9AK6GK4qf1G4wvifON4ujcrKF++ScyO8nNF2Gns81Qu8eZDmbGkoxD1xwuKpo7izPPSbI7hz5wg9DaCdiFfbsSvrbJQn6oPzrUeyTZgw6pXiNThOBWZPSmvVHbv2yDCiBVJBy3w8GZ+u1Cfc1mI0AIJ9V4Akr4BJ7VKMIyvZPEdu9jOfQbLrA1qFVk/E3JmJ0gE89t/4zYegsuL6hiCOuA7Y/9EnMX93EttPnyfj2FQt4bNwasirkMpEdwhVhwK1viNt3SmQ2RJw/J08Hlvh6M3F69XvdJO4fmP/XF2+GFk9WGmU3N5oPGdYKXg27Z0LtF0Rl2dGWi6mpAyTswUce4lHT0Ad5tMbvASFSkNHAGwyp9ISyC/qIW2bTWwu8Fl2E6BzluwdCkoRYLkHb3/H2YtZCW3eNBmnaG6PZ6ldNzzy46h80a0WMZl31upahVgmjiqfnMniVJJU0Bpd/HSimSd6ML6Y54Wm7SSRuI8T/8MQWyiaap1jw/HJKAQNpSgWgOhuIW+idYR27NNf9N5FBMfHpUK3QasZPqKi3JhPdBTkYan0ysA9EgwfqpFVr8Gpj03e65L03aqpJ07X/+nznEIQt58DCDIEoGc9VPt5Kd7wF7vNS3JALKY4mPvDmJ17rtmL/FLYw1bkKkLa0MaVouvgMNsAH4Eo7/pbeN14TAMxTuH7vmyqIpeVeZn9By+UUrQsSg3+PFuU5K/0xNpOP29IYNAQNEWobeFS/tx3FMAVyg/wHPfKVLmw6Hd5FQfwkAYDXab9o+1jn+EWUo8aAfHeodrlHwHcI4QylmSXUsoqoa9IS6e4tNTk8kDvumedvnYrZBj+IwoY1801+vAPvLGe1llJ0MaQLhEWawHNpBsGkzWSBj1VgEWMN9ioDFTmVEV0WC+skCKV6mr7xO93QEAr7hs1VzdGZKxbZi3c+FDmJ3rSd+cR+E5zg5SQwxMwxtNYs49A8OWne2aAl12MaBb2DbdQrwORhelAmXrc+cWrs3i4gmwYn1mD5PIW+cZGiAf5MTgj1R53O2dGjHNYol+lLb05RCumInQReeLGDvjZK1x02dmWzjMUZOMy+FUm3exEYSF4Ilp7bE3CIN9V+vdAVFPKHBJ1rIG9JSTCpIJR4KvJ7i4l8mfMX7Nds8oX9OLDIbGdWHaeqjvACOXp9YeCQn/tDG1icBzLcRo36jj8qPIGt1kpxDR0C58Bd3v1JnvPDleWVhvsGyCpSRy7byrulL9BvJG4VGVVv7CBRgFr8GH9byTx0OYBoFWHXPUl8IQGxezGUht0zNANwp1R8gJ2t1FIinOIpl8zcZ3pKw55NVdymvpWpsuGa16Ywe9sozOkXnqax6F+j3oW9MbSGDpz6GTmKlGMAC77FxHHri6fw2Wucz1VffKNzbWNqbp0cloyc2S+Tl7NwCyBbCwf6LZJrarR2/JNzrtGYNgoyyhGc+3R3izNaBhg3x6lIJhSqyZVi3wbIpIhdLcab7KvxRh8bLnars7Lhla8zc40Es+qYECOGFKAPsfyG/QlY14T58J82HGsj6W0CK+dURKevCZOB6tgCR4yuj+PdSz8sbSFe/udhlsDI5lpQj2+z8iLj4rv8FuKQb9kqj5dpIk9Jxk4DQjK42toelF1+P9ubhx/zFFO8IFmZRG5BWtqb653zotPENkY3nkCHaNtWpMftEqmWl7jJFaU6O8iAUPk6Qgq422yk7YHiIGClYL4FbVzaakLWpfKr14QnV6A7odz7vDdIvK6LK6JckSzYGSpVZRcmaa8sE9z8qyMGb93IRX2WeMA3XuJ9/W0yYESPC47H24HT/uK/f90NoZRyj7YUvRM5Hja0eU6mna/xEGAOQ+otRhjMZe1mAsKKH8L6QHzwhqUMtgD+EgAM2Kp2UCwp4vpE6xo3xSGwdf3FLrnE3EvdICveqOAJpWc5+bNpCwiT7PYi8kgYlI1oqcAgFsYNZ9JvsZGQQLHt5uXlYBGpAT0sUCzMk5MDLvAADmLRZq/cZ4iRtoBDUHk3liWDUiIaZ4e7PtCJMjjOZpJixvgkcyg8csMBYA9Vy1pUkgXbxvUfpmcsHnak0IQ20gUqPjDCWwN2z6iFi+GwKuL8qiQSZ3aaGh3c+IdVGG+d85+zKx450mfpqiU0EvpUladMFDHjsIf0qgEGBuEP2/g1R+OTx6Eix10IaRe3YX/kfgUgx3o9ZZ0uIfq3WSxe8VFyrAMIuIHKIMsHgBirvqJVTt6UAJMNeeogS4alT5HSLmUOfvmsnllHGcFj2g9Ju6ZekVp44TrLa00oCOSXV8kw/fv2vGFXcpKQ5l72qcfGpgJ647c/sdBKYAxtcWHd8VBWiPop9ax/kehjnQWKCy1vAdFZlE/nzCNgVt3T39xjzi0TIikjRgd3h8vwRKnIrNJtI4jQ+dKYD/u5+uWUnD8UuaxPt/5vYHbzaRwYoe3WXGENQTUTR98pyiZkLuymkdXzKVXGVFf+L5wgTiDcv6t/Shv+rYQXcmnj3ILQu7EaLzKx1Xu5bH9rFZYfi/lC5340cmxmA/BnxArQz5qj/2YrZmu7+BE0AXa16lQC3nC8/libQLcH/vj0Nl2w2F7MW+pSMj1J89ZzDAfkLGechWIaQoYEzWvHdwgA6L9e1VEx+ooCFHshnlz0M9stZw1R7geLTe7zuLQrmoyrx68DiBQbuUnsGR/PCSqET/Kwh6tZPBQ3oej4uLx8Yjlb157z7/1HrCLH+pln7EjhjHk9uBZFbJlkLZak12DSH9aMxNa3RBIykSao54KKLsDtH/ayNuPOXYVZBpnUCnmt1EXBcGVsVbbyrKpLedBskKgxXdk9I8jn1+7EVNx/LrUX839IV1h03byfgbUACdotI3xRt9DKiOxXLL8ZlLaCWayQKpWbSuB5BnRSy3iqNj+uJusTvh+Z9RzKcAp1r9r7gZhhncBRiIKSWSqf1qIqnRaMNDof+EhPBwLV4r8bj3TH3F/qIH1mzXPoDU5u/ikyhMXWmPJo/VdR3E6EO28fzWOmrbaGO46bnbeXIjNYjdboXy4ENNLUbl8cOtyH8geaLB+GONkR3bPCDfebpgN2s9yBpr/K7rrWBPraOl66rXQNdIg8UXqyKcSheZi9lUDuYtZFnXTtvnOE2nfweGupK0ZcSLQF8+hscdE7asqKlHXggZpbwfZyuJLTlsgONvgaUaFteKROh7DewVW5/sdwAdi+Q1YDrGfu4lxnL2Evaqklq3gd8Kvp3k0g9n36ftFl/uPEucMjgsVIyQ2PJoLcLaZXD63h1gsft0qNbyUenrSbQbQoKSJKthdf4O1qEQ0/2kN0sIjpr71ZuxeGHAtl9WPFdxbtvEYgmRcpfsQdhAEKXhztcz99ls4+99u91n5hCs65rJdkbi+OPhEeMTPWKlF0SrOd2epjYi0JIDhgChgTKg/s53xehpW3JwfyWQI0kQbb3ZBrl+GVCtFXt6sSbk4gL8AKtNjh/Z8AJzhjDWJqC+fkCWspB7mypKxWSAwUFyMTWk/5GWMIglzjhvu3cXdjCVD6VC12J2k44PVFz9LBGQ3BkcGcmXlIyMQU/1DDGaHlH9O6gvhqeh3zV2iFRuPz7fTgN0C/+RuDN7Ocs+33uXsX+dJJddt6WscfnraOIz9+KnU4ILHXvQmj71zmYFbpDMoWCALEsannWjZKMXutgXJU3rhvNPz+rW8hT1r2ZN+5Ahj5pSh300rZWJxvrHDn1dTtdvTYEy4Zm4N8MTGh8AWoOEUqVFvL9EZQGsTHQuxySUMBZM1bTCDFaZxIcRoNv3f8zqhKz50Pct7U86tJXMUwKwTBIy9N/VrUgCWRPTe9U1xchyo3/IjaaR0Ee2v3LOdeUi0LWHETWrY1mqewvnoWrcC+1Q3yGugxFKJeIcj87dFvMOJ5OjFpFJOBz96YJmYsiZ5GrdAiiH5oYyFySOUI2ZbUYEsKzRjVHRVtcP6ogRw/XCGi9M4gJNogg793PhvWyTKw5NR8VbadFwRe4Mwpij+Z2HJW/x1Hn222Okuta/577JPagycm6GsShB7A0yAI/VaYqPXUGgiq1RlU5CggAZK26qnVeEGTgaM2tkdCtbjNS8oRViV2WRbjEM6IKjBcK5a4wI/qwXu2TiZ4eCl1lp11JW45RglUMQNjhty8UZvzWd10kr1I9GHRWEL50xvKMi5krQiizrU9TS7bqPw8zMT+h+oWurjc+4Pfze0WiujTq2QWBfO0XXXJur2+6EgLu0VWuQSPN1ZL1GX1HwK4YkHnxHPhNL0zrcBJpM+cydhA+bd3LG1VA8qoOQlm64XLJZsypPO7hWf8Ib4siPnfku2d5YjKTsEsyAilCxfmFzEkbpJxFXktEuNBenyz8SG88mg6rts+jUZkDzbFkd7UKWr9UC+RdMoMS7zY9UMVxizB5/jraOvCDXd0zqWmI4DWuE1kuI6eMR81vd5axyB6/f446WsDL/LM+z1PKYfzR72czygMPJKmiMP5jpEqC5Zr6T3nbLoAZhVM2yXXFbvuowMRTWt8tQ+W8dAhIJ+pSyRTK2sgXv6O/0rtCnqX6Si+TWrJtM/6tzUAt4fGK4cVsby/ypVB/GJ1JtvHuxPD/qf25OhVkJxG0iG/MftnHPu9BkM/Yd+ovkf3hrd2WyFe2TRL4ymhjf/Ak8GSqGC3bpZdn940VIIUGmY6JpI3QERkTKOtZemEZegE1tDS/iM9VO4mWGjXGkzpmoJtpY93FnfVr/FNFfXjOLD1L0AoxRpl/0MtY9EVps310V+ypkT8xaI7jCYLkvKH+JVCIPmAW/28qXlzp/M3eKnam7kxu1hOYqv5goEKwtA0vQwQMxYc5FnamAAgj2l4RORcSuYFS/fZKw2ULvPkWLslsXySWcBxwEMEdFRepDSKm8ktwGUg2NIy9Ee3AEsL6QmLjMxTMNS6mG+NEuN8YXuVSDkdr/F9yYYbx3ofoKGal8pLEMq+R1ffmafYrQb4oFaOky/3nmG0EBvFOeBq2evvhkEdgSGEjqp2fUEfK1jok4B2r1txnoOdkz2LMVs2gEBz1EGIuvwXfL3ogc7pfi47zpiN6OVRhazMSQoivN4Y2932Y/7ka/aIbZd+RNtobgpFkuHpynIGDk36xUlhc134JWe988PUbKu5sAQ/VFpfVOuanHIIr8ImjvKbOe2uSkjunR79iHBR7w1J2Xekvx+8Ry8h3psEqKqd8vO9wosFOYgzXzWAaaCYcCB+ogIb8uQQbNaavT9vbthALXqd05x7ta5srlifUFrrdMlCetcYeCxWitOW9kd7qfPSEuKnn6FTc7P7+3WdCDiwassuVCvrQEh2/KOLfSD/0v9NJHFuzFUdeqKUYQCNyGns+r9Op3lhwKsunNnpwhvIJgsBKSnQPZ+2CUWEbzwv6DzENsDFvJ/c9YX/YDLHuGwuCOjjhaK3OMZqBHf9Mk5Px12tJrRrTkQk7MqE66JP9PH9XgT82EcauJEL2g41dL4u2IRJQl6VxPnbwxdAFkenC1+XG8MS4iuVqPvXMpXWKC7OtORkGYw6oJAP5hx6v1HCF3mxkRBuarSLgwSa5IauZwcwyokb/tkPmSoCcF9z/Zfjrow+EN7CepRBiqvHbHALoJooc6D2Ta1x6nVD16OP8F4kyG+ShSwYqOnKqbY6QQcOCRlVSFOsoFnvBdmPlftE6+RNnaDMjFE/yWzqWxekdRtMoj7f/1HHykWzUFgxpypMLChoneP3785LpSPWXNoWg4NOUcN7UFAQHIHtKSD6rthqD6u6i2N2BSTUilLHxDAb2CY/hAfpqrMg+lEUkljeuKz7jkKAUqBcCtMqo2M/605U9HE64hD+N76pp0lxRZPFZCT5ki0XvuPIEXCG8q60MF96cCAKPAnxZuFCfQbHfo8+BROdO9S2tuCUI3EDZib8uusMnZVeWp4rVjZfMRrSW8ME27fGCAhoOAs0g4j7gp0X+676DatErdNvhcD2Igu11JLn++qpJ0qqyW3TVrDXiKmkoEHyUGcGmMg6k/CGS/XLDzdb7iKt+oH0M9ErIY6mLJjIfW2icM5LYP/M1GRo/7oJui+RF6Q0Q11xqx2rI/wpeMky3EcPqRJ+f8/u006A4nT77lxIunfsxBqfsB36hDXiHw4I3YjEeHH6N67Sg5ZWqe02s/a3m9KxTX1NX/SeOg0S/ECtK1gc6dFJJauEjqbWPeXAz8xClEataD9FK/n586ZVv2sVJrcicJ6Yrz4j4M+5q7pl8sUr3mNd3nkKrVDbmL32Va1DS/K+AqsDqg7LUHwmO8nKGkcrZmffwPmJSmj39/7nYfRNyIfmP13DRWKDSEFTlH0QQhCYeMcigIMJowdDMvyribxgYI9c66JnnIOCYH/pJbv6RMfefveVS7NuWVdsAwYaRkrX/4/bHbmOKOAhitBUH/ANjcRpgpROq1h/nNScXzK1+sEsFtTYxMLiXNa3Ey6QwEE/QD2hH3ZvnFD0oS92WUWPXuNDD5WYb3wRWqf49Sfpuj/dr5SEJWcO9iw4qrv2H9irFOqghNtRvpt/3qchAbxL4s+TauklpaCPmJCCvzF8AhmPwLh+12zkT48oEnh9z6tILo00/xDLQXAQ+P3jhFGCXW5NQLu+Na5K7Gba9CTDwQFDpHhyR0See3y6UtEKa25dmPAi0eGLLX/wZZ+95283R4asoNjEVl7VFYVMXvexTxM5WfxzCyRJCopfsaWZoSjTh22Qyw14t1g4cWQDevKNRtbba0TJyvysTAnQgfv8PVwWVvmBGXHNOveJ0BUHRgEG0wyu6Ghhw0lOT5oKuqAEgp+UMc20Lth94E/3/1Lfl0KCfdn6jzibz2rxLMgeOv+OrSLTwcbyBXBWI5jGGmWBur117zGVrhoj0Nut/dNDG+Pp1Nvga7x++wXytmrxbGRjeNModMiula2M1dwGNxXsV9CrfTGaLxtpmaMv9uoQpbAmk9djR3tuDB+TRAiE6JlQzK8aiwqBKeHbwYTk8tz7SIEfpoFqA6L3gzeyyiE+gLqFMWXHHAMUhyUuSPLUxrlph+isjzenDs+HLMH+wcgZyWciSsFw4E7NBj7CAYmxWlYvdIAa0iRHv0xVvcvMAv9vDmL/V5ABp80oVIlA/KwwNP02remfDbdNCaDXm04Df5y78coCXT66TC3WNJPeIgApitOEH4pB0Hzv2NDrtPYLHNcxSxMK4djOQGO2PVN9czQ9FRjlAF/t9wI04JyeCRE58jYkXQPA5f+V6sqIWESidXM9pukYUvR7HOajUlHEePoNLNb2tfDnnsvCJvJX8T078gfrps9hxLAD8Br0qSqGO+h10PHKbeyx2Fqi3y+ZiwFbF9bK1FnsvkMkng2cn8v4JNpksSS6PGLEXJQNdDOPJIsVFanvyH/4WBUTikC+AitC5h+CKSV9MRG+fsysC0Ic+KD7K0FgqE/hh0ANaEdAQ1j43bAZoE44pgaPkHW3kH/9xDxj7f/xIG7zYLIaVW2kVPFAlYsUU0/0V38qBN64uiyOwnXyKIjcCqXzqJdgsHGDvBQyu6le2SGq0BL1dWvdTI4uFtklfFD7azI+vwHiIG2TBxz/l82QIZ9MVKMJhFwmMcXTLvRHlwyy5Z1qApV6AQZlR4vX6aZMmIAv0TN/nqDOc03yVQn/1bak1Zo6TNIYFMsEHKUD+Ly0yZYNZGR2KC2GmDnGv3QiqNY+nx52oBZBXquW0y3V/22b0uiEGoSK66a5hO4ECxHQKHMqRBUxN9QgvjRzMdB4vIBe7UWDhkhqJmh4i+gZgjGDbQzbzU8GchLoCZ+/mUTy8Do204j6itqpXj4ZeSud7bJYvCTkt4ZgjKa56GHEoFWvkBsFZmvCazgSP8IDDKVx8R95+8bvE9S809qwCNVynhovJbXa+9KrA83Y1qCb2nKX9xavMS4TGx2j7aeTqwleTsQcVY+XhBFBf/bWYTVi/IQ61c8KxEAGkjj+jFE03GB4vgCUKpJiyV5io0r+lVNvIvyQTU6qIOrRX1tO/OBZ8VRMa/OO4xYI9lRvojoKo4Qk0LSlySwqZYFur6XQ2QMldnyzf6dqB1X//j8zYI02JUSj6WRAF5px4CzoVlDG3IJmfZTWPvjS6YoGTF6gCYLnDg5whUlSBCyo02Q6qlxwKVGMYsc7al1XVS6jlVAkbbSFHqTttRYTS3ufl1sTzqOg20Lke1rEFWY+ia5MTBRvySDvYx9imp/i757YAU2gyT+GH9fH9l6ORyZ4lAxuu3fziOLNulSCAC30nhMh3Lc84gUBaDJ5VpD3hp4lRPgpb8ZTEV15Dxu2OKqDs84IwObUpGKQqfj/Sql65PuKin+3AG/TChUp6McjbChDDWCKUSQPLbY/jpEv5nOVtotjg3y0+8++GRc+mpzF5eHtMLIg4tjg4siRa3r4qLrG4MyimgKVgIa1m7ZABZn+F+W+0ftXC4sHuILGVA31oWXLa++3dP3xNej0L8UGYBWLA+32MQDMsO0WaW8lBmmAM7WH076bVoRvXEUrUbRq9aWOsc9kemTkRdNF5Uhz59Ll3kAzhatTwM+rrmcyMBY2D17Me1uwyGwLVYyqUrryxcXLwR5Zp9tHjP8x2vPWXVbUCvDssiIUZ67SNYVX5qk1pvUxIaqc+NJf7/AFAnIhgIFHl0skwwA2eMpF1PxdN8b6Qt71+NWXsAPIg3saZcOLIO1MyHVeJXEYH6xjwj40/rzmuZx3FLeyfobQoJP64adGzjffOZduAg1umxWLpshCcshG7NNuuupLSHm5/rbCl5yFAhyzerbLYeRuFB3FXLQ7nZweOuSfhp5a7dV+XxrQbmF8LamBuVUbin7FmOv472NmFzC0l8ukknvgNcRs2VQLk2uFRtP3lx62qj5V/pFKMDIvAGk0rEOijoX5gbuf/p1CkRVuGeFOV1QVhV6uPCUwB0saBgG6B2o2bbhGZd8agrBpQSTkroTR6XkH5AaDguiAppoSDGYXX88Wo2LBrpnZB8ooK5dOI1gW9XoYITzNj0yTSFi3T1+fLdG7Jp8u3zZznrc6HRd8GWoK0hox/DjETregTg2wUIQaFbPr9DTd/u7Skhn2qgQmSAP+zGOMhdh33i+fWPAYmzMIQPOovb4uueON060hg2nz3He++q2bWrdz4yDPEIlnL6MdOKKEBFS7VBuIa7NJtJZDgSOUxEMQCWyuFdCrwzHZtudKGmBNCl0mnfS6GeOPOJ2s8T53ZiYCGh7td5BXCAjTiag+xCn3OX3sgrk+CFJ+CGnR+2ua/H6BI5AsHA90n4DOnI4KmjOFKkzNi1GdJe2J04ugMrwTKnlTyVN89izc28K+11Kw8r03rhkMLZquEkSSqxluarQC/752nLqFZOtT86eZoNx1nE04z0r0GwEK0yK2Bw3WIZtFdD/tzEl65Tib6L+vHZjXn8AOr2juM19GxrKTxckkfeHyUX3EVCJGt4ksGM4z37kKm8M0RCdNt1oqW8sKOxCU/IviDsnrV7gr4aZc1qPkTrqI8X9WUX6klReWij7l+JleTTKrwnYVEVMAahspxvu36MU873Ptue9Q70QLXVb4Dn3b/S5elaN/xxnnqrAeSg3OIVO10HvjAqiQsnzxNAfm8Z/7RhoH4mj6qTQfMWHVOxd+D5R7MGAzINF4nDqEyF33bEQxN1etZj2M8XJAJRtk8RdQdAGQsj+IXB06YUbpt1Bhkx5JrlecyWwYrEpo/5qHDrNFKplkVUiUvR1pTUEPEYGbsnElmiAsIqYUUvvQ/hkj9ATyagcL32S2WkoKG8KZAhIBXNjrqxD40mbnABeSDr13N4Ja393bqqXUyAOCNNoVJ+CthWwycEkts+PqTD7CAhv/Z6kz5sW6pQleY/f2Lwyi/r1BKah7+FcdfZKI/Nk0IQmyVQjwLhEoYceskujbvElsRp4fSR8mdyan1MUh9OknMvpGE1sH6pGF+qjms1Q26bZIEAss0x0G4BkfJbhwcTyQnj4KVJKnHhOLf+wQFV1zZ+oXgtOmLVW9+uI/J9YUSNgVXkz7AdLIAljfru89cRZ4MzwG8wWKCydnfYn2MIfDsFJfiYJHIJDbkDXRHauYoxV1VhMBEADXytS4HBoCB4Ucya5ZBtSYMw8qiufowwL28h3c33KQbZc77wqktjqfKBBb32qFxhiPAmSHYdKrmBInfhwGWNdYYt2+eozhlhjVf90wbmpzbO8sZRi/pC1H4YfN6U/jlP/MXuZYYDrresXOqnafgAEVKUuADsOgjuDPeHakMdYw4ZlnbUGT/SUY0aD4i5xZ9gByUFJ/bqrK+oNPK4HkIRExZB7ONmRr0T9SPQgKb79VjjL+Eg7a/KOTAPlewDb62pJkGwPZyndCWJaMi07syLvzraFd0jo+SrytCTLAYLG93KsyzX/wRRcwkJ6urLZoXROExBqotvuk6Utbh6Ma9I0u9nLeFYyD1ZQH7ZB+fENoQRH6SdUydAJzETpgV8nIYVb2RDyKNG/On1aFjX77oUWgwr+fGsxJp5OzjzfbnzNM3Fk3jz8tkzMSxZdL7yqZvEI1oz9HU3H4JBzbf8/cNqN74IyvAdtFsd33G8vyPebpLui04hsOF9yZEauNzkgTQfmmObSqJYlTmLQKuKlRXghk4Rp2X5bEdtA9xmIQSwiM0dFernP1UA7ywL1METtSW0DjyLxlP60Bb0cmdBypuGokWB9hxYgiE9h6traPtk3PvvoIsP1wOvSrDEZh8Ndbaq/RIZqrPEhfLrkfoloUv9n+83LsBDicjrlfJS0dNjpf2CW6OoxlYjZ9bmf2kGPr62hI6/+opj4a4QMUSGo/RApKrJePW3K3Y3V89qwelk7f9+eAbIoCy4u2nKYxXGbxmh/yTo8YDPADVGx88ldP2TH/+MznzkfO/B8gDrTvUbfJBg81C55gH8u1cAt4iP0uNXHFWtWE9hmU7J9n2kLfchCkzt3PXoKSvrRspod1dqpDLYHmfhvR5sI2zQVi6qNRQOMCP3oZJdL7LB9ni2W6yhuePYDaiDrMa5fl9jgyPDwRSN1AqGZds+So+NKYLEqgFZ6kq6oPnRzKs1IU0NQgA4lE9hsbRHvfD0eF7/2gkveCeXVlTXv7fF1TFQSV7dUJJix9kjvInt1k+PWPWxrUk4I8JQD6hcDFPTYqi7orACTW2nQDZoovWJbQMAs+CCKEJwFsSAl+YT4RuSpYW6CZCVEvnBxeUVcsaTQ3GUW2Oi2O4O9uXYoXX75QygpRfS+eutgzqIN9sz6+rkpJu5w0KuY8VpLaqhSUCd292RVYTaDQw6/pXYjgfMDrx9My6QnOtGlL+TQRfmVj+YB1gH6S44hq+q0Y19YV2jT7pM0ZhrIRxdatiOSn6ibfN37W+iS3yFLghxBXyIpWvUBl9ivHDl6dNIPmw4Vq9LSz7wPBTeMj4XfN54OINJFpUGVkN+qrzdbAHclx8VC/pZeWUJU/X5lKSY0w7/waSQexskVB7C9Goy2rE9kgW9FkQegArCAYaqwm8m1OnPhtmNucvh3NnLAB0FF8UK9pxjW+VZAyiX61m1uDK3ENsIHwN6y9/1XKeuDIIKPw3igzPGO+gyT9kek7mb7j/biLq0qSJ+NiZbwfvpqG0jXgWyxhQn5tiyRsuMcoxmTz4AF1rcvklJHhCar3IQbeL3BXXN4Y1p03yS9SqKgQczXSR2ghJHYbdjWO6DkzADpYiamGw4EHF42M4FLLz2qDNVszGG4RDdr7DetF3RZwhHwNWIcdef3F+UGgE8zFS8czREje9q/lGD0zWrIt1GY87iAOUvVqIiT3kbQ9eaT9RvvkS7xj+J83jk90TSvBvZPXUlMnBRdBf6oclG5Hh5uxJsVjVuYGbWpCNYvuwKfA02rlnUwQCXkzHp2dYCaxWyD/d1InxZerLAd5n0VxxmZBg1bi0DPABqSkUy/aZroxrTRt2A84u2UXTv1KD0eI0bLrclWdIjoWAfZzoYU5cB4oQY63+XONiylQU9PSpRprVMaqK8E9U/l4iTH0b3jzq+qgkMgCuP0b169rncSDip4A4SbrWbGKF/FyU4xVCB34VjfptkQVtE3pLqC7qeyslhEz5Ze1jYt2hOsCkVDo230MxKw6LpD1GxPQaNY3+w4gGSMp6ZB7tZBJ9VBNBE0qDMOSjSpESy9B/D3NqS3ILYpoB/PmtCjFzEVUB4DsesiZZKaUAcmJaFPFQeF/uhIOe1MchvCKBkPZKMJEBuCXF0bRMfhc1pZTX3sX3y2BWcCi0iRk0hcdwZ6eiHbnl3GWDT83jYH/CJ9hgwbE1FIWOCNqALMJh2OjemnTNdlNOtK5XQWtkfvsOR7pJB/mPTe7CEIygdKhtsjnZLfwvCr7iIVS4sL/86rjByqm85Iuzmd9pEhW15rLQkjF7tLwVVGqMgGOCeAnLC4YA/4RCph9/ydMLFmlDDkpWlZ7kcq/GNjOP46yCh0iV2Es6+wcBU2eh5rgZj6xI3KaNMJDIfeXS84AnXd6VF2UbrxybsHfdPsoioWUwtcRQblVzgQzQzStKQiX0Zf/ovVTsnZOYKZlbVSl5jR/RtBXQKEo3QgkQXltNqR+ltiVeNNXBRaF9fRM4lT8bPTRhmFYIOYQuTti2zbMlgCOQWIli4qLm8edC0MZGVdxOtod2KK1inos8RM+jcB0ATSfOyw+fP1DREn+4vaT4CVif1vWyMDuwYlAg0ixk3AwZ+gDqkk2gPx1q11FDvCriwh0R/LxdAvQc9XBv76QACgf5QQoa/a4Ebge8gPNNG1gwrxXsxwBgBi4rUB7MxtPbdpAeft5JJGOOi+VNErELjCbNzlFGbmClxR/bNJZH5fNBxQPaO/CH1oOreK8RDYV8DqYYTHJB6DeWWK5FlsDxJsS4ofP33LnxXzJ8GLqTpfdCU8XOoWGbWYWqRCgkzRACneb7naj/p4tKJvekQHv64ojNu/mxb7HfN3dOoPm3wLdUHtZ81sIiqTGWgt1Gqnnk0BcxDzptdsLFK9Xvi4FPRzljcT5jWnXHEELoRWJ7/4FDlEYdso5Mqg1f3MX3m7mhKXiq8HzAfbTX1MchmMdIULPZZSZy9Sff725ySnQMHpY3zCYSkySsYNemmIvViGz9ljNrVKO91As9NbPzIJWMgdxIZxmQsm5MXbzf6d7EQZIaVxSc+G60ghuYDkaOCFAzYeGhhW9+dhBOxpyPJbx/HuvEhNTPCrVLmyGsSJo8HWD4o/l8x83Cgkz3SQS+zoSqDuWiHuhyNrSEupxFqXtyfkj1TEcio27C8X/QGwKx1U5pVQOFvJGUdv3UqAmaFcZjC7nBWCbfdla60DlMgWEhZvUc0ticMvrlu0ScB0Q/lFe1QcD4JBJj4VMw84yctShCIEHy+SJ5N1I8MSHBU0UA7+fsZ/MTOunCWqdOb1hsQ5FzNlmcvzhS2hzc5HtrKMgm0U9eeaf+523eFwuE8hps0subG6ZfMw9J8WCNuzxU1gFGSQqAlN3fz1upaD8b82mAUyDEr8mx+1BWMOyX8/HRpftbbyFeb6Vg/Qv9o0vNaeYt46+PZmfaehM1NWPYxzNb+3x/gcIhBi7Xzzsa1bZlimIgoeHs07SykZdH7tHaGDPbK60MzQJjL+jft15N4GcZ9+G60n+qrxd3y1I6oio1jQMx6EC1Zm6Xa0XNsCAjENvRC+iP+WTWFX0hQKrghxnv4uEX40Kn08UgbVNl5sOdJodiBxzxu0Jk+b7gM/C5I82/lCQtELbkaDTDarntjeO4YYbwVGTMt8O3JIQ+65c4/ZlzTzwuX+gV4l1FA/xOCbmIzr7hbXUNLMNKiZR7alZiP3g1t/G6ubjtjk4TOMgHdGYGxISFO9Iq/+562TOFHengDmnJJWhP5I17WNPPaor1UAyuXwCOhDIuMLq2pT0ikZDB31wZ85KoPtM/YRp56qjbTawiy4DTjJZ1IA/aBp8mhWmcHoeC9kwj3MRnS/lURP6uJXBmLBoc38Y/AbFsxNOV0KYKloC4JftXs5xowyx3BAhlWyFvsqFbKJ5mqjboSHZdpiJ8nUrvTfqAhUyg55eVMpip7Ch1Zbyz/Sp0oLd/e9UB/sKcyttSlmrBFd5uVt9r90TX5Qppt24lxGA066i7k6ld6SrXj5I89a7Tf0CuV1C6XImiAHoczTZ1f9iGsCLpMeAfyGu9ShOAOYKvw8AIQDaVYJ+CLd0fPOEVlgh5vESayKvwXyZCJY6OPhK0dHtxrgV6o3IB2rLqKkpB3aDIII1mw9ghaLSkcUVzXhOEXVBTL81MedX5RPCWQg9HdP2EN35tuvM2Zv6y3RacdVCt1U3swqNFEMPyk8dOyXL3TCsnBwIZlBHy9hLr21YwXmzsWBtCj44sMYyf+IPRhLRgjNpy9hLeWzfDhAxJzrn9mODuQGEZNH77jcw7azeeyKkEY//QNnj55luND0psibvZ63ZYF8th6m7ZSRDtybiAMN7pz+0X95xOYTWyxT9cYJpBTYFapwRRV+CXKquOgoN7B6v7dhuky9TBqNCdfIObMjMUc7RBLWjozWpkmLTddH+GKFsqsOzgeIJVpyryQB1x8uPgjApYvdlMIl1Q182QoEsFOO2WQfoDR1vZIPuV9UAnpF763mSls7opAHk53C2mQZquYsS984nQNa8Z7QhNGptjXX3lWV9MqKEe4pgvMqkZ0CBu9qLfMSfTon3iD7VjOAK+fmwwU3iZNIyMbYBPDvOEJEOADeSWsWsuReIq5tZzX8JzugEKqqGePwm/CWA5IKPuoLug+OaQlhleJyMAP12bfepNxD2zkvpsU4dctLJBFUGeL3Po2DoyfDW0yb4ohuDxMIfS4sFPV2T7NDi+ksYhqyFAj+Lc0BLhQ3XOJOYB4gyrt/rXCU5dZGMFy+aN9RFE0xGiTSLu2R9awN8LVFUhZOl1V3VgW+ucRAoChgqkp6doGS00AdbHxR6n898c5rtoZxZ+5LiCfs+TH97+J5TZK1FbSvaFRHYkY5VW+CkdCnw5nVTm638aqpNow41xNRvK5Hzd0dTIdWYYL6CgK1K6eMgZIWQT4TAeaBPF2U74uIBw8R6DIDuw2B/wrUPjXAQ6OGRvmy29kBOTeLducNMyxrZp1wYJVhq7bBnIQum7f5ifiEZUPy8MRZENgI0Oa+i3L5SRP4pX2zHHO11+ZwtsAkDRqP36fzw/jN1Eh1s4iyYOsm8tjb7xgTQMOxD/hx3WHIadNCNukSOnSAZ2eeBh4Noq7G3CHBk2BiKU5FsWTKrjnfEGnjoQExv0VAuGsWoB47gbhaCBMfBcC3JdsyiuVdUs3d1E/Rr1e1mxElkTiHNkRkWPmXvTVTZfkHxW1pgf3zf4WWYfGmwQ4LJyrjf+F1Fih4XC5kF0IeO7/wF8pBRwmWESa8o7pFGF2j1MSCcw98PC8MODb9FCqjhHOKBCCcKBdjZo69hZgAw2UUKKUHE/LYpa3YnIbDD9141v9jfWR7oXVVtnO/MUqzFcN2pwePhWhxZoq+KjGj2InExlPjlURUYSEzDNm0Tj0RsHyifcYTTGGYODZ3VM/mmFy4YzwL4npC6HQMi+hQbAMCY6oqdSrVHM9UK/qXQczh/aVMt9pFkiCpMNkZhEjN4rS4oqWL23lpaXCwOqIqAN1O01kkFcrgrdFS3GvJjaUZXGbn3O8CVdrzgM4KmoCTF/P06GpdYh5VyBtfZ3SzPaSTzhYTK5mQW7l3UqfHcgsB+ms19quzFapi3okEN1sJPUZ7vglEx+Sh8AuemypPWTYbLr48vRwA6zdxEzCZq+4CEeRzkVe6iplZGez1TG7lPZ8C94+viw83oQg79rIEV2kVz0vDQaW5OUxhvRuKg6OJHCdVawaHDjI2D5kZy7ihiWz6DNuDqGndYuV+Brft+TxSOYeCfGhWp5/Z5J5KJfHAZpYr8h26Sh05TUIqyETXxJhbFHP51HhSz+IChi8qsC0vnPyborh+8NmPwffPUxKvCaSVhR841UVCf9pO8cDV8xiZJH0Z5sgUqckc/idlPwYVvKzKlZEvXK3ComxYVuiAJNX/MhAmwV2aCr0wr0RwqMQ7QDATd1RKwYZWHB7PA6A1d9C9/i7HMN/EARvrwOLb3oqOFh8ldgObZuCMc15Rp/Ab5SY9qmEpGWBA+XcQM0er7GfZ8WTLZqWb0mwdEFlGbqM4gMgSAk/Gei9JOX5xUsRkAROiXf5D+RpROSIzvk374iZM04fFysIHVlQyqthz1jvSwFFGPbwXxQWSKwrnnt6uAYAVW1EgMUy7C6peVwbqyRkVQWga+jrieA+H1fNAS16My5mdlfI+o37VRaCoJMb03k/0g52qfP7e2IPNsuid4TNTwvCcgNPxaHVxRCHP63TrfHlxFmQlzQt9ZAUcYSD8Lpbz+ZssssuslxCFOM9uWQzxoAeDccjSZqkYvk+2aYPhrefniJY/i35byEM49IPwNa5KnVtW6noV9HNqTUmZy3jNCDDKkBgLL2+pIvxAlTir2e4JrMLugetsj6v+qAF55T8NWM+cTmfb0rWk55crRQHQEEQ7jC2wffZAIoflO6isBYLuqyYPUpLoCNe5UhH7+pL/hKNV+gdI8MiaF93D+mYHZ9zd7bwg0zQQXjPLxR2Y3U9G7vEmKLcmhkZ7MnLhECHOYNd8N2XrletxlLydb8DZfdmym7GT7q5VuIs938799ybBsBTzQgyHvipbGeTG+apPhrCd5wRCC/ikPrSNxnfve8lLA0+vSIl63YMCcrUPm+TiIIHvIA4m3N4v1oSyQLx3Qb5lSTmgDQcosG9e3981+pUk9tUf2YyInNsrwwcUWSoAxmuCGL3c4BmfZndhf2epTvnjtD4xKSGaJi4r8tRVM9xvJPgFxKpST/fcT3wPYJY8yMFqfaQp1HC0+UQmlLEvwmZSjRuMwagYiyYUUB2z4rTSsDxS9+fGCp/UYY5ftwR2RDtLOi0eYNOZmJMEMkwIvFmpkTivbtkUJIZvfRySL3CrnLQ8VfhT1OjGU96iu6Epb6Xse1jyf4kzUx84l72vKJNDrFj0B+XEgUnTfxkzhivw3ckiWVuEXSmDmN88DUs6qVbVy7TMIXbZTBXG5oo/9WsPPcKWVDYj8nvKKaoSelDjnZUuWtbueHxZq02EnmBgPV/Aegiowj/FtuirvUQBuWWRAbmmT7zqfBFKWdxig1GhmsYcJ5ldtfeijBXPTCboL7TJA6lS6cYblCfR/VhPiAgk1DMjisw02R/QbIyLc7hGbjqEwn1jVB7I34MUk8CX2jLvp48QToiPJlzfYRKcheuoCKGWlx5VtrNtSQje8VnJlbo4dD2/I7Etv8BftLwpq0lGNuJ7QAEujRhSpzxOwtEuPL8dWGU8Pe/AulMy9l9u6/9FwdfsEYbZUAFFhxkD6BGfhaNhMeCXzyJ8PzZQqrBRKIVy09CGGCsJG9fN5cteQgyBHkxsT7F3484QY8VkC4Tt8m6eqVMAKvYvposOXo+6Amop0OQjdYnQWdsRJjG4BABNKWcvBYpMaqDIC6HftSKUeK/6vO0Z7804bR4KnHkpJkQ3dO+LJnIVxFCqYUz4i1R0Y1518dcEDbTxid7EXiSKXSJf4rgg3PzR3dLLnDwkpcDRKuVXIeYGvseupGdgXQhMkoevo49sQ7Y5b3KViPGIGkf7Yd2Fnmw8x+jgGYdxjsg8K4IlgkBm4Bj6wGAb2UMSDbtOv53NyokohUaurv75qBQVhQDl6TRCCqI3kzA6KJgW4jtcxpyedTlTOfsQrBb0sHy8yVZa4pEGD6JzXVg0226CTqBBBCdoWa/t+bvSDYC6tC+Ch36y0dfb920YmS+ZUWzPfE5jLkknezYMJXOs0OgFe4iF39Sces9mXNhT4L9aGfcfhBUkDbabwE0x9leCviytZnBUI3XcKObOukXBHN5keIEBrnmVcpcGZfpoUSUr4e4ZKPYOvGd3ERLzooRqOJSO0mRYXTWvUBsQF3MN1bagTHEYBeSYxENE2Pt7r23POG+8TrLx6065wBTTs1cWpWmV8riUezGeWHQYy7aH39Uh+tddqqBKXgjbPgvij4Vj7Zu3qRXjXIuEOaopNaQ8lgzsmSLdJcUzGoHRBnQ+ZH0zsI37u+3jaGsl2IbTGwdp/esGA7noAOrVvcqdqEaAHZAovuDPAZt2ObhIJ9ZoepjaBTo17McgnE+4ko7mqe7lzA/PbZYg8wSIamg8IPhjasBu2fEJwB3lUTi7SQ1IOnRo8OiHPtWIdiH1/imJUrpyl/PSXb3XJf3up1Ti8qIYUHyGMtSmm/aG2F+muuqYBN/Ct7a8Q2MB6P52JrXCEmHDANOMP9535iJF208JAY9Pcpi7KV6VmapkxHhWOHugOTsaiWvtaN02UEVLowK8VLFSJXBnKcj9OYGLaZINtRtmJrDpwsUjREox8YNA7zJJjhfQ//P3QH2OiozRauCvDWhH4Dzy6SefByhIboxA9DOfZRNKO+I/t7VDpaP23wXW3LXwi5SdSHf7D9Jx0iQnPLh/A8WifakzkZ6hKDl5q0kD7AFZff6ho8F9UBXuNRqJmuYAXwqwCGDzVSBXO9x5BAbSjOCuuPynG28XPXC7cNjzXN+TcQvnEoKUIX5bs9DHs6Gx6tQYoCHA0r4ZIvmP9qUmZb8TMr5gtWkJaFMJ7kHl5/GRxuQAaFGO6cJH3zX/2JWVUKPdE9i8p2VkB23q4o9EznhNK1D27ruflklue/8WSWsajt3Bb8IfnuAdQemt4PzUUlCAfk1Rpno2uKK6z97inq0gnSqfLFkSdjug6lvmXlKQqsnpqUSW5UVEN36JJhr/OX+reeihGN2Psr/2yi/65aMKfp6EC6PqZdbD6mG0NX+s3eZIER6zudfZuFoLpge/ikllYdS6ft5skEnZY9jAJWbjjow1leEsfm25f2zbZWBt9TELFyrHp+UHA2q6rHAoYj2vjfg0NbEfdp57ZV8hufXKiu5/esCW/ZTgr27XRNFsIevknqE0avKjQxuSNOT1XZGn4VWhSN0NG0sL04vhmwDT+VSqJoD7bqur/26FlKWUA1Y/YJ+e8i9Cp77Aqr5uUTtmAx7LeJtlQyWJcJircHYoDMRbTrVhs3ShfkSHukUToEcbmVWPWa0LBMUJgISa1rzs9/i8e7HJnPT7y4a4PXW2V4YVcnIrImGFQeDwcZQumR+VUeokDhzHxJ7tFS28XbOVbakdZZbMWEHGerAoETpiWEGjn3pgi7ikBShQqYKcJNZYhBcjuBYDpm2of4aCgS2mWz9B60YhhCqfaxpB/9OZhXmdO6ldd0/Jge0AMe6BFNUkogeKme+gEknX8/OO5J+/ZrCR/v3FcAtROdkgW4CwR1p6LVlGdKeD8ImwdL0OUzK7tX9do5ZbGeEWtmmy6Q5YbzQtjUIT+kgjbSlaeus70vLSBvswv3d9LrFWAWMcwYbgrgzyu4skpqo41DQuUjLFJ/Brtw7YPhOs0bVc45tzLsXiJPpZ+AdH7cAMBJWJ8kG2EOh1d2+EZ6OEOPX85qTGAz99qd/9KvCfnwBlGC/cxE8oswS6+KfVZG6u822WbweB1W2JwBGL2asfpF0LGh9kcn87TL7GC1HjzJN1SsfDHgEZhXhbkGikNvSYwUnh8zEiALkzGKuHbSFyqa2l/EY9H3ZONLh7EYNEtDr7NEU35ZeifoIVw4fkh6AJjOb0SThguJUTLgDdq+rS6Gbd0bSjPUxL5AnpQsTDlLpwV7GM2c3otJc0J/N5CzdsOuf2nGwDG17NVTXgoBdATMT8iCCBY3xshEHinzcZJu+9NLsUU8gtoqcCp8oWhde/4I8WH6N4JDPkl8WHdPkHQXeQCd1uhZe+r3uCIkGBdj3Esj1Jrvj84zimm9axzF/KsJbF3EtU1dn2N2uALoS+5DOFFUt6m3jmy8aphyAoFLrWl99W9RCfDYa0NsDRHxxtbtIQ9YGqICyE7Gjo+vn/mSTDGK2VIJ2cL++MhDYIsNqzBz+3DMNJtHEDMlXsEHL94UsX2Jt3Q4Lu5xFP9cXTBQ29huvR/C5uBwh87O2QW0+hB1rGbFs3rkmDZBw0h+JAk79EGQBqOi/G3qooFslE/zF6IzbPQrFhC45po74VFjhvhVJBMfiJWoYlo1cV8AVzDhcWfmqngFbI9UcySlfd1zz01q3dcAA7rIR5rVzouoJ5hJo7pnf4A+Eb2vqoQ3rVw7kEMrCZ6fs+g2VfPWOoIZxVEPHp8AAjZE99w6CVSe7Z0p9S2L1dgtWFfZWtxS7J9Jlx8Rq4Qw0CnKxcxKwULFKXL0DspD/KDgNbN4aZBEBo5NSLE/UdpS4txPBuBLTH3GUMFcotRSr7ElPx2BiHSUYI7n2+SGspZk9HjOqUPQIdcrp6af1UWGk99CqoyuyLzIbotIQ9ddxKYn4vfSay9Yu+3XoFVBp00AVUgpNTNnzirKm69nmrwOJYa3tC+aEUqHjkf/k3muq20m1e4xYO5/3ca1pJlLhiPl+EDFkWV/CflQ6OJyI57cy3asDzJEDBLeES/L/4bIFkGyBi7JeyXiPGtPPNV6UzbLUtxmKHhuim3f54OLOtwvbc07xTiqSYegO3lhcSn9aurisDSFvaiWFLASw29zsMFGHUqXcbICpnJCtLcLzpVTqzKlWJuU9+10siPr2fsjHHp0cV5A5QcGKKAcLEkvwCkQSNa8P+VwspPj7qZVzcNwO96dpOrAqI2/PPwQGNnt7Z+RHQrBTT7C+/fQ+Y26uNtVKZOwj7JDQhRKXNzZxdnOqDG/G9Usa7FtTAo4f21UuvSwMaaXPdT1Fye6VIeGwTYP6X/XMGfY87U/011mqCon15d4GSKKmCn41KwYDyPiAqP5XLZOCjISaTsVy1roACoyLA19B3Eh3yjN8Q5mDuMmuW8hIcSrAWyPkXPv26oArRcZzDO0a9h5SdAPPhzONjZ5GMbuNutE1oqhLQtgOUuE/eHBF9AmMqu7j890TP5qtMceeqUKaUqqRrlDg8kKFtLY13yFfvAf1mZ3KKJvP+ea7GnLP3P4nLjx5kFXzj64PZQWKXKYDwGuJ32EuyBpMWsjScNi9fa9eWTkDdTyUc9WFI+fXfr+dCw4lqWkLthQgkrDbk9wCyuZ6FRca2AOclnPD2u2Y2EhNijWi3xGJBwjgXdBIr6b55SSQgKjr7pP0/9MOXazPNOxbB9Od//pvLyQ9huBhitqynvJi08Wn9sk6zDoaDLs8imO0v5jXz1/EAsrHOddXUBS0YrQHmLoKGwfycukV6IGgvuf25iZIuU4vhJCcgWomEVwuDK1e3NJ0hEfSgFUwQEwu9brWk2Al055JKelUWDm/dpfsi3geVa/NksnravsGd47JwWxRF0LvWbuZ9ZZjFZ403b3/ol+gOsD+maGCd7/N0BT34xdZut8717DXMi+Mjh3RyHqPKeZd2DA5iHJ8Fl1BxQeCj82Fji4RGZkff7xt5dL6sG1nt5dsYqL71eT+tDggQXFocsgSKTrLcjeCrK8ujli3r8k99v6HJyaC3atYnwqA9+m6rjwTlgbfcfsYknInwI6EXSdk77G0njO/Uuh4kg8qSWkWNAYNkXj7fxxTR2SZvKZX3XffaJnMjSknBqrCDcKyNEHs0M0vZGOCmO800233W6ju5oLMtHEoDkDch5T4MMiha99YsFyatYFN8FAVml196OKSxk44WlwiR2VhyyOL8jfvQqRm9K80w7WKtpiN3QMLN+Plxb+zzt/+FBDPbuTaOHLfCKUcahtWcz7j1HMEgTT1FLd46nYFc8yNTAPyqsGw/METyDEAHokZQnFvN2kjdpHwAKmfxuRimUiGmGKzXU7aLseV+A9lsBSWuilOBRZNpMYAMFxhCf4F+T1QsvqiEPYas75fYCRcaUesHBzaYItDps0/2mcDQWEycbNKUq8VJ4g5cJz2T7yngjCphkURHlIUt7D4dAWjeruJ0LsLUDWBZDW50iuRv5+cUrbENAxMio2JPtuvwg6KJuh6FUoyy8XOFr3chHYg1gCvDEccdkicMntOeIGQWe1pKEiknVk5aNKnIrHoB9yPZY2Ag6m7Vsl1ihYBOMbunbK63Rr5kgpRuYjE5lJk7zT9vS8YWi2e1Sz+aH45116ea4O+QBmxM57vVRpKncB+ljYM+QtcbOx5XNnRgVkT5/39dDDephdBv9I0+wbhkgyBv9oI8fb/XwJf3YO+jwVU+6zAqrqcxu4YWzrvpqGev9O+R/HG1o2FpTVqon3XjF0sdB/XRQ0Mz8L8bCCN9x4OhGUIvV1boVHrsL91LtgfLlUdTMeLs3iVGDQFzQrp1pQd/H1m+fv+ENUWuZ/6nUp1MJTYuQFFW0rWZAIgwXkiP7JwNEEW110SOdnAFdwmdsQtrJ41XLvEYkRStRF57NMdfcjP8ZZCHJ7rVc3Y0d9YH4fUWnmgR6WwysG3Q7idhHNc0cziR/zKQdW1TcvGH8pGP3UPVnAjtJ+qVkW03JFIG1LbMIbWfFm8n/elWYh8GgA9qOMHvolxexIT5ZdBoAawQ+h1KZbWE5aMY01x8RVgMeQVOciQpf7sXJQucajrH45NjwC5fVJ2trS4UqdzQ4ggj5oDvieXbKrAN0meoJRZGgLpLCVlnw3o7C1z5IH9ViHpA9ixYhsYmYUzT/M7sqeIOKm8+iZLmNDn5h+eD63p6GRHAozDaxZca25uVbcqpz0rn4NJcBpkjmW4sRF+m/kmW47QTYEW4muNhX/tAri3qZZmquOxgJxvnlXlh1HH5G5Xjo3eYql3wMobvZQpcsr00LRq0qgtxkOY+xmxA5Tk0bsjrBpVHiOeoxM9uQs7lAyrAI9slMZUf04ipobt+cLcdaBArtfOfpXze9ew0hKOjvyNwFH2Q8YmySq8dN0ENCQ0TAnZHhFULjUUW6Ohk8Xnya3NNsxK7S1s41AVbJ/E67pNzeTgj5pR0O9iX9GTUSCXfM4jv3kd21xAPqUvpGqDYQUDNTFfqwbnTMNQF0jRF8/5RsFB/vh4Jqmvb0iPa/FmOvpgAFsW6XeKaotRnyXbgeCNnHwDobYOf8Anz0RdpKeV2YMmvaerS3zetDVC98ju/TCGa8gSvnadRFecKwGKXSTB9FxIuXFBbi9Rasm926GOLsZ3grU4tVObIjAhYlwSqweK7ePNV4Zc2MQaksMjgg8uUJ7CYcBk8j61SfkIjwrf2CmNO0KVxNFw/VKKKE74NQD4mvzdgHqNKgsO3OlrRa2fHurkGRqh6KDszaKO577H7AYA39WyqhUggFNS4I57yZjUFPBq38Owh7M25iyzvtiSn4Km9Rs3+TnnnjHSUZ4r9EHGNWOXQ22z/QjwU6yfdTB3hxpUo2UpO0/yL6tD0783pGlspQyofqiHc3G51PDggNqkw6JcPls/rRaPqMlwrpXP1vlXdFpk94/o1TvHZlt/98qmTE0oL2MX/k7TR5OU02c44cilgLxyqGizEhytg4LMCwZr/pEyyLk/EVREoWMIAUWo1p/rDCIz5NoZ+DWjHqzzXAubcxK+chBXC1xCPLnAOewnIZkOWcQkEpGPPQyLiiMIFkbjXjjRpY9UaI6HYPoF4jRhZNHy4YDoEMHdm1rRML9RQfjYOH9HBxqoeTf14kn9NRM7hzQNP7v8fGkjagvfWxCrr1u4NCeYtxezJXpNPY2yG0gz8YwlXuiQvTCL4tLhj5Xd15KHSfxTOrMaD6kfUd78nAZnBkfgnv7x4pASncviRekMT83PE/f7Qi79bIXynu3DTgIzz2LnUy67U1Ri5JcvNqhB98Fm7wIZTHwfzzn4Dkl8WiavtF/4JdNT1DNIGRPXPD4pAnGfuVoEvswbGLmBU1VSi7iuBPQsWtsZ2DzGkFxvOFgdXRM2zGZTDaLIK7+7FC/rPTF+jIdU/81dn0bkP3QxchdLztUIehPrExPcRw/v10I/tLaMU7jbRfYgnfTUnWWhnklCx3p9iAl1f9vctfcLJZtIirS/GyYuWy1XUfzuojNv9i4mJrtHXMpTfEvguWloMmint/A7l0y93ZHNknU8QxWxryptYb4esMsnl0BDS0grqLPiANjZsSSshu2uh8mhGSCZUkzfQ0i2LY3aL3t0R+LQyvjFUtBYSEVmkw+fb7Ua4Yyjqvkxwt2/gS44FFSiiQdKDwxOI059/XK/+4fLtj0D0LEDp8z+rAqCPgMl9Pn2pErWuJ902CcYCV3xwLOO9RhTEFNDSnA2Z+1kgrWjcBynZUPAPGoGwLgclAeyZ50+VfbyV+n/s+E0+tdVPl59vKAKepHcVGDVkF0FrVOjiP3zH/RXJinT48lGKKqa/BvXcuOtCNs1soFMQIifOHZT39D9s+VBSd58q3EGKlIb/w8OIQVERfCqNSZ8lO8PDJLkoRmCoHqIHcaWzBfoPUJ22E0auOPQ3PXTd0MjGOSQQhaoTDSO0v7gcr/fhsPOhJVASpKFww5srSQ66UeOSiq263XQBXCGtwR53ZBF3la4ULUS3/1Vl7d9CBrwDDwJ+X3JpIeRBVz0s4NInhblbpUmDyAmQW2F4AX+IAvt3m1SWUvHduuJdglzWwgMfD5CFt1yytiiQpNb66clM8vXpZTwhH/UmuKWk4RTJue1LksY9a48zOaWPYRN1t6ACKFW4NPC9vrqBMHOtfyo39Go1mXwSz50rRJUtnPZiFHSnCc05nESU56DDVvgTZ1tt/6EDkpBD+vuoe/D8sfL79DcHOlDPLg+eMBqyUwUVv7FMieZy8flSw1vxe813QMxTByQFRyNfPYemQVBEZYB6zXyHe7RAwmluQyQSEXwAGx3G8yy75AaM+LU54l2n/OppsqbpQ7hr2gsgSA1UPdpAbwU2qzdSoRFlXV4XbxDVbwWeJtP5lvy9uUlCPm4YtW6MA2WBmzb5zZQ+/fN43DI7v6NnEt/rkVdZ5uJpX1krfHiWkR/apEbig0OOy0JZlXjhFiJZuB7+vCPUyF3Ps46JDCeD/YUSv7K4v2wxf8Rj6G0EULXbJ7kX1c0zhtwmvMvNsF7SwuAc9PKFXP76WGy0UfZopWkp9HZK5qDZ8yd2CdDAovzQ/rMbnpDH33JM65efNqtkk5m0xtkzzoAv9LZppinW6YRsgrq8KRhtjIoGqKJ+HSn+jtNVJwG50zzXVY2vmJXz0QoTIR/FBgxhajBERVvVWaA56GplteOXYyY8MhJsSTpuI6xzUTqQzB7uOZ8pzlUlAVzcaMGPKSS7f0Z23yRP5++8xR/nRPbFZbttbzXqqX16NyQG1dwmff+NCiHwBANP7GHDgD0WN7+TGJZ90g/DLss3mUwvv9IpYxpKTuGMlC68R5oT44n6EbJo8yV1Mrb2C53iyZIWA3UT6ssbVZjZHl96Ci1VusjBgUS1qxYDOafkbaxky5oRwZENGYgPRd+a/SAE/jvb6QnTWwOxoqsuBR1TWhHR5/dknHp3+9m110j3GCdvgGXyBZdrZmqq04cDQv0v22nQXBwaBFvXNyR+/ovmQ6GsZGuA9XnTotdoXOPZ9jUtTfB4dBWnhfgPiq8ikZ4v7ng8sNu83ozI1IDfgqmfnfvD9d8Hn5QTaM9fVt/x9/nwfIRDwMWeq6wX2wl8Q/PwAMiP/NrYTt+Ory9XkaT1imao6r3sKbCkZ1F0PkcTEo4U5Ep1FpzdhqbCiN2mbxoUAfMHn1IH+j1SpzPJ4O1fe5cp54VtBXbZWbdqsL0p+xYPVrr99/hL0+bzZgGvJEIX7Hf1rFP8B3WuK7m9PpDCMOuM+pgE9jPpMbLQlvR8KRtrMv5C2JqE8sTAlcI1H99CTLXKSZRF0+L8yAcJ4jhmxo1VJ0KQFNI+8QXJgojqYviA1UB+s32SDzp1OnGq5FJbDQhH4JAPgZZSJaBvHN78vfvW9ne1wBH8uXcj+ys+rlVBihRr7e+prTA+YhO0T2D/qKAQNfuiePbSQEZ2Y+L3b65et3fvofbqh7xqM7lJZDyN4wsYHIv7tjd79hEIfpqMz8VHGMNlADym5Kz6csR70zlccNUIk7e4VZd1LTD3SGIkE1QjrJeQ0XpSmcu/w9nQnlTUAgZWiJYdetp+LbTWHurUB0KNv1B8o+d5vrYGLXZA/XJNsAWciGrACJoxuPsHl9vQG3IEuTLv+fzQfvEBL4kIOZwqrJlUCx1fqpIv/x/29WudkLcykjadPJMnL8Zh0A2qHuIojxbO645OCGOPVnTOFgv0w8QDyOtrjbNhVQl1VtkN+Z9FSn7CPZHISXQ54Od2/9aDt3kXXpwcS1qi/t1rwrJhPyLVZAWbeEUm6Dvy4U2rqB6fRh1QMjLopJ3iLAkXMtvhk9n7dopNHvmSz7hljnR5TISbylJ3FGF00s/eexzXWDg9qrhW3Fp996/N+KugC4DlZxj+EbC8GlBJ39WnLYueTbUppj7+LayDZlTB132eiAaWfHQfydu24R3GknqI0mLcW+AEKsWurcdxdmUBpTn1DyHxZ2U80QkrHMcKtuNMbAXYsuZ+fegIQNYaaYJKGdqGeO8GSr09j+MID+Pyula58mBQj+qdUHK6khesjJaM1UjtuDAZxS8iKIvH4bn3QgIvJKiUt97sBVdRZz/sIBTgxszg5BEs0Bju/4FNi8inBUF59atH3W43A+mDh/fWs+ysJVNtnXWkEnK+QfEYf9uTRR+1D+M6DL42VAssDWn/JOhpIxpU5VRotUsuVg2MqPChz+ADdH1LSK0A5RXZxC2z7CMwYDXykowFNazNWhY09Ezis2GqaxdfUdn53PS+nzbB1QIaERzHyry2PM9ZsAcjyKI8moDz0xQs879LNPNCTJRXPW5wDwkfSufyjs+kguntuil6nX1k9KNgkiaQvCgY+9qPQ8L6dHJ/AAPpZj9YbUsjQ8KXmIB7iBSj6jWri6ktqqBb9b1gN9z5fxur6uvR8TmkyRblDtUQo8sidaquZBIQgsmLFOnhfvghmuIDHccbVSFavqTMyPFOUpOoKbbPOKFxbacUcxxmUHRr00NWGNgsFc5qCqKVl5oSvkd1GnlaFjrLjhGmpZUqFQGp0JzDqNpQohJNzgD09pUd2eEZiD9iHMmlhF+xgI4KncyBP7JgIUjzo5J9aGAXukV05DzGu2d5NmJ0kLS1+UWo8gmRgFYXeb1kfCw3NQCfC30j6xau3tsMzBcuxkGzWiKsohlwbgxZ/WAzdEKYtf4KRlkFFW0fyF7yJyLMDGKsTueN1AzR6ih7QKXGwHjXeBpko1rT9rHDuJWLl/ePEA3Kn0FYNTuvZoxnx9QuLeXz5H6l0yXkBcXQ6FzFXteGSFNOIGPjsGzD9ks1klsyj3SICT2fCCLGe2WBSsm5KDc0N2usEUx1Zgn1MOx23xccL+r573dm4WhVzhmY0avHoOcrix8/YM3yPjrkGD+2LdUgYA3k6LeLJ+QDFwHOduqpLy3nCGe3w1xnPXzVZg8WpMMjQGpZOK1KWfBG5TRBIddUQ+cnBiMkXzQWbzI0nWaTiir5vA6lKBmiPf08JGYiZZ7FMU5DEKoNSGaRPwn/wnG7BAuqk1Tu77b+tHIwnM3S5pBNxMRsmCCLvwGVtq7m46nITLtnTNAqnb4C+L1vHNjAr3H7qQN42BIHLaDdEPYX7ZFCh0Ct1pr9WLAFAGf70uhKuBNzHegizMgUQpJt4bMzNPLu9VJC2CJps0/wiA1j++usKqXiRkkRs5iwwKchCkswvWJjY//NNGDelDdDjkNXk5LyOuC1j5I/lZeY2b6zG1ZJnALGg7hgeZu75T2U76krR6A7GrFnIY01w4Hfe0jqfY5ffHXFkJauiTZ5D0tDGzv0pZeeelQkqhkZkMDpWRgMBPqMJsDZcj1qd34gJuN35Wsg3nTWbQa2BbDzinfLvM1fJzSxPW9ZRNwh9VStCZLt7N8PvN2DHMjlQEu1w11J5JzOjGhdReZXLeTyyQzum7MQovoYWYUkAieowjYu/1bDKWNdBrXYPse+erlTU/4vrE+NVL/1YXfZ6LpxmxQGZJgRAxhMF/UOnu+hMIah9gzxGEG9cooX9p8vEIa2qrnTeFYr5RoMjV8aQHTfW2vbsZvK3nOGVNCYc9VfqBezijdH4hybYQw2iMurteKl/9BBjVRxfd1V4CE61ON6aiZEkqzy3bFp8TFXmPxSgXaZbYFUO6oLz+RCZjBLSEhKENvyAY7zKqn5eiPOG74CWdSDYwbQjHSF1Kjgl6Rz8Tr+E6B+03rjhNOALBTsfrEdjE5x2wIxeyCMATDjfoaIjcE7DA1UqFkuiuq9oJJLhYseNgZI1BBVK3ciQm1fcxOoRf4rR+rJ8Yg4ICfbaQuA5+gNcMNas5PjOx1zFn6T2eiZ2amBtb25iR++ObUtKNrppQqPMzZg+eWwkHOKz+U2o+EaFFy+F6m3jvxgnABJHZ+7ylE0mkkG/NiUewy+4GWFx9gUelsfZWtkKXvJ538tPzXXRJxNMn9+nzUQpvAiLBiEG0Hc6h14nQ0W+WcbPjLGtUFC8XKyBVX+r1Z154EWDM+FAjsktrsO3m7GY8vt1qHF8q1MGnGzNKnpjR97csYT1bAsJQHBRfJjS4poWmjUJmE24rrB0kXS3VQLKDUF1z7pOIrnjMHgjHxM4f+jnfwx5PiVv0LAFPoCWPzV0vk+dSqkfM9GOnP3IqGk01KvLju+SVj5dQ117BK1bRzOG2N0kPBCgMmV9olS67Ac2XwQCAO20Z1hYS+otCyhKIFPpdtqCCbjH+TVzkRc5/FH5SBWRLS5IsBd//9z1h7m0DlKsZVYYhMfeLarGVxocg06KMwIXqdjrINz6HBx0SxJsG1/TOr3n23NEbWIWbDAvXP+Y+JjETNDJjHXQJ34NcJdFjwVzkYxfXXv/fuAWVoVhgui15yKtV5aezv6EnZYu1zo42V9D3PkuFaY2hooUIX1TC9afIkhEXMNePBmyNEGa9dLi4qWqtESFjsaDRMKFGQ5/wKTMSm8Yb+Eo7khIn9QszRIiVGrNyagWouUzcGOF0cRwzctaD1gyw0jHjH5Qys8IGNUlo3PI2Rpu9SN1/iXyDb5wK/dCk4bVYHHlOy+n1UecxreMspQGghF69/+3aSOa8cg1PTzGisxQEavgPknVwmATBRwALZ3dTzm2tK9DFPFB+Si5Yf8ZHc8fOv85MMak6WkqJxTbKQlV84wLYBSJp+3owRHui7pXg5VwBhh4kMTZPy4geh6E00ehWw95/uSC5r0K9JfDHlK1MQV8FRWM9oGEnYoJV/vPJ0jXoZSjzVjz+znQm+mmpGDXzDhILEXvGE/aXCpxNbHMzZEm7tVoQKxe2sncKpD/ZGmQlZMwwaIgIN60pVuG521MmEmp2O2MOGi4oKUZ5+HUL3XHY+FYFYZAhch5IWaHIgWI5AmpLpkQ0Q9T2WhBYHumxi+Fs/Dkt0rGNCaKx0+bJgl4F3SYe6i4Jw5DK4t5biTZv46+sARTcZA+LuaJEWCPCsqiRrq62HUkaRzhHnlIWg2SQOtuaCVubTQzU8GxCfzNhMj4GJa0qS+XVU3WKm2FZ57Ku4bU30fYTvauPnEpaBPalzpMq00S4r9yIJ0BPjV4rP0f7WCacIfVsPiFFxM/UmYTkKlCdIzgW/RifpATCx4/bUhY9EmA9l8O1u2nwmWRJMPkuoOmXrM9rD8W+1FLFkUYBdzFDAwC+ktcIPiGTeY+XX5kEakHKpgC9frWEMW5Pg3KXMFMHiLpqprmiFl21mPHVoDMxH6kbkJvVM1gSQB9NmgjXpOxGfshXaCmr+JVs7V/uh/rNN7cqbHwZMSVF7kffGlAt9MAK+xRqihZqrkzNehJ03uB0hAgQO27cU/OmB/hSG3GgunG/eBycQqFAc7JMpxLEXgaxQu/OTUqE6HP9x8KtpbeVdiQPlHkUH3w8zgVNhgnwDyBFDGUAEeuWN1Gr2T3RGE71oQly6BQSmn2snrSwrPRA/6FhK/hA/LMh5MYolcN3jsYVSGUrz9gIk3xRK67P3UN9D5K5zSl0oW9OBINxVJ1ITCe11sXeUf+DDIohzoaw5fRVz16jQi27cArpmGiHyQsGXK1z4QcyE3xFZ3c9sC/FZnV/lTp8sj3LYFF8RXaVi/1pEjY3Z0bz//YXAiI8zzejAl6qCc10t2nLdMqiA03FH8Voabuh3ILjry8T5UM7C9quuff7Tybl/cHD/1I+l1xqMcSSYQqVCPF+mCnNAulwKSSnc3l+Ojr4uctfKdbu4ZU2km+1+MiNG+OYgH0T3HnsC1/C3ztNnjepsuowa3wkDZPIYhXtu/55bt8oXciMZOg76H8h0bhzMuGVAh8blq1DZG35GGgxq9WXbI7rB4x4FHYKDvYIqlAxA3tBdQCGfKN9ekRn1+EKtyaKcPirWPyJAYwS3GwgBlidCqpOe6n0A68+4+Tao29Fxr8HMX6iiESN4MBg7cVHYJkbSISQDNwyrsoRhiNR3El7ruXYPyuIqDXxgou7iBQwqmqKEik4pH97XiPHbwJ9Dipt6S3pmp5fwnfahZjM0VmcN1TNoaBR7BrQyEXTYbKHu+bVaaORUM+TVaD8aYurZyIM270wm8ESDJeAqebKcEulY3HiRqoGIVjUlNC3lV+B4Z9AmQSswEXCO8isXv/b3TEAdiBQ1Dmw1MFzxZgiH+fRqNUPZnfNw+3m0eDhc1gqAI+k/zoA+6bnBlCBh+k5+qYvEWSIqfq9vBVd8VoSaj/2FcAChVXjNx46XLP1d1/lmECmQA8R6i0819gFDOPCMI77r1abyrezWs8O28B5KxVpdkChVWf6acC2LNCXtDmd/HDSpTZiH9kxYZfr8m3Tx2yIxM4yt5JmycAZ/GJCdJLznyHmBvqj5eNsn+OPMXqe2QbgYLLaWEjbl7x9adCyTEPPRCh4EtyZUbCIKN5RAzIF2qb+kEfad1DtV+BX/3zHmzR3QOngAoic+1Ewy0FHzlK5fDgPhMbVNyqmwebQS5N5L6TCskNhH0s/maVvGWjn1AhZfOBOAuuXluxT/d9uQexKraMgKkGY+BWs7SJwGFQLrAfL1TWCD4NUElS8iNksQuuhlKHvQU57TCjWz94PX3b5mkTdKkLF7KeTjZlkJSJFr/yqPb8LTGruthL7IvWbcMansH7EjS25X7DOfFX5EuVIyrJCVEaw3E9Ez4QU+LcWCrNx9sceAg9tdzpId4Ks67HGbHjX1cYdyHCzhA91jiQ1Qwi5jmUFl6nHCKUei8Y39WVRzQ+7sKs5z1G9MHsRIV0c2e9uv0QeOfyQslwxEwR+i3m92h8mVEAtzmbxDls9aj9izpR3kCn190+clQ0JrOvWflsA5AQ1/6nvTwmB64dBK6m3zKVNJS5IgQYkTj5KZUEg8Fmus/Wvh1H05PjswkuzP/8o/amYTxU5zyWIP0HhTDkPCX21f0pvKV+1L3y5EiqIHa/SlpO1Oul1PnRQ0qAgI2UQ4xF4wgfgX9fog06mbqxB360pIj1MbK0upH/a8pOivYOtPSJHq3vDvyjBEwCEYd0z/F9bqqBMSoD8zap3fO6cbcJfRiiE8wqJ0sJvFQo2KcNUGd3wCloYti/+ObsC+uteLj+R9YrDO+A45BokrJDnCkU9ZydI02CXcwDitBNtnU2Kz1ZNIAbuIhGVLAfe8HAijOB2EXO/EDz4BZk0pSnU9a1dOjnYqJ2Z9Z82ZtbRmqqClkvE/hSPL+h3d9NQsOY43QTLjcn0JAb+oGw1Hs4LORE6Gfmyo2/lt4hGmzykLXVBTnSnYZW5zO/a3vN2w0ivPcXj/gysWtGa991uBhYsV1TtYPNEN3HHLIkIKhD5BZ0nw62rgzKgPo1zcWw8AebWKqv03XXs51poXUrsb8S+GPuro0DKn17x4M7u0jILt8bIUv6iohX6dJzB0UznuQLbk/0lZ1piO1noaQA5K8Q1pWujkLpnc8nyTUWM3OEDB8Oborg3OePAR4XdFRBwqBZ3mymfUgvRajeY7Z9AD5nKQJgH95fgCI2JMSMxhBFQ1xfX8iMnZ5dfAST/cE7VnEVkKreSXnf/e4qvPzKN+/Z1n9qXTEAs0JcrEGIDwJhtRAobLJj77xsSSogfj0aKv4zsClTVJnBTEqNT/RWp7QcOO7T1mq/POYnGa1/vnaiC8AuTbYQ61jfE1Vuv8hgQ4mV30IKGwudMHMLNsP1ICBH3IFoiwTl0UMXyxkx1kyIObsbZ/u6OPHvzl5qkj/aY1twT2mwv3msBujRgMQz+RlDK7ID8ni+SUME6ySX5T/nHx1U81XH1N6PT7HxNwkc/ZQNVSj2uXviaXfefXzlYZdA1k90q195YvE8XlDq2x8y3YJX77E4Jb1oANIZ6Nb/iqtKub6Dzx/YDA05SEKZ4HqlM3F7jkkE9saMkn8+yhmySl/T2bnQUsc3SQLhR5wnxfu6BqWIzOlqlFVTDGutOYQSiVUsJENyytD8iJUvG1io88oNYx/ALjYBUHtmH5sDttOpeXeZt0eC1KZlgrKsPELD5hj1+V55DKqcCCmg7FaEnXi1H3/Tqxy8uQ6iKAQ80Afy6HobBqvQ2soKL9ToXYTo3wpocaHlTXQjZyagyt4j3lcbVIO/BLWATfoZwxWP6fRP5YIhM4jBQsKoGdrv5qwrksQvwJcEtJ05/2XOeDJ5pGqdcqZm0HcpahiffI3iv8bsPaBZuoGLDyRL892K/NN0zvlP4mm9CyIaZ9+Vr9wpJ9h1doeMojWev75CBBiDstu2JVUFY66MXB0HDYM1R1k9HWFGylAXGp8+4SyZ+AmDWtVk383AYOOhSZWmlLQBiwpxJr6OQpuAq7/Dg7Iv8WpiGsOLQ4U4dzvkudvbqLRsjI0Sl93+PKJM2mlqTMHsi9PrDTmoGOhCAmxzeD2cwPBaSZUhC81mYKcTmqmqpqVgGOPKn35JB6VveseStBoSdYadckbsQ32SDCqZ5AhK08clw3114LV5uBSEqiYEE8BYqdh5/TGguJE2eQ52HM2BYymfIlq3mn6E/PDZ+ArmWvnc/O+dxFQLD6uCsQ00ax0nKIzufXlb+1fTMoHaGsHkY31/QL9u3H2inRo2qrQyiyd0UkFC6/qDCLZ5Rw/FP3RFarN+U0jRBe9f+aLyjMnT8w1VGyhlYTXy1/3rzyy0PYZzeJCOOegKlMfa5Lbamh0LcLwK5lEYiOHhXhvbfuToN9jnGkpBtkhBjuN+FXJRQvHgfu/XZVXoKQDBLhQP3lHfP16c/gdOJw7VZKid2Vwi4K8IdLI+aOknZ2TCcSPIYMq5QQ2y77xi/a0uTx/7U1Ctefl4HVVigw4M8UvDfgI/C7UWBMOHZnABxvoOsqdyBaOJ1XB4/xbUh+kxtaL1t/qt3XH5AP1M17V0o2VqiAMr2S4xgcwmLIyzlC6P3sR6k9wRdJUCGB9iahRUukfjp0Ht9V5QWMdF7cLd5Fba+2HkPp3BLRU9S5U1uvs+oOJNyfNw/rLPx/+oY/9qZsbVbHdRN7pVJ0iUmktw2AlhtqMhKrBjhF11WHd+CITyw4r1szaNeavmaqjQ0jziy8jZQE1G3LywX/WUl8qscMjGmWmzTR5STQ1DNsQA61DMAnioF3KcKFdKemoqX80vI7mvtR2LW4xpqIAJZnAQkKH1FxNnag3IDc3SnHQdGnXqevPBk/qadz9+7ck2r4ljSm9JYXnCqacCFs5ZoVay7NSfdUwxZdbBT+vk7nNuoLvn4mgQsmSCDzqIawSD8uAQdFgslhGuYX9wx4N8Bw/It36VQufA8Oxqp2buVWLmyYw96aqOJ2q7pJ/5E5AoJAJamEFsWLCGzdOlkrh51tu+fclFR4nZzLc8iMRUUMZ0r5pyTvtme0Hb1j8c70r3brY7ACPoZf+aB3yLJueeuW7zZWoYMeae0ldU9QYQTF0KZqh8Nm8iyiKVdaNnMny6DocRbAEHNEyrgNYM3LMB9hJryucQF1o/3UzsPXz+NOKtesexAIUK0ycYkxUjRdDQ7QB+1PkVxewX5XGM3iwyTcqbNScB+AqAPGb48y/kzjsTDBxsuP2YAsyT4aTHtSAGkIEujT5LKmWqsSzqYybIWdF0oIGLUTlvxRo1vq15ejua5I7lp3HPluffYrE6Fhl3xoMDaCvj3eGy/i1MireQzoIEG7LqQh4C5mNdnfjZpYndGF6MJPRLaZHVqvZX5TtDXagMD3xGlgo35xT65jmjDFqaW2Lw0rSn5OWCPLGrVYR8glVjs4IvY8UsIqQvXeKWyP9KI3fTRlGbH2CLi3NiJNA2FeqCsRTOutdxIA4SUOH3ZESq+XlzUKCFFYhW4FrIZOz7we7NS1E6T4gYJeBVlCV2z/10yD1Mo3vU449J+2AMHe4mtiwUbCLfGURF1jAlQK+LmknrdecbBIRWg5zCF32pZStTUDHeGJCopAW9FfUN8FktjSkktqN/UvfCwadxUf5DJx8aUbd7sqmQFMBZFNvBHFLl7iaJ7l8a6Nlpz8zrTr8fZyrIvWDXoD/LLSlLcUjHBoOlJ4H6lyC//mjmo4gUdumRB61n2E0jxOpEZvJXSm23c58Jbg7drvd7R+8Pk+y4CsLYxQfIKkPd558gAQVHdZV72E/nDjF4gLDy41uxLB6tpOOKytGUZGNEqxdpLG3KgVUlXPu+rw9HNB0Gajxy/4cutrhmKKurFVo/QSqhby0CABtMuLMbEei8QAmw99j7193jrmdaB9IbsMlac1rQnqXugk+ons7G49ZMwgzg0OAh4ZIcRTbEuFNEc97RE47vS3gReBHDK2qRHqBMn44Otu/z2vqNut+f/4T3YqbHoURArxdEqAkOqSZmqvuk84lZYYMFGXQHCAY3F8FZSeIoFuRKWBowFfd8+VblSycctM4LSTDYM6eDUwLZzemzQldcjLE1dE9t1bc7MFAVRP5ewYNvLGPmps2mNvPMTVnrtTEu0WsBOI/bfISUJGv6eX+nA7fHNsO70duwwt8GDTPhUOlrNltSc8EnHQGE6IUQ7Fm+Hg1EZUXRkEKTAD2lMW47aCdCFb9cNZyP4p8M6e1GYRB+eUZ6qQ/IM1J0GFl7s2KOybo/BI+HRupUqRrwCTDox8RMiogzxthotq67f5GJjWNfeV+/2HjofhHeMUNq+7LuszR0mpQ5zN9jn8VjIs9LrTjcKVQDf3SMkQoyMbCNJT1yRzwBBDU6tV+EwIM9OcxWycsj8y5BcCilEshnKjvfHEopXgzZCjQAvYj9iHPNxOhxJRbYYRrFl25+NMU2aVBCKS6EZFkWmEFdYSsHVxVbMzdl6ChJPlIPDPJu62Md1JoWql/I4Kz60LRISEWv/wxnqFdr0oJA9z2a97N5oEEBubFOyXUxMRWpNrKRRFHLRHjYEAnKeQeCL1to1tnelvJqndi2oWuOAgoCj6GBTu1lWH8CcRmqanMp/JAo5GV3oEASvetsQQKPsY8q/3WgCGrmHOK/S5eIdePVgBBTFnaVFmXRaA781PMSz5+P4GIsu+P38+fEoMgQWUiV2DxznAvgXApV3uvo60JXf04CvitBxegpq0SF9sBsqk/cLOhaGvthwM/Dx69AwTjMP81rMmMS5SrPKnRAO0BeLqlB+W9aNZwJWBPV5+Isjxt6nkFN0N6+gLAwSa2VHHqR8kUUQ6yOPL8BWdEw2PxjbC0ggw6v+32w0xheYL+HUYzxvWnmFAQwrnzp6+/C6aEQ1uysT6SSRqg87Sdxttf6104iXmfr26X4RhbdBOUPRMWeiypwarHgAbcNhG4N+Og8M2bCb13fli3YHbvXaW1GEWFZoxko90MmBVjWTxvypdkGrBO2K4BcEwVVd2GbLsDVMjxPdTtY279b8as1bfjDsLHsFQZpmg9iEQttUwzDNUbqMvhwrFwHDoxXKnQ11PeKb0xvw1ElEI2zZi3zGh59o8jHLTehGU4Sul5p+X2f7oVmf/Ti0kqkLE+zMIT1Z3LuH96OAG7mQh9C8+wKkAyyPr1HygYPQ+w2zGvLU+FsdhgB5HxWJvNJfEU3Hm++qaTcl1Zcksc4a6ijhegO6pihfI+neiNDfdJ4P4eTDYcV6zNmlDyWo9k/FZCa1IhKWrD0NJ5DwT6dmTOHU+CDf3nfAfZ6/iRjUBTbrAQEvv2yKzRQkVacQZF7+rjaZ7uwDfLrRSnxU8vvFFWrM2MaRGtEzTOuWEEYxa+k50aE95WjlPxcb6Ig6ygtMO0/3N1g1zQMKOEj9R+SY4AbGyRCYLo7nHjob6HkalTJyvpgq4QQXMwv0fummNQXlZyIcc8Dv1tbkzJU7Nx4DcElUIdCQ+V8QrP7a4TKTeEPFIwJ+tHQagwhD+Kh8dcQjnGJYpHIroDgevPLd+mo2hZXpa4LLounjKgULuh9uAI7DWFiIAsFl3Hb0mJYMRGp9seaE8b6/m5P0HDDEGhM5y7ybUFAnH2ZJAz8slApXIAvWpSc7rMyUs+CS6PwYLSiawqIyzabTRGNgJlHqkhT924B/m8FK7lsdj6Vs3aV6wrsFWSHYmwOmYvecWmom6nBzSVi4stx++t4SPc0LpoDAedG+Yl+0/MMkgsR4HKZLom0fy86sFlHzAzwYurHwxYpsOxZ3vUUcRddQGLgthmBvo13su8Y3vWbjfQZ/iZHqzJuBqECoIEndb5aMR56pv2fglBzNwygugrRtreR2D/EgorK/kqjYKH811qsdRfXrRhdi4Z8DbnyRg+6cMlTW+vaQ7CIaU7sdK+qwhHu3eTQZhCDQWNeAVU3Kozgwqc48YRiUpn2rE9N8LIWqGcTWXAGqzmPYkrefIjBUJp3t3MJGXSbE6OrF6QxRvA2KYZHYfTmr4HaqaIxvttu1KU7XUFm51oQo10vdtMNrl+wMzw1lfDKy0ro87S4rbt1fNwRyofTYKLFDv7En1khcEmSKdCiXyLD8pNukWTFMCTL8xY0gWM6xCzjBRMcYGXRAr0tcOBTv3DTK6EgwkE3e5gJ4IYCqHLujC9a8pngUZS8UTKYAny6MghMEp3dspfxSAOimyTBOA46dJ1u62c/Y5G1o6GIisycPVQJiWFkx7q/Ish0aMEL91CFdf4igLMo5lBUvpvGFjwhQi3wyyJNRGttoyjQQEG8zJClWfnEeN9mdEuz8uiBmdEfelHVc1Mct1X9+JAJyfbabXp5bdjf654tOH6c+2woVQBv6LQLgdJc1u3kvT9qMsbIZ5Co4u97TWB2O79Ent1h6+UkJwZMmJI4P1oIhP2eILnUoTqNqifaFlTFpX22IV3PNK7f66ntEEt9MsJHeqArAZIiLbZh3NSk+SXBUQX4tGkA5AhafnV0MYfME2u7w2wMOKSSpz50yNnBgjaEeIgMlJ7qkfwM8nkJPv+Spr6Jq90PEEbCZVzGw5he/hCfHXmACxwId36SpjpnQ10QAJt75Y9T/SUq5ZEXeFq+RAhl7JTTJadLnOjKU9FaCg5tUIiq/L1dtalcQJqljW18sbgRsEI+naPbYL97e0MI4qB7hM8nHdR+uk1D/o1g252aaOm4QOSSQWTz9UsiFskmaMc86zrt5De9JB9Z0eRI7G+J+o3r3pp/BzaGM2226FebclfZW5UNM92k62ebzOyXJiKzGpfHpvMumaawPrlBc3za+OHVaT3vYGiDgsYGpGpWnlWN3YuFKGHeMZ8vRkBRmfPPc7gC/sCDQPCXYhczZNUX+xDFtccWAH2d3dP203pI30lWrxi1UwvNFfP0hsO6Wc/8SeS02jMT6SS/aaccyiGGWGtcFistmb6nheM06j0EuwMDjZc+8IRJBL4KVq26VmIuPKvD5dacKMsnopNnZqw=</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>THUSC 2021 游记</title>
      <link href="2021/05/16/THUSC%202021%20%E6%B8%B8%E8%AE%B0/"/>
      <url>2021/05/16/THUSC%202021%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>滚来更游记了 ~</p><h3 id="Day-n"><a href="#Day-n" class="headerlink" title="Day -n"></a>Day -n</h3><p>跑饭，骨裂了，退役 flag $*1$</p><p>干饭人巨大失败</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>搬到 601，一个人坐很苏胡，<del>坐空调下鏼鏼发抖</del></p><p>颓颓的复习了一些东西，成功没有复习完 todo-list，不过口胡出来一道 JOISC 2021 线段树合并 <del>结果考场上就没想到线段树合并啊啊</del> 退役 flag $*2$</p><p>被 xy 安排发言，兴奋不已 <del>哎别骂了我知道我是工具人啦</del></p><p>晚上痛斥【数据删除】，差不多决裂了，退役 flag $*3$</p><p>暴风雨的夜晚，路堵，11:00 到家，洗刷好发现一只奇怪生物，于是熬夜成功，早晨起来一脸仙气，退役 flag $*4$</p><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>试机，三道 sb 题，但是 T3 调不过去就很淦。不管啦开开心心合影去！</p><p>…… 拄拐的残疾少女 xml 成为一道靓丽风景。</p><p>好热！好闪！眼睛没了…… 摄影大叔：学生站在上面有危险，宝宝们快点配合</p><p>发言去。哦呼，第一排~ <del>不能睡觉了</del> THU 发言老师好知性！<del>画的饼好大</del></p><p>14:00，入场！</p><p>T1 一脸小清新签到题，肯定有性质…… 我找找…… <del>然后就找了 1h</del></p><p>突然㗅出一个三只 log 的树套树做法，简单好想但是…… 我上次写树套树还是 19 年啊！吓到了，细节吓得想不清楚，滚去写 T2 50pts 暴力，调了一年 <del>暴力可以直接 dfs 但我选择了 dp，实际上扩一下就能得到权值线段树合并的做法，可惜惜</del></p><p>写完暴力突然发现自己细节想明白了，两横一竖就是干！</p><p>半小时多一点写完了，开调：咦怎么疯狂 RE…… 怎么只删一个点…… 哦我 BIT ask 顺序写反了 😅 改完交，最后一个点 RE 了，算下空间 480 MB，一看 ML 嗯很稳，改一下 AC 了。<del>总算笃定了</del></p><p>飞快拿了 T3 T4 最低档暴力，然后没脑子选手决定弃掉 T3 T4 去刚 T2 正解！</p><p>接下来的 2h 做法假掉 复杂度假掉 代码假掉 都发生了…… 心累，最后调出来但是 T 的还不如暴力……</p><p>于是铁头娃 xml 就光荣 190 退役了…… 周围人怎么都 300 啊 /fad 右边 fyy 全程没怎么敲键盘然后 270，hhz 2h AK，懂了这就 Orz</p><p>出场听说 T2 线段树合并就立马会做了，唉。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>工程题，这不是那啥，信计图像题大作业嘛…… task1 总要刚出来的吧！</p><p>然而出题人认为的常识我一概不知…… 我甚至输出什么格式都搞不清楚…… 甚至没有找到题面说的逆操作 cpp…… 痛苦的用 Gvim 打开 bitmap-std.bmp 和我的 bmp，对着乱码一点点找规律，最后图是出来了，格式总算对了，字节数也刚刚好，但是「THU 交叉信息研究院」的 logo，tm的歪了…… 交上去甚至不返回 WA 而是 System Error…… <del>似乎是我在程序里写读入的原因 qaq</del> 心态崩了，后面的题也不敢碰……</p><p>虽然从没碰过工程题，但真没想到会爆零 ~</p><p>hhz Day2 210，讲题时得知此为全场最高，Orz…… hhz 两天加总分都是全场最高，CCCCCCCCCCOrz……</p><h3 id="讲题环节"><a href="#讲题环节" class="headerlink" title="讲题环节"></a>讲题环节</h3><p>某大佬 wyz 讲题。</p><p>wyz：大家好，我不是出题人，我也不是来讲题的，我是读题解的。（然后就真的读了一遍</p><p>wyz：大家有想来分享故事的吗？</p><p>wyz：大家好沉闷啊</p><p>wyz：今天走进会场就有亲切的感觉，我记得 15 年的 THUWC 我在会场里睡了不少觉，挺香的</p><p>T3 T4 都挺可做的，每道都有几十或几百人艹过去…… 今天又是被卡特兰数卡飞的一天呢！</p><h3 id="闭幕式"><a href="#闭幕式" class="headerlink" title="闭幕式"></a>闭幕式</h3><p>就是发约仪式！<del>咕了 1h</del></p><!-- 有二等呢！虽然是没什么用的约但还是很高兴啊，算是受到肯定和鼓励了。发约前，xml：我奶我们班签一半！发约时，发约老师：XJ 要不派个代表拿过去吧。然后递过来厚厚一沓。咱班签了快 10 个一等！！奶成功了！ --><h3 id="后记-总结"><a href="#后记-总结" class="headerlink" title="后记/总结"></a>后记/总结</h3><ul><li>达成成就：THUSC 开幕式发言</li><li>认识了外校的友好同学<!-- - 没想到这个赛季打这么垮还有~~废~~约拿 --></li></ul><p>那么 whk 加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JOISC 2021 做题记录</title>
      <link href="2021/05/14/JOISC%202021%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/14/JOISC%202021%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>写 JOISC 会不会给 THUSC 加 rp 呢？ε-(´∀｀; )</p><p><del>都要退役了还加个球</del></p><p><a href="https://loj.ac/p?keyword=joisc%202021" target="_blank" rel="noopener">link</a></p><h3 id="最差记者"><a href="#最差记者" class="headerlink" title="最差记者"></a>最差记者</h3><p>基环森林。分开做。</p><p>环值相等，缩点。</p><p>一棵树。</p><p>$dp[x, i]$ 表示 $x$ 取 $i$ 的最大代价，线段树合并（做 min 卷积），最后总的减一下</p><p>果然我会㗅的都是套路题 /kk 权当复习线段树合并了。</p><p>细节：区间 max，单点加，合并要记录右边最大值</p><p>upd: 口胡五分钟，调代码一年系列。</p><p><a href="https://uoj.ac/submission/475311" target="_blank" rel="noopener">$Code$</a></p><h3 id="道路建设"><a href="#道路建设" class="headerlink" title="道路建设"></a>道路建设</h3><h3 id="饮食区"><a href="#饮食区" class="headerlink" title="饮食区"></a>饮食区</h3><h3 id="聚会-2"><a href="#聚会-2" class="headerlink" title="聚会 2"></a>聚会 2</h3><h3 id="活动参观-2"><a href="#活动参观-2" class="headerlink" title="活动参观 2"></a>活动参观 2</h3><h3 id="保镖"><a href="#保镖" class="headerlink" title="保镖"></a>保镖</h3><h3 id="IOI-热病"><a href="#IOI-热病" class="headerlink" title="IOI 热病"></a>IOI 热病</h3><h3 id="特技飞行"><a href="#特技飞行" class="headerlink" title="特技飞行"></a>特技飞行</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARC 118 题解</title>
      <link href="2021/05/10/ARC%20118%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/05/10/ARC%20118%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>钛丢脸了…… 被数学乱搞题打爆了……</p><h3 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h3><p>$f(A + 100) = f(A) + (100 + t)$</p><p>总之就是周期就可以做的了。</p><h3 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h3><p>minimize $\max_i (\frac{1}{nm} |n * b_i - m * a_i|)$</p><p>二分, $n * b_i \in [L_i, R_i], \sum L_i \leq m \leq \sum R_i$ 就有解</p><p>构造就让 $b_i$ 都等于 $l_i$ 然后在满足限制的条件下将 $m$ 剩下的部分分给 $b$。</p><h3 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h3><p>构造题…… 比我想的还要简单 囧……</p><p>选质因子 $2$、$3$、$5$，钦定第 $n$ 个是 $15$，其余的放 $2 * 3$、$3 * 5$、$2 * 5$ 的倍数，容斥算出共有 $2666$ 个可放数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】数论</title>
      <link href="2021/05/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E8%AE%BA/"/>
      <url>2021/05/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[集训队作业2018]-不可名状</title>
      <link href="2021/05/06/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E4%B8%8D%E5%8F%AF%E5%90%8D%E7%8A%B6/"/>
      <url>2021/05/06/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E4%B8%8D%E5%8F%AF%E5%90%8D%E7%8A%B6/</url>
      
        <content type="html"><![CDATA[<p>推理题推理题？神仙题神仙题！</p><p><img src="/images/uoj-bqb3.jpeg" alt="uoj-bqb3"></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>让你猜一个 $2^n$ 次单位根，$n$ 仅有 $16$，给出四种操作：</p><ul><li>$INI(n)$: 初始化 $size = 2^n$ 的数组</li><li>$CU(d, k)$: 下标二进制第 $d$ 位为 $1$ 的乘上 $x^k$</li><li>$CR(d1, d2, A)$: 下标二进制第 $d1$ 和 $d2$ 位均为 $1$ 的 $i$ 乘上一个 $2 * 2$ 的矩阵</li><li>$ACR(A)$: $a$ 作为列向量左乘一个 $2^n * 2^n$ 的矩阵</li><li>$QR()$: 返回 $[0, 2^n)$ 一个整数，返回 $i$ 的概率为 $\frac{|a_i|^2}{\sum_j |a_j|^2}$</li></ul><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>假装我们支持：FWT、DFT、IDFT 也就是系数和点值转换</p><p>注意到 $QR$ 只能用一次，就不能像量子破碎那样靠期望了。</p><p>设 $x = \omega_{2^n}^b$</p><p>要让 $QR$ 返回值只有 $b$，必然 $a$ 序列是 $a_i = [i == b]$</p><p>这像个系数序列。</p><p>考虑什么点值多项式 IDFT 后 $a_i = [i == b]$：$f(x) = x^b$。</p><p>点值序列 $a_i = (\omega_{2^n}^b)^i$ 即 $f(x) = x^b$ 在 $\omega_{2^n}^i$ 处的点值，是好构造的，就是二进制拆分 $i$ 为若干 $2^j$ 然后执行若干 $CU(j, 2^j)$（记得在此之前要 FWT 一遍让每个 $a_i = 1$）</p><p>整理一下: FWT 让每个 $a_i = 1$，调用若干 $CU(i, 2^i)$ 使得 $a_i = x^i$，IDFT 使得 $a_i = [i == b]$，然后 $QR$ 返回答案。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>FWT 是从小到大对每个 $i$ 做 $CR(i, i, M = \{\{1, 1\}, \{1, -1\}\})$（$M$ 还要乘上 $\frac{1}{\sqrt{2}}$。那，DFT/IDFT 又是啥？</p><p>考虑模拟 DFT：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(C *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">C <span class="title">W</span><span class="params">(<span class="built_in">cos</span>(Pi / i), op * <span class="built_in">sin</span>(Pi / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">C <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++, w = w * W) &#123;</span><br><span class="line">                C x = a[j + k], y = w * a[j + k + i];</span><br><span class="line">                a[j + k] = x + y, a[j + k + i] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 FFT 做了什么？</p><ul><li>二进制位翻转：把 $CU(i, 2^i)$ 变成 $CU(i, 2^{15 - i})$ 即可</li><li>观察它在第 $i$ 层做的事：<ol><li>对于第 $i$ 位为 $1$ 的位置 $j$ 乘上了 $\omega_{2^{i + 1}}^{j \mod 2^{i + 1}}$，分解 $j$ 为若干 $2^k$ 和，只有第 $i$、$k$ 位都为 $1$ 的位置才能乘上 $\omega_{2^{i + 1}}^{2^k}$，因此调用 $CR(i, i, \{\{1, 0\}, \{0, \omega_{2^{i + 1}}^{2^k}\}\})$</li><li>就是 FWT 操作，调用 $CR(i, i, M)$</li></ol></li></ul><p>最后虽然有 $(\frac{1}{\sqrt{2}})^n$ 的常数误差但对答案没有影响。</p><p>神，量子 yyds！太 nb 了这个题。</p><p>好像真的有什么「量子傅里叶逆变换」(quantum phase estimation algorithm)，天！量子计算机？</p><details>  <summary>code</summary>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unnamable.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; C;</span><br><span class="line">C v = <span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>), M[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;v, v&#125;, &#123;v, -v&#125;&#125;;</span><br><span class="line">C w[<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">  rep(i, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">    w[i] = C(<span class="built_in">cos</span>(pi), <span class="built_in">sin</span>(pi)), pi *= <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">C <span class="title">SOL</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  prew();</span><br><span class="line">  INI(<span class="number">16</span>);</span><br><span class="line">  <span class="comment">// FWT</span></span><br><span class="line">  rep(i, <span class="number">0</span>, <span class="number">15</span>) CR(i, i, M);</span><br><span class="line">  <span class="comment">// IDFT</span></span><br><span class="line">  rep(i, <span class="number">0</span>, <span class="number">15</span>) CU(i, <span class="number">1</span> &lt;&lt; (<span class="number">15</span> - i));</span><br><span class="line">  rep(i, <span class="number">0</span>, <span class="number">15</span>) &#123;</span><br><span class="line">    <span class="comment">// step 1</span></span><br><span class="line">    rep(j, <span class="number">0</span>, i - <span class="number">1</span>) &#123;</span><br><span class="line">      C dft[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">      dft[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, dft[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      dft[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, dft[<span class="number">1</span>][<span class="number">1</span>] = w[i - j];</span><br><span class="line">      CR(i, j, dft);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step 2</span></span><br><span class="line">    CR(i, i, M);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">65536</span> - QR();</span><br><span class="line">  C ret = <span class="number">1</span>;</span><br><span class="line">  rep(i, <span class="number">0</span>, <span class="number">15</span>) <span class="keyword">if</span> (ans &gt;&gt; i &amp; <span class="number">1</span>) ret = ret * w[<span class="number">15</span> - i];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="吐槽（雾"><a href="#吐槽（雾" class="headerlink" title="吐槽（雾"></a>吐槽（雾</h2><p>我真不会玩推理游戏 /px</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>300iq contest 3 vp 记录</title>
      <link href="2021/05/05/300iq%20contest%203%20vp%20%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/05/300iq%20contest%203%20vp%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102538" target="_blank" rel="noopener">任意ドア</a></p><p>靠 300iq 续命了嘤 ~</p><p><img src="/images/pengsoo.png" alt="pengsoo"></p><hr><p>upd: 这里是咕咕咕的题（以后有心情受虐的话会回来的 QwQ</p><p>D 杨表，咕了</p><p>A 大毒瘤题，咕了</p><p>G 码农（？）题，咕了</p><hr><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>叶子和非叶子可以匹配，叶子彼此不可以匹配，非叶子彼此可以匹配。</p><p><a href="https://codeforces.com/gym/102538/submission/115425562" target="_blank" rel="noopener">$Code$</a></p><h2 id="I"><a href="#I" class="headerlink" title="$I$"></a>$I$</h2><p>画个韦恩图容斥一下……</p><p><a href="https://codeforces.com/gym/102538/submission/115426814" target="_blank" rel="noopener">$Code$</a></p><h2 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h2><p>又是搬过的题</p><p>考虑第 $i$ 个怪物如果选择要它的胜点，空出来去打后面怪物的回合数为 $l_i$；如果不要它的胜点，空出的回合数为 $r_i$。</p><p>$l_i \leq r_i$, $l_i \geq -1$</p><p>设合法方案中第 $i$ 个怪物贡献的空出回合数为 $p_i$，合法条件是 $\forall i \in [1, n], \sum\limits_{j = 1}^i p_j \leq -1$（因为不可能和对手相差超过 $1$），最优方案就是最大化 $p_i = l_i$ 的数量</p><p>贪心，初始所有 $p_i = l_i$，从前往后做，若 $\sum p &lt; -1$ 就贪心选之前 $r_i - l_i$ 最大的若干个换上。</p><p><a href="https://codeforces.com/gym/102538/submission/115464421" target="_blank" rel="noopener">$Code$</a></p><h2 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h2><p>求，让每个点邻边和为 $5k$ 的方案数。</p><p>首先可以列出 $m$ 条边作为自变量的 $n$ 个方程</p><p>$ans = 5^{m - 基个数}$</p><p>首先分连通块算基个数。</p><ul><li>树：[点数] 个基</li><li>偶环：[点数 - 1] 个基</li><li>奇环：[点数] 个基</li></ul><p>那么我们得到结论：二分图基的个数为 [点数 - 1]，非二分图基的个数为 [点数]。</p><p><a href="https://codeforces.com/gym/102538/submission/115489590" target="_blank" rel="noopener">$Code$</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>注意到这是个 bash 博弈。SG 函数为 $sg(x) = x \mod (k + 1)$，其中 $k$ 为一次最多能取的个数。</p><p>那么就是对于 $k \in [1, n]$，求出 $\otimes_{i = 1}^{n} (a_i \mod (k + 1))$</p><p>枚举 $k$，枚举 $j \in [0, \lceil \frac{n}{k + 1} \rceil]$，当前区间 $a_i$ 的贡献拆位计算。</p><p>当前在问第 $w$ 位。那么就是问 $a_i - j$ 第 $w$ 位为 $1$ 的 $a_i$ 个数。</p><p>对 $2^{w + 1}$ 取模后形成若干 $[0, 2^w)$, $[2^w, 2^{w + 1})$ 的区间，我们要统计在后一个里的个数。</p><p>整块的预处理，零散的前缀和。</p><p>细节出乎意料的少（我好像很怕这种进制题，上次那道「梦中的题面」把人直接搞没了 qwq</p><p><a href="https://codeforces.com/gym/102538/submission/115501932" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p>首先只保留所有从 $(n, m)$ 出发能到达的点。</p><p>每次行走都会到达新的斜对角线，因此把这些空位按斜对角线分组。</p><p>若一条斜对角线上只有一个空位那可以和任意位置搭，若有多个空位那选择最边缘的两个，因为可以证明中间点能到达的后继点，至少能从两边点中的一端到达。</p><p>假设堵上最左的空位，我们考虑堵上右下哪条斜线的哪些点能堵死路径。</p><p>我们从次左和最右的空位出发，次左的尽量往下，最右的尽量往右，若有汇合则堵上汇合点就堵死了路径。</p><p>好神啊。</p><p>注意特判初始就不连通的方案，和取一条斜对角线上两个点的方案。</p><p><a href="https://codeforces.com/gym/102538/submission/115508760" target="_blank" rel="noopener">$Code$</a></p><h2 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h2><p>求问一个左部点向右部点前缀连边的二分图的简单环个数。</p><p>那么将 $a_i$ 升序排序后一个右部点向左部点后缀连边，有什么性质呢？</p><p>没有性质。看题解了。</p><p>线头 dp！！确实挺有道理……</p><p>考虑用左部点去合并以右部点为端点的段，所以要将 $a$ 升序排序</p><p>$f[i, j]$ 表示前 $i$ 个右部点形成了 $j$ 段的方案数</p><p>加入左部点会合并段，加入右部点会增加段。</p><p><a href="https://codeforces.com/gym/102538/submission/115513076" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>四种树的计数</title>
      <link href="2021/05/05/%E5%9B%9B%E7%A7%8D%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0/"/>
      <url>2021/05/05/%E5%9B%9B%E7%A7%8D%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>prufer、生成函数都是数树的利器。</p><p>prufer 真的超好用！！有标号树计数，不管怎么变，只要考虑在 prufer 序列中的出现情况就都能解决。</p><h2 id="有标号无根树"><a href="#有标号无根树" class="headerlink" title="有标号无根树"></a>有标号无根树</h2><p>Cayley 公式：完全图生成树个数为 $n^{n - 2}$</p><p>广义 Cayley 公式：$n$ 个有标号节点形成 $k$ 棵树，使得给定 $k$ 个点两两不在同一棵树中的方案数为 $k n^{n - k - 1}$（实际上没怎么懂这个东西，现推推也挺快的（<a href="https://www.luogu.com.cn/problem/CF1109D" target="_blank" rel="noopener">CF1109D</a>））</p><h2 id="有标号有根树"><a href="#有标号有根树" class="headerlink" title="有标号有根树"></a>有标号有根树</h2><p>$n^{n - 1}$</p><h2 id="无标号有根树"><a href="#无标号有根树" class="headerlink" title="无标号有根树"></a>无标号有根树</h2><p>设 $f_i$ 表示大小为 $i$ 的树的方案数，其生成函数为 $F(z) = \sum\limits_{i \geq 0} f_i z^i$，则</p><p>$$F(z) = z \prod\limits_{i \geq 0} (1 - z^i)^{-f_i}$$</p><p>取对数</p><p>$$\ln{F(z)} = \ln{z} + \sum\limits_{i \geq 0} \ln((1 - z^i)^{-f_i})$$</p><p>$$= \ln{z} - \sum\limits_{i \geq 0} f_i \ln(1 - z^i)$$</p><p>求导</p><p>$$\frac{F’(z)}{F(z)} = \frac{1}{z} + \sum\limits_{i \geq 0} f_i \frac{i z^{i - 1}}{1 - z^i}$$</p><p>化简</p><p>$$z F’(z) = F(z) + F(z) \sum\limits_{i \geq 0} f_i i \frac{z^i}{1 - z^i}$$</p><p>只看第 $n$ 项系数</p><p>$$n f_n = f_n + \sum\limits_{i = 1}^{n - 1} f_i  \sum\limits_j [j \mid n - i] f_j j$$</p><p>$$f_n = \frac{1}{n - 1}( \sum\limits_{i = 1}^{n - 1} f_i \sum\limits_j [j \mid n - i] f_j j )$$</p><p>可以用分治 NTT 解决。<del>假装我会吧，现在实在没心情写</del></p><h2 id="无标号无根树"><a href="#无标号无根树" class="headerlink" title="无标号无根树"></a>无标号无根树</h2><p>设 $g_i$ 表示无根树的方案，$f_i$ 同上。考虑无根树可以用重心表示，所以把不是重心的答案都减去。</p><p>$$h_n = f_n - \sum\limits_{i = 1}^{n / 2} f_i f_{n - i}$$</p><p>注意当 $n$ 为偶数时要特判，加上 $f_{n / 2}^2 - \binom{f_{n / 2}}{2}$。</p><hr><p>upd: 再更点 prufer 内容。</p><p>$n$ 个点的有标号无向图有 $k$ 个连通块，每个连通块大小为 $a_i$，要求添加 $k - 1$ 条边使其连通，方案数为 $n^{k - 2} \prod a_i$。证明就多元二项式定理 <del>（多项式定理）</del> 搞一搞。</p><h3 id="雅礼集训-共"><a href="#雅礼集训-共" class="headerlink" title="雅礼集训-共"></a><a href="https://loj.ac/p/6044" target="_blank" rel="noopener">雅礼集训-共</a></h3><p>树是个按深度奇偶分类的二分图。</p><p>那么相当于数左部点个数为 $k$ 的二分图个数。</p><p>组合数 + prufer（考虑最终 prufer 序列中两边点出现的次数）：$ans = \binom{n - 1}{k - 1} * k^{n - k - 1} * (n - k)^{k - 1}$</p><p><a href="https://loj.ac/s/1132200" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF1109D"><a href="#CF1109D" class="headerlink" title="$CF1109D$"></a><a href="https://www.luogu.com.cn/problem/CF1109D" target="_blank" rel="noopener">$CF1109D$</a></h3><p>枚举 $a$、$b$ 距离。生成树个数可以广义 Cayley 直接算，也可以推柿子。还是推一下：</p><p>当前链大小为 $i$。枚举链中元素在 prufer 序列中出现的次数 $k$。</p><p>$tree num = \sum\limits_{k = 0}^{n - i - 1} i^{k + 1} \binom{n - i - 1}{k} (n - i)^{n - i - 1 - k} = i * n^{n - i - 1}$</p><p><a href="https://codeforces.com/contest/1113/submission/115163710" target="_blank" rel="noopener">$Code$</a></p><h3 id="清训-生成树计数"><a href="#清训-生成树计数" class="headerlink" title="清训-生成树计数"></a><a href="https://uoj.ac/problem/335" target="_blank" rel="noopener">清训-生成树计数</a></h3><p>度数相关，考虑 prufer。</p><p>$c_i$ 表示 $i$ 在 prufer 序列中出现的次数。枚举序列长啥样，第 $i$ 块某次出现是其中哪个点连出去了。</p><p>$ans = (n - 2)! \prod a_i \prod\limits_{\sum c_i = n - 2} \frac{(c_i + 1^m a_i^{c_i})}{c_i!} ( \sum_i (c_i + 1)^m )$</p><p>$= (n - 2)! \prod a_i \sum\limits_{\sum c_i = n - 2} \frac{(c_i + 1)^{2m} a_i^{c_i}}{c_i!} \prod\limits_{j \neq i} \frac{(c_j + 1)^m a_j^{c_j}}{c_j!}$</p><p>EGF 出来了。</p><p>设 $A(x) = \sum_i \frac{(i + 1)^{2m}}{i!} x_i$, $B(x) = \sum_i \frac{(i + 1)^m}{i!} x_i$，<br>$ans = (n - 2)! \prod a_i [x^{n - 2}] \sum_i \frac{A(a_ix)}{B(a_ix)} \exp( \sum_j \ln( B(a_jx) ) )$</p><p>$\frac{A(x)}{B(x)}$ 和 $\ln(B(x))$ 是好求的，怎么带 $a$ 进去？</p><p>以 $\ln(B(a_jx))$ 为例，设 $B’ = \ln B$，$\sum_j B’(a_jx) = \sum_i B’_i \sum_j a_j^i$</p><p>$\sum_j a_j^i = [x^i] \sum_j \frac{1}{1 - a_jx}$，通分 + 分治求这个即可。</p><p><a href="https://loj.ac/s/1132571" target="_blank" rel="noopener">$Code$</a></p><h3 id="ARC106F-Figures"><a href="#ARC106F-Figures" class="headerlink" title="$ARC106F-Figures$"></a><a href="https://atcoder.jp/contests/arc106/tasks/arc106_f" target="_blank" rel="noopener">$ARC106F-Figures$</a></h3><p>size 超大，要求每个点只能最多连一次。</p><p>答案 EGF $F(x) = = \prod_i \sum\limits_{j \geq 0} \frac{P_{d_i}^{j + 1}}{j!} x^j$</p><p>$= \prod_i \sum\limits_{j \geq 0} x^j \frac{d_i!}{j!(d_i - j - 1)!}$</p><p>$= \prod_i d_i (x + 1)^{d_i - 1}$</p><p>乘起来算。</p><p>$ans = (n - 2)! [x^{n - 2}] F(x)$</p><p><a href="https://atcoder.jp/contests/arc106/submissions/22328820" target="_blank" rel="noopener">$Code$</a></p><h3 id="Cumulative-Code"><a href="#Cumulative-Code" class="headerlink" title="$Cumulative\ Code$"></a><a href="https://codeforces.com/gym/101620/problem/C" target="_blank" rel="noopener">$Cumulative\ Code$</a></h3><p><a href>$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> prufer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Lyndon &amp; run</title>
      <link href="2021/05/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Lyndon%20&amp;%20Runs/"/>
      <url>2021/05/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Lyndon%20&amp;%20Runs/</url>
      
        <content type="html"><![CDATA[<p>本文中所有字符串比大小都是以字典序为依据。</p><h2 id="Lyndon"><a href="#Lyndon" class="headerlink" title="Lyndon"></a><strong>Lyndon</strong></h2><h3 id="lyndon-串"><a href="#lyndon-串" class="headerlink" title="lyndon 串"></a>lyndon 串</h3><p>lyndon 串 s <strong>严格</strong>小于 s 所有后缀。设 $\mathcal{L}$ 表示所有 lyndon 串的集合。</p><p>若 $a &lt; b \in \mathcal{L}$，则 $ab \in \mathcal{L}$</p><h3 id="lyndon-分解"><a href="#lyndon-分解" class="headerlink" title="lyndon 分解"></a>lyndon 分解</h3><p>定义 $CFL(s)$ 是一个关于 $s$ 的划分，其将 $s$ 划分为 $w_1 w_2 \cdots w_k$，所有 $w_i$ 都是 lyndon 串，且 $w_i$ 字典序单调不增或单调不减。</p><p>$CFL(s)$ <strong>存在且唯一</strong>。</p><p>如何构造 $CFL(s)$？方法还是挺多的。</p><p>可以倒做，开个栈维护所有 lyndon 串，出现增时就合并，$O(n)$</p><p>还有一种 $O(n)$ Duval 算法：<a href="https://oi-wiki.org/string/lyndon/#duval" target="_blank" rel="noopener">see oi-wiki!</a></p><p><a href="https://loj.ac/s/1130822" target="_blank" rel="noopener">template(LOJ129)</a></p><h3 id="lyndon-array"><a href="#lyndon-array" class="headerlink" title="lyndon array"></a>lyndon array</h3><p>$L_i = \max\{j | s[i : j - 1] \in \mathcal{L}\}$</p><p>最长的 lyndon 子串不会相交，只会包含：$\forall i &lt; j &lt; L_i$, $L_j \leq L_i$</p><h3 id="关于后缀"><a href="#关于后缀" class="headerlink" title="关于后缀"></a>关于后缀</h3><p>$s[i : L_i - 1] &lt; s<a href="i &lt; j &lt; L_i">j : L_i - 1</a>$，所以 $suf(i) &lt; suf(j)$</p><p>设 $NSV(i)$ 为第一个不满足 $suf(i) &lt; suf(j)$ 的 $j$。$s[i : NSV(i) - 1] \in \mathcal{L}$，因此 $L_i = NSV(i)$。</p><h2 id="Runs"><a href="#Runs" class="headerlink" title="Runs"></a><strong>Runs</strong></h2><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>run 是一个三元组 $(l, r, p)$，满足 $p$ 是 $s[l : r]$ 的最小周期，且 $2p \leq r - l + 1$ 且 $s_{l - 1} \neq s_{l - 1 + p}$, $s_{r + 1} \neq s_{r + 1 - p}$（两边不可拓展）</p><p>实数 $\frac{r - l + 1}{p}$ 称为该 run 的指数。</p><p>本质是对极长严格周期串（$2p \leq |s|$）按照它们的最小周期分类。</p><h3 id="The-Runs-Theorem"><a href="#The-Runs-Theorem" class="headerlink" title="The Runs Theorem"></a>The Runs Theorem</h3><p>长度为 $n$ 的 run 个数 $&lt; n$，最大的指数和 $\leq 3n - 3$</p><h3 id="Run-的-lyndon-root"><a href="#Run-的-lyndon-root" class="headerlink" title="Run 的 lyndon root"></a>Run 的 lyndon root</h3><p>一个 run $(l, r, p)$ 的 lyndon root 是 $s[l : r]$ 的一个长为 $p$ 的 lyndon 子串。</p><p>每个 run 都有 lyndon root。</p><h3 id="通过-lyndon-root-求所有-runs"><a href="#通过-lyndon-root-求所有-runs" class="headerlink" title="通过 lyndon root 求所有 runs"></a>通过 lyndon root 求所有 runs</h3><p>把串 lyndon 分解，枚举 $i$，一段 lyndon root 必然是 $s[i : L_i - 1]$ 的子串。二分 + 哈希找到包含 $s[i : L_i - 1]$ 的极长循环子串 $s[l : r]$，若满足 runs 定义则找到了一个 run，$s[l : r]$ 可能被统计多次，取周期最小的一次。</p><p>对于 lyndon 分解两种情况（单调不增和单调不减）各求一遍 runs，并去重。</p><p><a href="https://loj.ac/s/1130842" target="_blank" rel="noopener">template(LOJ173)，代码超清真</a></p><h3 id="WPL-Weak-Periodicity-Lemma"><a href="#WPL-Weak-Periodicity-Lemma" class="headerlink" title="WPL (Weak Periodicity Lemma)"></a>WPL (Weak Periodicity Lemma)</h3><p>对于串 $s$，若 $p$ 和 $q$ 都是它的周期且 $p + q \leq |s|$ 则 $gcd(p, q)$ 也是 $s$ 的周期。</p><h3 id="lyndon-tree"><a href="#lyndon-tree" class="headerlink" title="lyndon tree"></a>lyndon tree</h3><h4 id="标准划分"><a href="#标准划分" class="headerlink" title="标准划分"></a>标准划分</h4><p>定义 lyndon 串 $s$ $(|s| \geq 2)$ 的标准划分是一个有序对 $(u, v)$ 满足 $v$ 是 $s$ 字典序最小的严格后缀，且 $s = \overline{uv}$。</p><h4 id="lyndon-tree-1"><a href="#lyndon-tree-1" class="headerlink" title="lyndon tree"></a>lyndon tree</h4><p>一棵二叉树，每个节点对应一个 lyndon 串，左右节点是自己的标准划分 $(u, v)$，根节点对应原串 $s$，叶节点对应串长为 $1$。</p><p>性质：</p><ol><li>若 $s[i : j]$ 是 lyndon 串，那么 $\alpha = lca([i : j]) = [i_{\alpha}, j_{\alpha}]$，满足 $i = i_{\alpha} \leq j \leq j_{\alpha}$</li><li>若 $s$ 是 $i$（$i &gt; 1$）开始的最长 lyndon 串，$\alpha$ 一定是个右儿子节点。（否则可以再拼上父亲的右儿子）</li></ol><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>runs 无法表出非严格周期串。</p><hr><p>闲话：字符串怎么这么多 theorem 啊 lemma 的啊…… 好难</p><hr><h3 id="集训队作业2018-串串划分"><a href="#集训队作业2018-串串划分" class="headerlink" title="集训队作业2018-串串划分"></a><a href="https://uoj.ac/problem/429" target="_blank" rel="noopener">集训队作业2018-串串划分</a></h3><p>……好吧是因为这题才来学 Runs 的。</p><p>两个限制没法一起做。</p><p>让每个非法划分里的循环串变成他们最小循环节分割开来的结果，那么不满足 1 变成了不满足 2。</p><p>考虑容斥，没有相同看作 $\sum_k (-1^k) * (至少有 k 个相同段的方案数)$</p><p>根据这个有 dp：$dp_i$ 表示以 $i$ 结尾的前缀的划分方案数。$dp_i = \sum_j (-1)^{C(s[j + 1 : i]) - 1} dp_j$，其中 $C(s)$ 表示 $s$ 串的最小循环节循环的次数。</p><p>$dp_i = \sum_j dp_j - 2 * \sum_j [ C(s[j + 1 : i] is even) ] dp_j$</p><p>引入本原平方串的概念：串 $s$ 是本原平方串，当且仅当其最小正周期为 $s/2$。任何字符串的本原平方串个数是 $O(nlogn)$ 的。</p><p>$C(s[j + 1 : i])$ 为偶数，当且仅当 $s[j + 1 : i]$ 由若干相同的本原平方串拼成。而一个本原平方串对应一个 runs。</p><p>求出所有 runs。</p><p>对于某个 runs $(l, r, p)$，$\forall i \in [l, l + 2p - 1]$, $s[i : i + 2p)$ 是本原平方串。</p><p>对于起点 $i$，设置所有 $i + k * 2p$ 为二元组 $(i, p)$ 的关键点。</p><p>对于每个二元组维护当前关键点 $f$ 之和。</p><p>$O(nlogn)$。</p><p><a href="https://uoj.ac/submission/474357" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Lyndon分解 </tag>
            
            <tag> run </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UR 做题记录</title>
      <link href="2021/05/03/UR%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/03/UR%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#6">UR 6</a></li><li><a href="#7">UR 7</a></li><li><a href="#14">UR 14</a></li><li><a href="#17">UR 17</a></li><li><a href="#19">UR 19</a></li><li><a href="#20">UR 20</a></li><li><a href="#21">UR 21</a></li></ul><h2 id="UR-6"><a href="#UR-6" class="headerlink" title="$UR$ $6$"></a><span id="6">$UR$ $6$</span></h2><h3 id="智商锁"><a href="#智商锁" class="headerlink" title="智商锁"></a>智商锁</h3><p>点数不超过 $100$ 的无向图，满足生成树个数模意义下为 $k$</p><p><del>看那个数据范围！$k$ 非常诡异！</del> 考虑构造一些图然后拿链把它们串起来使得方案数为它们各自的相乘，恰好为 $k$（很自然的想法）</p><p>……然后怎么做啊（虚弱）</p><p>膜题解</p><p>绝了！随机化 + 概率分析 + 数感！全是我不会的东西！！！</p><p>考虑生成 $1000$ 个点数为 $12$ 的图，从中任取 $4$ 个图串起来，矩阵树算出图的生成树个数</p><p>即 $f(G1)f(G2)f(G3)f(G4) \equiv k \pmod{998244353}$，可以预处理两两乘积，丢到 map 里</p><p>由于 $n^{n - 2} = 12^{10} &gt; 998244353$，取模后可以看作 $[0, 998244353)$ 的随机数</p><p>相当于我们有 $1000^{4} = 10^{12}$ 个随机数</p><p>$10^{12}$ 个随机数完全覆盖 $[0, 998244353)$ 的概率是多少？我们可以近似的看作 $10^9$ 个数需要被覆盖</p><p>实际上是 $1 - (1 - \frac{1}{10^9})^{10^{12}} \approx 1 - e^{-10^3}$，非常接近 $1$</p><p>后记：爆了 $17$ 发 OJ，一定是上天被感动了才放我过了 Extra Test【感动】一模一样的代码一遍 $70$ 一遍 $100$ 吐了呀</p><p><a href="https://uoj.ac/submission/471272" target="_blank" rel="noopener">$Code$</a></p><h3 id="懒癌"><a href="#懒癌" class="headerlink" title="懒癌"></a>懒癌</h3><p>以前写的，又不会做了 = = 神仙题！！！</p><p>根据完全图提示，开枪策略是假设我的狗没病，取 $time = \max\limits_{S \in 我看不到的集合}( S 开枪时间 )$，那么如果 $time$ 以前都没有开枪我就要在 $time + 1$ 开枪。</p><p>建出补图（即看不到关系组成的图）如果有病狗在环里，逻辑链条就永远不可能停止。否则缩点，DAG。</p><p>仔细思考上面 dp，可以构造解法：初始染黑一些点表示病狗，白的表示健康，每次选一个黑点染白，并将它的相邻点集的一个子集染黑，最终把整个图染白。这样的开枪时间为一度染黑过的点数，即所有黑点能到达的点数。这个过程和 dp 过程很类似 <del>（根本就不是人类能想到的吧！）</del> 证明可以考虑归纳。</p><p>显然最优策略是每次染全部相邻点，这样才能最大化到达的点数。</p><p>为什么这就是最小开枪时间？（一旦有人开枪就停止）因为这是 DAG，一定有黑点处在不可被其他黑点到达的位置，这些黑点就是开枪的点，即从他们出发得到最小开枪时间（这个只能从逻辑上理解了……）第二问就很好回答了，每个点 $x$ 对答案的贡献就是 $2^{n - 可以到达 x 的点数}$</p><p>第一问也是考虑每个点被到达，对答案的贡献。如果 $x$ 能被 $i$ 个点到达，方案数就是 $(2^i - 1) * 2^{n - i}$。</p><p><a href="https://uoj.ac/submission/439195" target="_blank" rel="noopener">ε-(´∀｀; )</a></p><h2 id="UR-7"><a href="#UR-7" class="headerlink" title="$UR$ $7$"></a><span id="7">$UR$ $7$</span></h2><p><a href="https://uoj.ac/contest/10" target="_blank" rel="noopener">Jump!</a></p><h3 id="水题走四方"><a href="#水题走四方" class="headerlink" title="水题走四方"></a>水题走四方</h3><p>不妨看作只有分身在瞬移。那么本体走的是一条通到叶子的链。</p><p>记录 $sd[x]$ 表示 $x$ 子树的叶子深度和，$num[x]$ 表示 $x$ 子树的叶子个数。路径上有若干个关键点，是本体可能会停的点。</p><p>考虑 dp。设上个关键点为 $u$，当前关键点为 $v$。</p><p>若分身走的最后一个叶子的深度 $&lt; dep[v]$，那么到达叶子后就可以瞬移并和本体一起走到 $v$。这样 $v$ 显然不是关键点，因为瞬移回来的那个才是。</p><p>设 $md[u, v]$ 表示 $u$ 到 $v$ 路径上（不包括 $v$）所有延伸子树的叶子深度 max。</p><p>这样对于 $v$ 就只要考虑 $md[u, v] \geq dep[v]$ 的 $u$ 作为上一个关键点，并且 $md[u, v]$ 对应的叶子出现在 $u$ 这个节点的延伸子树里。</p><p>若 $v$ 有俩祖先都可以作为关键点，那必然是两者一起成为关键点最不劣。因此要求最深的 $u$ 满足 $md[u, v] \geq dep[v]$，设为 $fr[v]$</p><p>考虑长剖，从下往上做，维护还未找到 $fr$ 的点的链表，每次合并俩子树的链表，长儿子所在的子树一定不为空，而另一子树一定空，因此复杂度 $O(n)$。</p><p><a href="https://uoj.ac/submission/474445" target="_blank" rel="noopener">$Code$</a></p><h2 id="UR-14"><a href="#UR-14" class="headerlink" title="$UR$ $14$"></a><span id="14">$UR$ $14$</span></h2><p><a href="https://uoj.ac/contest/28" target="_blank" rel="noopener">Jump!</a></p><h3 id="最强跳蚤"><a href="#最强跳蚤" class="headerlink" title="最强跳蚤"></a>最强跳蚤</h3><p>我们只关注每种质因子能否抵消干净，这个用 bitset 大材小用了，只要给每个质因子分配一个 $[0, 2^64]$ 的权值即可。不出错的概率是 $(1 - \frac{1}{2^{64}})^{\binom{100000}{2}} \approx 0.99999999973$</p><p>惨遭 Extra Test 卡常，一通 registeR$ int、inline 后艹过去了……</p><p><a href="https://uoj.ac/submission/469536" target="_blank" rel="noopener">$Code$</a></p><h3 id="人类补完计划"><a href="#人类补完计划" class="headerlink" title="人类补完计划"></a>人类补完计划</h3><p>以前写的。</p><p>要求的就是所有基环树中 $2$ 的「非叶节点的个数」次方。</p><p>给这个 $2$ 赋予实际意义：基环树上点黑白染色的方案数，其中叶子只能染白。</p><p>设 $h(s)$ 表示点集 $s$ 构成的基环树个数。</p><p>枚举染成了黑色的不合法点集合 $t$，容斥：</p><p>$ans_s = \sum_{t \subset s} (-1)^{|t|} 2^{|s - t|} <em> h[s - t] </em> [t 向 s - t 中的点连边的方案数]$</p><p>考虑 $h(s)$ 怎么求？仅有一个环很好求，叶子数 $\geq 1$ 的方案数就状压 + 容斥求。</p><p><a href="https://uoj.ac/submission/469705" target="_blank" rel="noopener">$Code$</a></p><h3 id="思考熊"><a href="#思考熊" class="headerlink" title="思考熊"></a>思考熊</h3><p>题意：插入、删除点，询问点 $x$ 到一个区间的点的最大距离，要求强制在线。</p><p>权值为正：</p><ul><li>线段树维护点集直径就行了。</li></ul><p>权值可以为负：</p><ul><li>就只能建虚树处理每个点集中的节点到子树内和子树外最大距离。虚树合并只能重建。</li></ul><p>没有删除：</p><ul><li>二进制分组，合并就两遍 dfs 合并虚树。</li><li>因为要查询区间，所以合并时要新建点指向被合并的区间，查询就像线段树那样，空间是 $O(nlogn)$。</li></ul><p>带删除：</p><ul><li>类 $Unknown 做法！就是，这一层的下个区间插满了，就合并当前区间。<ul><li>删除时，给当前块打标记表示信息错误，$O(1)$。</li><li>插入时，当前块打标记，如果插满了就看同层前驱块有没有标记，有就重建前驱块。第 $i$ 层重建一个块的复杂度是 $O(i 2^i)$，均摊分析第 $i$ 层总复杂度 $O(ni)$，求和是 $O(nlog^2n)$。</li><li>查询时，碰到标记区间就要递归下去。一个块最多查询 $log$ 次所以 $O(log^2n)$。</li></ul></li></ul><p>惨遭 Extra Test 卡空间，竟严苛到个位，大无语事件。</p><p><a href="https://uoj.ac/submission/469677" target="_blank" rel="noopener">$Code$</a></p><h2 id="UR-17"><a href="#UR-17" class="headerlink" title="$UR$ $17$"></a><span id="17">$UR$ $17$</span></h2><p><a href="https://uoj.ac/contest/43" target="_blank" rel="noopener">Jump!</a></p><h4 id="T1"><a href="#T1" class="headerlink" title="$T1$"></a>$T1$</h4><p>题目看错了！是前缀 and！</p><p>显然最终一定是链，挂在链的最下方肯定比挂在之前的某个节点下优。</p><p>$f_S = \min( f_{S \&amp; a_i} + (S \&amp; a_i) )$</p><p>然而每次减少正整数个位，而且一个 $a_i$ 不会被 $\&amp;$ 两次，想到枚举子集，预处理哪些子集可以被减掉。虽然也很爆炸但总比 $O(nA)$ 好。</p><p>要剪枝！就nm滑稽！</p><p><a href="https://uoj.ac/submission/465235" target="_blank" rel="noopener">$Code$</a></p><h4 id="T2"><a href="#T2" class="headerlink" title="$T2$"></a>$T2$</h4><p>二分。怎么判定？</p><p>幸好这是直的，所以一个人的轨迹固定，另一个人就是单调的。设 $(x, y)$ 表示一个人在点 $x$，另一个在点 $y$ 的状态，$(x1, y1)$ 和 $(x2, y2)$ 可达当且仅当两人的距离都 $\leq lim$。$f_{x, y}$ 表示状态 $x$ 是否合法，从 $(stx, sty)$ 开始跑 bfs 就行了？</p><p>但是有可能一个人为了配合另一个人而同时移动诶！GG</p><p>冷静思考。准确来说应该是如果两个状态中两人所在的边都相同。<del>你不会让 $f_{x, y}$ 表示一个人在边 $x$，另一个在边 $y$ 吧？很难转移的。</del></p><p>$f_{x, y}$ 表示一个人在点 $x$，另一个在边 $y$ 上距离点 $x$ 最近的位置。讨论是谁在配合谁，转移分两种：</p><ol><li>第一个人从 $x$ 走到相邻边，为了配合第二个人走到 $y$ 的某个端点。</li><li>第二个人仍旧在 $y$ 上走，为了配合第一个人从 $x$ 走到相邻点。</li></ol><p><a href="https://uoj.ac/submission/465324" target="_blank" rel="noopener">$Code$</a></p><h4 id="T3"><a href="#T3" class="headerlink" title="$T3$"></a>$T3$</h4><p>完全不会啦……</p><script type="math/tex; mode=display">ans = \int_0^2 Pr[\lambda = x]x dx = 2 - \int_0^2 Pr[\lambda \leq x] dx</script><p>考虑如何求 $Pr[\lambda \leq x]$。设 $g(s, x, t)$ 表示点集 $s$ 点权最大值 $\leq x$，$\max(点权最大值，边权最大值) \leq t$ 的概率。</p><ul><li>若点权都 $\leq \frac{t}{2}$ 则概率就是 $(\frac{t}{2})^{|s|}$</li><li>否则最大点权 $&gt; \frac{t}{2}$，考虑扣掉最大点权的点和与它直接相连的点集，不会和剩下的点矛盾。（为什么？）</li></ul><script type="math/tex; mode=display">g(s, x, t) = (\frac{t}{2})^{|s|} + \sum\limits_{i \in s} \int_{\frac{t}{2}}^x g(s', y, t) (t - y)^{|s| - |s'| - 1} dy</script><p>$s’$ 表示从 $s$ 中扣掉「最大点权的点和与它直接相连的点集」后的集合。</p><p>$g(s, x, t)$ 其实是个关于 $x$ 和 $t$ 的二元生成函数。那怎么求啊？？</p><p>我们发现每一项 $x^i t^j$ 都满足 $i + j = |s|$（积分后项数加一），那么把 $x$ 当作主变量就好啦（就是把 $t^k$ 看作 $x^{n - k}$）。</p><p>上面那个柿子，$\int$ 有下界，怎么办？$t$ 被视为常数啦，所以 $y \leq \frac{t}{2}$ 的贡献就从常数项里减掉。</p><p>最终答案里 $x$ 只要不超过 $t$ 即可，因此：</p><script type="math/tex; mode=display">ans = 2 - \int_0^2 g(all, min(1, t), t) dt = 2 - \int_0^1 g(all, t, t) dt - \int_1^2 g(all, 1, t) dt</script><p>这时把 $t$ 当成主变量，那么把形式幂级数 reverse 一下就可以了~</p><p><del>xml 弱弱问道：怎么算微积分……</del></p><p><del>$\mathscr{Naive}$！求导 + 积分啊</del></p><p>实现细节：不同连通块分别做然后乘起来，可以大大减小状态数。</p><p><a href="https://uoj.ac/problem/372" target="_blank" rel="noopener"><del>跑的贼啦快的</del>代码</a></p><h2 id="UR-19"><a href="#UR-19" class="headerlink" title="$UR$ $19$"></a><span id="19">$UR$ $19$</span></h2><h3 id="清扫银河"><a href="#清扫银河" class="headerlink" title="清扫银河"></a>清扫银河</h3><p>以前做的，题解也是以前写的，现在看看好简单嘛！ε-(´∀｀; )</p><p>若有解则必然可以在 $m + 1$ 次操作里出解。</p><ul><li>证明：首先要知道一个性质：无向图的任何环都可以由若干个非树边覆盖的环异或得到。也就是说有用的操作一只有 $m - n + 1$ 个。而操作二等价于每次选一个点，将与这个点相邻的边全部反转，也就是说有用的操作二有 $n$ 个。<br>总共操作数为 $m + 1$ 个，解异或方程组，必然可以在 $m + 1$ 次操作里出解，况且多个操作二还可以合成一个呢。</li></ul><p>直接做 $O(m^3 / 32)$，考虑优化。</p><p>将所有 $1$ 边形成的图称为目标子图。根据<strong>欧拉回路</strong>的知识，若目标子图中每个节点的度数都是偶数，则必然可以通过不超过 $m - n + 1$ 次操作一将边权都变成 $0$。</p><p>因此只要考虑，仅用操作二能否让目标子图中每个节点度数变成偶数。这样是 $O(n^3 / 32)$ 的。</p><p>异或什么的想想方程组啊，，，虽然暴力，但到底是个切入口。不过后续就需要找性质了。</p><p>正式做题时，逆推回去比较好：环上点的度数都是偶数…所以blabla</p><p><a href="https://uoj.ac/submission/415536" target="_blank" rel="noopener">$Code$</a></p><h3 id="通用测评号"><a href="#通用测评号" class="headerlink" title="通用测评号"></a>通用测评号</h3><p>读清题啊，添加燃料是无限的，加加加直到全员达到 $b$，所以转化题意为：到 $a$ 的舱也可以选，求达到 $a$ 舱个数的期望</p><p>又发现每个舱都是相同的，我们只要考虑 $1$ 舱在全员达到 $b$ 前达到 $a$ 的概率然后乘 $n$。</p><p>和猎人杀有点像，现在我们<strong>只关注</strong> $1$ 舱是否到 $a$，所有非 $1$ 舱是否全到 $b$，有用的操作序列长度仅为 $b(n - 1) + a$，给已经到 $b$ 的非 $1$ 舱 $+1$ 的操作可以忽视。</p><p>相当于现在要求 $b(n - 1) + a$ 项中最后一项给 $1$ 舱的概率（忽视操作乘给概率的贡献为 $1$）</p><p>设 $n - 1$ 个非 $1$ 舱到 $b$ 的时间分别为 $t_1, \cdots, t_{n - 1}$</p><p>概率 = 方案数 / 总数：</p><script type="math/tex; mode=display">P = \frac{ \prod\limits_{i = 1}^{n - 1} \binom{t_i - 1 - (i - 1)b}{b - 1} }{ \prod\limits_{i = 1}^{n - 1} (n - i + 1)^{t_i - t_{i - 1}} }</script><p>根据上柿 dp, dp 当然要一步步来啦，每步都乘分母那玩意，换阶段了乘分子那玩意，$dp_{i, j}$ 表示到 $i$ 时间，有 $j$ 种非 $1$ 舱到 $b$ 了，$O(n^3)$。</p><p><a href="https://uoj.ac/submission/467148" target="_blank" rel="noopener">$Code$</a></p><p>生成函数也能做到 $O(n^3)$，口胡一波？</p><p>设 $F(x) = \sum\limits_{i = 0}^{b - 1} \frac{x^i}{i!}$，</p><p>答案生成函数 $= \frac{x^{a - 1}}{(a - 1)!} \sum\limits_{i = 1}^{n - 1} \binom{n - 1}{i} F^i(x) ( e^x - F(x) )^{n - 1 - i}$</p><p>我们要求 $F^i(x)$。</p><p>$F’(x) = F(x) - \frac{x^{b - 1}}{(b - 1)!}$（正常求导……）</p><p>设 $G_k(x) = F^k(x)$，</p><p>$G_k’(x) = kF^{k - 1}(x) F’(x)$（归纳证明），$= kG_{k}(x) - k \frac{x^{b - 1}}{(b - 1)!} F^{k - 1}(x)$，积分，就可以递推啦。预处理 $e^x - F(x)$。</p><h3 id="前进四"><a href="#前进四" class="headerlink" title="前进四"></a>前进四</h3><p>画出图来嘛。每个操作在时间线段树上影响的都是一段区间。</p><p>由于是后缀 $\min$，考虑从后往前维护时间线段树，支持区间取 $\min$（sgt beats 即可）</p><p>应对询问，相当于最后单点询问时间线段树上某个位置被取 $\min$ 的次数。想不到吧这个可以在 sgt beats 区间取 $\min$ 的时候一并维护！</p><p>具体来说，设 $mx’[x]$ 表示新的 $mx[x]$，修改最大值时打标记，如果 $mx’[x] &lt; mx[ls]$ 或 $&lt; mx[rs]$ 就下传。</p><p>什么这样不会出现 $x$ 节点的标记不对下传节点 $y$ 起效而多算的情况嘛？</p><p>不会的。我们分讨说明：</p><p>首先既然是累计了好多次标记一次性下传说明 $se[x]$ 没有改动。$mx[x] &gt; mx’[x] &gt; se[x]$。</p><ol><li>$se[x] \geq mx[y]$：$y$ 不可能是下传节点。</li><li>$se[x] &lt; mx[y]$：$mx[x] = mx[y]$!!!</li></ol><p>（智障问题++）</p><p><a href="https://uoj.ac/submission/467205" target="_blank" rel="noopener">$Code$</a></p><h2 id="UR-20"><a href="#UR-20" class="headerlink" title="$UR$ $20$"></a><span id="20">$UR$ $20$</span></h2><p>切了签到题，上分了 _QAQ_</p><h3 id="跳蚤电话"><a href="#跳蚤电话" class="headerlink" title="跳蚤电话"></a>跳蚤电话</h3><p>方案合法的充要条件是新加点和任意已选点的 LCA 都已选，我们将其称为「和谐」。直接做不好搞，考虑 dp——类似分治思想，只要保证 $x$ 的每个子树都和谐，dp 的时候再维护一下就能让 $x$ 的子树和谐了。</p><p>怎么维护？具体来说有两种情况：</p><ol><li>选 x 再任意排子树</li><li>选一个子树任意排，再选 x，剩下的子树任意排</li></ol><p>这样就不会出现「选择不同子树的点，$x$ 作为它们的 LCA 没有被选」的情况了。</p><p><a href="https://uoj.ac/submission/466646" target="_blank" rel="noopener">$Code$</a></p><h3 id="机器蚤分组"><a href="#机器蚤分组" class="headerlink" title="机器蚤分组"></a>机器蚤分组</h3><p>最小链覆盖 = 最长反链。</p><p>结论1. $最长反链 = \max\limits_{len}( 长度为 len 的不同子串数量 )$</p><ul><li>证明考虑末尾为 $len$ 的最长反链，其中比 $len$ 长的子串可以截，长度为 $len$ 的子串可以移动，最后能调整成一个全为 $len$ 的反链。对每个反链都这么搞，对应的是上面的取 $max$ 操作。</li></ul><p>结论2. $最长反链 \geq k$ 当且仅当长度为 $n - k + 1$ 的串两两不同。</p><ul><li>充分性显然。</li><li>必要性：反证，假设存在两个长度为 $n - k + 1$ 的串相同。考虑长度为 $len$ 的不同子串数量，首先 $len \leq n - k + 1$，其次「长度为 $len$ 的不同子串数量」$\leq n - len + 1 - (n - k + 1 - len + 1) = k - 1$（一个小放缩？），即 $max &lt; k$，矛盾。</li></ul><p>我们要求的是最长反链，即 $k_{max}$。$(n - k + 1)_{min} = \max\limits_{1 \leq i &lt; j \leq |S|}( lcp(S[i, ], S[j, ]) ) + 1$，那么 $k_{max} = |S| - \max\limits_{1 \leq i &lt; j \leq |S|}( lcp(S[i, ], S[j, ]) )$，用 SAM 或 SA 即可计算单组询问，$O(nQ)$。</p><p>要优化就只有离线或者 LCT 了。我选择离线 _QAQ_</p><p>后缀树上启发式合并 endpos 集合，每次合并两个子树的时候把合法对提取出来，最后来个二维数点。提取合法对是 hhz 讲过的套路，由于任意不同子树的对在合并时的贡献都是合并点的 $len$，我们只要挨最近的对，每次是 $O(size_{min})$ 对，总共就是 $O(nlogn)$ 对。</p><p>坑点：4 1 caca 1 3 这样的数据告诉你要考虑「第二个串截一半」的情况。</p><p>不需要考虑「第一个串截一半」的情况，因为那样意味着更短的 lcp，归其他对管。</p><p>具体实现可以搞个备选堆，当前弹掉了就从备选堆里选一个补上。</p><p><a href="https://uoj.ac/submission/467115" target="_blank" rel="noopener">$Code$</a></p><p><del>想补 LCT 做法</del></p><h3 id="金坷垃"><a href="#金坷垃" class="headerlink" title="金坷垃"></a>金坷垃</h3><p>咕了，题解看一半看不下去了 /哭</p><p>直接做肯定没法做，考虑贡献拆分：$ans_k = \int Pr[第 k 小的数 \geq x] dx$</p><p>设 $Pr[第 k 小的数 \geq x]$ 为 $F_k(x)$。</p><p>枚举 $k - 1$ 个比第 $k$ 小数小的。</p><p>$f_k(x) = \sum\limits_{|s| = k - 1} \prod\limits_{j \in s} Pr[val_j &lt; x] \prod\limits_{j \notin s} (1 - Pr[val_j &lt; x])$</p><p>$Pr[val_j &lt; x] = \frac{x - val_j}{m}$ 是分段函数，因此 $F_k(x)$ 是分段多项式</p><p>设 $g_k(x) = \sum\limits_{|s| = k - 1} \prod\limits_{j \in s} Pr[val_j &lt; x]$</p><p>考虑实际意义：$f_k$ 是恰好 $k$ 个，$g_k$ 是只管 $k$ 个，$g_k = \sum_i \binom{k}{i} f_i$，求出 $g$ 再二项式反演即可得到 $f$</p><p>设 $G$ 为 $g$ 的生成函数</p><p><a href="https://blog.csdn.net/weixin_34746495/article/details/112767446" target="_blank" rel="noopener">函数乘积的高阶导数，就是将求导分配到每个乘积里</a></p><h2 id="UR-21"><a href="#UR-21" class="headerlink" title="$UR$ $21$"></a><span id="21">$UR$ $21$</span></h2><h3 id="挑战最大团"><a href="#挑战最大团" class="headerlink" title="挑战最大团"></a>挑战最大团</h3><p>题意：快速统计每个大小的完全子图数量。优美图有性质：不存在一个大小为 $4$ 的点集的生成子图是链。</p><p>这种全求出来的题考虑生成函数，OGF。</p><p>这个优美图有性质：原图和补图的连通性相反。</p><ul><li>原图不连通：答案 OGF 为各个连通块 OGF 相加。</li><li>原图连通：补图不连通，答案 OGF 为补图每个连通块在原图中的 OGF 相乘。</li></ul><p>难点在于划分连通块时决定走原图还是补图。原图是个稠密图，共 $n^2$ 条边，直接做最坏复杂度 $O(n^3)$。</p><p>定义图的直径为两两之间距离的最大值，距离是最短长度。显然优美图的直径仅为 $2$，也就是说 BFS 两层即可！</p><p>如果选一个度数为 $d$ 的点开始 BFS，第一层每个节点需要 $n$ 的代价扩展到第二层，所以这部分是 $O(dn)$</p><p>从原图和补图各选度数最小的为起点，同时开始扩展，$O(min(d_1, d_2)n)$ 即可确定哪个不连通。</p><p>来分析这个复杂度为什么正确。</p><p>设 $min(d_1, d_2) = S$，$n - S = T$，显然 $S \leq T$</p><p>被分出来的那个连通块大小为 $S + 1$（<strong>这也是这个划分策略基于的性质</strong>），因此 $min(d_1, d_2)n = O(Sn) = O(S^2 + ST) = O(ST)$，也就是说划分出大小为 $S$ 和 $T$ 的两个连通块的代价为 $O(ST)$。</p><p>一切都很明朗了，这就和树上背包合并 $O(n^2)$ 一个道理。</p><p><a href="https://uoj.ac/submission/483463" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EC Final 2019 vp 记录</title>
      <link href="2021/05/01/EC%20Final%202019%20vp%20%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/01/EC%20Final%202019%20vp%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102471" target="_blank" rel="noopener">Jump!</a></p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><p>签到题，跳</p><p><a href="https://codeforces.com/gym/102471/submission/114744542" target="_blank" rel="noopener">$Code$</a></p><h2 id="M"><a href="#M" class="headerlink" title="$M$"></a>$M$</h2><p>还是签到题，每类分别枚举，复杂度就是对的。</p><p>完球了降智太严重，直接写偏一次，long long 没开又 WA 一次，手写 out() 挂掉了 WA 一次。</p><p><a href="https://codeforces.com/gym/102471/submission/114747010" target="_blank" rel="noopener">$Code$</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>操作：一对边，流量一个减 $1$、一个加 $1$，询问使得流量最大的最小操作数。图的性质是，从 $1$ 到 $n$ 有 $k$ 条等长的除端点外不相交路径。</p><p><del>xml 这个憨憨竟然以为每条路径的流量都一样</del></p><p>最大流量 $= tot / (m / k)$</p><p>对于每条路径，发现移动到这条路径的代价是关于这条路径最终流量的分段函数，并且斜率越来越大。证明显然。</p><p>于是只要每次贪心选当前斜率最小的路径即可。</p><p>分段函数可以预处理。</p><p>一开始把每个分段函数用 vector 维护，再拿指针指着，疯狂 RE + WA，后来把分段函数全都丢进 pq 反倒没有问题。果然我是 STL 黑洞。</p><p><a href="https://codeforces.com/gym/102471/submission/114771242" target="_blank" rel="noopener">$Code$</a></p><hr><p>完球了 只会三道</p><p>我只会做题解不超过三句话的 sb 题。我是不是完球了！！！！！！！</p><hr><h2 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h2><p>瞧这奇怪的回答方式，必有蹊qī跷qiao <del>（woc我一直读xī，然后就一直打不出来拼音</del></p><p>一个长度大于等于 $n/2$ 的等比数列，相邻项在实际坐标中，不超过 $2$ 的距离有至少 $n/4$ 对！</p><p>对于每种出现次数合法的公比，分别做最长序列。</p><p><a href="https://codeforces.com/gym/102471/submission/114778591" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p>还能这么耍？$f^k = g$, 因为 $f^{mod} = \epsilon$（不会证明……）所以 $g^{1/k} = f$，直接狄利克雷卷积快速幂就好了。$O(nlog^2n)$</p><p>看了看，还有一种方法是巧妙的倍增递推：<a href="https://blog.csdn.net/weixin_40859716/article/details/108881309" target="_blank" rel="noopener">点我</a></p><p>模数写错了 WA 好几发。wcnm！！！</p><p><a href="https://codeforces.com/gym/102471/submission/114812824" target="_blank" rel="noopener">$Code$</a></p><h2 id="K"><a href="#K" class="headerlink" title="$K$"></a>$K$</h2><p>平面图最大流转最小割转对偶图最短路。</p><p>考虑与最外面相邻的边，设其中权值最小的为 $e$，$e$ 靠里那一面会被经过 $0$ 次或 $2$ 次，$2$ 次就一定经过 $e$。于是干脆把 $e$ 的权值分到这个面其他边上，$e$ 消失——用堆维护上述过程，每次除一个环，最终得到一棵树。</p><p>再回到平面图最小割的角度看，类 kruskal 重构树的维护一棵最小割树就可以了。</p><p><a href="https://codeforces.com/gym/102471/submission/114813921" target="_blank" rel="noopener">$Code$</a></p><h2 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h2><p>显然最小值的位置永远不动。但这个性质太弱了。</p><p>性质：</p><p>对于某个最小值所在的 $i$，若 $minpos_{[1, i - 1]} \in [i - c, i - 1]$，$[i - 2c, i - 1]$ 在满足 $minpos_{[i - 2c, i - 1]} \in [i - c, i - 1]$ 的情况下可以随意排列。（把 $minpos$ 放到 $i - k(k \in [1, c]$，随意换，然后再以 $i$ 为 $minpos$ 随意换，这样就能把 $[i - 2c, i - c - 1]$ 的元素搞过来了）</p><p>同理若 $sempos_{[1, i - 1]} \in [i - c, i - 1]$，$[i - 3c, i - 1]$ 在满足 $sempos_{[i - 3c, i - 1]} \in [i - 2c, i - 1]$ 的情况下可以随意排列。</p><p>以此类推。</p><p>于是我们得到了一个递归解法：$solve(L, R, vl, vr)$，表示从小到大考虑，靠左侧有 $vl$ 个，靠右侧有 $vr$ 个</p><ul><li>若 $(vl + vr) * c &gt; R - L + 1$ 那么剩下的数可以在 $R - L + 1$ 中随便放，大概有点「管辖」的意味。</li><li>否则考虑考虑当前区间未放的最小数字在 $k$，$k$ 最多只能被一侧管辖（否则就是前面那种情况啊）<ul><li>如果能被管辖，递归到管辖它的那边继续做</li><li>否则返回 $solve(L, k - 1, vl, 1) * solve(k + 1, R, 1, vr)$</li></ul></li></ul><p><a href="https://codeforces.com/gym/102471/submission/114816185" target="_blank" rel="noopener">$Code$</a></p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><p>要求遍历一棵树的出发时间最晚。每个点要恰好施魔法一次。$a \rightarrow b$ 当且仅当 $t_a &gt; 0$ 且 $t_b \geq 0$</p><p>由于最终的路径一定是走完整个子树，或者还差一段。设 $f_x$、$g_x$ 分别表示前者和后者的最晚进入时间。</p><p>假设我们已经求出了每个儿子的信息。</p><p>假设遍历 $x$ 所有儿子子树的顺序是 $y_1, \cdots, y_k$，我们要一种最优的 $y_i$ 排列使得 $f_x$ 最大。</p><p>$f_x = \min\limits_{i = 1}^k ( f_{y_i} - \sum\limits_{j &lt; i} 2size_{y_j} )$</p><p>微扰一下，猜测按照 $f_{y_i} + 2size_{y_i}$ 升序排列。感性理解这是对的。</p><p>计算 $g$ 需要枚举走到哪个子树里停住了。前后缀维护一下，计算与 $f$ 类似。</p><p><a href="https://codeforces.com/gym/102471/submission/114824781" target="_blank" rel="noopener">$Code$</a></p><h2 id="L"><a href="#L" class="headerlink" title="$L$"></a>$L$</h2><p>问选两条路径，不重复覆盖一个点超过 $k$ 次的方案数。$k \leq 1e9$。</p><p>不会，咕了</p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>假设当前 $a - b = x$</p><p>一次走一步没法判断 $x$ 的变化，考虑一次走两步</p><ol><li>👆👆</li><li>👉👉</li><li>👆👉</li><li>👉👆</li></ol><p>$1$ 和 $2$ 对 $x$ 和横纵坐标的奇偶性无影响，$3$ 和 $4$ 则对这俩都有影响</p><p>枚举 $3 + 4$ 的个数 $p$，$4$ 的个数 $q$</p><p>有关系柿: $\lfloor \frac{p + 1}{2} \rfloor - q = k$，因为只有在纵坐标为偶数的时候走 $3$ 才 $+1$，</p><p>那么枚举 $p$，贡献是 $\binom{(n + m)/2}{p} * \binom{p}{q} * \binom{(n + m)/2 - p}{(n - p)/2}$</p><p><a href="https://codeforces.com/gym/102471/submission/114830195" target="_blank" rel="noopener">$Code$</a></p><p>剩下几道奇怪的模拟、计算几何、随机化，咕了咕了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21Apr 训练日志（退役冲刺实录）</title>
      <link href="2021/04/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Apr%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97%EF%BC%88%E9%80%80%E5%BD%B9%E5%86%B2%E5%88%BA%E5%AE%9E%E5%BD%95%EF%BC%89/"/>
      <url>2021/04/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Apr%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97%EF%BC%88%E9%80%80%E5%BD%B9%E5%86%B2%E5%88%BA%E5%AE%9E%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>300iq contest 2 vp 记录</title>
      <link href="2021/04/28/300iq%20contest%202%20vp%20%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/28/300iq%20contest%202%20vp%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102331" target="_blank" rel="noopener">Jump!</a></p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><p>看完题目头皮发麻，这啥啊！</p><p>咕了。</p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>结论：$c &lt; b &lt; a$, $a \otimes b \geq x$, $b \otimes c \geq x$，那么 $a \otimes c \geq x$。</p><p>设 $b$ 与 $c$ 不同在第 $i$ 位，$b_i = 1$, $c_i = 0$</p><ul><li>$a_i = 1$：$a \otimes c &gt; a \otimes b$ 显然；</li><li>$a_i = 0$：则前面位必有位置 $j$ 满足 $a_j &gt; b_j = c_j$，而 $b \otimes c \geq x$ !!! $b$ 和 $c$ 从当前位异或为 $1$ 开始就 $\geq x$ 了你 $a$ 和 $c$ 在之前位异或为 $1$ 了当然 $\geq x$。</li></ul><p>有传递性就好做了。trie 上卡位。</p><p><a href="https://codeforces.com/gym/102331/submission/114441081" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p>将一条边也看作环，仙人掌就是许多环拼在一起。</p><p>凭借 xza 模拟赛教育过你的 exp 知识，应该可以轻松 AC 此题（划掉）。</p><p>从小到大枚举每个点，把包含它的环拼起来</p><p><a href="https://loj.ac/s/1127846" target="_blank" rel="noopener">$Code$</a></p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><p>这个题目条件就告诉你，所有边双大小不超过 $k$。然后要求邻接矩阵行列式？</p><p>图的行列式 $= \sum\limits_{图的所有分解方式，分解为若干环} (-1)^{偶环个数}$</p><p>由于要考虑二元环，就比较恶心了……</p><p>在边双缩点得到的树上做 dp。</p><p>每个块有两种类型：$0$、$1$，表示该块的顶点 $top$ 是否和父亲块连。$dp[x, 0/1]$ 表示边双树上第 $x$ 个块及其子树的答案。</p><p>和父亲连的话只要在计算块行列式前把 $top$ 抠出来就可以了。</p><p>把儿子子树的系数和放到矩阵里做行列式，得到当前子树的系数和。</p><p>复杂度大概是 $O(\frac{n}{k} k^3) = O(nk^2)$</p><p><a href="https://codeforces.com/gym/102331/submission/114740535" target="_blank" rel="noopener">$Code$</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>动态加边，每次寻找最大权的异或和为 $0$ 的非欧拉回路图，可以不连通</p><p>catalan 数 😂 这个 300iq 怎么造奇怪样例</p><p>首先把边看作向量，一条 $(x, y, a)$ 的边可以看作 $x$ 维和 $y$ 维都是 $1$，第 $n + 1$ ~ $n + 65$ 维为 $a$ 的二进制表示的向量</p><p>那么就是求最大权的线性无关向量组。</p><p>不用对每个前缀求的话怎么做：按 $w$ 降序排列后能加则加。正确性大概是因为它有拟阵结构！！！遗传性和交换性都满足。</p><p>对每个前缀求：当新加的向量异或成 $0$ 时，找到异或它的基内最小权向量并替换。。</p><p><a href="https://codeforces.com/gym/102331/submission/114503954" target="_blank" rel="noopener">$Code$</a></p><h2 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h2><p>粗略的想法：从前往后扫，非法的存起来，合法的合并并查询有无满足之前要求的，搞个并查集 + 线段树合并询问。丢进线段树的询问形如 $(need_val, qid)$。感觉这个细节有问题而且巨大难写。</p><p>——你需要一些奇怪的复杂度！</p><p>官方：</p><p>性质：$a + b \geq s$ 时必然满足 $a \geq s/2$ 或 $b \geq s/2$</p><p>设 $a$ 和 $b$ 所在连通块当前和分别为 $x$ 和 $y$，在两个连通块的 $(s - x - y)/2$ 处放上两个事件，标注一下是哪对 $a$ $b$</p><p>当一对连通块满足条件就合并，否则在新的 $(s - x - y)/2$ 处放上事件</p><p>每个 $s$ 会被分 $log$ 次，对连通块及其事件采取启发式合并，复杂度 $O(nlog(nlogC)logC)$</p><p>注意答案可能不为 $n - 1$ 因为最后可能并不成一棵树。</p><p><a href="https://codeforces.com/gym/102331/submission/114732408" target="_blank" rel="noopener">$Code$</a></p><h2 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h2><p>SAM？不用。</p><p>如果每个字符都不同，方案数为 $2^n - 1$</p><p>否则对于每个极长连续段减去重复计算的方案，就，枚举一下左边刚取到 $l$ 时右边到 $[l, r]$ 中哪个位置了，以及右边刚取到 $r$ 时左边到 $[l, r]$ 中哪个位置了，减去多算的操作序列数即可。</p><p><a href="https://codeforces.com/gym/102331/submission/114448841" target="_blank" rel="noopener">$Code$</a></p><h2 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h2><p>差点读错题。是要求选 $k$ 个不相交子区间价值和的最大值。</p><p>模拟费用流似乎没法搞。但是费用流告诉我们这是凸的。wqs 二分，单次 $O((r - l + 1) * log)$，线段树预处理每个区间凸包，就三只 log 了。</p><p>注意到总区间长（重复算一次）不过 $nlogn$，整体二分，将询问排序，有单调性了，指针就够了，$nlognlogV$。</p><p>——第三个点大概 $10000$ 到 $30000$ 之间吧，为什么疯狂 TLE 啊？</p><p>——find 那里传了一整个 vector 进去……</p><p>传指针形式的 vector，和传编号，都可以 AC。</p><p><a href="https://codeforces.com/gym/102331/submission/114663233" target="_blank" rel="noopener">$Code$</a></p><h2 id="I"><a href="#I" class="headerlink" title="$I$"></a>$I$</h2><p>用不超过 $4 log_2 n$ 次操作找出关键点 $A$，每次询问 $?$ $k$ $x$ $y_1 \cdots y_k$，返回 $dis(A, x) \geq \min( dis(A, y_i) )$</p><p>$log^2$ 就是重链上二分。</p><p>wssb！$log$ 就是每次割一半，那么每次找重心即可。</p><p>数据好像比较水？/yiw</p><p><a href="https://codeforces.com/gym/102331/submission/114507258" target="_blank" rel="noopener">$Code$</a></p><h2 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h2><p>设 $f(k)$ 表示 $k$ 个匹配的最大价值和。</p><p>费用流模型容易建出。</p><p>费用流增广路径的价值递减，那么 f 就是上凸的了！</p><p>有凸性的考虑 dp，$dp[i, j, 0/1]$ 表示 $i$ 子树内匹配了 $j$ 对，$i$ 有无选。</p><p>dp 数组的合并其实就是凸包合并，闵可夫斯基和。</p><p>合并 $u$、$v$ 的复杂度是 $O(sz[u] + sz[v])$，那么启发式合并即可。</p><p>具体来说是类似链分治的玩意。重链要分治卷！！！跟花朵一样的方式，$[0/1][0/1]$ 表示该重链片段左右是否已匹配。鲨了我吧。</p><p>大概是一只 $log$？</p><p><a href="https://codeforces.com/gym/102331/submission/114641436" target="_blank" rel="noopener"><del>终于搞过去了嘤嘤嘤</del></a></p><h2 id="K"><a href="#K" class="headerlink" title="$K$"></a>$K$</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不可做题。</span><br><span class="line">打开题解。</span><br><span class="line">玄学暴力。</span><br><span class="line">关闭题解。</span><br><span class="line">仔细思考。</span><br><span class="line">——不会。</span><br></pre></td></tr></table></figure><p>官解真是有够暴力 /px</p><p>预处理可能存在非法串的位置和可能成为非法串的长度</p><p>由于不能控制所有位置的字符，考虑容斥，钦定一些位置是这些非法串，剩下位置随便摆。方案数可以通过并查集把应当相同的位置并起来得到。</p><p>先搜长串再搜短串。</p><p><a href="https://codeforces.com/gym/102331/submission/114730928" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XXI Open Cup. GP of Korea</title>
      <link href="2021/04/27/XXI%20Open%20Cup.%20GP%20of%20Korea/"/>
      <url>2021/04/27/XXI%20Open%20Cup.%20GP%20of%20Korea/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102759" target="_blank" rel="noopener">Jump!</a></p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><p>POI-LOG？这里的 $s$ 不相同。放到方阵上看你就输了！</p><p>把 $a$ 降序排列。答案为 $1$ 的充要条件：$\forall k, \sum\limits_{i = 1}^k a_i \leq \sum\limits_{j = 1}^m \min(b_j, k)$</p><p>证明考虑网络流模型，连边 $(S, i, a_i)$, $(j, T, b_j)$, 若 $maxflow = \sum a_i$ 则答案为 $1$。</p><p>考虑割的话一定是割一段 $a$ 的后缀和一段 $b$ 的前缀，即 $\sum\limits_{i = k + 1}^{n} a_i + \sum\limits_{i = 1}^{|B_{cut}|} b_i + \sum\limits_{i = |B_{cut}| + 1}^m k \geq mincut = \sum\limits_{i = 1}^n a_i$，整理得到上柿。</p><p>来个什么 DS 维护一下 min。由于每次只改变 $1$，操作都很容易维护。$a$ 相等，减的话减最后面的，加的话加最前面的，位置二分得到。注意 long long（</p><p>我在写什么我个憨憨。</p><p><a href="https://codeforces.com/gym/102759/submission/114418141" target="_blank" rel="noopener">$Code$</a></p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>$(1, 1)$ 能到达 $(n, m)$ 的充要条件是：</p><ol><li>不存在一行或一列被阻断</li><li>同时起始点不被阻断。</li></ol><p>证明也很清真：因为不存在一行或一列被阻断，任选一个好点 $(r, c)$；$(r, c)$ 必然能往上或往左走，不然就是「起点被阻断」了，矛盾。</p><p>枚举 $S$ 所在行，$T$ 所在的位置，对于条件 1，显然具有单调性；对于条件 2，维护单调栈，ban 掉一些起点，终点类似。具体来说，枚举 $x$，ban 掉 $x$ 坐标小于 $x$ 的离它最近的起点，找这个可以考虑找到最左边的列 $j$ 满足 $a_x + b_j \geq 0$，$j$ 左边找到 $b_j$ 最小的 $y$ 处，再找 $x$ 坐标最大的小于 $x$ 的 $i$ 满足 $a_i + b_y \leq 0$，$[i + 1, x]$ 的都不能成为起点了。</p><p>代码咕了</p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p>给一个边双定向使得强连通并且路价最小。</p><p>构造强连通图的方法：耳分解，即每次选一条起终点在已构造 SCC 里，除起终点外的点都不在 SCC 里的路径，拼到 SCC 里。</p><p>dp, $dp[s, u, v]$ 表示当前已加入集合 $s$ 的点，还需填充 $u \rightarrow v$ 的路径</p><p>代码咕了</p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><p>$m$ 对是确定的，不能改变。剩下 $n(n - 1) / 2$ 条可以根据 $\forall i, j, k, C(i, j) \geq \min(C(i, k), C(k, j))$ 这条规则来推出</p><p>只要有树结构，就可以令其余对的权值等于路径上最小值。求出 $m$ 条边构成的<strong>最大</strong>生成森林。点对不连通则权值视作 $1$。</p><p>代码咕了</p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>毒瘤大工业题，询问有多少区间，满足只保留区间内的点，构成的是一条链</p><p>考虑链是啥，就是 边数 $= R - L$ 且每个点度数不超过 $2$ 且无环。</p><p>枚举 $R$。</p><ul><li>无环、度数不超过 $2$：LCT + 双指针</li><li>边数 $= R - L$：线段树</li></ul><p>代码咕了</p><h2 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h2><p>就是使得每个区间至多被覆盖两次。显然是个费用流。</p><p>primal-dual 算法：初始运行一遍 spfa 求出 s 到每个点最短路，定义势函数 $h_x = dist(s, x)$，对于一条边 $(x, y)$ 将其边权修改为 $cost(x, y) + h_x - h_y$，就非负了，可以跑 dij 费用流，$O(mlogm * f)$</p><p>此处 $f = 2$</p><p><a href="https://codeforces.com/gym/102759/submission/114405117" target="_blank" rel="noopener">$Code$</a></p><h2 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h2><p>考虑检验方程：$dp[i, j] = max( dp[i - 1, j], dp[i, j - 1], dp[i - 1, j - 1] + [a_i == b_j] )$</p><p>本质不同的串的 dp 过程也不一样。所以我们要去 dp 有多少种本质不同的 dp 过程：</p><p>注意到 $dp[i - K, i - K] = i - K$，只需要记录「当前位置的前 $K$ 个和后 $K$ 个 dp 值的差分状态」就能推出这 $2K$ 个的 dp 值，$f[i, s]$ 表示 $dp[ , ] = i$, 当前位置的前 $K$ 个和后 $K$ 个 dp 值的差分状态为 $S$。</p><p>$O(n 2^6 <em> 4 </em> 26 * 8)$ 但是跑过去了（</p><p>不难写，本质就是个压缩 + 解压缩。</p><p><a href="https://codeforces.com/gym/102759/submission/114410446" target="_blank" rel="noopener">$Code$</a></p><h2 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h2><p>逆向思维，考虑若最后合并出了 $k$，将合并 $k$ 用到的 $k - 1$ 都变成 $0$ 就能合并出 $k - 1$ 了，因此答案具有二分性。倒推，已知需要 $0$ ~ $i$ 的物品共多少个，推出需要 $0$ ~ $i - 1$ 的物品各多少个，最后到 $0$ 位置判断是否满足。</p><p><a href="https://codeforces.com/gym/102759/submission/114406768" target="_blank" rel="noopener">$Code$</a></p><h2 id="I"><a href="#I" class="headerlink" title="$I$"></a>$I$</h2><p>带权重心一定满足，其子树和严格大于总和一半，并且带权重心在一条链上。dfs 序的带权中位数一定在子树里，好像随便倍增就好了。</p><p>代码咕了。</p><h2 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h2><p>xza 搬到模拟赛的题，预处理出 $(0, 0)$ 四个方向每个后缀的决策结果即可。</p><p>WA on 15？不管了不管了。</p><h2 id="K"><a href="#K" class="headerlink" title="$K$"></a>$K$</h2><p>树退化为链比较好做。以 $x$ 为第一关键字，$y$ 为第二关键字排序，正着连一遍，反着连一遍。这样保证不会相交。</p><p><a href="https://codeforces.com/gym/102759/submission/114406173" target="_blank" rel="noopener">$Code$</a></p><h2 id="L"><a href="#L" class="headerlink" title="$L$"></a>$L$</h2><p>我们的目标是消掉所有凹顶点。消凹顶点的过程中不会产生新的凹顶点，因此都是原有的。最小化次数就是最大化「一次消两个」的次数。预处理所有竖着的和横着的「消两个」方案。但是方案可能互相影响！！我们要求他们的最大独立集。</p><p>幸运的是，横着的和竖着的内部都不互相影响。所以这是个二分图。二分图中最大独立集 = $|V|$ - 最大匹配！二分图最大匹配即可！dinic $O(n^2 \sqrt{n})$</p><p>然而这是个篱笆，考虑贪心做最大匹配，每次选最左边的竖线和经过它的右端点最小的横线, $O(nlogn)$。</p><p><a href="https://codeforces.com/gym/102759/submission/114368696" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XXI Opencup GP of Tokyo</title>
      <link href="2021/04/27/XXI%20Opencup%20GP%20of%20Tokyo/"/>
      <url>2021/04/27/XXI%20Opencup%20GP%20of%20Tokyo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102978" target="_blank" rel="noopener">Jump!</a></p><h3 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h3><p>傻了，&amp; 和 | 操作没有可下手之处，但是操作等价于选一个位置，删除它的一个 neighbor</p><p>枚举最后赢家是哪个 $1$。</p><p>$dp_i$ 表示 $i$ 个用这种删除方法删光的方案，$dp_i = dp_{i - 1} <em> (2 </em> i - 1)$，表示 $i$ 种「$i$ 最后删除」的方案，$i - 1$ 种「$i$ 作为邻居被删除」的方案</p><h3 id="I"><a href="#I" class="headerlink" title="$I$"></a>$I$</h3><p>必然是一段上升子序列选最长的，剩下就是凑数用。<br>填数可以填在小于自己的 $x_i$ 前面，方案乘积为答案。</p><h3 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h3><p>考虑期望的线性性，考虑每个 $b_i$ 的贡献。<br>它产生贡献当且仅当它在所有 $a_i$ 删完之前删了</p><p>考虑容斥，枚举<strong>至少</strong>在它之后删的 $a$ 中集合 $S$，容斥系数 $(-1)^{|S|}$</p><p>理智推柿：</p><p>$\sum\limits_{S \subseteq U} (-1)^{|S|} \sum_i (1 - \frac{\sum\limits_{j \in S} a_j + b}{sum})^i \frac{b}{sum}$</p><p>$= \sum\limits_{S \subseteq U} (-1)^{|S|} \frac{b}{\sum\limits_{j \in S} a_j + b}$</p><p>只和 $\sum a_j$ 有关，dp 即可。</p><p>为什么不能直接算 $b$ 在所有 $a$ 之后的概率？题设中的概率计算方式，限制我们只能从前往后，不能倒着妄图 $\frac{b}{b + \sum\limits_{j = 1}^n a_j}$。</p><h3 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h3><p>woc 题目读错了，只要 $n - 1$ 和 $n$ 的 lca</p><p>设 $lca(n - 1, n) = x$，$sz[x] = S$ 的方案数是 $\frac{(S - 1)!}{2}$。证明大概考虑补集转化，总数为 $(n - 1)!$，然后任意一个 $lca = x$ 某个儿子的方案都可以将 $n - 1$ 所在分支子树拆出来挂成 x 儿子，即合法方案和不合法方案之间构成双射。</p><p>这个方案数要乘给关于 $S$ 的 OGF 里。分治 FFT 卷这个 OGF，$x$ 子树的贡献 $(x - 1) <em> a_x </em> \prod_i (1 + a_iz)$，第一项表示 $x$ 选父亲。</p><h3 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h3><p>普通图的匹配方案数是 np 问题吧…… 事有蹊跷</p><p>注意到每个点出入度都至多为 2，4-sat？AB 用处不止于此。完全不会。</p><p>官解：</p><p>$B \leq \sqrt{n}$ 时状压即可。维护一个状态条，一格格移。</p><p>否则：$B$ 大，可是 $n / B$ 小啊！</p><p>设 $g = gcd(A, B)$</p><p>若 $g = 1$，将每个点对应到一个 $(n / B) * B$ 的矩阵，点 $v$ 对应到 $(x, y)$ 满足 $x = \lfloor \frac{v}{B} \rfloor$, $yA \equiv v \pmod{B}$，在方格图上从左往右做状压。</p><p>关于细节：需要高维前缀和，需要枚举第一列内部配对状态以及第一列指向第二列的配对状态。</p><p>若 $g &gt; 1$，则为了让点与格点的映射关系不串，需要分开做然后方案数乘起来。（同余什么的好玄学啊…… 自己画几组小样例玩玩）</p><h3 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h3><p>上次咕了的题，这次一定！（订完这道就去写数学作业</p><p>$\sum\limits_{b = 0}^B \sum\limits_{r = 0}^R \binom{b + r}{b} \binom{(B - b) + (R - r)}{B - b} \min( \frac{r}{b}, \frac{R - r}{B - b} )$</p><p>$= \sum\limits_{A = 1} \sum\limits_{b = 0}^B \sum\limits_{r = 0}^R \binom{b + r}{b} \binom{(B - b) + (R - r)}{B - b} [bA \leq r] [(B - b)A \leq (R - r)]$</p><p>$= \sum\limits_{A = 1} \sum\limits_{i = r - bA = 0}^{R - B} \sum\limits_{b = 0}^B \binom{b + r}{b} \binom{(B - b) + (R - r)}{B - b}$</p><p>即将 $b$ 视为 $x$，$r$ 视为 $y$，$y = Ax +$ 一个常数 $i$，构成了一个平行四边形形状的区域，枚举路径经过的点 $(b, Ab + i)$, 说明要统计的是所有路径经过这个区域的点的次数和。</p><p>先来解决前置问题：<br>求解 $f(W, A, P)$ 表示从 $(0, 0)$ 到 $(W, AW + P)$ 且中途不跨过 $y = Ax + P$ 的路径条数。</p><p>枚举第一次跨过的位置：</p><p>$f(W, A, P) + \sum\limits_{i = 0}^{W - 1} f(i, A, P) \binom{ (A + 1)(W - i) - 1 }{ W - i } = \binom{(A + 1)W + P}{W} (I)$</p><p>考虑一条从 $(0, 0)$ 到 $(W - 1, AW + P + 1)$ 的路径，其必然跨过 $y = Ax + P$（题外话：你一直记不住的 Catalan 数就是这么推的，$(0, 0)$ 到 $(n, n)$ 的路径 $- (0, 0)$ 到 $(n - 1, n + 1)$ 的路径 $= \binom{2n}{n} - \binom{2n}{n - 1}$ ）</p><p>$\binom{(A + 1)W + P}{W - 1} = \sum\limits_{i = 0}^{W - 1} f(i, A, P) \binom{ (A + 1)(W - i) - 1 }{ W - i - 1 } = \sum\limits_{i = 0}^{W - 1} f(i, A, P) \frac{1}{A} \binom{(A + 1)(W - i) - 1}{W - i} (II)$</p><p>$(I) - A(II)$ 得出 $f(W, A, P) = \binom{(A + 1)W + P}{W} - A \binom{(A + 1)W + P}{W - 1}$</p><p>考虑计算某条路径 $y = Ax + P$ 被所有 $(0, 0)$ 到 $(W, H)$ 直线经过的次数和，记为 $g(W, H, A, P)$，保证 $H \geq AW + P$</p><p>枚举路径上的点：$g(W, H, A, B) = \sum\limits_{i = 0}^W \binom{(A + 1)i + P}{i} \binom{ W + H - (A + 1)i - P }{ W - i }$</p><p>这么快速得到 $g$ 呢？我们还和之前 $f$ 一样，考虑 $g(W, H, A, B) - A g(W - 1, H + 1, A, B)$</p><p>$= \sum\limits_{i = 0}^W \binom{ (A + 1)i + P }{ i } ( \binom{W + H - (A + 1)i - P}{W - i} - \binom{W + H - (A + 1)i - P}{W - 1 - i} )$</p><p>$= \sum\limits_{i = 0}^W \binom{ (A + 1)i + P }{ i } f( W - i, A, H - AW - P )$</p><p>其组合意义也很好想，$(0, 0)$ 走到 $(i, Ai + P)$，再在不跨过 $y = Ax + P$ 的情况下走到 $(W, H)$（未来的你会绕晕吗，如果会，那你比现在的我逊 /大杯 但是这个组合意义显然正确）</p><p>实际上这玩意 $= \binom{W + H + 1}{W}$！！！没想到吧，和 $A$、$P$ 无关（xyx：$A$、$P$ 只是我们对路径的分类方式）</p><p>可以看作，枚举 <strong>最后一次碰到</strong> $y = Ax + P$ 的位置 $p$，在 $p$ 位置向上走一格，走到 $(W, H + 1)$ 的方案数。</p><p>因此我们终于得到了：<br>$g(W, H, A, B) - A g(W - 1, H + 1, A, P) = \binom{W + H + 1}{W}$</p><p>$g(W, H, A, B) = \sum\limits_{i = 0}^W \binom{W + H + 1}{i} A^{W - i}$</p><p>结 果 与 $P$ 无 关</p><p>最后一步了。因为结果和 $P$ 无关，所以 $A$ 相同的线段合在一起算。</p><p>$ans = \sum\limits_{A = 1}^{R/B} (R - AB + 1) \sum\limits_{i = 0}^B \binom{R + B + 1}{i} A^{B - i}$</p><p>$= \sum\limits_{i = 0}^B \binom{R + B + 1}{i} [ (R + 1) \sum\limits_{A = 1}^{R / B} A^{B - i} - B \sum\limits_{A = 1}^{R / B} A^{B - i + 1} ]$</p><p>法一：</p><p>伯努利数计算自然数幂和即可。<br>什么你不知道伯努利数？<a href="https://www.cnblogs.com/Judge/p/10722777.html" target="_blank" rel="noopener">owo</a></p><p>伯努利数满足 $B_0 = 1$, $\sum\limits_{i = 0}^{n - 1} \binom{n}{i} B_i = 0$</p><p>$nlogn$ 求解伯努利数：<br>$\sum\limits_{i = 0}^{n - 1} \binom{n}{i} B_i + B_n = B_n$</p><p>$\sum\limits_{i = 0}^{n} \binom{n}{i} B_n = B_n$</p><p>$\sum\limits_{i = 0}^n \frac{B_i}{(n - i)!i!} = \frac{B_n}{n!}$</p><p>EGF 出来了。准确来说，$B(x) = \sum\limits_{i \geq 0} (\frac{B_i}{i!} + [i == 1]) x^i$</p><p>即 $B(x) e^x = B(x) + x$</p><p>$B(x) = \frac{x}{e^x - 1}$</p><p>法二：</p><p>计算 $e^x + e^{2x} + \cdots + e^{(R/B)x}$，等比数列求和，$\frac{ 1 - e^{((R/B) + 1)x} }{ 1 - e^x }$</p><p>upd: 我的全家桶太慢了，卡了别人板子才过的…… 烦</p><p>woc 好好一场 XXI，一道 C 题占一半篇幅 /tuu</p><h3 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h3><p>写在「LGV」</p><h3 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h3><p>咕咕咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数树 &amp; Communication Network</title>
      <link href="2021/04/27/%E6%95%B0%E6%A0%91%20&amp;%20Communication%20Network/"/>
      <url>2021/04/27/%E6%95%B0%E6%A0%91%20&amp;%20Communication%20Network/</url>
      
        <content type="html"><![CDATA[<p>多久没有单独开篇了 = = 碰到两道 trick 类似的，来写写。</p><p>结论：$f(S) = \sum\limits_{T \subseteq S} \sum\limits_{P \subseteq T} (-1)^{|T| - |P|} f(P)$。</p><p>证明：规定 $0^0 = 1$，只有当 $P = S$ 当时候会被计算进 $f(S)$。</p><p>似乎有道严格弱化版 <a href="https://www.luogu.com.cn/problem/CF917D" target="_blank" rel="noopener">$CF917D$</a>。真的很弱。</p><h2 id="Communication-Network"><a href="#Communication-Network" class="headerlink" title="$Communication Network$"></a><a href="https://loj.ac/p/3399" target="_blank" rel="noopener">$Communication Network$</a></h2><p>感觉是个 prufer 大杂烩啊…… 设 $f(v)$ 表示 $|E1 \cap E2| = v$ 的方案数，连通块嘛，树形 dp？然后乘个 prufer？容斥？复杂度爆炸！</p><p>试试我们的今日 trick。</p><p>$$ans = \sum\limits_{T_2} \sum\limits_{S \subseteq ( T_1 \cap T_2 )} \sum\limits_{T \subseteq S} (-1)^{|S| - |T|} |T| 2^{|T|}$$</p><p>$g(S)$ 表示<strong>包含</strong> 边集 $S$ 的 $T_2$ 个数，$g(S) = n^{k - 2} \prod\limits_{i = 1}^k a_i$，其中 $k = n - |S|$</p><p>通过各种靠近二项式定理，可以推得：</p><p>$$ans = 2 \sum\limits_{S \subseteq T_1} |S| g(S) = \frac{2}{n^2} \sum\limits_{S \subseteq T_1} |S| \prod\limits_{i = 1}^{n - |S|} n a_i$$</p><p>$a_i$ 的组合意义是 $\binom{a_i}{1}$。于是采用 $CF917D$ 的 dp 方式：$dp_{x, 0/1, 0/1}$ 表示 $x$ 子树，$x$ 所在连通块是否选了点、是否选了边，的贡献和。树形背包合并。</p><p><a href="https://loj.ac/s/1125813" target="_blank" rel="noopener">$Code$</a></p><h2 id="WC2019-数树"><a href="#WC2019-数树" class="headerlink" title="$WC2019-$数树"></a><a href="https://loj.ac/p/2983" target="_blank" rel="noopener">$WC2019-$数树</a></h2><p>算是“网红”题目了？打卡！数树、数数、数鼠、鼠树…… /yun</p><h3 id="op-0"><a href="#op-0" class="headerlink" title="$op = 0$"></a>$op = 0$</h3><p>设重边数为 $cnt$，$ans = col^{n - cnt}$</p><h3 id="op-1"><a href="#op-1" class="headerlink" title="$op = 1$"></a>$op = 1$</h3><p>这个 subtask 和上一道简直一毛一样</p><p>推出来 $ans = \sum\limits_{S \subseteq T_1} col^{n - |S|} (1 - col)^{|S|} g(S)$，$g(S)$ 表示包含边集 $S$ 的树个数</p><p>$$ans = \frac{(1 - col)^n}{n^2} \sum\limits_{S \subseteq T_1} \prod\limits_{i = 1}^k \frac{n col}{1 - col} a_i$$</p><p>考虑 $a_i$ 组合意义，$\binom{a_i}{1}$，于是可以 dp, $dp_{x, 0/1}$ 表示 $x$ 所在连通块有无选点</p><h3 id="op-2"><a href="#op-2" class="headerlink" title="$op = 2$"></a>$op = 2$</h3><p>换汤不换药。</p><p>因为 $T_1$ 也不确定了，每个块方案数还要算上树的形态方案数，即 $n^{n - 2}$，同时编号也有待分配，因此对 $g(S)$ 要魔改一发，最后：</p><p>$$ans = \frac{(1 - col)^n}{n^4} \sum\limits_S \prod\limits_{i = 1}^k \frac{n^2col}{1 - col} a_i^2 a_i^{a_i - 2} * \binom{n}{a_1, \cdots, a_k}（分配编号）$$</p><p>ho~ 这下没法 dp 咯，转战生成函数。</p><p>考虑 EGF 和 exp 的组合意义，拼一下就好了。</p><p>具体来说，设 EGF $F(x) = \sum\limits_{i \geq 1} \frac{n^2 col}{(1 - col) i!} i^i x^i$, $G(x) = e^{F(x)}$，$ans = \frac{(1 - col)^n n!}{n^4} [x^n] G(x)$</p><p><del>有个靠谱的全家桶真好 qwq</del></p><p><a href="https://loj.ac/s/1126517" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】鞅和停时问题：一种构造势能函数的做法</title>
      <link href="2021/04/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9E%85%E5%92%8C%E5%81%9C%E6%97%B6%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%9E%84%E9%80%A0%E5%8A%BF%E8%83%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%81%9A%E6%B3%95/"/>
      <url>2021/04/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9E%85%E5%92%8C%E5%81%9C%E6%97%B6%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%9E%84%E9%80%A0%E5%8A%BF%E8%83%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有终止条件，随机操作，问期望多少次到达终止状态。</p><p>这是「鞅和停时」问题，可以构造势能函数满足每操作一次势能就降低 $1$，答案显然等于初势能 - 末势能。列等式解出初末势能。</p><h2 id="CF1349D-Slime-and-Biscuits"><a href="#CF1349D-Slime-and-Biscuits" class="headerlink" title="$CF1349D-Slime and Biscuits$"></a><a href="https://www.luogu.com.cn/problem/CF1349D" target="_blank" rel="noopener">$CF1349D-Slime and Biscuits$</a></h2><p><strong>势能法</strong>比概率做法不知道高到<strong>哪里</strong>去了！</p><p>我们希望构造势能函数 $\phi$ 和 $f$，其中 $\phi(A) = \sum\limits_{i = 1}^n f(a_i)$ 使得每操作一步，$\phi(A)$ 就减少 $1$。（真是神奇的定义啊）</p><p>$ans = 初势能 - 末势能 = ( \sum\limits_{i = 1}^{n} f_{a_i} ) - ( f_m + f_0 (n - 1) )$。也就是说 $\sum\limits_{i = 1}^n f_{a_i}$ 要比后继的期望大 $1$。即 $\sum\limits_{i = 1}^n f_{a_i} = \frac{1}{m} \sum\limits_{i = 1}^n a_i ( f_{a_i - 1} + \sum\limits_{j \neq i} (\frac{1}{n - 1} f_{a_j + 1} + \frac{n - 2}{n - 1} f_{a_j}) )$。化得 $\sum\limits_{i = 1}^n f_{a_i} = \sum\limits_{i = 1}^n \frac{a_i}{m} ( f_{a_i - 1} + 1 ) + f(a_i + 1) \frac{m - a_i}{m(n - 1)} + f(a_i) \frac{(n - 2)(m - a_i)}{(n - 1)m}$</p><p>再强调一次，是<strong>构造</strong>，怎么方便怎么来。强制钦定每个 $i$ 左右项都相等，则 $f(a) = \frac{a}{m} ( f(a - 1) + 1 ) + f(a + 1) \frac{m - a}{m(n - 1)} + f(a) \frac{(n - 2)(m - a)}{(n - 1)m}$。</p><p>这种和相邻若干项有关的方程组叫做 band-matrix。方程组个数为 $n$、与相邻 $d$ 项有关的 band-matrix 消元复杂度是 $O(nd^2)$，大概是竖着消且只消那 $d$/$2d$ 项？<a href="https://www.luogu.com.cn/blog/froggy/qian-tan-gao-si-xiao-yuan-ta-zhan-zhi-band-matrix" target="_blank" rel="noopener">点我</a></p><p>另一种方便的解法是设 $f(i) = k_i f(m) + b_i$。钦定 $f(m - 1) = 0$，解出 $f(0 \cdots m - 2)$，根据 $f(0) = f(1)$ 再推回来。</p><p><a href="https://codeforces.com/contest/1349/submission/111783801" target="_blank" rel="noopener">$Code$</a></p><h2 id="CF1479E-School-Clubs"><a href="#CF1479E-School-Clubs" class="headerlink" title="$CF1479E-School Clubs$"></a><a href="https://www.luogu.com.cn/problem/CF1479E" target="_blank" rel="noopener">$CF1479E-School Clubs$</a></h2><p>设 $\phi(A) = \sum\limits_{i = 1}^m f(a_i)$</p><p>$\sum\limits_{i = 1}^m \frac{a_i}{n} \frac{1}{2} ( f(1) + f(a_i - 1) - f(a_i) + \sum\limits_{j \neq i} \frac{a_j}{n} ( f(a_j + 1) + f(a_i - 1) - f(a_i) - f(a_j) ) ) = -1$</p><p>$ans = \phi(A) - f(n)$</p><p>整理得</p><p>$\sum\limits_{i = 1}^m \frac{a_i}{n} ( 2 - f(a_i) + f(1) + f(a_i - 1) + \frac{n - a_i}{n}( f(a_i - 1) - f(a_i) ) + \frac{n - a_i}{n}( f(a_i + 1) - f(a_i) ) ) = 0$</p><p>更激进一点，令每项 $= 0$，推得</p><p>$f(x + 1) = \frac{1}{n - x} (-2n + (3n - 2x) f(x) - n f(1) - (2n - x ) f(x - 1))$</p><p>设 $f(0) = 0$, 为了方便令 $f(1) = -2$，递推即可。</p><p>4s 4e8，保留分数形式这样中途就不用求逆元了，选用 GNU C++17 (64) 就可以 AC 了。</p><p><a href="https://codeforces.com/problemset/submission/1479/114261827" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 鞅和停时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THUSCH 2017 做题记录</title>
      <link href="2021/04/25/THUSCH%202017%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/25/THUSCH%202017%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=thuscH%202017" target="_blank" rel="noopener">Jump!</a></p><h2 id="巧克力"><a href="#巧克力" class="headerlink" title="巧克力"></a>巧克力</h2><p>很好的 <del>随 机 化</del> 斯坦纳树题。首先如果 $C$ 很小的话怎么做？我们可以二分中位数（变权值为 $0$/$1$） + 状压跑斯坦纳树。但是我们首要的是选的块数尽量少，次要的是选的 $0$ 尽量多，怎么 $dp$？<strong>这里有个超好的 Trick：把 $0$ 赋为 $inf - 1$，把 $1$ 赋为 $inf + 1$，块数就是 $\lfloor \frac{val + 300}{1000} \rfloor$</strong></p><p>但是 $C$ 大而 $K$ 小。于是想到把 $C$ 种颜色随机分为 $K$ 类跑状压。正确率是 $\frac{k!}{k^k}$，约等于 $0.0384$, 跑个几百次就没问题了。</p><p><a href="https://loj.ac/s/991228" target="_blank" rel="noopener">$Code$</a></p><h2 id="杜老师"><a href="#杜老师" class="headerlink" title="杜老师"></a>杜老师</h2><p>思索良久，无果</p><p>打开题解 -&gt; 线性基 -&gt; 关闭题解，仔细思考.png</p><ul><li>$&gt; \sqrt{r}$ 的特殊处理？</li><li>$&lt; \sqrt{r}$ 的，存为质因子分解后指数奇偶性的二进制数，那么问题就是问有多少个子集异或和为 $0$。</li></ul><p>卡 壳</p><p>打开题解。</p><p>任意线性基外的一种取法都能在线性基内选一种取法使得两者异或为 $0$，因此方案数为 $2^{r - l + 1 - 线性基大小}$</p><p>神必了神必了！</p><p>$&gt; \sqrt{r}$ 的记录一下，对于之后所有有该因子的数都异或上。</p><p>设 $f(r)$ 表示小于 $r$ 的素数个数。这样复杂度是 $O(\frac{r - l + 1}{\omega} f^2(\sqrt{r}))$，无法通过。</p><p>题解说：暴力验证 $r - l + 1 &gt; 6661$ 时一定会满，即线性基大小为 $l$、$r$ 出现的质因子个数，因此复杂度为 $O(f(r) + \frac{6661}{\omega} f^2(\sqrt{r}))$</p><p>对不起这谁想得到啊 fxck</p><p><a href="https://loj.ac/s/1125498" target="_blank" rel="noopener">$Code$</a></p><h2 id="换桌"><a href="#换桌" class="headerlink" title="换桌"></a>换桌</h2><p>裸的 KM $O(n^3m^3)$（还不会）</p><p>注意到 $m$ 很小</p><p>可以考虑优化连边什么的？比如相邻座位间连边，每个座位上开两棵线段树，表示向左走和向右走，共 $2m$ 棵。线段树上的边带有权值。到达线段树上某个节点，默认在端点。</p><p>点、边都是 $nmlog$，需要多路增广（就是 UNR-白鸽 那道，dinic 一起跑，把残量网络上余量增广掉）需要打 $vis$ 标记，因为可能有 $0$ 环</p><p><a href="https://loj.ac/s/1125594" target="_blank" rel="noopener">$Code$</a></p><h2 id="大魔法师"><a href="#大魔法师" class="headerlink" title="大魔法师"></a>大魔法师</h2><p>所有操作都可以用 $x = x * a + b$ 的形式来替代，线段树维护矩阵即可。$O(4^2 q logn)$</p><p>不加「乘向量」的优化直接艹过去了，我就是传说中的小常数选手吗（划，可能是开了 Ofast 的缘故罢</p><p><a href="https://loj.ac/s/1125632" target="_blank" rel="noopener">$Code$</a></p><h2 id="如果奇迹有颜色"><a href="#如果奇迹有颜色" class="headerlink" title="如果奇迹有颜色"></a>如果奇迹有颜色</h2><p>这题比洛谷上的 Polya 模板题多了个相邻 $m$ 项颜色不能全不同的限制。</p><p>$|X/G| = \frac{1}{|G|} \sum_g m^{c(g)} = \frac{1}{|G|} \sum_k \varphi(n / k) * f(k)$</p><p>现在要算 $f(gcd = k)$ 的染色方案数。可以状压计算，状态数是 $m^{m}$，直接跑矩阵快速幂能拿到 $55$ 分的好成绩，然后我就不会了</p><p>题解告诉我要去学常系数齐次线性递推，我就滚去学了。厚厚，新知识！（于是就有了这篇拼凑起来的笔记</p><p>猜测递推式长度小于 $m^{m}$，借助超能力（打表）发现 $m = 7$ 就 $409$.</p><p><a href="https://loj.ac/s/1012066" target="_blank" rel="noopener">$Code$</a></p><h2 id="宇宙广播"><a href="#宇宙广播" class="headerlink" title="宇宙广播"></a>宇宙广播</h2><p>咕了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】拟阵</title>
      <link href="2021/04/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8B%9F%E9%98%B5/"/>
      <url>2021/04/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8B%9F%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>超浅谈。证明挂不挂看心情（可以去看 18 年集训队论文《浅谈拟阵的一些拓展及其应用》）</p><ul><li><a href="#1">拟阵</a><ul><li><a href="#2">秩函数</a></li><li><a href="#3">基 &amp; 环</a></li><li><a href="#4">拟阵在贪心的应用</a></li><li><a href="#k">对偶拟阵</a></li><li><a href="#7">拟阵交</a><ul><li><a href="#8">最小最大定理</a></li><li><a href="#6">交换图</a></li><li><a href="#5">算法流程</a></li></ul></li><li><a href="#9">带权拟阵交</a><ul><li><a href="#10">扩展最小最大定理</a></li></ul></li></ul></li><li><a href="#11">习题</a></li></ul><p><strong><h3 id="1">拟阵</h3></strong></p><p>定义拟阵 $M = (S, \mathcal{I})$，表示一个定义在有限集 $S$ 上，独立集的集合是 $\mathcal{I}$ 的拟阵，显然 $\mathcal{I} \subseteq S$。</p><p>这里独立集是抽象概念。</p><p>拟阵的两条公理：</p><ul><li>遗传性：对于 $I \in \mathcal{I}$，$x \in I$，$I \setminus {x} \in \mathcal{I}$</li><li>交换性：$I, J \in \mathcal{I}$，$|J| &gt; |I|$，存在 $x \in J \setminus I$ 满足 $I \cup {x} \in \mathcal{I}$</li></ul><p>任何组合优化问题（某种最优化问题）如果满足这两条公理，就具有拟阵结构，所有拟阵的定理在这个组合优化问题上成立。比如以下三种：</p><ol><li>均匀拟阵：拟阵 $M_n^k = (S, \mathcal{I})$，其中 $|S| = n$，$\mathcal{I} = {I \subseteq S : |I| \leq k}$。显然满足遗传性和交换性。简单但有用的一个东西，可以把长相清真的限制拿来凑拟阵，做拟阵交。</li><li>图拟阵：<strong>仅对无向图成立</strong>。无向图 $G = (V, E)$，图拟阵 $M = (E, \mathcal{I})$，$\mathcal{I} = {F \subseteq E: F 无环}$，即，独立集是生成森林。</li><li>匹配拟阵：$G = (V, E)$，匹配拟阵 $M = (V, \mathcal{I})$，$\forall \mathcal{I}, 存在匹配覆盖 \mathcal{I} 中所有点$。二分图匹配问题是个拟阵。</li></ol><p><strong><h3 id="2">秩函数</h3></strong></p><p>对于拟阵 $M = (S, \mathcal{I})$，定义 $r(U)$ 为集合 $U \subseteq S$ 的秩函数，表示 $U$ 中极大独立集的大小。</p><p>秩函数满足拟阵的两条公理。因此满足秩函数的性质的组合优化问题具有拟阵结构。</p><p><strong><h3 id="3">基 &amp; 环</h3></strong></p><ul><li>基：极大独立集。加任何一个元素都会变成非独立集。同个拟阵的所有基，大小相同。<ul><li>基交换定理：对于两个基 $A$、$B$，$A \neq B$，对于任意一个 $x \in A \setminus B$，都存在 $y \in B \setminus A$，满足 $A - {x} + {y} \in \mathcal{I}$</li><li>强基交换定理：对于两个基 $A$、$B$，$A \neq B$，对于任意一个 $x \in A \setminus B$，都存在 $y \in B \setminus A$，满足 $A - {x} + {y}$ 和 $B - {y} + {x}$ 都是拟阵的基。</li></ul></li><li>环：极小非独立集。减任何一个元素都会变成独立集。</li></ul><p><strong><h3 id="4">拟阵在贪心的应用</h3></strong></p><p>将<strong>元素</strong>按照权值 $\omega$ 降序排列，维护答案集合 $I$，初始 $I = \emptyset$，顺次考虑每个元素 $x_i$，若 $I \cup {x_i} \in \mathcal{I}$ 则加入 $x_i$。</p><p>正确性证明：</p><ul><li>$I$ 是拟阵的一个基：归纳证明，记 $I_i$ 表示在 $i$ 处的 $I$ 版本。若 $I_i$ 是个基，则讨论 $I_{i + 1}$：<ul><li>若 $r(I_{i + 1}) = r(I_i)$，仍是基。</li><li>若 $r(I_{i + 1}) &gt; r(I_i)$，若 $I_i \cup {x_{i + 1}}$ 是独立集则仍是基，否则新并进去的元素 $\in I_i$，说明 $I_i$ 不是基，矛盾。</li></ul></li><li>最优性：考虑反证，若与最优解不同的选择第一次出现在 $x_i$，最优解选择了 $x_i’$，那么 $\omega(x_i) &gt; \omega(x_i’)$，$x_i &lt; i’$，那么必然存在另一对不同选择 $x_j’$ 和 $x_j$ 满足 $x_j’ &lt; x_j$。根据基交换定理，$I - {x_j’} + {x_j} \in \mathcal{I}$，贪心算法一定会先选择 $x_j’$ 的。</li></ul><p>嘿嘿，还是现实的问题有意思<del>㗅着爽</del>。MST、二分图最大匹配都是拟阵上的最优化问题，可以用拟阵说明他们的正确性。（就好比可以用费用流说明凸性）</p><p><strong><h3 id="k">对偶拟阵</h3></strong></p><p>算是补充定义？做题会用到，但和拟阵交没什么关系。</p><p>定义：拟阵 $M = (S, \mathcal{I})$ 的对偶拟阵 $M^* = (S, \mathcal{I^*})$，$\mathcal{I^*} = {I: 存在 M 中的基 B \subseteq S \setminus I}$，即从 $S$ 中删掉 $I$ 后还存在基。</p><p>对偶拟阵的秩函数 $r’(U)$ 的意义也很显然了，公式化讲得更清楚：$r’(U) = \max\limits_{I \subseteq U, I \in \mathcal{I^*}} |I|$</p><p>推下去，$r^*(U) = |U| - r(S) + r(S \setminus U)$。</p><p>一个拟阵对偶两次又回来了。这可以从秩函数看出：$r(S \setminus U) \rightarrow r^*(U) \rightarrow r(S \setminus U)$</p><p>可以从秩函数角度证明<strong>拟阵对偶后还是个拟阵。</strong></p><p>经典应用嘛，还是图拟阵。「图连通」问题本身不是拟阵结构，但它可以用图拟阵的对偶拟阵做。<strong>注意是用对偶拟阵做！！！而不是把对偶拟阵再对偶，那样啥都不是了。</strong></p><p><strong><h3 id="7">拟阵交</h3></strong></p><p>求同时属于两个拟阵的独立集中最大的独立集。<strong>两个拟阵的交不是拟阵</strong>，否则直接贪心就行…… 那么怎么做呢？</p><p><strong><h3 id="8">最小最大定理</h3></strong></p><p>$\max\limits_{I \in \mathcal{I_1} \cap \mathcal{I_2}} |I| = \min\limits_{U \subseteq S}( r_1(U) + r_2(S\setminus U) )$</p><p>我们只要求出一组 $I$ 和 $U$ 满足这个定理，就解决了拟阵交问题。</p><p><strong><h3 id="6">交换图</h3></strong></p><p>定义：给定两个拟阵 $M_1$, $M_2$，和一个集合 $I \in \mathcal{I_1} \cap \mathcal{I_2}$，定义关于 $I$ 的交换图 $D_{M_1, M_2}(I)$ 是如下的二分图：两部分点集由 $I$ 和 $S \setminus I$ 组成。</p><ul><li>一条从 $y \in I$ 指向 $x \in S \setminus I$ 的边存在，当且仅当 $I - {y} + {x} \in \mathcal{I_1}$。</li><li>一条从 $x \in S \setminus I$ 指向 $y \in I$ 的边存在，当且仅当 $I - {y} + {x} \in \mathcal{I_2}$。</li></ul><p><strong><h3 id="5">算法流程</h3></strong></p><ol><li>令 $X_1 = {x \in S \setminus I | I \cup {x} \in \mathcal{I_1} }$, $X_2 = {x \in S \setminus I | I \cup {x} \in \mathcal{I_2} }$。</li><li><strong>增广</strong>，每次找一条 $X_1$ 到 $X_2$ 的最短路 $P$，令 $I$ 变为 $I \Delta P$（$\Delta$ 为对称差）。每次增广会扩张恰好 $1$ 个元素（显然，类比二分图增广过程）。</li><li>重复增广直到找不到 $X_1$ 到 $X_2$ 的路径。</li></ol><p>算法运行结束后，$|I| = r_1(U) + r_2(S \setminus U)$。</p><p>关于时间复杂度，令 $r = \max(r_1(S), r_2(S))$，$n = |S|$，图有 $n$ 个点、$rn$ 条边，找最短路单次 $O(n + m)$，增广次数不超过 $r$（每次增广 $|I|$ 至少增加 $1$），总复杂度 $O(r^2n)$。</p><p>实现时，设源汇点 $s$、$t$，若 $x \notin I$ 满足 $I + {x} \in I_1$，就连边 $s \rightarrow x$，若 $I + {x} \in I_2$ 就连边 $x \rightarrow t$。</p><p><strong><h3 id="9">带权拟阵交</h3></strong></p><p>带权了。令点权为 $w(x)$。</p><p><strong><h3 id="10">扩展最小最大定理</h3></strong></p><p>$\max\limits_{I \in \mathcal{I_1} \cap \mathcal{I_2}} \sum\limits_{e \in I} \omega(e) = \min\limits_{\omega_1, \omega_2: \forall x, \omega_1(x) + \omega_2(x) = \omega(x)} ( \max\limits_{I \in \mathcal{I_1}} \omega_1(I) ) + ( \max\limits_{I \in \mathcal{I_2}} \omega_2(I) )$</p><ul><li>$x \in I$, $w(x) = -\omega(x)$</li><li>$x \in S \setminus I$, $w(x) = \omega(x)$</li></ul><p>以最大权为例，求最长路，第一关键字是点权最大（论文这里出错了），第二关键字是路径最短。交换图上不存在正权环，因此可解。</p><hr><p>多个拟阵交是 NP-hard 的。</p><p>拟阵的并？咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕</p><hr><p><strong><h3 id="11">习题</h3></strong></p><h4 id="NAIPC18G-Rainbow-Graph"><a href="#NAIPC18G-Rainbow-Graph" class="headerlink" title="$NAIPC18G-Rainbow Graph$"></a><a href="https://nanti.jisuanke.com/t/A1875" target="_blank" rel="noopener">$NAIPC18G-Rainbow Graph$</a></h4><p>众所周知，图连通不是拟阵结构。但是删边判连通可以用图拟阵的对偶拟阵做（连通图必然存在树！）。</p><p>有两个限制，要求拟阵交。</p><p>倒着做，每增广一次表示对偶拟阵大小 +1。做最小带权拟阵交。</p><p>代码不放了，跟 奶糖 那道差不多。</p><h4 id="Milk-Candy"><a href="#Milk-Candy" class="headerlink" title="$Milk Candy$"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6636" target="_blank" rel="noopener">$Milk Candy$</a></h4><p>恰好怎么搞？先限制不超过 $c - k$ 条，然后不停增广增广。由于求最大权拟阵，一定会取到 $c - k$ 条。</p><p>两个限制：</p><ul><li>每个位置都要至少被覆盖一次。这是图拟阵的对偶。</li><li>以及每种颜色删的边不超过 $c - k$ 条。这是均匀拟阵。</li></ul><p>做最大拟阵交即可！</p><p>最后还是要判一下是否 $&lt; c - k$。</p><p>sb 错误调一年？</p><details>  <summary>code</summary>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Go(i, x, v) for (int i = 0, x = (i == v.size() ? 0 : v[i]); i &lt; v.size(); i++, x = (i == v.size() ? 0 : v[i]))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">  x = <span class="number">0</span>; <span class="keyword">char</span> ch = gc(); <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = gc()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = gc()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">  x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">cmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = min(x, y); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">cmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = max(x, y); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += mod - y; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = (ll)x * y % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; x += y; <span class="keyword">if</span> (x &gt;= mod) x -= mod; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; x += mod - y; <span class="keyword">if</span> (x &gt;= mod) x -= mod; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (ll)x * y % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">int</span> ret = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, Mul(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) Mul(ret, a); <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="comment">/* ============ Header Template ============ */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">90</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cost[N], bel[N];</span><br><span class="line"><span class="keyword">int</span> lnk[N], cnt, nxt[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">vi in;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> lim[N], c[N], k[N];</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(vi in)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) lim[i] = c[i] - k[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt / <span class="number">2</span>) <span class="keyword">if</span> (in[i]) --lim[bel[i]];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="keyword">if</span> (lim[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(node a)</span> </span>&#123;</span><br><span class="line">  rep(i, <span class="number">1</span>, m) <span class="keyword">if</span> (a.lim[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> vis[N];</span><br><span class="line">  graph(<span class="keyword">int</span> N = <span class="number">0</span>) &#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, N + <span class="number">2</span>) lnk[i] = <span class="number">0</span>; cnt = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i])</span><br><span class="line">      <span class="keyword">if</span> (!in[i / <span class="number">2</span>]) dfs(to[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(vi in)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) vis[i] = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Matroid &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line">  <span class="keyword">int</span> dis[N], pre[N], S, T;</span><br><span class="line">  <span class="keyword">bool</span> inq[N];</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  vi e[N];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[x].pb(y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">dt</span>, <span class="title">class</span> <span class="title">M1</span>, <span class="title">class</span> <span class="title">M2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">find</span>(<span class="title">int</span> <span class="title">n</span>, <span class="title">dt</span> <span class="title">w</span>[], <span class="title">M1</span> <span class="title">m1</span>, <span class="title">M2</span> <span class="title">m2</span>, <span class="title">vi</span> &amp;<span class="title">in</span>) &#123;</span></span><br><span class="line">    S = n + <span class="number">1</span>, T = n + <span class="number">2</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) e[i].clear();</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (in[i])</span><br><span class="line">      rep(j, <span class="number">1</span>, n) <span class="keyword">if</span> (!in[j]) &#123;</span><br><span class="line">        in[i] ^= <span class="number">1</span>, in[j] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m1.chk(in)) add(i, j);</span><br><span class="line">        <span class="keyword">if</span> (m2.chk(in)) add(j, i);</span><br><span class="line">        in[i] ^= <span class="number">1</span>, in[j] ^= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">      in[i] ^= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (m1.chk(in)) add(S, i);</span><br><span class="line">      <span class="keyword">if</span> (m2.chk(in)) add(i, T);</span><br><span class="line">      in[i] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) dis[i] = -inf, inq[i] = <span class="number">0</span>, pre[i] = <span class="number">-1</span>;</span><br><span class="line">    q.push(S), inq[S] = <span class="number">1</span>, dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">      Go(i, y, e[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = in[y] ? -w[y] : w[y];</span><br><span class="line">        <span class="keyword">if</span> (dis[y] &lt; dis[x] + v) &#123;</span><br><span class="line">          dis[y] = dis[x] + v;</span><br><span class="line">          pre[y] = x;</span><br><span class="line">          <span class="keyword">if</span> (!inq[y]) inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] == -inf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pre[T] != S) in[T = pre[T]] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">dt</span>, <span class="title">class</span> <span class="title">M1</span>, <span class="title">class</span> <span class="title">M2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">vector</span>&lt;dt&gt; <span class="title">intersaction</span>(<span class="title">int</span> <span class="title">n</span>, <span class="title">dt</span> <span class="title">w</span>[], <span class="title">M1</span> <span class="title">m1</span>, <span class="title">M2</span> <span class="title">m2</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (find(n, w, m1, m2, in));</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="keyword">using</span> <span class="keyword">namespace</span> Matroid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cas; rd(cas);</span><br><span class="line">  <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">    rd(n), rd(m);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="function">graph <span class="title">g</span><span class="params">(n + <span class="number">5</span>)</span></span>;</span><br><span class="line">    node tmp;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">      rd(tmp.c[i]), rd(tmp.k[i]);</span><br><span class="line">      rep(j, <span class="number">1</span>, tmp.c[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, w; rd(l), rd(r), rd(w); ++l, ++r;</span><br><span class="line">        g.adde(l - <span class="number">1</span>, r), g.adde(r, l - <span class="number">1</span>);</span><br><span class="line">        bel[cnt / <span class="number">2</span>] = i;</span><br><span class="line">        cost[cnt / <span class="number">2</span>] = w;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    in.clear();</span><br><span class="line">    in.resize(cnt / <span class="number">2</span> + <span class="number">5</span>);</span><br><span class="line">    vi res = Matroid::intersaction(cnt / <span class="number">2</span>, cost, g, tmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt / <span class="number">2</span>) <span class="keyword">if</span> (!in[i]) ans += cost[i];</span><br><span class="line">    <span class="keyword">if</span> (g.chk(res) &amp;&amp; tmp.chk(res) &amp;&amp; chk(tmp)) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="元旦老人与丛林"><a href="#元旦老人与丛林" class="headerlink" title="元旦老人与丛林"></a><a href="https://uoj.ac/problem/168" target="_blank" rel="noopener">元旦老人与丛林</a></h4><p>快乐的咕了。学不动了放过我吧 /dk 我要找我的 JOI 接受心灵慰藉去</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 拟阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】杨表</title>
      <link href="2021/04/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9D%A8%E8%A1%A8/"/>
      <url>2021/04/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9D%A8%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>vp 时咕掉的杨表题：</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6642" target="_blank" rel="noopener">19多校R6-three investigators</a></p><p><a href="https://codeforces.com/gym/102538/problem/D" target="_blank" rel="noopener">D-disjoint Lis</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 杨表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭电多校 2019 R6</title>
      <link href="2021/04/23/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%202019%20R6/"/>
      <url>2021/04/23/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%202019%20R6/</url>
      
        <content type="html"><![CDATA[<p>中国人何必要写英文题面为难中国人 = =</p><h2 id="Salty-Fish"><a href="#Salty-Fish" class="headerlink" title="$Salty Fish$"></a>$Salty Fish$</h2><p><a href="https://imilyx.github.io/2020/12/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/" target="_blank" rel="noopener">以前写过 ε-(´∀｀; )</a></p><h2 id="Nonsense-Time"><a href="#Nonsense-Time" class="headerlink" title="$Nonsense Time$"></a>$Nonsense Time$</h2><p>加点 LIS。每次考虑把贡献放到之后所有比自己大的点，管它 ban 没 ban？……QAQ我还是不会树套树意外的解法</p><p>离线！分治？不！注意到数据范围有「generated randomly」</p><p><a href="https://www.zhihu.com/question/266958886" target="_blank" rel="noopener">随机排列 LIS 期望长度 $\sqrt{n}$</a></p><p>倒做，若删的点在当前 LIS 就重新求 LIS。$O(n\sqrt{n} logn)$</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35876629" target="_blank" rel="noopener">$Code$</a></p><h2 id="Milk-Candy"><a href="#Milk-Candy" class="headerlink" title="$Milk Candy$"></a>$Milk Candy$</h2><p>写在「拟阵」。奶糖 <del>埃维昂</del>awa! 甜甜</p><h2 id="Speed-Dog"><a href="#Speed-Dog" class="headerlink" title="$Speed Dog$"></a>$Speed Dog$</h2><h2 id="Snowy-Smile"><a href="#Snowy-Smile" class="headerlink" title="Snowy Smile"></a>Snowy Smile</h2><p>首先一定四个边界都有点！好像可以枚举下和右边界的点，预处理上和左边界的点，然后二维数点一只 $log$？好笨啊。</p><p>正解：在框定左右边界时线段树维护纵向最大子段和, 一只 $log$。但是清真多了。</p><p>简单题想不到……</p><p>$x$ 和 $y$ 要分开离散化，不然会 T。</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35877158" target="_blank" rel="noopener">$Code$</a></p><h2 id="Faraway"><a href="#Faraway" class="headerlink" title="$Faraway$"></a>$Faraway$</h2><p>士兵 $10$ 人，坐标 $1e9$，模数 $5$。</p><p>考虑拆绝对值，$4^10$ 枚举 $(x_e, y_e)$ 在每个点的哪个方向，确定范围，crt 合并？可以是可以，但是不合法状态太多了，效率太低。</p><p>正解清真巧妙：每个点把平面划成四份，共有 $O(n^2)$ 个区域，每个区域到所有点的距离不带绝对值。<br>枚举区域，然后怎么做？crt 合并？麻烦了。</p><p>$lcm(1, 2, 3, 4, 5) = 60$，枚举 $x_e$ 和 $y_e$ 模 $60$ 的余数，$O(n)$ 判合法，$O(1)$ 计算该区域中有多少点，即可。</p><p>$O(3600n^3)$</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35881862" target="_blank" rel="noopener">$Code$</a></p><h2 id="TDL"><a href="#TDL" class="headerlink" title="$TDL$"></a>$TDL$</h2><p>心累…… 真正的乱搞题……</p><p>$m$ 只有 $1000$。打表可以发现 $f(n, m) - n$ 不超过 $1000$。</p><p>设 $p = f(n, m) - n$。$p \oplus n = k$。由于 $p 只有 1000$，影响很小，$n$ 应当在 $k$ 附近，在 $k \pm 1000$ 范围内找一下即可。</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35882023" target="_blank" rel="noopener">$Code$</a></p><h2 id="11-Dimensions"><a href="#11-Dimensions" class="headerlink" title="$11 Dimensions$"></a>$11 Dimensions$</h2><p>中国 ACM 题好没意思…… <del>完蛋我疯狂脑内循环 Mili 的「我们 在羊水 中漫 步」和「Over (over and over)」怎么办在线等急</del></p><h2 id="Stay-Real"><a href="#Stay-Real" class="headerlink" title="Stay Real"></a>Stay Real</h2><p>模拟当然没什么问题，但是性质是父亲一定比俩儿子小，按「父亲要比儿子后取」的规则最优取，其实就是从大往小取。排序后交替取即可。</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35882179" target="_blank" rel="noopener">$Code$</a></p><h2 id="Ridiculous-Netizens"><a href="#Ridiculous-Netizens" class="headerlink" title="$Ridiculous Netizens$"></a>$Ridiculous Netizens$</h2><p>事情开始变得有一丢丢意思</p><p>统计「$\prod\limits_{x \in G} w_x \leq m$」的连通子树 $G$ 的个数。</p><p>首先敏锐的注意到选了 $x$ 就必须选一溜祖先上去，这是个依赖背包问题。$dp_{i, j}$ 表示 dfs 序为 $i$ 的位置之后乘积为 $j$ 的方案数。$m$ 太大了怎么办！$&lt; \sqrt{m}$ 的权值 dp，$&gt; sqrt{m}$ 的权值只能选一个，加一维表示还能取几个 $&gt; \sqrt{m}$ 的。有一种更方便的想法是，把此时乘上那个 $&gt; \sqrt{m}$ 的值得到的 $v$ 变成 $m / v$，此后把乘都表示为除。</p><p>这样是 $O(n * n\sqrt{m})$ 的，每个点作为根做一遍 dp 太费啦，我们点分治。</p><p>我靠…… 吐了呀 xml 你别再找完 $rt$ 还 $work(y)$ 了！T 疯</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35883168" target="_blank" rel="noopener">$Code$</a></p><h2 id="Three-Investigators"><a href="#Three-Investigators" class="headerlink" title="$Three Investigators$"></a>$Three Investigators$</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EC Final 2018 vp 记录</title>
      <link href="2021/04/21/EC%20Final%202018%20vp%20%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/21/EC%20Final%202018%20vp%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/102056" target="_blank" rel="noopener">Jump!</a></p><p>题面太长了（），被吓走了…… 只做下面几题！</p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><p><del>题面长差评（你被 300iq contest 惯坏了！）</del></p><p>好题！</p><p>删是单个删，一条边价值算多次</p><p>$w$ 很小。</p><p>算一条边或一种权值的边出现次数不好做。</p><p>$ans = \sum_e w(e) = \sum\limits_{i = 1}^{30} \sum_e [w(e) \geq i]$</p><p>上面这个的意义是，加好 $&lt; i$ 的边后，形成的连通块数 $- 1$。</p><p>这个高明！<strong>不用考虑最小化边数最小化权值和什么的</strong>，直接简单维护连通性即可！很好做。</p><p>拆点并查集，当前若 $u + n$ 和 $v + n$ 连通则 $u’$ 和 $v’$ 连通，不用加边 $(u’, v’)$；否则 $u’$ 和 $v’$ 也应该连通（不用最小化边数以最小化权值和），要加边 $(u’, v’)$</p><p>实现细节：对于 $(u, v)$，要连续合并好几列的 $(u, v)$，而我们真正有机会考虑 $(u’, v’)$ 只在一开始加入，和 $u + n$ 和 $v + n$ 连通时停止加边。于是维护加边情况的差分。</p><p><strong>我们只需要知道新连通的 $(u + n, v + n)$ 数量，而不需要知道具体是哪些对。</strong></p><p>每条边只会被加一次 ban 一次，复杂度 $O(30(m + e))$。</p><p><a href="https://codeforces.com/gym/102056/submission/113734034" target="_blank" rel="noopener">$Code$</a></p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>大小为 $n$ 的本质不同析合树计数？</p><p>$dp_{i, j}$ 表示长度为 $i$ 的序列，划分成 $j$ 个连续子段的本质不同析合树个数, $f_n$ 表示大小为 $n$ 的本质不同析合树个数。</p><ul><li><p>根是合点：合点儿子数至少为 $2$，只需要把 $i$ 划分成至少 $2$ 个子段然后必然存在一种合法方案给它们拼起来</p></li><li><p>根是析点：析点儿子数至少为 $4$，只需要把 $i$ 划分成至少 $4$ 个子段然后必然存在一种合法方案给它们拼起来</p></li></ul><p>$f_i = \sum\limits_{k \geq 2, \sum a_k = i} \prod\limits_{j = 1}^k f(a_k) + \sum\limits_{k \geq 4, \sum a_k = i} \prod\limits_{j = 1}^k f(a_k)$</p><p>维护一下子段个数 $= 2$、$= 3$、$\geq 4$ 三类即可, $O(n^2)$</p><p><a href="https://codeforces.com/gym/102056/submission/113821077" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p>$\mu$……？所有完全平方数的倍数一定为 $0$！</p><p>暴枚显然不行……</p><p>$200$ 以内的质完全平方数有 $4$ $9$ $25$ $49$ $121$ $169$</p><p>考虑 $a^k \equiv p + i \pmod{lcm(4, 9, 25, 49) = 44100}$（不取 $121$、$169$ 是为了让 $lcm$ 大小刚好，其余的位置可以后面 check）</p><p>枚举 $p \mod 44100$ 的余数，在合法的余数处枚举倍数并 $check$。合法的余数很少，完全跑不满。可以加一些剪枝和卡时。</p><p><a href="https://codeforces.com/gym/102056/submission/113823126" target="_blank" rel="noopener">$Code$</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>神仙题。</p><p>当 $hp = 1$ 且接下来俩都是 $-1$ 就死了。</p><p>分开做，最后暴力合并。</p><p>倒着 dp，状态为当前后缀和，碰到一个 $-1$ 的时候，大于 $0$ 的后缀和要清零。</p><p>不懂的话，画折线图。</p><p>非常神奇，这样可以保证每对 $-1$ 前的前缀和 $&gt; 0$。$F \times F$ 显然，$F \times G$ 呢？后缀与前缀的折线关于 $x$ 轴对称，小于 $0$ 的后缀和被延续下来，其实就是前缀和 $&gt; 0$。</p><p>特殊情况是，如果最终结果是 $0 + 0$，中途不能小于 $0$。</p><p><a href="https://codeforces.com/gym/102056/submission/113878423" target="_blank" rel="noopener">$Code$</a></p><h2 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h2><p>很神仙的构造题，先咕了</p><h2 id="H"><a href="#H" class="headerlink" title="$H$"></a>$H$</h2><p>咕咕咕</p><h2 id="J"><a href="#J" class="headerlink" title="$J$"></a>$J$</h2><p>啊这…… <a href="https://dev.xjoi.net/contest/1629/problem/1" target="_blank" rel="noopener">模拟赛搬过的题</a></p><p>lcp，反建 SAM。</p><p>考虑合并，$ans = \min( lans <em> x + (1 - x) </em> h, rans <em> (1 - x) + x </em> h )$，$X$ 形函数下表面，相交处即相等处最大。所以子树答案相等时答案最大。比例分配一下。</p><p>和某 THUPC2020-切糕 很像。</p><p><a href="https://codeforces.com/gym/102056/submission/113825621" target="_blank" rel="noopener">$Code$</a></p><h2 id="K"><a href="#K" class="headerlink" title="$K$"></a>$K$</h2><p>询问有多少区间存在子序列可以凑出 $k$ 级。</p><p>$2^k$ 个 $w$ 级可以凑一个 $w + k$ 级</p><p>$k$ 只有 $log$！然而你还是不知道怎么做。</p><p>以每个位置为左端点，合成某个 $k$ 的子区间数量只要求出对应的最小右端点就行了。</p><p>所以考虑 dp：$f[i, j]$ 表示 $i$ 位置要合成 $j$ 至少往后延伸多少距离</p><p>$f[i, j] = \min( f[f[i, j - 1] + 1, j - 1], nxt[i, j] )$</p><p>$nxt[i, j]$ 表示 $i$ 后第一个 $j$</p><p>对于询问 $(l, r, k)$，二分出满足 $f_{p, k} \leq r$ 的最大 $p$，$ans = \sum\limits_{i \in [l, p]} (r + 1 - f[i, k]) = (p - l + 1) * (r + 1) - \sum\limits_{i \in [l, p]} f[i, k]$</p><p>我们需要知道 $Q$ 个区间的 $\sum f[, k]$</p><p>对于每个 $k$，$f[i, k]$ 的位置单调不减，即是若干个连续段。</p><p><del>大胆猜测</del>对于所有的 $k$，$f[i, k]$ 形成的连续段数之和是 $O(nlogn)$ 级别，因为每次新生成的段数在倍增作用下只会影响 $log$ 层</p><p>于是挨段挨段二分连续段边界即可，每层会在上一层的基础上加入一些 $nxt[i, j]$ 代表的端点形成的新段。$O(nlog^2n)$</p><p><a href="https://codeforces.com/gym/102056/submission/113868709" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UNR 2 题解</title>
      <link href="2021/04/21/UNR%202%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/04/21/UNR%202%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="积劳成疾"><a href="#积劳成疾" class="headerlink" title="积劳成疾"></a>积劳成疾</h2><p>最大值这种东西的 dp，考虑删去最大值的类笛卡尔树思想。</p><p>$f[i, j]$ 表示长度为 $i$ 的区间，最大值不超过 $j$ 的价值和</p><p>$f[i, j] = f[i, j - 1] + \sum\limits_{k = 1}^{i} f[k - 1, j] * f[i - k][j - 1] * w[j]^{跨过 k 的区间个数}$</p><p><a href="https://uoj.ac/submission/470867" target="_blank" rel="noopener">$Code$</a></p><h2 id="梦中的题面"><a href="#梦中的题面" class="headerlink" title="梦中的题面"></a>梦中的题面</h2><p>数位 dp？感觉巨大麻烦</p><p>先不管大数，考虑经典容斥：</p><p>$$ans = \sum\limits_{S = 0}^{2^m - 1} (-1)^{|S|} \binom{n + c * |S| - |S| - \sum\limits_{i \in S} b^i + m}{m}$$</p><p>接下来都设 $n$ 表示原来的 $n + c * |S| - |S|$</p><p>设 $n’ = n - \sum\limits_{i \in S} b^i$</p><p>枚举 $|S|$，把 $n$ 算出来。</p><p>大组合数不好搞。</p><p>注意到 $\binom{n’ + m}{m}$ 是个关于 $n’$ 的 $m$ 次多项式，我们可以算出所有个数为 $|S|$ 的 $n’$ 的 $k$ 次方和，系数预处理即可。</p><p>$dp[i, j, k]$ 表示前 $i$ 个选了 $j$ 个位置的 $k$ 次方和。</p><p>**直接把 $n$ 拼进去没法保证 $n’ \geq 0$**。呜呜。</p><p>所以还要枚举 $\sum\limits_{i \in S} b^i$ 是从哪位开始小于 $n$ 的，后面的就可以任选了。有救就好。等于的情况判一下。</p><p>那就要先转 $b$ 进制了。麻烦。</p><p>$O(m^4)$。</p><p>upd：细节一大堆！！大概是我最近最刚的一次。调大半天了，孩子傻了谢谢。AC 了，感动。长是长了点，但是跑的贼特喵快！！哼这是胜利。</p><p>细节有在代码里注明。</p><p><a href="https://uoj.ac/submission/473827" target="_blank" rel="noopener">$Code$</a></p><p>本题 $c \in {0, 1}$，有做法是分 $0$、$1$ 讨论的（$c = 1$ 时分位讨论，数位 dp；$c = 0$ 时再加一维表示之前 $x_i = b^i$ 的个数），相比之下好像细节也不少…… QAQ 然而完全可以拓展到 $c \leq M$ 嘛。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UNR 1 题解</title>
      <link href="2021/04/20/UNR%201%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/04/20/UNR%201%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="争夺圣杯"><a href="#争夺圣杯" class="headerlink" title="争夺圣杯"></a>争夺圣杯</h2><p>求所有 $m$，所有长度为 $m$ 的区间的 $max$ 值之和，之 $xor$ 和。</p><p>当前在某个 $i$，设 $p = \min(i - L_i, R_i - i)$, $q = \max(i - L_i, R_i - i)$，对下面这三个区间的贡献：</p><ul><li>$len \in [p, q]: hp_i * p$</li><li>$len \in [1, p - 1]: hp_i * len$</li><li>$len \in [q + 1, p + q - 1]: hp_i * (p - (len - q))$</li></ul><p>就是加一次函数。前缀和随便做？</p><p>👇这个 sb 因为忘记取模 WA 了一发= = 所以读题要仔细啊！！！</p><p><a href="https://uoj.ac/submission/470795" target="_blank" rel="noopener">$Code$</a></p><h2 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a>合唱队形</h2><p>$n = m$ 时，假设总共有 $p$ 节课，当前有 $r$ 个人。那么拓展到 $r + 1$ 的概率就是 $\frac{m - r}{p}$，期望次数是 $\frac{p}{m - r}$, $ans = \sum\limits_{i = 0}^{m - 1} \frac{p}{m - i}$</p><p>设 $t_i$ 表示以第 $i$ 个人为开头的队形组成的期望时间，min-max 容斥，现在要算 $\max(t_i)$。显然答案只和课程数有关！</p><ul><li>$n - m + 1$ 较小时，$O(n2^{n - m + 1})$ 暴枚即可，就和 $n = m$ 一样算。</li><li>$n - m + 1$ 较大，就是说 $m$ 比较小，可以考虑 dp：$f_{i, j, k}$ 表示到第 $i$ 个人，$i$ 前 $m$ 个人为开头的队形选择状态为 $j$，有 $k$ 个课程要教的方案数（是带 min-max 容斥系数的）</li></ul><p>题还不错，就是做法割裂开了，有点降好感诶 = =</p><p><a href="https://uoj.ac/submission/465915" target="_blank" rel="noopener">$Code$</a></p><h2 id="火车管理"><a href="#火车管理" class="headerlink" title="火车管理"></a>火车管理</h2><p>区间压栈，单点弹栈，区间询问栈顶</p><p>$1$、$3$ 操作一棵线段树，$2$ 操作一棵主席树。主席树存时间，得到的时间也可以作为下标查询某位置的上一个版本。</p><p>代码咕了。</p><p>wangyisong1996 给出了一个二叉树的神仙做法，待补。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】五边形数</title>
      <link href="2021/04/20/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/"/>
      <url>2021/04/20/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>小清新生成函数，vp 做到题来学一发</p><h2 id="五边形数"><a href="#五边形数" class="headerlink" title="五边形数"></a>五边形数</h2><p>$f_1 = 1, f_n = f_{n - 1} + 3n - 2$</p><p>$f_n = \frac{n(3n - 1)}{2}$</p><p>前几项：$0, 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57, 70, 77, 92, 100, 117, 126, 145, 155, \cdots$</p><p><a href="http://oeis.org/A001318" target="_blank" rel="noopener">oeis: $A001318$</a></p><h2 id="广义五边形数"><a href="#广义五边形数" class="headerlink" title="广义五边形数"></a>广义五边形数</h2><p>$n$ 可以非正。</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\phi(x) = \prod\limits_{i = 1}^{+\infty} (1 - x^i)$</p><h2 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h2><p>$\phi(x) = 1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15} \cdots$</p><p>$= 1 + \sum\limits_{i = 1}^{+\infty} (-1)^i ( x^{\frac{i(3i - 1)}{2}} + x^{\frac{-i(-3i - 1)}{2}} )$</p><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><p>定义整数划分为将整数 $n$ 划分为若干正整数之和。</p><p>生成函数显然为 $G(x) = \prod \limits_{i = 1}^{+\infty} \frac{1}{1 - x^i}$</p><p>$G \times \phi = 1$</p><p>就是对 $\phi$ 求逆啦。暴力展开，得：</p><p>$G(1) = 1$, $G(n) = G(n - 1) + G(n - 2) - G(n - 5) - G(n - 7) + \cdots$</p><p>直接做，枚举五边形数，$O(n \sqrt{n})$</p><p>例题：<a href="https://codeforces.com/gym/102268/problem/G" target="_blank" rel="noopener">300iq contest 1 G Graph Counting</a> sol 见 vp 记录</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 五边形数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300iq contest 1 vp 记录</title>
      <link href="2021/04/19/300iq%20contest%201%20vp%20%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/19/300iq%20contest%201%20vp%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>老年退役选手<del>体验生活</del> 听说 Gym 很好玩？！</p><p>写的顺序就是开题顺序 QwQ</p><h2 id="Free-Edges"><a href="#Free-Edges" class="headerlink" title="$Free Edges$"></a>$Free Edges$</h2><p>就是要切成树，每个连通块答案为 $E - (V - 1)$。</p><p><a href="https://codeforces.com/gym/102268/submission/113449450" target="_blank" rel="noopener">$Code$</a></p><h2 id="Best-Subsequences"><a href="#Best-Subsequences" class="headerlink" title="$Best Subsequences$"></a>$Best Subsequences$</h2><p>最小值一定会取，为什么，考虑 shift 到开头。</p><p>二分答案。</p><p>$dp_i$ 表示以 $i$ 结尾最多能取多少个，权值线段树维护即可。</p><p><a href="https://codeforces.com/gym/102268/submission/113449822" target="_blank" rel="noopener">$Code$</a></p><h2 id="Cool-Pairs"><a href="#Cool-Pairs" class="headerlink" title="$Cool Pairs$"></a>$Cool Pairs$</h2><p>两个都动，太蛋疼了，考虑让 $a$ 为 $-n$ ~ $-1$</p><p>考虑让一段前缀（按大小顺序）的 $b$ 的贡献都为 $q_i - 1$，即让这些 $b_i$ 都 $= 0$</p><p>剩下的补齐。</p><p><a href="https://codeforces.com/gym/102268/submission/113450575" target="_blank" rel="noopener">$Code$</a></p><h2 id="Dates"><a href="#Dates" class="headerlink" title="$Dates$"></a>$Dates$</h2><p>很「流」。</p><p>瞄一眼数据范围，$3e5$！hoho 模拟费用流！</p><p>建出费用流模型，发现跑最大费用最大流的话，退流后边权为负，必不会被跑，对应着说明按价值从大往小放没有毛病。</p><p>Hall 定理判能否加入。</p><p>设 $b_i$ 表示第 $i$ 个女孩子是否选</p><p>由于 $L_i \leq L_{i + 1}$, $R_i \leq R_{i + 1}$</p><p>我们要满足 $\min\limits_{l, r} ( a_{R_r} - a_{L_l - 1} - \sum\limits_{i = l}^r b_i ) \geq 0$</p><p>区间子段最小值可以线段树维护。</p><p><a href="https://codeforces.com/gym/102268/submission/113452120" target="_blank" rel="noopener">$Code$</a></p><hr><p>接下来好像难度差不多 <del>（都挺难）</del>，顺序开！</p><p>upd：</p><p>都不会，都要膜题解【绝望】</p><hr><h2 id="Angel-Beats"><a href="#Angel-Beats" class="headerlink" title="$Angel Beats$"></a>$Angel Beats$</h2><p>爷不会带花树，咕咕咕（可能没有下次一定）</p><h2 id="Expected-Value"><a href="#Expected-Value" class="headerlink" title="$Expected Value$"></a>$Expected Value$</h2><p>数数题！啊~这，300iq 啥都有！我只会高消……</p><p>膜一发题解 ——BM！啊学过的全忘了。</p><p>$f_i$ 表示 $Pr[t \geq i]$。$ans = \sum f_i$</p><p>$g_{i, j}$ 表示走 $i$ 步到 $j$ 的概率，$f_i = \sum\limits_{j = 1}^{n - 1} g_{i, j}$</p><p>$g$ 的转移是个矩乘，考虑 BM 求出 $f$ 的递推式 $C$</p><p>设 $f$ 生成函数为 $F$，那么有 $F = F * C + F_0$（$F_0$ 是预处理的前 $O(n)$ 项）</p><p>答案是 $F(1) = \frac{F_0(1)}{1 - C(1)}$</p><p>好妙 qwwwwq！</p><p><a href="https://codeforces.com/gym/102268/submission/113480582" target="_blank" rel="noopener">$Code$</a></p><h2 id="Graph-Counting"><a href="#Graph-Counting" class="headerlink" title="$Graph Counting$"></a>$Graph Counting$</h2><p>定理题，打不过；数学题，打不过！</p><p>太绝望了…… 权当学习了……</p><p>$tutte-berge$ 定理：一个图 $G = (V, E)$ 的最大匹配的大小等于 $\frac{1}{2} \min\limits_{U \subseteq V} ( |U| - odd(G - U) + |V| )$。$odd(G)$ 表示 $G$ 中具有奇数个顶点的连通块个数</p><p>必要性显然，充分性不会（<a href="https://baike.baidu.com/item/%E5%A1%94%E7%89%B9%E5%AE%9A%E7%90%86/53987625?fr=aladdin" target="_blank" rel="noopener">百度百科</a> 给出了证明</p><p>具体来说，我们考虑所有度数为 $|V| - 1$ 的点组成的集合 $S$，那么剩下的一定是 $|S| + 2$ 个奇团</p><p>枚举 $|S|$，剩下的相当于把 $2n - |S|$ 分成 $|S| + 2$ 个奇数；</p><p>相当于把 $2n - 2|S| - 2$ 分成 $|S| + 2$ 个偶数；</p><p>相当于把 $n - |S| - 1$ 分成 $|S| + 2$ 个非负整数；</p><p>相当于把 $n + 1$ 分成 $|S| + 2$ 个正整数；</p><p>即，求把 $n + 1$ 分成 $\geq 2$ 个正整数的方案数。</p><p>分拆数可以用五边形数求。<br>那是个啥？【学习笔记】里有。</p><p>$O(n \sqrt{n})$。$5s$ 还是能跑滴！</p><p><a href="https://codeforces.com/gym/102268/submission/113571306" target="_blank" rel="noopener">$Code$</a></p><h2 id="Hall’s-Theorem"><a href="#Hall’s-Theorem" class="headerlink" title="$Hall’s Theorem$"></a>$Hall’s Theorem$</h2><p>构造 2/2…… 想不到啊 QAQ……</p><p>你会什么？你只会向前缀连边！</p><p>考虑第 $i$ 个点向前 $a_i (a_i \leq i)$ 个点连边，满足 $a_i \leq a_{i + 1}$，这样前 $i$ 个点的 $|N(A)| = a_i$</p><p>好的集合个数为 $\sum\limits_{i = 1}^n \sum\limits_{j = 0}^{a_i - 1} \binom{i - 1}{j}$（也就是枚举并强制第 $i$ 个点必选）</p><p>随便构造即可！！！</p><p>好háo嗨hāi哦ǒu。</p><p><a href="https://codeforces.com/gym/102268/submission/113482988" target="_blank" rel="noopener">$Code$</a></p><h2 id="Interesting-Graph"><a href="#Interesting-Graph" class="headerlink" title="$Interesting Graph$"></a>$Interesting Graph$</h2><p>小清新简单题。</p><p>不合法的集合，所有点对的路径都在集合内。也就是说该图所有连通块大小 $&lt; 7$。</p><p>算出每个连通块用若干种颜色的方案数，然后暴力合并。</p><p>点数 $&lt; 7$ 的本质不同连通块很少，所以本质相同的连通块要一起算掉不然会 T。</p><p><a href="https://codeforces.com/gym/102268/submission/113569003" target="_blank" rel="noopener">$Code$</a></p><h2 id="Jealous-Split"><a href="#Jealous-Split" class="headerlink" title="$Jealous Split$"></a>$Jealous Split$</h2><p>结论题，打不过</p><p>结论：一定存在合法方案，并且方案就是使得每段平方和最小</p><p>证明：考虑相邻两段和为 $a$、$b$，$x$ 是 $a$ 最右边的值或 $b$ 最左边的值</p><ul><li>$a - b \leq x$：显然合法</li><li>$a - b &gt; x$：令 $a = a - x$，$b = b + x$，趋于合法，且平方和变小</li></ul><p>考虑 wqs 二分。但是调物体额外权值的时候可能会跳过正确答案。怎么办呢？</p><p>可以合法形成的段个数一定是一个连续区间，我们要尽量让这个区间包含 $K$。</p><p>求出以每个位置结尾可以分的段个数区间。</p><p><a href="https://codeforces.com/gym/102268/submission/113512492" target="_blank" rel="noopener">$Code$</a></p><h2 id="Knowledge"><a href="#Knowledge" class="headerlink" title="$Knowledge$"></a>$Knowledge$</h2><p>做过一遍的题，再碰到还是不会（</p><p>暴搜 + 手玩，只有 $12$ 种初始串</p><p>给定串不管怎么操作，其对应的初始串都是不变的。</p><p>手玩初始串间的转移，矩乘即可。</p><p><a href="https://codeforces.com/gym/102268/submission/113564999" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】析合树</title>
      <link href="2021/04/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%90%E5%90%88%E6%A0%91/"/>
      <url>2021/04/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%90%E5%90%88%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>好嘛，最近新学的算法有点多。我所理解的「退役不留遗憾」就是，想学的算法、想做的题都学了、做了。更高一点的梦想——在赛场上驰骋，这…… 我控制不了哈……</p><p><a href="https://oi-wiki.org/ds/divide-combine/" target="_blank" rel="noopener">OI-wiki</a></p><p>大概解决排列中的连续段问题。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>本原连续段：是个连续段，且排列 P 的连续段集合里不存在「与之相交且不是包含关系」的连续段。排列 P 的析合树由 P 的<strong>所有</strong>本原连续段组成。</li><li>儿子序列：每个儿子体现为值域区间。</li><li>儿子排列：依照儿子序列离散化得到的排列。</li><li>合点：儿子排列为顺序或逆序的点。特别的，<strong>叶子为合点。</strong></li><li>析点：非合点。</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>合点：任取儿子序列的一个区间，并集都构成一个连续段。</li><li>析点：任取儿子序列的一个区间（区间长度 $&gt; 1$），并集都不构成一个连续段。</li></ul><p>合点性质显然，析点性质考虑反证：若存在这些个区间，取其中最长的，构成的并集是本原连续段，因为 P 中不存在与它相交且不是包含关系的连续段，但它又不在析合树中，与「析合树由所有本原连续段组成」矛盾。</p><p>还是挺直观的。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>就学 $O(nlogn)$ 的。（OI-wiki 的图太顶了）</p><p>增量法，即挨个加点。用栈维护析合森林。当前加入 x，栈顶为 y。重复下列步骤若干次直到栈空或都不满足。（接下来按顺序判每项，即：若之前都不可，且满足……，则……）</p><ol><li>x 能成为 y 新的儿子（即 y 的最后一个儿子和 x 能成为连续段），把 x 挂入 y 的子树并递归下挂。</li><li>x 能和 y 成为兄弟（即 y 和 x 能成为连续段），新生成点 z 作为 x 和 y 的共有父亲</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 析合树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 2021 补题</title>
      <link href="2021/04/14/USACO%202021%20%E8%A1%A5%E9%A2%98/"/>
      <url>2021/04/14/USACO%202021%20%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JOI 做题记录</title>
      <link href="2021/04/13/JOI%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/13/JOI%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="断层"><a href="#断层" class="headerlink" title="断层"></a><a href="https://loj.ac/p/2346" target="_blank" rel="noopener">断层</a></h3><p>时光倒流，地表下沉，考虑追踪所有位置，一次操作导致被追踪位置的一段前缀 $x$ 减小、一段后缀 $x$ 增大。</p><p>考虑用某种 DS 维护这些位置，将一段前缀坐标同时加上 $(-l, -l)$ 或将一段后缀同时加上 $(+l, -l)$</p><p>为了找前后缀的分界线，我们需要二分找到最后一个被板块运动影响的被追踪位置。$45$ 度的斜率还是挺良心的 qwq</p><p>怎么加？<strong>维护差分序列</strong>，那么就是单点加，前缀和查询，树状数组 + 二分即可。</p><p><a href="https://loj.ac/s/1113591" target="_blank" rel="noopener">$Code$</a></p><h3 id="火车旅行"><a href="#火车旅行" class="headerlink" title="火车旅行"></a><a href="https://loj.ac/p/2395" target="_blank" rel="noopener">火车旅行</a></h3><p>唯一的性质就是从 $s$ 到 $t$ 一定是先走一段上升路再走一段下降路。倍增预处理，下降路可以反跳。</p><p><a href="https://loj.ac/s/1114165" target="_blank" rel="noopener">$Code$</a></p><h3 id="焚风现象"><a href="#焚风现象" class="headerlink" title="焚风现象"></a><a href="https://loj.ac/p/2332" target="_blank" rel="noopener">焚风现象</a></h3><p>简单 BIT 题。不加快读后俩 subtask 过不去？？</p><p><a href="https://loj.ac/s/1114241" target="_blank" rel="noopener">$Code$</a></p><h3 id="JOIOI王国"><a href="#JOIOI王国" class="headerlink" title="JOIOI王国"></a><a href="https://loj.ac/p/2334" target="_blank" rel="noopener">JOIOI王国</a></h3><p>简单题，答案肯定是阶梯状，mx 和 mn 被分在两边。二分答案，mx 一边的 min 要大于等于 mx - lim，mn 一遍的 max 要小于等于 mn + lim，那么预处理前后缀 max/min，分两种阶梯方向、两种 mx 和 mn 的位置讨论。</p><p><a href="https://loj.ac/s/1115152" target="_blank" rel="noopener">$Code$</a></p><h3 id="地牢3"><a href="#地牢3" class="headerlink" title="地牢3"></a><a href="https://loj.ac/p/3472" target="_blank" rel="noopener">地牢3</a></h3><p>JOI(SC) 的题考思维和逻辑啊，这段日子多做吧！写起来还挺爽。最近的出题趋势啊，哎~</p><p>这种题一看就得警惕起来——不列关系式搞不定。</p><p>画在数轴上，设 $X_i = \sum\limits_{j &lt; i} A_j$</p><p>每个 $B_i$ 覆盖的范围是 $[X_i, X_i + U)$，暴力做就是直接区间取 $\min$ 然后求和。</p><p>但显然有单调栈关系。第 $i$ 个区间覆盖的实际是 $[L_i, R_i] = [\max(X_i, X_{pre} + U), \min(X_i + U, X_{nxt})]$ 其中 $pre$ 和 $nxt$ 是最近的两个 $B &lt; B_i$ 的位置。$ans = \sum_i B_i * (R_i - L_i)$</p><p>容易算出从每个 $S$ 到 $n + 1$ 的答案，而 $S$ 到 $T$ 的答案减去覆盖了 $T$ 的那个区间多覆盖的部分即可。</p><p>倒做，离散化，BIT 维护 $ans$</p><p>hint：$L &lt; R$ 当且仅当 $X_{nxt} - X_{pre} &gt; u$。</p><p><a href="https://loj.ac/s/1115256" target="_blank" rel="noopener">$Code$</a></p><h3 id="门票安排"><a href="#门票安排" class="headerlink" title="门票安排"></a><a href="https://loj.ac/p/2393" target="_blank" rel="noopener">门票安排</a></h3><p>看题解.gif</p><p>来复读啦</p><p>考虑两个被反转的区间如果无交那一定不优。因此所有被反转的区间都有公共部分。</p><p>设公共部分为 $[l, r]$，$a_i$ 为都不反转时的覆盖次数，$b_i$ 为最终的覆盖次数，$t$ 为 $[l, r]$ 中 $b$ 最大的位置</p><p>有三个定理：</p><ol><li><p>$b_t \geq \max(b_i) - 1$</p><p> 反证：如果 $b_t \leq \max(b_i) - 2$ 那么反转一个 $[l, r]$ 的区间答案不会变劣。</p></li><li><p>$a_t = \max(a_i)$</p><p> 反证：若存在 $a_p &gt; a_t$ 且 $p \notin [l, r]$，根据定义至少存在一个区间不包含 $p$，即 $a_p - b_p \leq a_t - b_t - 1$，$b_p - b_t \geq a_p - a_t + 1$, $b_p - b_t \geq 2$，与定理 $1$ 矛盾。</p></li><li><p>$\forall a_k = \max(a_i), k \in [l, r]$</p><p> 证明类似定理 $2$。</p></li></ol><p>二分答案 $ans$, $ans = b_t = a_t - 反转个数 cnt$ 或 $ans = b_t + 1 = a_t - cnt + 1$</p><p>关于判定，$ans$ 确定了 $cnt$ 也就确定了，chk 能否在 $cnt$ 次内完成。从左到右扫，当前位置 $i$，每次把 $l \leq i$, $r \geq t$ 的区间加入以 $r$ 为第一关键字的大根堆。设还应反转区间个数为 $x$，若 $a_i - (cnt - x) + x &gt; ans$ 则弹出并反转堆顶区间。那么当前已反转个数能算出，不足就补。</p><p>至于正确性，性感理解一下，优先反转 $r$ 大的对后续最有利且负面影响最小。</p><p><a href="https://loj.ac/s/1115604" target="_blank" rel="noopener">$Code$</a></p><h3 id="长途巴士"><a href="#长途巴士" class="headerlink" title="长途巴士"></a><a href="https://loj.ac/p/2396" target="_blank" rel="noopener">长途巴士</a></h3><p><del>话说 JOI 的题，堆啊贪心啊取模啊都运用得很溜诶</del></p><p>把人和服务站都拍在 $[0, T)$ 的数轴上。接下来的顺序都是按数轴来。</p><p>考虑怎么踢掉不想要的人，如果存在 $S_j \mod T \in (D_i, D_{i + 1})$ 那就可以成功踢走 $[x, i] (1 \leq x \leq i)$ 的人。踢人肯定是一段一段踢，并且每段在对应最早的 $j$ 出现时踢。</p><p>就可以设计 dp：$f_i$ 表示考虑数轴上前 $i$ 个乘客的最小花费，根据 $i$ 选不选有两种转移：</p><ul><li><p>$f_i = f_{i - 1} + (\lfloor \frac{X - D_i}{T} \rfloor + 1) * W$</p></li><li><p>$f_i = \min\limits_{0 \leq j &lt; i}( f_j + calc(j + 1, i) )$，其中 $calc(l, r) = (r - l + 1) <em> W </em> ( \min\limits_{S_k \mod T \in (D_r, D_{r + 1})}( \lfloor \frac{S_k}{T} \rfloor ) + (preC_{r} - preC_{l - 1}) )$</p></li></ul><p>斜优即可。</p><p><a href="https://loj.ac/s/1115742" target="_blank" rel="noopener">$Code$</a></p><h3 id="幽深府邸"><a href="#幽深府邸" class="headerlink" title="幽深府邸"></a><a href="https://loj.ac/p/2397" target="_blank" rel="noopener">幽深府邸</a></h3><p>为什么「幽深府邸」原文是「细长的屋敷」啊【/笑cry】本题是某 HNOI2018 的非严格加强版。原题写了线段树一只 $log$，但是暴力更新 + 二分也是一只 $log$ 的，而且好写到不知道哪里去了</p><p>复杂度证明的话，每个位置只会被最小区间统计一次。</p><p><a href="https://loj.ac/s/1115989" target="_blank" rel="noopener">$Code$</a></p><h3 id="自然公园"><a href="#自然公园" class="headerlink" title="自然公园"></a><a href="https://loj.ac/p/2398" target="_blank" rel="noopener">自然公园</a></h3><p>神仙交互题，做不来做不来</p><p>$Ask(x, y, P)$ 表示能否只用 $P$ 中的点使 $x$ 和 $y$ 连通。</p><p>可能的使用姿势：询问一堆点的补集以确定这些点中是否有必经点。</p><ul><li>链怎么做？考虑分治做 $[l, r]$，询问 $O(lstlen)$ 次确定夹在 $[l, r]$ 中的点然后取一个中点 $mid$，递归做，$O(nlogn)$。</li><li>树怎么做？考虑以 $x$ 为根的连通块，每次找一个块外点 $z$，找到块中离 $z$ 最近的点 $y$，接下来就是做 $y \rightarrow z$ 这条链。实现用点分治。</li><li><p>图怎么做？考虑以 $x$ 为根的连通块，每次拓展块外相邻点 $x$，具体来说选一个块外点然后二分找到离块最近的。</p><p>  怎么给 $x$ 找块内与它直接相连的点？搞出块的 dfs/bfs 序，找到当前与 $x$ 连通的序最小的点，连边并删除。大概是 $n^2$ 的，询问 $nlogn$。</p></li></ul><p>细节一大堆，烦死了 /fn</p><p><a href="https://loj.ac/s/1116054" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="JOI-2018-Final"><a href="#JOI-2018-Final" class="headerlink" title="JOI 2018 Final"></a>JOI 2018 Final</h2><p>这套好水啊……</p><h3 id="团子制作"><a href="#团子制作" class="headerlink" title="团子制作"></a>团子制作</h3><p>对于两个 $G$ 如果他们不在同一东北-西南方向对角线的相邻位置是绝不会互相影响的。每条对角线单独 dp。</p><p><a href="https://loj.ac/s/1118263" target="_blank" rel="noopener">$Code$</a></p><h3 id="月票购买"><a href="#月票购买" class="headerlink" title="月票购买"></a>月票购买</h3><p>题意：给出一张无向图和 $s$，$t$，$u$，$v$，你可以钦定一条 $s \rightarrow t$ 的最短路并把路径上所有边的边权改为 $0$，然后最小化 $u \rightarrow v$ 的最短路。</p><p>显然是在所有 $s$ 到 $t$ 最短路上找两个点 $(i, j)$，满足 $u \rightarrow i \rightarrow j \rightarrow v$ 最小。</p><p>好办，枚举 $j$，求前/后缀最小即可。是否在最短路上——这不是随便判嘛？$dis[x] + w = dis[y]$！</p><p><a href="https://loj.ac/s/1118458" target="_blank" rel="noopener">$Code$</a></p><hr><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a><a href="https://loj.ac/p/3030" target="_blank" rel="noopener">考试</a></h3><p>一眼做法：设 $z = x + y$，$(x, y, z)$ 做三维偏序。没意思！</p><p>考虑几何意义：求一个两条直线和坐标轴平行、一个角被切掉的图形内包含的点数。</p><p>考虑容斥！$c = \max(c, a + b)$（这样就把 $c$ 这条限制代表的斜线移到 $(a, b)$ 右上方去啦，使得 $ans$ 中的<strong>后两项无交</strong>）</p><p>$ans = \sum [总分 &lt; c] - \sum [总分 \geq c 但 a 偏小] - \sum [总分 \geq c 但 b 偏小]$</p><p><a href="https://loj.ac/s/1118501" target="_blank" rel="noopener">$Code$</a></p><h3 id="馕"><a href="#馕" class="headerlink" title="馕"></a><a href="https://loj.ac/p/3032" target="_blank" rel="noopener">馕</a></h3><p>膜题解。优美的贪心！</p><p>预处理每个人的 $n$ 等分位置。第 $i$ 次选还没安排的人里第 $i$ 个 $n$ 等分点最小的。可以归纳证明每个时刻的右端点一定是所有方案里最小的。</p><p><a href="https://loj.ac/s/1118588" target="_blank" rel="noopener">$Code$</a></p><h3 id="两道料理"><a href="#两道料理" class="headerlink" title="两道料理"></a><a href="https://loj.ac/p/3034" target="_blank" rel="noopener">两道料理</a></h3><p>$f[i, j] = \max( f[i - 1, j] + p_i [ sa_i + sb_j \leq s_i ] (\mathbb{I}), f[i, j - 1] + q_j [ sa_i + sb_j \leq t_j ] (\mathbb{II}) )$</p><p>对每个 $i$ 处理出 $mxu_i$ 满足 $\mathbb{I}$ 中方括号成立，对每个 $j$ 处理出 $mxr_j$ 满足 $\mathbb{II}$ 中方括号成立</p><p>那么一条从 $(0, 0)$ 走到 $(n, m)$ 的路径，如果 $(i, mxu_i)$ 在路径上或路径上方就产生贡献，如果 $(mxr_j, j)$ 在路径上或路径下方就产生贡献。</p><p>$(i, j)$ 不在路径上或路径上方，即 $(i, j)$ 在路径下方，当且仅当 $(i - 1, j + 1)$ 在路径上或路径下方</p><p>$sum[i, j]$ 表示 $(i, j)$ 正下方的贡献和</p><p>$f[i, j] = \max(f[i, j - 1], f[i - 1, j] + sum[i, j])$</p><p>线段树维护前缀最大值差分，正数直接单点加，负数往后消，消不完就算了（虽然但是 我不懂复杂度怎么算……</p><p><a href="https://loj.ac/s/1118838" target="_blank" rel="noopener">$Code$</a></p><h3 id="两个天线"><a href="#两个天线" class="headerlink" title="两个天线"></a><a href="https://loj.ac/p/3033" target="_blank" rel="noopener">两个天线</a></h3><p>设坐标为 $d$</p><p>离线询问，按右端点排序。怎么统计所有 $(i, j)$ 的贡献？我们的策略是枚举 $j$，把贡献放在 $i$ 上。</p><p>$i$ 在 $i + A_i$ 时变得可用，在 $i + B_i + 1$ 时变得不可用</p><p>每次新加入一个 $j$，将 $[j - B_j, j - A_j]$ 里可用的 $i$ 上的权值对 $H_i - H_j$ 取 $\max$</p><p>实用的 trick 是让 $H_i$ 在 $i$ 可用时为其本来值，在 $i$ 不可用时为 $-\infty$</p><p>查询就查整个区间的 $i$ 的权值 $\max$</p><p>绝对值嘛，取相反数，做两遍就好了</p><p><a href="https://loj.ac/s/1119104" target="_blank" rel="noopener">$Code$</a> <del>调写的时候 sb 错误一大堆，你可能需要去上个厕所</del></p><h3 id="指定城市"><a href="#指定城市" class="headerlink" title="指定城市"></a><a href="https://loj.ac/p/3036" target="_blank" rel="noopener">指定城市</a></h3><p>维护当前的「双向边」连通块，「双向边」连通块不会再对答案有贡献</p><p>$E = 1$ 可以换根 dp 做，$E = 2$ 可以把所有的 $(x, y)$ 放到 $LCA(x, y)$ 上去统计。</p><p>设第 $i$ 次选的点集为 $S_i$，有个结论是 $i \geq 2$ 时 $S_i \subseteq S_{i + 1}$，所以之后的贪心选即可。</p><p><a href="https://loj.ac/s/1119982" target="_blank" rel="noopener">$Code$</a></p><h3 id="开关游戏"><a href="#开关游戏" class="headerlink" title="开关游戏"></a><a href="https://loj.ac/p/3037" target="_blank" rel="noopener">开关游戏</a></h3><p>性质一看一大堆。</p><p>操作序列中如果前一个是 TOG，后一个是 ON/OFF 且他们相交，可以交换顺序。</p><p>——那干脆把 ON/OFF 都排到操作序列的前段！</p><p>ON/OFF 彼此不相交。TOG 彼此显然不交。画一下图发现非常清真。</p><p>$dp_{i, 0/1/2}$ 表示第 $i$ 盏灯 未被赋值/被赋值$’0’$/$’1’$ 时需要的操作次数的两倍（为了方便统计 TOG）。</p><p>hint：串开头结尾各加一个 $’0’$ 可以少一些边界 case。</p><p><a href="https://loj.ac/s/1120146" target="_blank" rel="noopener">$Code$</a></p><h3 id="蛋糕拼接"><a href="#蛋糕拼接" class="headerlink" title="蛋糕拼接"></a><a href="https://loj.ac/p/3039" target="_blank" rel="noopener">蛋糕拼接</a></h3><p>简单题？按 $C$ 排序，显然 $C$ 只和两端位置有关，$ans = \sum V_i - 2 * ( C_M - C_1 )$<br>对于 $l_1 &lt; l_2$</p><p>感性理解新加入一个 $r$ 对 $l_1$ 产生的收益小于等于 $l_2$（$C$ 之差！），即，若对于 $r_0$，$l_2$ 优于 $l_1$，那么对于 $r \geq r_0$，$l_2$ 都优于 $l_1$。其决策单调性得证。</p><p>分治求出每个 $l$ 对应的 $r$。</p><p>区间查前 $K$ 大，主席树板子！</p><p><a href="https://loj.ac/s/1120219" target="_blank" rel="noopener">$Code$</a></p><h3 id="穿越时空-Bitaro"><a href="#穿越时空-Bitaro" class="headerlink" title="穿越时空 Bitaro"></a><a href="https://loj.ac/p/3038" target="_blank" rel="noopener">穿越时空 Bitaro</a></h3><p>DS 题！放官图：</p><p><img src="https://img-blog.csdnimg.cn/20200506225745429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RTTF9ITl8yMDAy,size_16,color_FFFFFF,t_70" alt="picture_in_Official_solution"></p><p>路线是条斜率为 $1$ 的折线。我们要最小化竖线个数。</p><p>严格上升很讨厌，将第 $i$ 列整体向下移 $i$ 单位，走路时间就变成 $0$ 了。</p><p>关于一段有始有终的路径，维护两个分段函数:</p><ul><li>$f(x)$ 表示 $x$ 时间走进去，什么时候走出来</li><li>$g(x)$ 表示 $x$ 时间走进去，使用多少次特技走出来</li></ul><p>$f(x)$ 是两段平，中间是 $y = x + k$；$g(x)$ 是前面一段平，后面是 $y = x + k$</p><p>考虑合并，发现函数形状不会改变。线段树维护。</p><p>结构体的定义是：$(l, r, x, y)$ 表示 $f(x)$ 两个端点是 $(l, x - (r - l))$ 和 $(r, x)$，$g(x)$ 端点是 $(r, y)$</p><p><a href="https://loj.ac/s/1120500" target="_blank" rel="noopener">$Code$</a></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a><a href="https://loj.ac/s/1122003" target="_blank" rel="noopener">合并</a></h3><p>感觉像分治。</p><p>我们可以通过 $2n$ 次询问将 $2n$ 个宝石分在两个集合 $A$、$B$ 中，满足相同集合内宝石种类互不相同。</p><p>考虑将 $B$ 与 $A$ 匹配。</p><p>把 $A$ pia 成两半，通过长度次询问能确定 $B$ 中元素应当在哪半。</p><p>递归下去做即可。</p><p>假设每次取前 $pn$ 个（$n$ 是当前 $A$ 长度）</p><p>$F(n) = F(pn) + F((1 - p)n) + pn + n$</p><p>$p$ 取 $\frac{3 - \sqrt{5}}{2}$ 时最优，大概询问 $980000$ 次。</p><p><a href="https://loj.ac/s/1122003" target="_blank" rel="noopener">$Code$</a></p><h3 id="回转寿司"><a href="#回转寿司" class="headerlink" title="回转寿司"></a><a href="https://loj.ac/p/2736" target="_blank" rel="noopener">回转寿司</a></h3><p>给了 $9s$，操作又不是很好维护，考虑分块（JOISC 竟然出分块题！</p><p>每个块搞个堆，散块暴力，整块删除最大值，加入新最小值即可。</p><p>考虑整块标记怎么下推。注意到标记之间的顺序没有影响，从左到右推一遍即可。</p><p>标记下推还是挺有意思的。</p><p><a href="https://loj.ac/s/1123543" target="_blank" rel="noopener">$Code$</a></p><h3 id="糖"><a href="#糖" class="headerlink" title="糖"></a><a href="https://loj.ac/p/2840" target="_blank" rel="noopener">糖</a></h3><p>第一反应决策单调性？emmmm；第二反应增广…… emm xml 你拟阵学傻了吧！第三反应反悔贪心。呼呼总算正常了。</p><p><a href="https://loj.ac/s/1125441" target="_blank" rel="noopener">$Code$</a></p><h3 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a><a href="https://loj.ac/p/2841" target="_blank" rel="noopener">图书馆</a></h3><p>做你丫的交互，劳资快乐 SCT 去了 <del>（SAM + LCT）</del></p><h3 id="女装大佬"><a href="#女装大佬" class="headerlink" title="女装大佬"></a><a href="https://loj.ac/p/2734" target="_blank" rel="noopener">女装大佬</a></h3><p>题意杀——同一分钟里，领取男女装的事件同时进行。</p><p>剩下的 M 个数需要 $\leq$ F，即，将 F 视作 $1$，M 视作 $-1$，要满足最小后缀 $\geq -1$，且要使最大的不满意值最小。</p><p>从后往前扫，小于 $-1$ 就从把前面最近的 F 拿过来，发现这样代价最小并且恰好是 $- sufmin - 1$。</p><p><a href="https://loj.ac/s/1173916" target="_blank" rel="noopener">$Code$</a></p><h3 id="道路建设"><a href="#道路建设" class="headerlink" title="道路建设"></a><a href="https://loj.ac/p/2831" target="_blank" rel="noopener">道路建设</a></h3><p>题意：求某个点到根的链的逆序对，然后对链做区间赋值</p><p>每条链可以被划分为若干权值相同的段。考虑每个颜色相同且深度递增的段维护一个 splay——就是 LCT 啦！每棵 LCT 维护子树大小也就是该颜色的个数，access 时用 BIT 记一下每种颜色的个数。复杂度分析参考 LCT。</p><p><a href="https://loj.ac/s/1177117" target="_blank" rel="noopener">$Code$</a></p><h3 id="帐篷"><a href="#帐篷" class="headerlink" title="帐篷"></a><a href="https://loj.ac/p/2833" target="_blank" rel="noopener">帐篷</a></h3><p>题意：每个点，其四个方向最多只有一个点。我们称「自由点」为四面都没有点的点。该方案的权值为 $4^{自由点数}$</p><p>只要知道了空余的行和列数就可以了？好像很难记录状态。</p><p>考虑扣掉一个自由点，空出来的一行一列删掉也不会有影响；扣掉一对点，空出来的一行两列或两行一列删掉不会有影响。</p><p>于是直接 $f[n, m]$ 表示 $n * m$ 的答案。每次新加一列，有：</p><p>$f[n, m] = f[n, m - 1] + f[n - 1, m - 1] <em> n </em> 4 + \binom{n}{2} <em> f[n - 2, m - 1] + n </em> (m - 1) * f[n - 1, m - 2]$</p><p><a href="https://loj.ac/s/1177379" target="_blank" rel="noopener">$Code$</a></p><h3 id="修行"><a href="#修行" class="headerlink" title="修行"></a><a href="https://loj.ac/p/2834" target="_blank" rel="noopener">修行</a></h3><p>再一次被计数题杀。。。</p><p>等价于有多少排列 $a_i &gt; a_{i + 1}$ 的 $i$ 个数为 $k - 1$</p><p>转化为求期望。（？？怎么想到的）</p><p>等价于 $n$ 个 $[0, 1)$ 随机变量 $a_i &gt; a_{i + 1}$ 的个数为 $k - 1$</p><p>等价于 $n$ 个 $[0, 1)$ 随机变量 $b_i$ 前缀和的小数部分，前一个大于后一个的个数为 $k - 1$</p><p>等价于求 $k - 1 \leq \sum b_i &lt; k$</p><p>容斥 $[0, 1)$ 的限制，枚举 $\geq 1$ 的个数 $i$，那么问题转化为 $n$ 个非负变量之和 $&lt; k - i$ 的方案数，$= \frac{(k - i)^n}{n!}$，大概意思是在长度为 $k - i$ 的段里选 $n$ 个节点划分 $n$ 段的方案数。</p><h3 id="最差记者-3"><a href="#最差记者-3" class="headerlink" title="最差记者 3"></a><a href="https://loj.ac/p/2836" target="_blank" rel="noopener">最差记者 3</a></h3><p><del>听说是提高组题，自己想想。</del> 最后还是看题解了 /dk</p><p>每个人的周期是可以计算的。如果当前人的周期小于上个人的周期，那他的新周期等于上个人的周期。<br>否则他的新周期 $f_i = \lceil \frac{f_{i - 1}}{d_i} \rceil$</p><p>然后就是非常神必的一步：该函数每次减少一半左右……</p><p>所以把这个分段函数存下来就行。$O(QlogD)$</p><p>实现是我最讨厌的细节！！！啊！</p><h3 id="野猪"><a href="#野猪" class="headerlink" title="野猪"></a><a href="https://loj.ac/p/2842" target="_blank" rel="noopener">野猪</a></h3><p>设某条有向路径 $path$ 的最后一条边为 $lst_{path}$</p><p>上一次 $X$ -&gt; $Y$，那么 $Y$ -&gt; $X$ 只会走：</p><ol><li>除掉 $lst_{path(x, y)}$ 的最短路 $minpath$</li><li>除掉 $lst_{path(x, y)}$ 和 $lst_{minpath}$ 的最短路</li></ol><p>相当于对于每一对点 $(X, Y)$，求出：</p><ol><li>最短路</li><li>和最短路首边不同的最短路</li><li>和最短路首边不同且和 2 末边不同的最短路</li><li>和最短路末边不同的最短路</li><li>和最短路末边不同且和 4 首边不同的最短路</li></ol><p>（23 和 45 就是反一下）</p><p>你发现就是把边当作点去求最短路嘛！</p><p><strong>菊 花 图 直接卡飞</strong>，单次 $O(m^2)$</p><p>$f[i, j]$ 表示走到 $i$ 节点，最后经过的边是 $j$ 的最小代价，发现这样总状态是 $O(n)$，转移按点来，也是 $O(n)$ 的。直接相连的点对要特殊处理。</p><p>考虑修改。并不是只会改与修改点相邻的两条路径啊！可能会波及到挺远，所以你需要——SGT！对每个区间维护以上五种类型的路径，复杂度 $O(m^2logm + 5^3 T log L)$</p><p><a href="https://loj.ac/s/1202985" target="_blank" rel="noopener">$Code$</a></p><h3 id="俄罗斯套娃"><a href="#俄罗斯套娃" class="headerlink" title="俄罗斯套娃"></a><a href="https://loj.ac/p/2729" target="_blank" rel="noopener">俄罗斯套娃</a></h3><p>显然这是个 DAG 上的偏序关系。就是求 DAG 的最小链精确覆盖。</p><p>画在 $R$ 为 $x$ 坐标、$H$ 为 $y$ 坐标的图上比较直观，询问变成一个四分之一平面</p><p>根据 Dilworth 定理，最小链精确覆盖 = 最长反链，即这题中的最长不升子序列（即 $R$ 增 $H$ 不增）</p><p>考虑离线询问和点，按 $R$ 从大到小排序，BIT 维护当前高度区间为 $[1, x]$ 的最长不升子序列</p><p><a href="https://loj.ac/s/1205615" target="_blank" rel="noopener">$Code$</a></p><h3 id="饮食区"><a href="#饮食区" class="headerlink" title="饮食区"></a><a href="https://loj.ac/p/3489" target="_blank" rel="noopener">饮食区</a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】支配树</title>
      <link href="2021/04/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%94%AF%E9%85%8D%E6%A0%91/"/>
      <url>2021/04/12/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%94%AF%E9%85%8D%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zerol.me/2018/10/22/dominator-tree/#%E5%8D%8A%E5%BF%85%E7%BB%8F%E7%82%B9" target="_blank" rel="noopener"><del>不想复读了。</del></a></p><p>（注意上面博客中的大小比较都是基于 $dfn$ 的）</p><p>求 $semi$，就根据 $semi$ 性质中最后一条来，由于 $semi \leq$ 「所有祖先链上的最小 $semi$」，用带权并查集维护这个东西。还是很直观的。</p><p>求 $idom$，先把 $idom(x) = semi(x)$ 的确定下来，剩下的记录 $x$ 同哪个 $t$ 相同，最后正推一遍即可。</p><p>luogu 模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], rg[N], buc[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dominater &#123;</span><br><span class="line">    <span class="keyword">int</span> dfn[N], clk, rdfn[N], fa[N];</span><br><span class="line">    <span class="keyword">int</span> semi[N], idom[N], best[N], c[N];  <span class="comment">// best 是带权并查集上维护链最小 semi 位置的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">            c[i] = <span class="number">-1</span>;</span><br><span class="line">            buc[i].clear();</span><br><span class="line">            semi[i] = best[i] = i;  <span class="comment">// 初始化先设为自己</span></span><br><span class="line">            dfn[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = ++clk, rdfn[clk] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[x][i]; <span class="keyword">if</span> (!dfn[y]) fa[y] = x, dfs(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> &amp;f = c[x], t = fix(f);</span><br><span class="line">        <span class="keyword">if</span> (dfn[semi[best[x]]] &gt; dfn[semi[best[f]]]) best[x] = best[f];</span><br><span class="line">        <span class="keyword">return</span> f = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        dfs(rt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = clk; i; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rdfn[i], mn = clk + <span class="number">1</span>;  <span class="comment">// mn: 祖先链上最小的 semi</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rg[x].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = rg[x][j];</span><br><span class="line">                <span class="keyword">if</span> (!dfn[u]) <span class="keyword">continue</span>;  <span class="comment">// 可能无法到达所有点</span></span><br><span class="line">                fix(u);</span><br><span class="line">                mn = min(mn, dfn[semi[best[u]]]);</span><br><span class="line">            &#125;</span><br><span class="line">            c[x] = fa[x];</span><br><span class="line">            semi[x] = rdfn[mn], buc[semi[x]].pb(x);</span><br><span class="line">            x = rdfn[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc[x].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = buc[x][j];</span><br><span class="line">                fix(u);</span><br><span class="line">                <span class="keyword">if</span> (semi[best[u]] != x)  <span class="comment">// 此处 best[u] 为 idom 性质第二条中的 t</span></span><br><span class="line">                    idom[u] = best[u];  <span class="comment">// 先指向 t，之后正推一遍得到所有 idom</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    idom[u] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            buc[x].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        buc[<span class="number">1</span>].clear();</span><br><span class="line">        rep(i, <span class="number">2</span>, clk) &#123;  <span class="comment">// 正推啦</span></span><br><span class="line">            <span class="keyword">int</span> x = rdfn[i];</span><br><span class="line">            <span class="keyword">if</span> (idom[x] != semi[x])  <span class="comment">// 此时的 idom[x] 是 t</span></span><br><span class="line">                idom[x] = idom[idom[x]];</span><br><span class="line">            buc[idom[x]].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dominater;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init();</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        g[x].pb(y), rg[y].pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    work(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    per(i, clk, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rdfn[i];</span><br><span class="line">        num[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc[x].size(); j++) &#123;</span><br><span class="line">            num[x] += num[buc[x][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 支配树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2021 游记</title>
      <link href="2021/04/10/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892021%20%E6%B8%B8%E8%AE%B0/"/>
      <url>2021/04/10/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892021%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>爆炸了爆炸了，考场上不知道怎么回事。T1 啥都没想到，人傻了。</p><p>大众分 200，我 66 + ?，太好笑了。</p><p>所以思维基本是没有提升。总不全是考场 debuff 的锅吧！</p><p>不过怎么说呢，我也不后悔这些日子学数数。</p><p>【听天由命.jpg】</p><p>怎么办啊我好废啊 类目啊</p><p>qy：不要患得患失</p><p>那…… 好呗</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>A 了 T1，结果赛后一测发现正解没锅，暴力锅了！！！我暴力的 20 分呐！！！没了 /dk</p><p>所以两天都没有大众分。总分大概 hcy 一天的分都没有。（upd：是真的，但是 hcy 挂分了，听他在对面哀怨的和 dst 说“我好菜我菜死了”的时候 我 难 受 极 了）</p><hr><p>qy 并不打算放我们回去学 whk 的样子，又要开始冲刺夏令营了！！</p><p>并不知道 SC 的出题风格。已经被 noip 和联合省选搞晕了，完全 joi(sc) 的风格嘛。</p><p>接下来的路也不知道怎么走，就做 joi 和填坑吧，whk 自己上心，数学自己学。还有早睡，困死了困死了猝死了</p><hr><p>题解。</p><h3 id="D1T1-卡牌游戏"><a href="#D1T1-卡牌游戏" class="headerlink" title="D1T1. 卡牌游戏"></a>D1T1. 卡牌游戏</h3><p>最多翻 m 次，最小化极值——容易想到把 a 和 b 都拍在数轴上，枚举值域左端点，满足下面两个限制的情况下，最小化右端点：</p><ul><li>删去的前缀和后缀中 a 的出现次数不超过 m</li><li>没有正反面同时被删的事件发生</li></ul><p>有单调性，双指针即可。O(nlogn)。有解无解的细节还挺多的，CCF 完全可以卡死一堆漏考虑的程序…… 就这？上 UOJ 挨 hack 吧！</p><p><a href="https://loj.ac/s/1117846" target="_blank" rel="noopener">Code</a></p><h3 id="D1T2-矩阵游戏"><a href="#D1T2-矩阵游戏" class="headerlink" title="D1T2. 矩阵游戏"></a>D1T2. 矩阵游戏</h3><p>构造题，你要想到的是先随便构造一个值域没有限制的 A（抱歉…… 我连这一步都没想到……），然后通过行列加减来使其合法，相邻加减号不同（这样不改变四个格子的和）。但是仅这样还不够，因为形成的不等式形如 a_{i, j} \pm r_i \pm c_j \geq 0，分类讨论太烦啦！不如让行列加减如下：</p><p>行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+-+</span><br><span class="line">-+-+-</span><br><span class="line">+-+-+</span><br><span class="line">-+-+-</span><br><span class="line">+-+-+</span><br></pre></td></tr></table></figure></p><p>列则刚好错开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-+-+-</span><br><span class="line">+-+-+</span><br><span class="line">-+-+-</span><br><span class="line">+-+-+</span><br><span class="line">-+-+-</span><br></pre></td></tr></table></figure></p><p>本质其实很平凡，就是你一开始就注意到有 nm 个变量但只有 (n - 1)(m - 1) 个方程，缺 n + m - 1 个方程，即如果确定了一行一列就确定了整个矩阵，而行列的操作就做了这件事。</p><p><a href="https://www.luogu.com.cn/record/49525382" target="_blank" rel="noopener">$Code$</a></p><h3 id="D1T3-图函数"><a href="#D1T3-图函数" class="headerlink" title="D1T3. 图函数"></a>D1T3. 图函数</h3><p>复杂度 $n^3$ 就离谱好吧，$n^3$ 跑 $1000$ CCF 少爷机是不是膨胀力？依稀记得 CSP2020 时 $1e6$ 离散化 被卡 痛失那 $35pts$ CCF 卡常之仇我与你不共戴天！！！</p><p>其实删到 $x$ 时 $x$ 能到达 $y$ 等价于 $x$ 走 $[x, n]$ 的导出子图边能到达 $y$。因为 $x$ 前面的点如果没被删掉，意味着经过它也到不了 $y$。</p><p>设 $g_{x, y}$ 表示 $x$ 能否通过 $[x, n]$ 到达 $y$</p><p>$ans = \sum g_{i, j} \&amp; g_{j, i}$</p><p>考虑 $g_{x, y}$ 表示最多删除多少边使得 $x$ 能通过 $[x, n]$ 到达 $y$</p><p>$ans = \sum \min(g_{i, j}, g_{j, i})$</p><p>我们想得到 $g$！</p><p>枚举删除的边显然不行。</p><p>考虑 floyd，从大到小枚举并加入中转点 $k$，此时所有 $g_{i, j} (i \leq k)$ 路径都是 $\geq i$ 的。</p><p><a href="https://loj.ac/s/1122479" target="_blank" rel="noopener">$Code$</a></p><h3 id="D2T1-宝石"><a href="#D2T1-宝石" class="headerlink" title="D2T1. 宝石"></a>D2T1. 宝石</h3><p>想了很久（wtcl），哦可以倍增 + 二分 + 主席树！</p><p>不会 windows 手动开栈空间，虽然没有因为这个丢分但要记录一下方法：在 devc++ 的工具一栏，在「编译时加入以下命令」处加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,--stack=1024000000</span><br></pre></td></tr></table></figure></p><p>数字以 B 为单位。</p><p>ubuntu 则是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s 1024000</span><br></pre></td></tr></table></figure></p><p>数字以 KB 为单位。</p><h3 id="D2T2-滚榜"><a href="#D2T2-滚榜" class="headerlink" title="D2T2. 滚榜"></a>D2T2. 滚榜</h3><p>真是很简单的题啊…… 暴力稍微改改就能 AC 了，可惜考场上没时间…… <strong>主要思维太慢了！！！</strong> 简直光速退役好么……</p><p>对于一种排名的 $a_i$ 序列，$b$ 每次尽量小的选，看贡献和是否不超过 $m$</p><p>$b_i = b_{i - 1} + \max(0, a_{i - 1} - a_i)$</p><p>$\sum b_i = \sum \max(0, a_{i - 1} - a_i) (n - i + 1)$</p><p>那么 dp，$f_{s, i, j}$ 表示选了集合 $s$ 的人，最后一个是 $i$，贡献和为 $j$，的排列方案数。</p><p>空间 $5e7$，时间 $6e8$，但可以 AC。</p><p><a href="https://loj.ac/s/1122468" target="_blank" rel="noopener">$Code$</a></p><h3 id="D2T3-支配"><a href="#D2T3-支配" class="headerlink" title="D2T3. 支配"></a>D2T3. 支配</h3><p>咕咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 014 题解</title>
      <link href="2021/04/09/AGC%20014%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/04/09/AGC%20014%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><p>两个数的差会逐渐缩小，因此只要 $log$ 次就可以出解</p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><p>构造？结论！</p><p>如果一个点度数为奇，其必然存在一条邻边满足只被加过奇数次；否则全部为偶，存在欧拉回路，那…… 就走两遍呗</p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><p><del>脑筋急转弯题</del></p><p>可以把策略看作如下：先走 $K$ 步，然后选 $K$ 个格子 unlock，然后走 $K$ 步</p><p>看出来没有？</p><p>提前开疆拓土没有意义，保证接下来的 $K$ 步平坦没有阻碍才有意义。</p><p>我们真正关注的只有第一轮能走到离边界多近的位置。bfs 即可！</p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><p>跟模拟赛那题简直一模一样！</p><p>考虑完美匹配，若该树存在完美匹配，不管先手选什么，后手只要选对应点即可；如果不存在，考虑某个叶子节点的父亲，它如果被黑的染色那不太优，如果被白的染色，黑的一定会染叶子，然后这两个点一起被去掉没有影响，最后剩下一些散点，先手赢。</p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><p>每次操作选取一个只被覆盖一次的边，那么要维护所有边被覆盖次数的最小值以及位置，以及覆盖了这条边的所有路径编号异或和，这样就可以快速操作。</p><p>更好写的做法：可以发现最终操作的一定是红蓝重边，那么缩点并考虑倒做，发现每次操作的都是缩点后的红蓝重边结构。要支持相邻边边集的合并，启发式合并就好了。合并的时候把新的合法对入队。$O(nlog^2n)$。</p><h2 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h2><p><a href="https://blog.csdn.net/wxh010910/article/details/71305939" target="_blank" rel="noopener">挂题解</a></p><p>没订，没看，看不进去 <del>为什么女生打代码能这么盛气凌人啊 fxck</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNR 3 题解</title>
      <link href="2021/04/08/UNR%203%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/04/08/UNR%203%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uoj.ac/contest/45" target="_blank" rel="noopener">fly!</a></p><p>晚上莫名疲惫，开一场 UNR <del>刺激一下</del> 只有 AC 才能给我麻木的神经带来一丝<del>变态的</del>兴奋</p><hr><h2 id="鸽子固定器"><a href="#鸽子固定器" class="headerlink" title="鸽子固定器"></a>鸽子固定器</h2><p>将鸽子按 $S$ 从小到大排序。先统计所有长度 $\leq m$ 的连续区间的贡献。</p><p>考虑不连续的，选取的一定是一段区间中 $V$ 较大的一些，于是考虑从小到大删除 $V$，删去时用包含它的区间更新答案即可。链表维护。</p><p>包含它的每个区间都有<strong>恰好</strong> $m$ 个元素，为什么？<del>我好像有点考前 debuff = = 省选 flag $*$ 1</del> 如果没有达到 $m$ 个元素：</p><ul><li>区间连续：在开头统计过了。</li><li>区间不连续：间隙中一定有小的被删了！此时加上小的会更优，当前是劣的。</li></ul><p>因此删除只会影响到相邻的 $m$ 个区间，$O(nm)$。</p><p><a href="https://uoj.ac/submission/467959" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="To-do-tree"><a href="#To-do-tree" class="headerlink" title="To do tree"></a>To do tree</h2><p>贪心的选深子树。证明看官方题解吧 <del>/害怕</del></p><p><a href="https://uoj.ac/submission/467912" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="配对树"><a href="#配对树" class="headerlink" title="配对树"></a>配对树</h2><p>考虑树上偶数个点的匹配，树形 dp：子树里的点不可能拿到子树外匹配，所以 $f[x, 0/1]$ 表示 $x$ 子树中有无未匹配点，统计出边的贡献。</p><p>其实我们就是统计每条边的贡献。</p><p>一条边有贡献当且仅当其两端子树都有奇数个点。相当于统计子树内选点使得偶数长度区间内有奇数个点被选的方案数。即：做前缀和后，$l$ 与 $r$ 奇偶性相同，$pre_l$ 与 $pre_r$ 奇偶性不同。直接做 $O(nm^2)$，线段树维护 $O(nmlogm)$</p><p>需要子树信息的题，两种做法：线段树合并，dsu on tree。总共才 $O(n)$ 个点，很难不线段树合并qwq，$[0/1][0/1]$ 分别表示下标和前缀和的奇偶性，$O(nlogn)$。然而其实还可以再优化：$cnt[0/1]$ 表示该区间内下标为偶/奇的位置以前，前缀和为奇的个数。</p><p><del>不懂为什么要 dsu + 线段树？？$O(nlognlogm)$ 又慢又难写</del></p><p><a href="https://uoj.ac/submission/467983" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="白鸽"><a href="#白鸽" class="headerlink" title="白鸽"></a>白鸽</h2><p>噫吁嚱，毒瘤哉！复杂度题真是不好的。</p><p>有解：连通且每个点度数为偶数</p><p>角度很抽象，不如看作收益，我们要最大化收益。</p><p>诡异的收益计算方法题，我们选择费用流。欧拉回路要求每个点入度 = 出度。</p><p>考虑一个经典套路就是先每条边随便定向，这样显然不是欧拉回路，那么最大化「给边反向使得每个点入度 = 出度的新收益」即可。</p><p>实现细节：角度太炸精度了。有个好东西叫射线法：顺时针经过一条射线的次数 - 逆时针经过的次数。很自然的想法。普通费用流会 T 成 $50$，怎么办？？</p><p>这是个单位图！（单位图长什么样？参考二分图 QAQ）好家伙那 dinic 就是 $O((n + m) \sqrt{n})$ 的。</p><p>你有办法：多路增广！即，每做完最短路用 dinic 增广残量网络上的余量，题解里说最短路长度不超过 $n^{1/4}$，所以总复杂度就是 $O(n^{3/4} (n + m))$</p><p><a href="https://uoj.ac/submission/468044" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="百鸽笼"><a href="#百鸽笼" class="headerlink" title="百鸽笼"></a>百鸽笼</h2><p>放一下以前写的题解：</p><p>直接算是错的…（我是 sb！）因为概率不均等，受当前没选完的列数影响。</p><p>相当于对于每个 $i$ 求出它最后被选完的方案数。</p><p>直接做不好做，考虑类猎人杀做法：容斥，减去存在某个集合 $S$ 在 $i$ 之后被选完的方案数。</p><p>因为只关心 $S$ 集合，所以除了 $i$ 和 $S$ 以外的列就不用管了。<strong>整个过程概率不变</strong>，实际上方案数与 $S$ 种类数 $m$ 和拼成的序列长度 $L$ 有关，<br>某个 $(m, L)$ 的序列的概率就是 $(\frac{1}{m + 1})^L$。放心大胆 dp，枚举每种数的出现次数。</p><p>每次重新 dp 复杂度是 $n^6$。先一个都不选完 dp 一次，再每次改一改就 $n^5$ 了。</p><p><a href="https://uoj.ac/submission/440827" target="_blank" rel="noopener">$Code$</a></p><p>省选非正式选手的 xml 是自由的魂灵，由于很喜欢生成函数，打算再补一个 EGF 做法：</p><p>每次选择，$a_i$ 会改变，这是不好的。考虑猎人杀怎么做的，认为满了仍然能放，只是没有效果（因为趋于无穷的时候概率和就是 $1$）。</p><p>设 $F_i(x) = \sum\limits_{i = 0}^{a_i - 1} \frac{x^i}{i!}$，即没取满的 EGF。假设最后剩下 $k$ 位置，设 $F(x) = \frac{x^{a_k - 1}}{(a_k - 1)!} \prod\limits_{i \neq k} (e^x - F_i(x))$，答案 EGF 即为 $\sum\limits_{i \geq 0} \frac{i! [x^i] F(x)}{n^{i + 1}}$</p><p>$\prod$ 是一定要展开的，展开 $F(x)$ 后得到每部分形如 $\lambda e^{dx} x^w$，这部分对答案 EGF 的贡献即为 $\frac{\lambda}{n^{w + 1}} \sum\limits_{i \geq 0} \frac{ (i + w)! d^i }{ i! n^i } = \frac{w! \lambda}{n^{w + 1}} \sum\limits_{i \geq 0} \frac{d^i}{n^i} \binom{w + i}{i}$</p><p>设 $\frac{d}{n} = \beta$，$\sum\limits_{i \geq 0} \beta^i \binom{w + i}{i} = \frac{1}{(1 - \beta)^{w + 1}}$，原理就是经典的插板法 QAQ，因此贡献为 $\frac{w! \lambda}{n^{w + 1}} ( \frac{n}{n - d} )^{w + 1}$</p><p>设 $V = \max(a_i)$，瓶颈在 dp 预处理系数，$O(n * n * (nV)^2)$（$n$ 个 $k$，转移枚举原来次数和新加次数，$n$ 次转移）</p><p>预处理 $\prod (e^x - F_i(x))$，每次除掉 $k$ 的贡献（和第一种做法的“反背包”一样！），$O(n^3 V^2)$。</p><p><a href="https://uoj.ac/submission/467998" target="_blank" rel="noopener">$Code$</a></p><hr><h2 id="鸽举选仕"><a href="#鸽举选仕" class="headerlink" title="鸽举选仕"></a>鸽举选仕</h2><p>咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SNOI2020 乱写</title>
      <link href="2021/04/06/SNOI2020%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/04/06/SNOI2020%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/list?keyword=SNOI2020&amp;page=1" target="_blank" rel="noopener">Jump!</a></p><p><del>挑战一下今天能写完几题（</del> 太毒瘤了…… 咕着吧</p><h2 id="取石子"><a href="#取石子" class="headerlink" title="取石子"></a>取石子</h2><p><del>博弈题怎么能正经做呢</del></p><p>$f_{i, j}$ 表示还剩 $i$ 个石子，这一步能取 $[1, j]$ 时是否有必胜策略。</p><p>$f_{i, j} = OR_{k = 1}^{j} [f_{i - k, 2k} = 0]$</p><p>设 $pos_i$ 为使得 $f_{i, j} = 1$ 的最小的 $j$。$pos$ 的表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 34 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 55 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 89 1 2 3 1 5 1 2 8 1 2 3 ……</span><br></pre></td></tr></table></figure><p>诶你发现这玩意和斐波那契数列有大大的关系！实际上<del>我也不知道怎么看出来</del>$pos_i$ 等于 $i$ 斐波那契进制下最低位对应的斐波那契数。可能因为 $pos_{i - pos_i} \geq 2pos_i$？</p><p>预处理 $s_{i, j}$ 表示前 $fib_i$ 项 $pos$ 中 $fib_j$ 出现的次数。$s_{i, j} = s_{i - 1, j} + s_{i - 2, j} - [j == i - 2]$，减去这个是因为 $pos_{fib_i}$ 斐波那契进制中“本”应该第 $i - 1$ 和第 $i - 2$ 位都是 $1$，但是进位了所以 $pos_{fib_i}$ 的最低位从 $i - 2$ 变成了 $i$。</p><p>$1e18$ 内的斐波那契数量是 $log$ 级别的，所以 $O(nlogn)$。</p><p><a href="https://loj.ac/s/1111004" target="_blank" rel="noopener">$Code$</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>问题显然等价于排列 $a$、$b$ 使得 $\sum lcp(a_i, b_i)$ 最大。</p><p>倒插 SAM，从底向上贪心匹配。</p><p><a href="https://loj.ac/s/1111599" target="_blank" rel="noopener">$Code$</a></p><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>如果原图是仙人掌显然答案等于各环大小之积。否则必然是一个大环串了很多仙人掌。</p><p>断边方式有两种：</p><ol><li>断一条大环边，仙人掌上每个环各断一边</li><li>把一个大环上仙人掌断成两半，剩余仙人掌上环各断一边</li></ol><p>设大环边数为 $dis$，第 $i$ 个环大小为 $siz_i$，第 $i$ 个环两半边数分别为 $l_i$、$r_i$</p><p>那么 $ans = dis \prod siz_i + ( \sum \frac{l_i * r_i}{siz_i} ) \prod siz_i$</p><p>怎么找大环边？观察发现仙人掌中度数为 $3$ 的点一定有一条邻边是大环边。<del>出题人不讲唔得，直接令输入最后一条边为大环边……</del></p><p><a href="https://loj.ac/s/1112230" target="_blank" rel="noopener">$Code$</a></p><h2 id="水池"><a href="#水池" class="headerlink" title="水池"></a>水池</h2><p><a href>$Code$</a></p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p><a href>$Code$</a></p><h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p><a href>$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】吉司机线段树</title>
      <link href="2021/04/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%89%E5%8F%B8%E6%9C%BA%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>2021/04/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%89%E5%8F%B8%E6%9C%BA%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>吉司机线段树，又名 Segment Tree Beats!（Angel Beats？= =），一种支持 $O(nlog^2n)$ 区间取 $\min$/$\max$ 的势能线段树。</p><p>以取 $\min$ 为例，每个节点维护最大值和最大值出现次数和<strong>严格</strong>次大值（即不等于最大值），如果修改值小于当前区间次大值就往下递归，否则如果小于当前区间最大值就把最大值更换为修改值。这样复杂度是 $O(nlogn)$。</p><p>均摊分析证明：设线段树上一个节点的势能函数 $\varphi$ 为区间内本质不同的数字个数，每次往下递归必然使得 $\varphi - 1$，未被修改区间完全覆盖的节点 $\varphi$ 至多加一，总复杂度为 $O(nlogn)$。</p><p>主要思想就是这些，打标记啊处理啊和普通线段树不同的地方就是「给最大」「给次大」或「给历史最大」「给历史次大」要分开。</p><p>可以维护区间和。</p><p>实现没什么难点。</p><p><a href="https://www.luogu.com.cn/problem/P6242" target="_blank" rel="noopener">模板</a>：</p><p>要求支持：</p><ul><li>修改：区间加，区间取 $\min$</li><li>查询：区间和，区间 $\max$，区间历史 $\max$</li></ul><p>用「V」那题的做法没法维护区间和，所以只能上 Beats 啦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGTBeats &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> inf 1e18</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs (x &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cmax</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = max(x, y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atom</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        ll mxa, se, cnt, mxb, sum;</span><br><span class="line">        <span class="comment">// 下面四个都是加法懒标记，只是对象不同</span></span><br><span class="line">        ll add_a;  <span class="comment">// 区间最大值</span></span><br><span class="line">        ll add_b;  <span class="comment">// 区间历史最大值</span></span><br><span class="line">        ll add_a1;  <span class="comment">// 区间非最大值</span></span><br><span class="line">        ll add_b1;  <span class="comment">// 区间历史非最大值</span></span><br><span class="line">    &#125; tr[N &lt;&lt; <span class="number">2</span>], t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tr[x].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">        tr[x].mxa = max(tr[ls].mxa, tr[rs].mxa);</span><br><span class="line">        tr[x].mxb = max(tr[ls].mxb, tr[rs].mxb);</span><br><span class="line">        <span class="keyword">if</span> (tr[ls].mxa == tr[rs].mxa) &#123;</span><br><span class="line">            tr[x].cnt = tr[ls].cnt + tr[rs].cnt;</span><br><span class="line">            tr[x].se = max(tr[ls].se, tr[rs].se);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr[x].cnt = (tr[ls].mxa &gt; tr[rs].mxa ? tr[ls].cnt : tr[rs].cnt);</span><br><span class="line">            tr[x].se = (tr[ls].mxa &gt; tr[rs].mxa ? max(tr[rs].mxa, tr[ls].se) : max(tr[ls].mxa, tr[rs].se));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modi</span><span class="params">(<span class="keyword">int</span> x, ll add_a, ll add_b, ll add_a1, ll add_b1)</span> </span>&#123;</span><br><span class="line">        t = tr[x];</span><br><span class="line">        t.sum += add_a * tr[x].cnt + add_a1 * (tr[x].r - tr[x].l + <span class="number">1</span> - tr[x].cnt);</span><br><span class="line">        t.mxa += add_a;</span><br><span class="line">        cmax(t.mxb, tr[x].mxa + add_b);</span><br><span class="line">        t.add_a += add_a;</span><br><span class="line">        t.add_a1 += add_a1;</span><br><span class="line">        cmax(t.add_b, tr[x].add_a + add_b);</span><br><span class="line">        cmax(t.add_b1, tr[x].add_a1 + add_b1);</span><br><span class="line">        <span class="keyword">if</span> (t.se != -inf) t.se += add_a1;</span><br><span class="line">        tr[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mxn = max(tr[ls].mxa, tr[rs].mxa);</span><br><span class="line">        <span class="keyword">if</span> (tr[ls].mxa == mxn)</span><br><span class="line">            modi(ls, tr[x].add_a, tr[x].add_b, tr[x].add_a1, tr[x].add_b1);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modi(ls, tr[x].add_a1, tr[x].add_b1, tr[x].add_a1, tr[x].add_b1);</span><br><span class="line">        <span class="keyword">if</span> (tr[rs].mxa == mxn)  <span class="comment">// 这里如果写「&gt;= tr[ls].mxa」就炸了，因为改了……</span></span><br><span class="line">            modi(rs, tr[x].add_a, tr[x].add_b, tr[x].add_a1, tr[x].add_b1);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modi(rs, tr[x].add_a1, tr[x].add_b1, tr[x].add_a1, tr[x].add_b1);</span><br><span class="line">        tr[x].add_a = tr[x].add_a1 = tr[x].add_b = tr[x].add_b1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tr[x].l = l, tr[x].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[x].mxa = tr[x].mxb = tr[x].sum = a[l];</span><br><span class="line">            tr[x].se = -inf;</span><br><span class="line">            tr[x].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        build(ls, l, mid), build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modi_add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">            modi(x, v, v, v, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        psd(x);</span><br><span class="line">        <span class="keyword">if</span> (lx &lt;= mid) modi_add(ls, l, mid, lx, rx, v);</span><br><span class="line">        <span class="keyword">if</span> (rx &gt; mid) modi_add(rs, mid + <span class="number">1</span>, r, lx, rx, v);</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modi_min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lx &gt; r || rx &lt; l || v &gt;= tr[x].mxa) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx &amp;&amp; v &gt; tr[x].se) &#123;</span><br><span class="line">            modi(x, v - tr[x].mxa, v - tr[x].mxa, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        psd(x);</span><br><span class="line">        modi_min(ls, l, mid, lx, rx, v);</span><br><span class="line">        modi_min(rs, mid + <span class="number">1</span>, r, lx, rx, v);</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lx &gt; r || rx &lt; l) <span class="keyword">return</span> op == <span class="number">3</span> ? <span class="number">0</span> : -inf;</span><br><span class="line">        <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> op == <span class="number">3</span> ? tr[x].sum : op == <span class="number">4</span> ? tr[x].mxa : tr[x].mxb;</span><br><span class="line">        psd(x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>) <span class="keyword">return</span> qry(ls, l, mid, lx, rx, op) + qry(rs, mid + <span class="number">1</span>, r, lx, rx, op);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(qry(ls, l, mid, lx, rx, op), qry(rs, mid + <span class="number">1</span>, r, lx, rx, op));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SGTBeats;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n), rd(m);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rd(a[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> op, l, r, v;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        rd(op), rd(l), rd(r);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            rd(v), modi_add(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            rd(v), modi_min(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, qry(<span class="number">1</span>, <span class="number">1</span>, n, l, r, op));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>习题：<a href="https://uoj.ac/problem/515" target="_blank" rel="noopener">前进四</a> 题解见「UR 19 题解」。</p><p><a href="https://www.luogu.com.cn/problem/P6792" target="_blank" rel="noopener">SNOI2020-区间和</a> 题解见「SNOI2020 乱写」（可能咕了 QwQ）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> SegBeats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LibreOJ Round 9</title>
      <link href="2021/04/04/LibreOJ%20Round%209/"/>
      <url>2021/04/04/LibreOJ%20Round%209/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=LibreOJ%20Round%20%239" target="_blank" rel="noopener">Jump!</a></p><h3 id="Tangjz-的背包"><a href="#Tangjz-的背包" class="headerlink" title="Tangjz 的背包"></a>Tangjz 的背包</h3><p>$ans = r^p [x^m] \prod\limits_{i = 0}^{n - 1} (1 + \frac{1}{r^i} x)$</p><p>设 $q = \frac{1}{r}$，根据<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E7%B3%BB%E6%95%B0/18892160?fr=aladdin" target="_blank" rel="noopener">高斯系数-定理3</a>，$ans = r^p * q^{\binom{m}{2}} {n \brack m}_q$（百度百科-定理1 写错了，应为 ${m \brack m}_q = 1$）</p><p>${n \brack m}_q$ 是类似组合数的定义。定义 $[n]_q = \sum\limits_{i = 0}^{n - 1} q^i = \frac{q^n - 1}{q - 1}$，$[n]_q! = \prod\limits_{i = 1}^n [i]_q$，${n \brack m}_q = \frac{[n]_q!}{[m]_q![n - m]_q!}$。分子分母都有 $\frac{1}{(q - 1)^n}$，约掉不管。</p><p>设 $a$ 为 $q$ 在模 $P$ 意义下的阶，即 $q^a \equiv 1 \pmod{P}$</p><p>现在的问题是求解 $F(n) = \prod\limits_{i = 0}^{n - 1} (q^i - 1)$。由于 $q^a = 1$，先统计分子分母模 $P$ 意义下 $0$ 的个数，如果不等显然 $ans = 0$。具体来说，$q^{ai} - 1 = (q^a - 1) ( \sum\limits_{j = 0}^{i - 1} q^{aj} )$, 后面这坨 $= i$, $F(n) = \prod\limits_{i = 0}^{n/a} (q^{ai} - 1) \prod\limits_{i = 1, a \nmid i}^{n - 1} (q^i - 1) = (q^a - 1)^{n/a} (n/a)! \prod\limits_{i = 1, a \nmid i}^{n - 1} (q^i - 1)$。$a$ 是确定的，相当大，不用担心阶乘算不出来啦~</p><p>接下来考虑 $\prod\limits_{i = 1, a \nmid i}^{n - 1} (q^i - 1)$。模意义下高斯系数有了更好的性质——${n \brack m}_q = {n \mod a \brack m}_q = {n \brack m \mod a}_q$（随便 yy 一下QAQ），所以这就等于 ${n \mod a \brack m \mod a}_q$ 嘛。</p><p><a href="https://loj.ac/s/1108722" target="_blank" rel="noopener">$Code$</a></p><h3 id="CommonAnts-的调和数"><a href="#CommonAnts-的调和数" class="headerlink" title="CommonAnts 的调和数"></a>CommonAnts 的调和数</h3><p>设所有 $p$ 和 $k$ 的最小公倍数为 $z$，即 $p$ 和 $k$ 都是 $z$ 的因子。</p><p>修改会改一些 $z$ 的因子位置和一些不是 $z$ 的因子的位置，询问只问 $z$ 的因子位置。</p><p>考虑只改 $z$ 因子位置怎么做，高维前缀和，再做一遍高维后缀和应对查询即可。</p><p>不是 $z$ 的因子的位置 $pos$ 的贡献可以考虑放在 $gcd(z, pos)$ 上，即最近的前一个 $z$ 因子位置。所以高维前缀和求完后每个位置 $x$ 还要乘上 $F(n/x) = \sum\limits_{i = 1}^{n/x} i^2 [gcd(i, z) == 1]$，$i^2$ 是因为前缀一遍后缀一遍。$F(n) = \sum\limits_{d | z}^n \mu(d) d^2 \sum\limits_{i = 1}^{n/d} i^2$。</p><p>$\sum\limits_{i = 1}^x i^2 = \frac{1}{6} x(x + 1)(2x + 1)$，别再忘了！！<del>（丢死人了</del></p><p><a href="https://loj.ac/s/1110219" target="_blank" rel="noopener">$Code$</a></p><h3 id="Menci-的序列"><a href="#Menci-的序列" class="headerlink" title="Menci 的序列"></a>Menci 的序列</h3><p>好巧妙…… 每位如果有值，最多保留两个，剩下的进上去，这样只有可能“进的不够”。然后从第 $K$ 位开始往低走，如果比当前位更高的地方有值，就把它算到当前位（在实际序列中对应删除了一些 ‘$*$’）；否则就把低位“能进则进”，发现这样并不会进到高于当前位的位置，所以是最优的。</p><p>我觉得直接想很难啊。</p><p><a href="https://loj.ac/s/1108776" target="_blank" rel="noopener">$Code$</a></p><h3 id="ZQC-的迷宫"><a href="#ZQC-的迷宫" class="headerlink" title="ZQC 的迷宫"></a>ZQC 的迷宫</h3><p>sb 题…… 一直沿着一边走，显然能在 O(nm) 步内走出来。（话说这不是我逛各种展览时候的策略吗= =）</p><p><a href="https://loj.ac/s/1110241" target="_blank" rel="noopener">$Code$</a></p><p>完结撒花~ (=ﾟωﾟ)ﾉ</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>男人八题 做题记录</title>
      <link href="2021/04/01/%E7%94%B7%E4%BA%BA%E5%85%AB%E9%A2%98%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/01/%E7%94%B7%E4%BA%BA%E5%85%AB%E9%A2%98%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E7%94%B7%E4%BA%BA" target="_blank" rel="noopener">Jump!</a></p><h3 id="1-8-：-AStringGame"><a href="#1-8-：-AStringGame" class="headerlink" title="$1/8$：$AStringGame$"></a>$1/8$：$AStringGame$</h3><p>签到题？加字符就是在 SAM 上跑，算出 SAM 的 SG 函数即可。</p><p><a href="https://loj.ac/s/1105841" target="_blank" rel="noopener">$Code$</a></p><h3 id="2-8-：-SignLocation"><a href="#2-8-：-SignLocation" class="headerlink" title="$2/8$：$SignLocation$"></a>$2/8$：$SignLocation$</h3><p>结论是最优方案一定放在整点上！！<del>伪</del>证明考虑微扰：假设两个相邻车站的距离为 $dis$，左右点数各为 $l$ 和 $r$，当前是 $dis <em> l$，那么移到中间后是 $dis </em> \frac{n}{2}$，因为 $l \leq \frac{n}{2}$ 所以不会变优。</p><p>$f_{i, j}$ 表示当前放了 $i$ 个，最后一个在 $j$ 位置。决策点感性理解下是单调不减的？并且据说也是凸的。我用的是决策单调性，贡献用前缀和什么的就能计算，随便做。<del>数据有点水</del> </p><p><a href="https://loj.ac/s/1105995" target="_blank" rel="noopener">$Code$</a></p><h3 id="3-8-：-PerfectNPArray"><a href="#3-8-：-PerfectNPArray" class="headerlink" title="$3/8$：$PerfectNPArray$"></a>$3/8$：$PerfectNPArray$</h3><p>很明显这个「全部 $\geq 0$」是在演你—— $&lt; 0$ 截掉无影响。</p><p>冷静分析一波，由于可以反走下降路径，经过一个点最大的路径前缀是经过它的路径的 $\min( |mx|, |mn| )$。记录每棵子树的最大最小次大次小链。</p><p><a href="https://loj.ac/s/1106102" target="_blank" rel="noopener">$Code$</a></p><h3 id="4-8-：-EquationsAndInequations"><a href="#4-8-：-EquationsAndInequations" class="headerlink" title="$4/8$：$EquationsAndInequations$"></a>$4/8$：$EquationsAndInequations$</h3><p>未完……</p><p>先按照偏序关系和相等关系算出划分方案，再算依照这种划分方案的大小关系来，$\sum x_i = s$ 的解数。假设大小关系已经完全确定。可是直接算很难遵守大小关系，考虑差分。将 $x$ 差分，设 $\sum\limits_{j = i}^m = a_i$, 应满足 $\sum a_i x_i = s$，即 $[x^s] \prod\limits_{i = 1}^m \frac{x^{a_i}}{1 - x^{a_i}}$</p><p>后面不会了</p><h3 id="5-8-：-IntervalTree"><a href="#5-8-：-IntervalTree" class="headerlink" title="$5/8$：$IntervalTree$"></a>$5/8$：$IntervalTree$</h3><p>神……</p><h3 id="6-8-："><a href="#6-8-：" class="headerlink" title="$6/8$："></a>$6/8$：</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIol21-1 题解</title>
      <link href="2021/04/01/NOIol21-1%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/04/01/NOIol21-1%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>今年比去年难多了！xml 没有任何长进 难过子</p><h2 id="T1-愤怒的小-N"><a href="#T1-愤怒的小-N" class="headerlink" title="$T1.$ 愤怒的小 N"></a>$T1.$ 愤怒的小 N</h2><p>第二部分没调出来，但是先把推的记录一下免得以后找不着:</p><p>结论 1: $\sum\limits_{i = 0, cnt(i) \&amp; 1}^{2^k - 1} i^p = \sum\limits_{i = 0, cnt(i) \&amp; 1 = 0}^{2^k - 1} i^p$</p><p>$ans = \frac{1}{2} \sum\limits_{i = 0}^{n - 1} (1 - (-1)^{cnt(i)}) f(i)$</p><p>第一部分：</p><p>$\sum\limits_{i = 0}^{n - 1} f(i) = \sum\limits_{i = 0}^{k - 1} a_i \sum\limits_{j = 0}^{n - 1} j^i$</p><p>设 $S_i(n) = \sum\limits_{j = 0}^{n - 1} j^i$</p><script type="math/tex; mode=display">S_{i + 1}(n) = \sum\limits_{j = 0}^{n - 1} (j + 1)^{i + 1} - n^{i + 1}</script><script type="math/tex; mode=display">= \sum\limits_{j = 0}^{n - 1} \sum\limits_{c = 0}^{i + 1} \binom{i + 1}{c} j^c - n^{i + 1}</script><script type="math/tex; mode=display">= \sum\limits_{c = 0}^{i + 1} \binom{i + 1}{c} S_c(n) - n^{i + 1}</script><script type="math/tex; mode=display">= S_{i + 1}(n) + (i + 1)S_i(n) + \sum\limits_{c = 0}^{i - 1} \binom{i + 1}{c} S_c(n) - n^{i + 1}</script><p>所以 $S_i(n) = \frac{ n^{i + 1} - \sum\limits_{c = 0}^{i - 1} \binom{i + 1}{c} S_c(n) }{i + 1}$ 这部分可以 $O(K^2)$ 计算。</p><p>结论 2: 形如 $\sum\limits_{i = 0}^{2^n - 1} (-1)^{cnt(i)} i^k$ 在 $n &gt; k$ 时 $= 0$。 </p><p>证明：看作 $n$ 元集合在里面任意选，第 $i$ 个元素的权值是 $2^i$。一种物品集合 $t$ 的系数是 $\sum\limits_{s \geq 0, t \subseteq s}^{2^n - 1} (-1)^{cnt(s)}$，显然这个东西只在 $t = 2^n - 1$ 时不等于 $0$。而 $n &gt; k$ 就意味着 $t$ 不可能为全集。</p><p>第二部分：</p><script type="math/tex; mode=display">\sum\limits_{i = 0}^{n - 1} (-1)^{cnt(i)} f(i)</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{k - 1} a_i \sum\limits_{j = 0}^{n - 1} (-1)^{cnt(j)} j^i</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{k - 1} a_i \sum\limits_{j = 0, n_j = 1}^{n - 1} (-1)^{cnt(T)} \sum\limits_{l = 0}^{2^j - 1} (-1)^{cnt(l)} (T + l)^j</script><p>$T = \sum\limits_{o = j}^{n - 1} (str[o] - ‘0’) * 2^{o - j + 1}$。二项式展开</p><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{k - 1} a_i \sum\limits_{j = 0, n_j = 1}^{n - 1} (-1)^{cnt(T)} \sum\limits_{l = 0}^{i} \binom{i}{l} T^l ( \sum\limits_{p = 0}^{2^j - 1} (-1)^{cnt(p)} p^{j - l} )</script><p>后面那坨设它等于 $sum(j, i - l)$</p><script type="math/tex; mode=display">sum(i, j) = sum(i - 1, j) - \sum\limits_{p = 0}^j \binom{j}{p} (2^{i - 1})^p sum(i - 1, j - p)</script><p>根据结论 2，</p><script type="math/tex; mode=display">\sum\limits_{i = 0}^{n - 1} (-1)^{cnt(i)} f(i)</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{k - 1} \sum\limits_{j = 0}^{\min(k, n) - 1} (-1)^{cnt(T)} \sum\limits_{l = 0}^i \binom{i}{j} T^l sum(j, i - l)</script><p>这部分可以 $O(k^3 + n)$ 计算。</p><h3 id="T2-积木小赛"><a href="#T2-积木小赛" class="headerlink" title="$T2.$ 积木小赛"></a>$T2.$ 积木小赛</h3><p>SAM 的话记录每个长度区间哪些长度出现过。然而实际上 hash 就行了。SAM 是 $O(n^2)$ 的，hash 需要 map/排序，我写双模就 TLE $80$ 了 /dk</p><h3 id="T3-岛屿探险"><a href="#T3-岛屿探险" class="headerlink" title="$T3.$ 岛屿探险"></a>$T3.$ 岛屿探险</h3><p>算是最正常的一道题了吧。。</p><p>询问差分，离线，从前往后做。</p><p>还是拆位的思想。</p><p>使 $a ^ c \leq b$ 的 $c$ 必定是从高到低一段 $0$ 然后一个 $1$ 剩下任取。</p><p>把 $(a, b)$ 复制 $log$ 份塞进对应的所有 $c$ 的合法区间，现在要用 $(c, d)$ 去切这 $log$ 个区间，那么把 $(c, d)$ 也复制 $log$ 份塞进所有包含 $c$ 的区间即可。</p><p>$log$ 个位置分别做，开 $01 trie$ 查询 $a ^ c \leq d$ 的 $a$ 的个数。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25e5</span> + <span class="number">3</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>) + <span class="number">3</span>, E = <span class="number">75e5</span> + <span class="number">3</span>, O = <span class="number">1e5</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n, Q, id, a[O], b[O], c[O], d[O], ans[O];</span><br><span class="line"><span class="keyword">int</span> lnk[M], cnt, to[E], nxt[E];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[O];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar());</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iabs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    adde(x, id);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pos &lt;= mid ? insert(x &lt;&lt; <span class="number">1</span>, l, mid, pos, id) : insert(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>], idx, sz[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">1</span>;</span><br><span class="line">        ch[<span class="number">1</span>][<span class="number">0</span>] = ch[<span class="number">1</span>][<span class="number">1</span>] = sz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (val &amp; i) &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[u][c]) ch[u][c] = ++idx, ch[idx][<span class="number">0</span>] = ch[idx][<span class="number">1</span>] = sz[idx] = <span class="number">0</span>;</span><br><span class="line">            u = ch[u][c];</span><br><span class="line">            sz[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d &amp; i) &#123;</span><br><span class="line">                <span class="keyword">int</span> op = (c &amp; i) &gt; <span class="number">0</span>;</span><br><span class="line">                ret += sz[ch[u][op]], u = ch[u][!op];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                u = ch[u][(c &amp; i) &gt; <span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret + sz[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rd(n), rd(Q);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rd(a[i]), rd(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        rd(l), rd(r), rd(c[i]), rd(d[i]);</span><br><span class="line">        q[l - <span class="number">1</span>].pb(-i), q[r].pb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q[i].size(); j++) &#123;</span><br><span class="line">            insert(<span class="number">1</span>, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) - <span class="number">1</span>, c[iabs(q[i][j])], q[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); j; j &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            x *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; j) x ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[i] &amp; j) adde(x, i + Q), x ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        adde(x, i + Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lnk[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tr.init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lnk[i]; j; j = nxt[j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = to[j], xx = iabs(x);</span><br><span class="line">            <span class="keyword">if</span> (xx &lt;= Q)</span><br><span class="line">                ans[xx] += (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>) * tr.qry(c[xx], d[xx]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tr.ins(a[x - Q]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21Mar 训练日志</title>
      <link href="2021/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Mar%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Mar%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数发散</title>
      <link href="2021/03/28/%E5%87%BD%E6%95%B0%E5%8F%91%E6%95%A3/"/>
      <url>2021/03/28/%E5%87%BD%E6%95%B0%E5%8F%91%E6%95%A3/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX18seivdnjvw8HkJdVI0VC9w0dT2G9W3Ivc+QAdOuluQ3miJEqOQwXbp4+OIahiwGcmUk2a3ANQTupIqkXpz/LfoOsfQL3rfFo02zaq8u7aZaYrOT8zJVutvw8wUu94PmcokQny2U0yDPGE3K4d+u137WGst8fqdvgIiQLS5WZy3X3e79TN8phdiT7c3dhYJazYLWaMi7WnfwP14h0FPxd65THkR+2m4NE2+H9vdzUYDof45jUmzQgF3kBek54aY88PJxf+zrIMjgZ53oiF12+gb9OFIbAicnp1H6zYaeePH4o504aEYtJz3MdhNiPIJbg1X3Z/s3BNN9wJCygr426vnyHh+PWvzHFdIK7Ygc9rKV1yTrN/eLhiclcUNpSSmo8UpKyz/Ky5CKzaxRDsWl3pMZ9rMrr5V1MfE5Ii8wy6r/0CApnnEvgwBkeLWVcavc7y2ZTc/o+aU0litsMUYd3g1Y5fV7lhLyrMj+pztbp8+tCO28+CLjEYXZycvuboxycEfyBYUGjhUgxBV0rY7OXi1RPpdASTWRHMCb4zjp8xSP5OzgiZtiC+vTH1CBFNcWjKxyKKQOKgROtBjCqUtp6fQfzwrA9dfvq8W5HnJpqvi8TCRnSuIeryWiaXpB5KeQruDKLbUT+YTVxozEBXrRg72rJgFoV5f4O8YQbUyCgZ2bLuCk4ScFztQFspQH3x6HIKUheo1GTT9a8IKKMLTTpmCD7sem0g/8R1eqTd5kJScFTPVGblaBfOkJbyei58PlfKJv5UhWhl58JlZ/+D/YrUuWdrOyxl4qtTpN9qX1lwpUJ//J/5GB63abp1MvSivHKMvc5iCZCdePoT0LR0q4Y0+d6vyzyfcexbaH+KzvQNjMU56yilqlLRUBWiAe3F9xx08K1lxMupmaYOYFfZytKIHNpIX06JVEapfXLePuIdBDUi286A0qhwzSd0RrfIVoGixJQG6B9bWzCKYoRbmEr1evJnQXVelA3v6Qo2sJw3gF9TqrvlzmxgBW2J47EL14KxNBZm4Ry1cpXte5DlqrkFsjBO6qfEDH7ONxo1JWW7ACXuUDl/szqWoJtEwXgPz86nU9NzIGgr9jIeMT6+gC6Qs3jPFNlWVOGReFpCeYlMAUaJlxhz0x09Lf6BCZjkzzsXr2p1czvRVYJS4tRH2BsbNcL3spaUXP6AojWigCg3xer+ppA850u3/e1yAAflxAtWT+tO+eS8nj5La8WT3D+ciCyuEkxLqOwPIB2d0Twa255EfqjcWKHPUkiHdfIhErB3ejFsmYemPz+3+cBzRcNk5fP1XL+xfbYf+s6TJRR+XY71RVdynS9omVr3dEFx0GsvaUsV1u7FeLNkBzet9rsAZONpyxyPMxhw=</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ynoi 做题记录</title>
      <link href="2021/03/26/Ynoi%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/03/26/Ynoi%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>原来我逻辑也这么差！！！数据结构能说什么呢。。细节自己多想想。</p><h3 id="Ynoi2011-竞赛实验班-loj517-计算几何瞎暴力"><a href="#Ynoi2011-竞赛实验班-loj517-计算几何瞎暴力" class="headerlink" title="$Ynoi2011-$竞赛实验班/$loj517-$计算几何瞎暴力"></a><a href="https://www.luogu.com.cn/problem/P5312" target="_blank" rel="noopener">$Ynoi2011-$竞赛实验班/$loj517-$计算几何瞎暴力</a></h3><p>不真的全局异或，而是：</p><ul><li>加入新值，异或上当前 xor 和，丢到等待队列里；</li><li>排序时把等待队列的值都插到 Trie 里；</li><li>异或就异或到当前 xor 和上；</li><li>查询如果涉及到一部分有序一部分无序，就是全局和；否则如果全有序，Trie 上考虑「<strong>上次全有序时的 xor 和</strong>」下的前 k 项，差分。</li></ul><p>维护每个子树各位出现次数和。</p><p>坑点：查询，在 Trie 上走的时候按「<strong>上次全有序时的 xor 和</strong>」，但查子树各位的时候按「<strong>当前 xor 和</strong>」来。</p><p>其实如果你考虑清楚了，这题一点都不坑，甚至还比较小清新。</p><p><a href="https://loj.ac/s/1100809" target="_blank" rel="noopener">$Code$</a></p><h3 id="五彩斑斓的世界"><a href="#五彩斑斓的世界" class="headerlink" title="五彩斑斓的世界"></a><a href="https://www.luogu.com.cn/problem/P4117" target="_blank" rel="noopener">五彩斑斓的世界</a></h3><p>离线询问，对每个块单独做。这样空间就不会炸。</p><p>对下标开并查集，权值相同的并一块儿；开一个数组记录每种权值的根的位置。</p><p>散块，不支持全局打标记，就暴力改，并趁机重构，清空 $tag$。</p><p>整块：</p><ul><li>$maxn \leq 2x$：暴力改所有 $&gt; x$ 的，用 $O(\alpha * (maxn - x))$ 的代价让最大值减少了 $maxn - x$</li><li>$maxn &gt; 2x$：可以看作整体减少 $x$ 再给 $\leq 0$ 的加上 $x$，用 $O(\alpha * x)$ 的代价让最大值减少了 $x$</li></ul><p>值域与 $n$ 同阶，单块的复杂度是 $O(n)$ 的，总体 $O(n \sqrt{n} * \alpha)$。</p><h3 id="镜中的昆虫"><a href="#镜中的昆虫" class="headerlink" title="镜中的昆虫"></a><a href="https://www.luogu.com.cn/problem/P4690" target="_blank" rel="noopener">镜中的昆虫</a></h3><p>区间数颜色的标准套路：$pre_i$ 表示 $i$ 前一个和 $i$ 颜色相同的位置，那么询问 $[L, R]$ 就是在统计 $pre_i &lt; L$ 的个数。静态就是二维数点。</p><p>单点修改怎么做？$pre$ 总修改次数只有 $O(n + m)$，是个带修改二维数点问题。树状数组套线段树可以做，<del>空间也不是很紧。</del> 仅能过 loj 的数据！！ಥ_ಥ</p><p>如果加一维时间，看作在每个时间点做完左边的所有修改后查询，就可以 cdq 分治了，每次统计 $[l, mid]$ 的修改对 $(mid, r]$ 的询问的贡献。</p><p>区间修改呢？把相同颜色看成一块，考虑均摊分析，如果修改区间不相交显然 $pre$ 的总修改次数是 $O(n)$，如果相交也只会改端点 $O(1)$，总的是 $O(n + 2m)$</p><p>为了计算出所有实际的修改，需要开一个 set 维护所有块、颜色数个 set 维护该颜色的块, $O((n + 2m) logn)$</p><p><a href="https://loj.ac/s/1101667" target="_blank" rel="noopener">loj-Code</a></p><p>cdq 的不想写了。。下次一定</p><h3 id="未来日记"><a href="#未来日记" class="headerlink" title="未来日记"></a><a href="https://www.luogu.com.cn/problem/P4119" target="_blank" rel="noopener">未来日记</a></h3><p>因为这是 Ynoi，值域 $1e5$ 必有其用意。</p><p>二分啊主席树的没法和分块有机结合。所以要序列分块套值域分块（</p><p>$cnt1_{i, j}$ 表示序列前 $i$ 块在值域第 $j$ 块里出现的次数，$cnt2_{i, j}$ 表示序列前 $i$ 块第 $j$ 个数出现的次数。查询 $kth$ 就先扫值域块确定块，再挨个儿扫过去。</p><p>修改呢？散块暴力。整块怎么做？</p><p>注意到修改不会增加每块内的颜色种类。这超有用。</p><p>块内 $x$、$y$ 同时有的就暴力改，颜色种类减少 $O(n)$ 次，总复杂度 $O(n\sqrt{n})$；否则并查集即可。</p><p>这题唯一打标记的就是整块的并查集，而只要在散块重构的时候下推就好了。<del>所以还比较清真？我是超级受不了巨大多 tag 的题 /kk</del></p><p>为了方便在下推的时候快速得到所有的真实颜色，还要记录每个根对应的真实颜色是什么。</p><p>$id_{x, c}$ 表示块 $x$ 内颜色 $c$ 的根，$rid_{x, d}$ 表示块 $x$ 内根 $d$ 对应的颜色，$pos_i$ 记录第 $i$ 个位置上的颜色对应的根。把颜色 $y$ 的根指向颜色 $x$ 的根，并清空颜色 $x$ 的根即可。本质是个离散化。</p><p><a href="https://www.luogu.com.cn/record/48714436" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AGC 013 题解</title>
      <link href="2021/03/24/AGC%20013%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/03/24/AGC%20013%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><del>订不出 XJOI 的题就跑来 AGC 寻找安慰</del></p><h3 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h3><p>管他升或者降，每次选尽量长的就完事了。贪心随便证一证。</p><h3 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h3><p>脑筋急转弯题。路径倒过来看就是最后一个点没有出边。</p><p>考虑从中间切开。随便选一个点做切入点，从切入点不断深度遍历，直到当前点没有出边；这么做两次就找到俩端点了。</p><h3 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h3><p>我又来力！</p><p>所有蚂蚁面目模糊的最终位置容易算。只要考虑 $1$ 号蚂蚁排名是啥就知道它最终位置是啥，其他蚂蚁的也就知道了。</p><p>想象 $0$ 处有一只哨兵蚂蚁，每有一只蚂蚁经过它，整体蚂蚁的排名就会左移/右移一位（自行脑补原因。。）</p><p>细节：$x_i \mod L &lt; 0$ 时也会左移哦</p><h3 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h3><p>$f_{i, j}$ 表示前 $i$ 个取完后黑色还有 $j$ 个，构成的不同颜色序列个数。然而你很快就发现，初始黑色不同、取球过程相同的时候这样会算重。</p><p>画出黑球个数的增减图像，显然我们统计的不是不同路径数，而是不同图像数。</p><p>我们定一种图像的特征点是其最低点碰到 $0$ 的版本。统计特征点个数即可，$dp_{i, j, 0/1}$ 表示前 $i$ 步做完，当前黑球个数为 $j$，是否碰到过 $0$。</p><ol><li>-B, +BW, -B : $-1$</li><li>-B, +BW, -W : $0$</li><li>-W, +BW, -B : $0$</li><li>-W, +BW, -W : $+1$</li></ol><p>1 &amp; 2 均可能碰到 $0$。</p><h3 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h3><p>$n$ 那么大，考虑矩乘。但是 $m$ 也很大啊，直接矩乘显然不现实。</p><p>考虑到柿子很简单，看看能不能用前缀和转移什么的。</p><p>$f_i = \sum\limits_{j = 0}^{i - 1} f_j (i - j)^2$</p><p>考虑从 $i$ 转移给 $i + 1$。将 $(i - j)$ 看作 $x_j$。</p><p>将转移给 $i + 1$ 的项整理成「在转移给 $i$ 的项的基础上修修补补」的形式：</p><ul><li><p>$i$ 已标记</p><p>  $f_{i + 1} = \sum\limits_{j = 0}^{i} f_j (x_j + 1)^2 = \sum\limits_{j = 0}^{i - 1} f_j x_j^2 + 2 f_j x_j + f_j$</p></li><li><p>$i$ 未标记</p><p>  $f_{i + 1} = ( \sum\limits_{j = 0}^{i - 1} f_j (i + 1 - j)^2 ) + f_i = ( \sum\limits_{j = 0}^{i - 1} f_j x_j^2 + 2 f_j x_j + f_j ) + f_i$</p></li></ul><p>令 $g_i = \sum\limits_{j = 0}^{i - 1} f_j x_j^2$</p><p>$h_i = \sum\limits_{j = 0}^{i - 1} 2 f_j x_j$</p><p>$s_i = \sum\limits_{j = 0}^{i - 1} f_j$</p><p>那么这三者转移有：</p><p>$g_{i + 1} = g_i + h_i + s_i$</p><p>$h_{i + 1} = h_i + 2 s_i$</p><p>$i$ 已标记：$s_{i + 1} = s_i$</p><p>$i$ 未标记：$s_{i + 1} = s_i + f_i = g_i + h_i + 2 s_i$</p><p>初始 $[g, h, s] = [0, 0, 1]$（艹，我真不是故意的我发誓）</p><p>答案：$mat[0][0]$</p><p><a href="https://atcoder.jp/contests/agc013/submissions/21224362" target="_blank" rel="noopener">$Code$</a></p><h3 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h3><p><del>我会 $n^2 logn$!（迫真</del></p><p>这问题一看就要抽象化。</p><p>考虑如何判两个数组 $a$、$b$ 是否存在一种配对方式满足 $a_i \leq b_i$：对于 $a_i$, 执行一个从 $a_i$ 开始的后缀加；对于 $b_i$, 执行一个从 $b_i$ 开始的后缀减；存在配对方式当且仅当每个位置的值 $\geq 0$。</p><p>因为要最大化选正面的个数，先全部选正面。</p><p>如果不满足完全配对，我们可以这么做来修修补补：</p><ol><li>对于 $first &gt; second$ 的，可以给 $[second, first)$ 加一，花费 $1$ 的代价</li><li>对于询问插入的新牌，我们可以选择 $X$ 或者 $Y$，设选择的位置为 $p$，给 $[p, n) + 1$</li></ol><p>可以看作，当前有一个有正有负的数组，我们有若干 $[second, first)$ 的区间，要求选最少的区间使得 $[1, p) \geq 0$, $[p, n] \geq -1$，其中 $p$ 未知。我们需要<strong>预处理</strong>每个 $p$ 的答案。</p><p>区间的选择分为两部分。</p><p>第一部分：先把 $&lt; -1$ 的都搞掉，从右往左，每遇到一个 $&lt; -1$ 的就使用包含它的区间中左端点最左的。如果区间用完了还没搞完，直接全部无解。</p><p>做完后还有区间没用完，不能浪费了——</p><p>第二部分：从前往后，碰到 $-1$ 就用询问加入的当前还没用的右端点最右的区间。这步是处理所有 $p$ 的答案。如果区间用完了，当前 $i$ 位置的 $-1$ 消不掉了，从 $i + 1$ 开始就不满足「$[1, p) \geq 0$」的要求了，所以 $p \in [i + 1, n]$ 全部无解。</p><p>$O(nlogn + Q)$。</p><hr><p>总结：喜欢 $F$！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】斜率优化、带权二分、决策单调性</title>
      <link href="2021/03/23/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%81%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E3%80%81%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
      <url>2021/03/23/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E3%80%81%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E3%80%81%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>把「带权二分」并过来了，都是和斜率有千丝万缕关系的家伙们 =w=</p><h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><hr><p>整理 dp 柿子后得到一个「斜率、截距是当前项，$x$、$y$ 坐标是之前项」的类一次函数柿子。根据截距的正负考虑维护什么方向的凸包。</p><p>举个例子：$dp_i = \max( dp_j + \frac{i - j}{i} )$，整理得 $(dp_j + 1) <em> i - dp_i </em> i = j$，截距项是 $-dp_i * i$，而我们要 $dp_i$ 尽量大，截距尽量小，即 $0$ 处取值尽量小，感性理解是直线尽量低，所以维护 $(dp_j + 1, j)$ 的下凸包，用斜率为 $i$ 的直线去切。</p><h3 id="一道不错的题：-UOJ430-line"><a href="#一道不错的题：-UOJ430-line" class="headerlink" title="一道不错的题：$UOJ430-line$"></a>一道不错的题：<a href="https://uoj.ac/problem/430" target="_blank" rel="noopener">$UOJ430-line$</a></h3><p>朴素 dp 方程：$f_i = \min\limits_{l_i \leq j &lt; i}( \max( t_{j + 1}, \cdots, t_i ) * suf_{i + 1} + f_j )$</p><p>考虑 cdq 分治计算 $f$，即递归处理好 $[l, mid]$ 再算 $[l, mid]$ 对 $[mid + 1, r]$ 的贡献，再递归处理 $[mid + 1, r]$。</p><p>这个 $max$ 得拆：</p><ul><li><p>$max \in [mid + 1, r]$</p><p>  $\max(t_{j + 1}, \cdots, t_{mid})$ 需要 $\leq max$，显然 $j$ 的位置单调不升，只要取左边的 $\min(f)$ 即可。</p></li><li><p>$max \in [l, mid]$</p><p>  设 $max$ 在 $j(j \in [l, mid])$ 处取到。$j$ 处 $-max * suf_{i + 1} + f_i = f_{j - 1}$。</p><p>  要 $f_i$ 最小就是截距最小。线段树维护下凸包，询问时每个区间二分求切点；然而如果离线将询问按 $suf$ 升序排列，就有单调性了，一路切过去就行了，少一只 $log$。所以最后是 $O(nlogn)$ 的！</p></li></ul><p>人傻了，$AB * AC &gt; 0$（叉积）表示三角形 ABC 为逆时针。xml 记错了，浪费一小时拼命撕烤，特此记录。</p><p><a href="https://uoj.ac/submission/464622" target="_blank" rel="noopener">$Code$</a></p><h2 id="带权二分"><a href="#带权二分" class="headerlink" title="带权二分"></a>带权二分</h2><hr><p>这玩意儿其实早几个月就学了，现在来补笔记。</p><p>带权二分又称 wqs 二分，解决的是这样一类问题：有 $n$ 个物品，需要在强制选 $K$ 个物品的前提下最大/最小化代价；设强制选 $K$ 个的代价最值为 $val(K)$，$val(K)$ 无法直接求得，但是 $val$ 函数的最值以及取到最值的位置可以求，并且 <strong>$val$ 是一个凸函数</strong>。</p><p>现在讨论求上凸函数最大值（下凸函数最小值一个道理）。令 $f(x) = val(x) + kx$，$k$ 的实际意义是「多选一个物品就要付出的代价」，在坐标系上就是将 $val$ 的导函数向上平移了 $k$。导函数与 $x$ 轴的交点对应的就是 $val$ 的最高点，且上凸函数的导函数递减，因此 <strong>$k$ 变大，最值点右移</strong>，可二分。最后让 $val(K) = f(K) - kx$。</p><p>求下凸函数最小值，<strong>$k$ 变大，最值点左移</strong></p><p><strong>调边界是真的恶心</strong>，zbl</p><p>二分物品额外代价的时候还有可能跳过正确答案，这时如果答案的 $k$ 是一段连续区间，维护区间并判断即可。</p><p><em>如果不用输出方案，直接记录斜率，输出答案时乘一下。</em></p><p>习题：<a href="https://loj.ac/p/2478" target="_blank" rel="noopener">林克卡特树</a> <a href="https://imilyx.github.io/2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/#%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91" target="_blank" rel="noopener">题解</a></p><h2 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a>决策单调性</h2><hr><p>作为感性理解的忠实爱好者…… 笔者只能用感性的语言来讲述它啦qwq！大概就是如果存在 $r_0$ 使得对于 $l_1 &lt; l_2$，$l_1$ 优于 $l_2$，那么所有 $r \geq r_0$ 都满足 $l_1$ 优于 $l_2$。也就是说决策点（转移来源）分段且来源的位置单调增。<strong>决策单调性的有无，显然取决于价值函数。</strong>（废话）</p><p>以<a href="https://www.luogu.com.cn/problem/CF321E" target="_blank" rel="noopener">$CF321E$</a>为例，$dp_{i, j} = \min( dp_{i - 1, k - 1} + val(k, j) )$，若对于 $k_1 &lt; k_2$, $dp_{i - 1, k_1 - 1} + val(k_1, j) &gt; dp_{i - 1, k_2 - 1} + val(k_2, j)$，那么随着 $i$ 增加，$val(k_1, j)$ 永远大于 $val(k_2, j)$，$k_2$ 永远优于 $k_1$。</p><p>再以 <a href="https://loj.ac/p/3039" target="_blank" rel="noopener">$JOI-$蛋糕拼接3</a> 为例，$ans = \sum V_i - 2 * ( C_M - C_1 )$。对于 $l_1 &lt; l_2$，感性理解新加入一个 $r$ 对 $l_1$ 产生的收益小于等于 $l_2$（$C$ 之差！），即，若对于 $r_0$，$l_2$ 优于 $l_1$，那么对于 $r \geq r_0$，$l_2$ 都优于 $l_1$。这就是决策单调性的定义。</p><p>编写大概有几种方式：</p><ol><li>分治，$solve(l, r, L, R)$ 表示处理 $[l, r]$ 的 dp 值，决策点位置锁定在 $[L, R]$，每次找到 $mid = \frac{l + r}{2}$ 的决策点并递归，一只 $log$</li><li>二分 + 单调队列，单调队列维护决策点，他们的影响区间可以二分求，每次进来新决策点先看看能不能弹队尾，不能再二分求新决策点的影响区间（诗人小 G 那题好像就是这个）（上面那道 $321E$ 代码在这：<a href="https://codeforces.com/problemset/submission/321/110814883" target="_blank" rel="noopener">点我</a>）</li></ol><p>四边形不等式笔者还没学会…… 主要是从没遇到过 <del>感觉上面这些就能畅行天下了 qaq</del></p><p><del>考场上当然都是先猜后证啦 =w=</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 带权二分 </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC115 &amp; CF709 题解</title>
      <link href="2021/03/22/ARC115%20&amp;%20CF709%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/03/22/ARC115%20&amp;%20CF709%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><del>两场时间相同就并起来写了</del></p><p><del>还是 ARC 好啊</del></p><h2 id="ARC012"><a href="#ARC012" class="headerlink" title="$ARC012$"></a>$ARC012$</h2><h3 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h3><p>显然 $(i, j)$ 不可能当且仅当 $bitcount(a_i \oplus a_j) = 2k (k \in Z)$，分讨一下发现后面这个满足当且仅当 $bitcount(a_i)$ 和 $bitcount(a_j)$ 的奇偶性相同。</p><h3 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h3><p>无解随便判：令 $A_i = c_{i, 1} - a_1$, $B_j = c_{1, j} - b_1$, $a_i = a_1 + A_i$, $b_j = b_1 + B_j$，那么若 $c_{i, j} \neq c_{1, 1} + A_i + B_j$ 则无解。否则考虑 $a_1$ 和 $b_1$ 的取值，要保证所有 $a_i$ 和 $b_j$ 非负，$mna = \max(0, \max(-A_i))$, $mnb = \max(0, \max(-B_i))$，若 $mna + mnb &gt; c_{1, 1}$ 则无解，否则取 $a_1 = mna$ 即可。</p><h3 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h3><p>我是煞笔，直接写了个 $O(n \sqrt{n} + nlog^2n)$ 的二分 + 线段树，取 mex，好在 at 评测姬快如闪电。</p><p>正解有点小妙，将 $a_i$ 设为 $i$ 的质因数个数（重复算多个），这样一定满足 $a_{i 的因数} &lt; a_i$。</p><h3 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h3><p>首先如果是树的话，$k$ 为奇数无解，否则看作两两配对，答案就是 $\binom{n}{k}$；图呢答案就是 $2^{m - (n - 1)} \binom{n}{k}$。</p><p>因为选一条非树边，有几种情况：</p><ol><li>如果连接两个黑点，这俩原先配对的就断了，变成他俩用这条非树边彼此配对</li><li>如果连接两个白点，可以先让这俩在树上路径上配对变黑，再用非树边让他俩变白</li><li>连接一黑一白，直接还是合法的</li></ol><p>多个连通块，背包一下就好。</p><h3 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h3><p>$dp_{i, j}$ 表示到第 $i$ 个，与其同色的有 $j$ 个。$dp_{nxt, j + nxt - i - 1} += dp_{i, j} * \min\limits_{k \in [i + 1, nxt]}( a_k )$</p><p>每个元素都有两种去处，一是归入已有块，二是自成一块。考虑单调栈维护已有块，越往前最小值一定是递减的，有元素进栈时就推平一块儿地顺便合并被推平块，成为新块，新块的值是推平块的值之和。</p><h3 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h3><p>咕咕？</p><h2 id="CF709"><a href="#CF709" class="headerlink" title="$CF709$"></a>$CF709$</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="$A$"></a>$A$</h3><p>$\lceil \frac{m}{2} \rceil$ 意味着即使有不合法的小朋友也只有一个。于是先随便选，若不合法则在有选择余地的天里换人。</p><p>记录 xml 的手贱瞬间：换的是不合法小朋友<strong>被选中的那些天</strong>啊喂！</p><h3 id="B-1"><a href="#B-1" class="headerlink" title="$B$"></a>$B$</h3><p>每次删除不会对其他位置造成影响。链表即可？不过我用的并查集。</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="$C$"></a>$C$</h3><p>用线段树——烦了！往前走，最小值递减，于是维护每个块的 $\max(dp_{i - 1})$。当前块有两种选择：</p><ol><li>归入上一块，即 $dp_i = dp_{stk_{top - 1}}$</li><li>新成一块，即 $dp_i = Mx_{top} + b_i$</li></ol><p>一个简单的单调栈就 AC 辣，是不是很奈思？</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, h[N], b[N], dp[N], top, stk[N], Mx[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmax</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = max(x, y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;h[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">-1e18</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Mx[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        ll mx = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; h[stk[top]] &gt;= h[i]) &#123;</span><br><span class="line">            cmax(mx, Mx[top]);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">        Mx[top] = mx;</span><br><span class="line">        dp[i] = max(dp[stk[top - <span class="number">1</span>]], mx + b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="D-1"><a href="#D-1" class="headerlink" title="$D$"></a>$D$</h3><p>对于某对 $(u, v, l)$，$(x, y)$ 合法当且仅当 $dis_{u, x} + v_{x, y} + v_{y, v} \leq l$</p><p>枚举 $u$, $x$, $y$，$(x, y)$ 合法当且仅当 $dis_{u, x} + v_{x, y} \leq \max(l - v_{y, v})$</p><p>就做完了？大水题，真的是 div1 的 $D$ 嘛。。</p><h3 id="E-1"><a href="#E-1" class="headerlink" title="$E$"></a>$E$</h3><p>咕咕</p><h3 id="F-1"><a href="#F-1" class="headerlink" title="$F$"></a>$F$</h3><p>ACAM。广义 SAM 怎么做啊？</p><p>$s_j$ 在 $s_i$ 中出现，一定 $|s_j| \leq |s_i|$。我们枚举 $i$ 和 $i$ 中 $j$ 出现位置的右端点 $k$，<br>$s_j$ 一定是右端点为 $k$ 的左端点最小的串。$j$ 是好确定的——就是在 ACAM 上跑 $s_i$ 的时候，距离 $k$ 最近的整串位置。然后右端点在 $[k + 1, |s_i|]$ 的串的最小左端点还要大于 $k - |s_j| + 1$。</p><p>$s_j$ 对 $s_i$ 有贡献，当且仅当其在 $s_i$ 中出现的次数 $=$ 不被其他 $s_i$ 中出现串包含的出现次数（有点绕），左边这个用 BIT 维护 dfs 序，右边那个直接做就好啦。</p><p>$O((\sum |s_i|) log (\sum |s_i|))$</p><p><a href="https://codeforces.com/contest/1483/submission/110977535" target="_blank" rel="noopener">$Code$</a></p><p>ACAM 虽然没有 SAM 功能多，但处理模式匹配、部分子串问题就简洁许多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Burnside &amp; Polya</title>
      <link href="2021/03/19/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Burnside%20&amp;%20Polya/"/>
      <url>2021/03/19/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Burnside%20&amp;%20Polya/</url>
      
        <content type="html"><![CDATA[<p><a href="https://oi-wiki.org/math/permutation-group/" target="_blank" rel="noopener">oi-wiki</a></p><h3 id="Burnside-定理"><a href="#Burnside-定理" class="headerlink" title="$Burnside$ 定理"></a>$Burnside$ 定理</h3><p>$|X/G| = \frac{1}{|G|} \sum\limits_{g \in G} |X^g|$</p><p>其中</p><ul><li>$X$ 是不考虑本质不同的染色方案集合</li><li>$G$ 是各种翻转啊旋转啊等操作构成的置换群</li><li>$X/G$ 是本质不同的染色方案集合</li><li>$X^g$ 是在置换 $g$ 意义下 $X$ 中不动点个数（不动点表示 $g(x) = x$）</li></ul><h3 id="Polya-定理（-Burnside-的显然推论）"><a href="#Polya-定理（-Burnside-的显然推论）" class="headerlink" title="$Polya$ 定理（$Burnside$ 的显然推论）"></a>$Polya$ 定理（$Burnside$ 的显然推论）</h3><p>大概其诞生之意义是解决环上问题？<del>也可能我 $\mathcal{Naive}$ 了</del></p><p>$|X/G| = \frac{1}{|G|} \sum\limits_{g \in G} |M|^{c(g)}$</p><p>其中</p><ul><li>$M$ 是颜色数</li><li>$c(g)$ 是置换 $g$ 的不相交循环置换个数</li></ul><h3 id="Polya-板题"><a href="#Polya-板题" class="headerlink" title="$Polya 板题$"></a><a href="https://www.luogu.com.cn/problem/P4980" target="_blank" rel="noopener">$Polya 板题$</a></h3><p>这题我们直接套公式就可以做！<br>$ans = \frac{1}{n} \sum\limits_{g \in G} n^{c(g)} = \frac{1}{n} \sum\limits_{i | n} \varphi(n / i) * n^i$</p><p>设 $g$ 旋转了 $i$，则 $c(g) = gcd(n, i)$，因为某个点在置换 $g$ 的重复作用下经过 $lcm(n, i)$ 次操作回到自身，所以 $c(g) = \frac{n * i}{lcm(n, i)} = gcd(n, i)$</p><p>枚举 $c(g)$，系数为 $\varphi(n / i)$，因为<br>$\sum\limits_{k = 1}^{n} [gcd(n, k) == i]= \sum\limits_{k = 1}^{n / i} [gcd(n / i, k) == 1] = \varphi(n / i)$</p><p>$O(\sqrt{n})$。</p><h3 id="Magic-Bracelet"><a href="#Magic-Bracelet" class="headerlink" title="$Magic Bracelet$"></a><a href="https://vjudge.net/problem/POJ-2888" target="_blank" rel="noopener">$Magic Bracelet$</a></h3><p>有限制，填色方案那里要魔改一发：$ans = \frac{1}{n} \sum_k f(k) \varphi(n / k)$，$f(k)$ 表示 $c(g) = k$ 的方案数，显然等于长度为 $k + 1$ 且首尾颜色相同的链的方案数，矩阵加速即可。</p><p>类似的还有「如果奇迹有颜色」，写在「常系数齐次线性递推」里。</p><h3 id="洛谷4128-有色图"><a href="#洛谷4128-有色图" class="headerlink" title="$洛谷4128-有色图$"></a><a href="https://www.luogu.com.cn/problem/P4128" target="_blank" rel="noopener">$洛谷4128-有色图$</a></h3><p>染色的是边，转的是点。某置换的不动点个数等于 $m$ 的「边等价类个数」次方。要求边等价类个数，就要分_连接同个循环的点_和_连接不同循环的点_讨论。</p><p>同个循环：设长度为 $b_i$，边等价类个数为 $b_i / 2$</p><p>不同循环：边等价类大小为 $lcm(b_i, b_j)$，边等价类个数为 $b_i * b_j / lcm(b_i, b_j) = gcd(b_i, b_j)$</p><p>现在知道了具体 $b_i$ 就能算答案了。<br>考虑 $n$ 的分拆，$7e7$ 左右，十分稳</p><p>我们枚举 $b$ 的多重集，系数也挺正常的：$\frac{n!}{\prod b_i!} <em> \prod (b_i - 1)! </em> \frac{1}{c_i!}$</p><p>其中第一项是把点分配到多重集里，第二项是每个集合排顺序（是置换嘛），第三项是除掉大小相同的集合算重的方案。</p><p>有双倍经验题：HNOI2009-图的同构计数。第一反应是无标号连通图计数 + 背包——不对劲，我只会有标号的。再一想，边的有无不正对应着此题中染成黑或白色吗？于是看题解，果真就是有色图的卡常版——把 gcd 在中途计算掉就能 AC 了。</p><p>三倍经验题：<a href="https://dev.xjoi.net/contest/1633/problem/2" target="_blank" rel="noopener">（校内模拟赛）种族</a>，还要讨论一条边跨越两个循环和跨越三个循环的情况。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 012 题解</title>
      <link href="2021/03/14/AGC%20012%20%E9%A2%98%E8%A7%A3/"/>
      <url>2021/03/14/AGC%20012%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/agc012/tasks" target="_blank" rel="noopener">链接</a></p><h3 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h3><p>$t_{i, j}$ 表示把距离 $i$ 为 $j$ 的区域染色的最晚指令，每次把 $t_{i, j}$ 转给 $t_{x, j - 1}$ 其中 $x$ 和 $i$ 相邻。$O(d(n + m))$</p><h3 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h3><p>巧妙的构造，考虑分为两半，后半是 $1$ ~ $100$，前半是 $1$ ~ $x$ 的排列，好串数量即为前半部分上升序列的个数。考虑进空串就是构造个数为 $n + 1$ 的。考虑从小到 $x$ 加字符，每次可以放在结尾或开头，对应的答案每次 $*2$ 或 $+1$。</p><h3 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h3><p>这关系显然具有传递性。。即如果 $a$ 能到达位置 $i$，能和 $a$ 交换的 $b$ 也能到达 $i$。那么缩块，每个连通块分别独立。</p><p>一个连通块的答案是 $\frac{(\sum s_i)!}{\prod s_i!}$，$s_i$ 表示该连通块中颜色为 $i$ 的点数。</p><p>考虑如何连边：每种颜色向其重量最小的球连边，每个重量最小的球向全局重量最小球连边（如果两者颜色相同就只能找全局次小球）</p><p>最后只有全局最小球所在的块的颜色可能 $&gt; 1$（显然 $= 1$ 就没有贡献）。</p><h3 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h3><p>跳跃只能使用 $log$ 次。而你如果“固步自封”就只能走一个连续区间。预处理每种长度的区间。</p><p>抽象一点看，是从 $log$ 层每层不选或选一个区间看能不能覆盖所有位置。由于没有顺序要求，我们考虑维护前后缀的 dp。</p><ul><li>$l_S$ 表示使用了 $S$ 长度集合，能完全覆盖到的最右端点</li><li>$r_S$ 表示使用了 $S$ 长度集合，能完全覆盖到的最左端点</li><li>$L_{d, x}$ 表示第 $d$ 层中 $x$ 所在区间的左端点</li><li>$R_{d, x}$ 表示第 $d$ 层中 $x$ 所在区间的右端点</li></ul><p>转移就枚举长度、枚举区间，更新 $l$ 和 $r$，复杂度是 $O(V log V log(区间个数))$</p><p>这样会不会爆炸啊？$\mathcal{Naive}$！区间个数如果在长度最大的那层超过 $logV$ 了那就直接无解了啊。</p><h3 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h3><p>首先 $b_n$ 是确定的，删去它。然后需要选 $2$ 个 $a$ 中元素一块删去。我们发现 $b_{n - 1}$ 最多移动 $1$！</p><p>可以推一些结论:</p><ol><li>$a_i \leq b_i \leq a_{2n - i}$</li><li>不存在 $i &lt; j$ 使得 $b_j &lt; b_i &lt; b_{j + 1}$</li></ol><p>大概是充要条件？</p><p>所以 $b_i$ 的取值范围就是 $[a_i, \min(b_j)] \cup [\max(b_j), a_{2n - i}]$（要用到第二条性质，所有 $b_j$ 都是连贯的）。设两个集合分别为 $A$ 和 $B$。</p><p>后面的限制前面的，考虑从后往前 dp。$A.l$、$A.r$ 递减，$B.l$、$B.r$ 递增。维护可选空位集合，需要支持每次插入/删除后的去重排序操作，等价于「加首尾」和「删除 $b_{i + 1}$ 到 $b_i$ 这段区间」（不包括端点），显然每个 $b_i$ 都在边界上。</p><p>按此设计 dp 方程：$dp_{i, j, k}$ 表示<strong>选定</strong> $b_i$ 后，$A$ 还剩 $j$ 个空位，$B$ 还剩 $k$ 个空位。转移就枚举选哪个空位。</p><p>坑点：如果选择拓宽某一方向，另一方向的空位数需要额外加一，因为每次删除的区间不包括端点，$b_{i + 1}$ 的位置需要空出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六省联考2017 乱写</title>
      <link href="2021/03/12/%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/03/12/%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/list?keyword=%E5%85%AD%E7%9C%81%E8%81%94%E8%80%83&amp;page=1" target="_blank" rel="noopener">链接</a></p><h2 id="寿司餐厅"><a href="#寿司餐厅" class="headerlink" title="寿司餐厅"></a>寿司餐厅</h2><p>$mx^2 + cx$ 解读：吃一个 $x$ 代价 $x$，吃过 $x$ 代价 $mx^2$</p><p>看题：</p><ul><li><p>如果选了 $d_{i, j}$，则必须选择 $d_{l, r} (i \leq l \leq r \leq j)$，必须选择 $d_{k, k} ( i \leq k \leq r )$</p></li><li><p>可以在 $d_{k, k}$ 处减去代价 $a_k$</p></li><li><p>选了 $d_{k, k}$ 就必须选择物品 $a_k$，代价 $m * a_k^2$</p></li></ul><p>至此已经转化为最大权闭合子图模型。</p><p>关于建图：怎么选所有子区间？从 $d_{i, j}$ 向 $d_{i + 1, j}$ 和 $d_{i, j - 1}$ 连 $\infty$ 边表示强制选。</p><h2 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h2><p>大水<del>桶</del>题，枚举最晚时间，前后缀算一算。卡 long long，<strong>从小到大枚举最晚时间</strong>，如果仅仅是同学的不满意度已经大于历史的 $ans$ 最小值就 break。</p><h2 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h2><p>组合意义（这个真的不阴间）：从 $nk$ 个物品中选 $t (t \mod k = r)$ 个物品的方案数。</p><p>朴素 dp：$f_{i, j}$ 表示到第 $i$ 个物品，选的物品个数 $\mod k = j$ 的方案数。转移就是循环的形式。</p><p>注意到 $K$ 和 $r$ 很小，矩乘即可。</p><p>另一种做法：$\sum\limits_{i \mod k = r} \binom{nk}{i} = \sum\limits_{i \mod k = r} [x^i] (1 + x)^{nk}$，暴力做多项式快速幂取模即可。</p><h2 id="摧毁树状图"><a href="#摧毁树状图" class="headerlink" title="摧毁树状图"></a>摧毁树状图</h2><p>暴力拼起来有 84！<del>考场上谁 tm 去写正解啊</del></p><p>只有两种情况：相交与不相交。</p><p>设计状态的时候考虑两条路径“生长”的过程。状态如下：</p><ul><li>$dp_{x, 0}$：选一条上端点为 $x$ 的路径的最大连通块数</li><li>$dp_{x, 1}$：选一条 $x$ 子树里不经过 $x$ 的路径的最大连通块数（注意这时 $x$ 和 $x$ 的父亲会构成新连通块）</li><li>$dp_{x, 2}$：选一条 $x$ 子树里经过 $x$ 的路径的最大连通块数</li><li>$dp_{x, 3}$：选一条上端点为 $x$ 的路径，和一条 $x$ 子树里的路径（两者边不相交）的最大连通块数</li></ul><p><strong>注意：这里的最大连通块数都仅指「$x$ 子树内」。</strong></p><p>转移比较常规，细节有点多，建议看代码：<a href="https://loj.ac/s/1098042" target="_blank" rel="noopener">点我</a></p><h2 id="分手是祝愿"><a href="#分手是祝愿" class="headerlink" title="分手是祝愿"></a>分手是祝愿</h2><p>首先按键的方案唯一——从后往前就能唯一确定。$50$ 分就直接从后往前按。</p><p>考虑正解：除开这些必须按的键，如果按了其他的键 <strong>就得按同一个键按回来</strong>。</p><p>根据期望线性性，将 dp 状态设为 $f[i]$ 表示从 $i$ 个必选的键转移到 $i - 1$ 个必选的键的期望操作次数。</p><script type="math/tex; mode=display">f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])</script><p>第一项表示选了一个必选的，一次就到 $i - 1$ 去了；第二项表示选了一个其他的，就得 $f[i + 1]$ 次按回来，再 $f[i]$ 次按到 $i - 1$ 去。解一个一元一次方程就好了（</p><p>很神仙！</p><h2 id="相逢是问候"><a href="#相逢是问候" class="headerlink" title="相逢是问候"></a>相逢是问候</h2><p>就剩一道了！加油 xml！</p><p>做过的套路题，套了数论皮子的暴力题。</p><p>扩展欧拉定理：$a ^ b \mod{p} =$</p><ul><li><p>$b &lt; \varphi(p)$：$a^{b}$</p></li><li><p>$b \geq \varphi(p)$：$a^{b \% \varphi(p) + \varphi(p)}$</p></li></ul><p>这题本质是个套娃，$c^{c^{c^{\cdots}}} \mod{p} = c^{c^{c^{\cdots}} \mod{ \varphi(p) } + \varphi(p)（加不加 \varphi(p) 要按上面那样分类讨论） } \mod{p}$，一直套娃下去，模数变成 $\varphi(\varphi(\varphi(\cdots\varphi(p)))) = 1$，并且只要 $log$ 层。</p><p>所以<del>像 segment tree beats 那样</del>维护线段树每个区间最小修改次数，如果超过 $log$ 就不改了因为值再也不会变了，否则就递归下去。复杂度三只 $log$：线段树一只，扩展欧拉定理一只，快速幂一只，而快速幂那只可以预处理优化掉所以最后是两只 $log$。</p><p><a href="https://loj.ac/s/1098152" target="_blank" rel="noopener">$Code$</a></p><hr><p>总结：「寿司餐厅」如果再熟练一些就能自己做出来了……感觉对模型的转化还不够。<del>待会去做 CF 题</del>「摧毁树状图」恶心人的树形 dp，口区口区。「分手是祝愿」还是挺有意思的，我喜欢它！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2020 乱写</title>
      <link href="2021/03/08/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892020%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/03/08/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892020%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E8%81%94%E5%90%88%E7%9C%81%E9%80%89" target="_blank" rel="noopener">link</a></p><h3 id="冰火战士"><a href="#冰火战士" class="headerlink" title="冰火战士"></a>冰火战士</h3><p>就是求一个 $lim$ 使得 $\min( \sum\limits_{b_i \leq lim} a_i, \sum\limits_{d_i \geq lim} c_i )$ 最大。$X$ 型函数求交点问题，考虑二分，但线段树上二分太慢了……</p><p>卡常神器：BIT + 倍增。二分找到第一个冰系前缀和不小于火系后缀和的位置，稍微移项得「两种前缀和之和不小于火系全和」。</p><p><a href="https://loj.ac/s/1085474" target="_blank" rel="noopener">$Code$</a></p><h3 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h3><p>Trick：$\binom{n}{k} k^{\underline{m}} = \binom{n - m}{k - m} n^{\underline{m}}$（易证）</p><p>把 $f(k)$ 变成下降幂形式 $\sum\limits_{i = 0}^m b_i k^{\underline{i}}$，再把 $\binom{n}{k} k^{\underline{i}}$ 变成 $\binom{n - i}{k - i} n^{\underline{i}}$，变换求和符号，上二项式定理就做完了。</p><p><a href="https://loj.ac/s/1088152" target="_blank" rel="noopener">$Code$</a>  <del>模数非质啊啊啊</del></p><h3 id="信号传递"><a href="#信号传递" class="headerlink" title="信号传递"></a>信号传递</h3><p>状压 dp, $f_S = \min_x( f_{S - x} + |S| <em> ( \sum\limits_{y \in S - x} (K </em> c_{x, y} + c_{y, x}) + \sum\limits_{y \notin S - x} (K * c_{y, x} - c_{x, y}) ) )$。复杂度 $O(2^m m^2)$，空间 $O(2^m m)$，都不行。</p><p>考虑把 $|S| <em>$ 后面那坨括号设为 $g_{S, x}$，后面那个计算 $y \notin S - x$ 的用容斥，即最开始先算好全集，到时候抠掉 $y \in S - x$ 的错误贡献就好了。则 $g_{S, x} = g_{S - x, x} + (K </em> c_{x, y} + c_{y, x} ) - ( K * c_{y, x} - c_{x, y} )$，$y$ 取 $lowbit(S - x)$ 这样转移就是 $O(1)$ 的了。</p><p>空间怎么搞呢？注意到每个 $g_{S - x}$ 在给 $g_{S}$ 转移完后就失去价值了，考虑回收。具体用 queue 实现。</p><p><a href="https://loj.ac/s/1087320" target="_blank" rel="noopener">$Code$</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>逆建 01 Trie（从低位到高位插入），维护 $v_{a_i} + d(x, a_i)$ 的集合，这样每次 $+ 1$ 就是 $0$ 变 $1$ 并返回，或者 $1$ 变 $0$ 并继续递归。直接交换儿子并递归到改后的 $0$ 子树里去继续修改就好了。记录每位 $1$ 的奇偶。单次 $logV$，总的就是 $nlogV$。</p><p><a href="https://loj.ac/s/932042" target="_blank" rel="noopener">$Code$</a></p><hr><p>还剩两道毒瘤题。。。/kk</p><hr><h3 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h3><p>反演一波，根据 $n = \sum\limits_{d \mid n}$ 可得 $ans = \sum\limits_{d = 1}^{V} \varphi(d) \sum\limits_{d \mid w_{e_i}} ( \sum\limits_{i = 1}^{n - 1} w_{e_i} )$</p><p>trick: 矩阵树求边权和，边权为 $1 + w_i x$，答案为行列式的一次项系数。所以行列式只需在模 $x^2$ 意义下计算，维护 $x^0$ 和 $x^1$ 项即可。<del>拉插就算了吧</del></p><p>复杂度 $O(Vn^3)$，会 T。玄学优化：边少于 $n - 1$ 就跳过。于是非常跑不满。</p><p>行列式除法：$(ax + b)^{-1} \equiv -\frac{a}{b^2} + \frac{1}{b} \pmod{x^2}$；寻找当前位置非零行，若存在常数项非零则直接选那个，否则常数项都为零，选一次项系数非零的。代码超好写。</p><p><a href="https://loj.ac/s/1088258" target="_blank" rel="noopener">$Code$</a></p><h3 id="魔法商店"><a href="#魔法商店" class="headerlink" title="魔法商店"></a>魔法商店</h3><p><del>终于……要开始贺了么……</del> 拟阵？保序回归？蒟蒻全都不会哒！</p><p>异或相关啊。任何一个 $c_i$, $i \notin A$ 都可以被 $A$ 的一个子集异或出来，否则 $A$ 就不是最大的了。对于 $k \notin A$，设 $s_k$ 表示 $A$ 中异或出 $c_k$ 的集合（这个可以线性基 + bitset/ll数组 得到）。$A$ 价格总和最小的充要条件是 $v_k \geq \max\limits_{i \in s_k}(v_i)$。对 $B$ 也可以得到一些 $\geq$ 关系。把这些关系建成边，问题转化为「在一个 DAG 上，把第 $i$ 个点点权修改为 $x$ 的代价是 $(x - v_i)^2$，要求每个点点权<strong>大于等于</strong>其所有后继」，即一个经典的保序回归问题。</p><p>感性理解一下保序回归吧。。整体二分，如果一个值在当前情况中取 $mid$ 最优，那么在最终答案其应取 $\leq mid$，否则应取 $&gt; mid$。</p><p>强制每个点先为 $mid + 1$，那么选一个点为 $mid$ 相当于强制其后继也为 $mid$，边权反一下（准确的说是连边方向换一下，原来和 $S$ 连的现在和 $T$ 连）做最大权闭合子图问题。</p><p>复杂度 $O(n^2 <em> nB </em> logV)$，$B$ 这里是 $64$ <del>甭慌人家稳着呢</del></p><p><a href="https://loj.ac/s/1090121" target="_blank" rel="noopener">$Code$</a></p><h3 id="丁香之路"><a href="#丁香之路" class="headerlink" title="丁香之路"></a>丁香之路</h3><p>挺妙的…… 这种结论题，考思维模式的，唉，我就不行。</p><p>答案一定是一条欧拉回路，这个欧拉回路由这 m 条必走边和一些你添加的凑度数的边组成。</p><p>具体来说先给起始点连边，奇度点肯定是两两配对，不会带上偶度点的，那必然是相邻的两个奇度点配对。但是当前可能有若干个连通块，没关系，求 MST 即可，代价是 MST 边权和两倍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】LGV 引理</title>
      <link href="2021/03/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LGV%20%E5%BC%95%E7%90%86/"/>
      <url>2021/03/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LGV%20%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><p>LGV 引理，用来处理<strong>有向无环图</strong>上的不相交路径计数问题。</p><ul><li>$w(Path)$ 表示 $Path$ 这条路径上的边权积，也可以是生成函数，这样就能搞很多事情</li><li>$e(u, v)$ 表示 $u$ 到 $v$ 所有路径的 $w(Path)$ 之和</li><li>$N(\sigma)$ 表示 $\sigma$ 这个排列的逆序对数</li><li>有矩阵 $M$ 和点集 $A$、$B$，$M_{i, j} = e(A_i, B_j)$</li></ul><script type="math/tex; mode=display">ans = det(M) = \sum\limits_{S : A \rightarrow B} (-1)^{N(\sigma(S))} \prod\limits_{i = 1}^n w(S_i)</script><p>其中 $S$ 这个映射是在枚举 $A$ 到 $B$ 的每个路径组。</p><p>感性理解挺容易的，所有相交的路径从排列角度都可以看作在相交的那一刻互换灵魂，会形成逆序对；只要逆序对数 $&gt; 0$，经过类行列式的容斥，这个路径组贡献就是 $0$。</p><hr><h3 id="Gym102978-A"><a href="#Gym102978-A" class="headerlink" title="$Gym102978-A$"></a><a href="https://codeforces.com/gym/102978/problem/A" target="_blank" rel="noopener">$Gym102978-A$</a></h3><p>先不考虑 $a_{R, C} = V$。划一条折线 $i$ 表示分割了 $val_i$ 和 $val_{i + 1}$，共有 $k - 1$ 条线，将每条线向右向下平移一个单位后转化成不相交路径计数，上 LGV。</p><p>考虑 $a_{R, C} = V$。诶——也就是说恰好 $V - 1$ 条折线跨过了 $(R, C)$ 西北方向的直线！怎么用 LGV 呢？边积 + 生成函数！把 $(R, C)$ 西北方向的所有路径的 $w()$ 赋为 $z$，答案就是行列式求出的生成函数第 $V - 1$ 项。然而行列式套卷积什么的显然boom，考虑见过的套路——随便什么带进去，最后插回来得到系数。</p><p><a href="https://vjudge.net/solution/29880391" target="_blank" rel="noopener">$Code$</a></p><hr><p><del>好诶 又水了一篇</del> 碰到有趣的题目会回来写的啦</p><p>upd on 2021.7.22: 补一道 XJOI2817 xza 场 T3！！</p><h3 id="操作计数"><a href="#操作计数" class="headerlink" title="操作计数"></a>操作计数</h3><p>先只考虑每次下标不同的限制。</p><p>设总操作数为 $t$。每个下标 $i$ 需要操作次数为 $d_i = b_i - a_i$。</p><p>容斥，枚举不合法操作数 $s$（被分到了相同的下标上），每个下标 $i$ 分到的不合法操作数 $x_i$，贡献是 $(-1)^s \binom{s}{x_1, \cdots, x_n} \binom{t}{s} \binom{2(t - s)}{d_1 - 2x_1, \cdots, d_n - 2x_n} = \prod\limits_{i = 1, \sum x_i = s}^n \frac{ 1 }{ x_i! (d_i - 2x_i)! } (-1)^s s! [2(t - s)]! \binom{t}{s}$，后面这坨关于 $s$ 可以最后处理。</p><p>考虑 EGF。设 $f_{k}(x)$ 表示 $d_i = k$ 的 EGF, $f_{k}(x) = \sum \frac{1}{(k - 2i)!} \frac{x^i}{i!}$</p><p>现在考虑数互不相等的限制。转化为不相交路径计数，上 LGV，$mat_{i, j} = f_{b_j - a_i}(x)$，带单位根插出多项式（经典操作</p><p>相当于两个容斥套起来，正确性显然。</p><p>注意这里有个细节就是我们默认序列递增，每次操作是大的下标在前，这样保证同一次操作不会引发可避免的「数相等」事件。因此答案要除以 $2^t$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21Feb 训练日志</title>
      <link href="2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】类欧几里得</title>
      <link href="2021/02/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>2021/02/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="平平无奇类欧几里得"><a href="#平平无奇类欧几里得" class="headerlink" title="平平无奇类欧几里得"></a>平平无奇类欧几里得</h2><p>最原始的类欧几里得长这样：</p><ul><li>$f(a, b, c, n) = \sum\limits_{i = 0}^n \lfloor \frac{ai + b}{c} \rfloor$</li></ul><p>其推广形式有</p><ul><li>$g(a, b, c, n) = \sum\limits_{i = 0}^n i\lfloor \frac{ai + b}{c} \rfloor$</li><li>$h(a, b, c, n) = \sum\limits_{i = 0}^n \lfloor \frac{ai + b}{c} \rfloor ^2$</li></ul><p>证明看<a href="https://oi-wiki.org/math/euclidean/" target="_blank" rel="noopener">oi-wiki</a>，这里只复读结论~</p><p>设 $m = \lfloor \frac{an + b}{c} \rfloor$</p><h3 id="求-f"><a href="#求-f" class="headerlink" title="求 $f$"></a>求 $f$</h3><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $f(a, b, c, n) = f(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \frac{n(n + 1)}{2} + \lfloor \frac{b}{c} \rfloor (n + 1)$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $f(a, b, c, n) = nm - f(c, c - b - 1, a, m - 1)$</p></li></ul><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">euclid</span><span class="params">(ll n, ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> (b / c) * (n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= c || b &gt;= c) <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span> * (a / c) + (n + <span class="number">1</span>) * (b / c) + euclid(n, a % c, b % c, c);</span><br><span class="line">    ll m = (a * n + b) / c;</span><br><span class="line">    <span class="keyword">return</span> n * m - euclid(m - <span class="number">1</span>, c, c - b - <span class="number">1</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="求-g"><a href="#求-g" class="headerlink" title="求 $g$"></a>求 $g$</h3><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $g(a, b, c, n) = g(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \frac{n(n + 1)(2n + 1)}{6} + \lfloor \frac{b}{c} \rfloor \frac{n(n + 1)}{2}$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $g(a, b, c, n) = \frac{1}{2}( n(n + 1) m - g(c, c - b - 1, a, m - 1) - h(c, c - b - 1, a, m - 1) )$</p></li></ul><h3 id="求-h"><a href="#求-h" class="headerlink" title="求 $h$"></a>求 $h$</h3><ul><li><p>$a \geq c$ 或 $b \geq c$</p><p>  $h(a, b, c, n) = h(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor ^2 \frac{n(n + 1)(2n + 1)}{6} + (n + 1) \lfloor \frac{b}{c} \rfloor ^2 + 2 \lfloor \frac{b}{c} \rfloor f(a \% c, b \% c, c, n) + 2 \lfloor \frac{a}{c} \rfloor g(a \% c, b \% c, c, n) + \lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor n(n + 1)$</p></li><li><p>$a &lt; c$ 且 $b &lt; c$</p><p>  $h(a, b, c, n) = m (m + 1)n + 2g(c, c - b - 1, a, m - 1) - 2f(c, c - b - 1, a, m - 1) - f(a, b, c, n)$</p></li></ul><p>带有下取整的都可以试试类欧几里得。分两种情况：分离后递归，变换后递归。</p><p>类欧几里得的最大优势是其几何意义：比如说原始型可理解为一条直线下的整点个数。下面这道在分离那种情况里的几何意义是梯形整点个数。</p><p>变换一般也很套路，结合几何意义在坐标轴上旋转/对称/反转… 即可再次转化为可分离的情况。</p><p>复杂度 $O(log(\max(a, c)))$。</p><h3 id="Sum"><a href="#Sum" class="headerlink" title="$Sum$"></a><a href="https://uoj.ac/problem/42" target="_blank" rel="noopener">$Sum$</a></h3><p>那个根号在指数上太猖狂了，得想办法把它拿下来。$(-1)^a = 1 - 2 * (a \% 2) = 1 - 2a + 4 \lfloor \frac{a}{2} \rfloor$</p><p>我们要求的形如下：$\sum\limits_{d = 1}^n \lfloor d \frac{a \sqrt{r} + b}{c} \rfloor$。</p><p>利用类欧几里得的思想，中间那个分数 $\geq 1$ 的时候求的是较短底边长为 $\lfloor \frac{a \sqrt{r} + b}{c} \rfloor$ 的梯形内整点个数，分离并递归；$&lt; 1$ 的时候是个斜边斜率 $&lt; 1$ 的 $Rt△$，把它关于直线 $y = x$ 对称就变成了斜边斜率 $&gt; 1$ 的 $Rt△$。<a href="https://blog.csdn.net/hzj1054689699/article/details/79552941" target="_blank" rel="noopener">图看其他人的</a></p><p>复杂度考虑每次缩小一半求解区域面积，$O(logn)$。</p><p>坑点：long double，gcd 减小分子分母</p><p><a href="https://uoj.ac/submission/456838" target="_blank" rel="noopener">$Code$</a></p><h2 id="万能欧几里得！"><a href="#万能欧几里得！" class="headerlink" title="万能欧几里得！"></a>万能欧几里得！</h2><p>好东西。【感动】</p><p><del>复读 START！</del></p><p>以最简单的求 $\sum\limits_{x = 1}^n \lfloor \frac{px + r}{q} \rfloor$（这里我们从 $1$ 开始因为下面那道习题就是从 $1$ 开始的 qwq）为例，我们还有一种 $O(T log(\max(p, q)))$ 的算法，其中 $T$ 是两个结构体相乘的复杂度。它适应性很强，可以解决奇形怪状的类欧几里得问题……</p><p>画一条直线 $y = \frac{px + r}{q}$，我们有一个路径串，经过横坐标为整点的坐标时丢一个 $R$，经过纵坐标为整点的坐标时丢一个 $U$，都是整点先丢 $U$，用一个结构体表示路径串，$cnt1$、$cnt2$ 分别为 $U$ 和 $R$ 的个数，$sum$ 为答案。路径串<strong>拼接</strong>过程如下：</p><script type="math/tex; mode=display">(cnt1, cnt2, sum) \times (cnt1', cnt2', sum')</script><script type="math/tex; mode=display">= (cnt1 + cnt1', cnt2 + cnt2', sum + sum' + cnt1 * cnt2')</script><p>没有交换律所以注意顺序。</p><p>设 $f(p, q, r, n, U, R)$ 表示计算 $y = \frac{px + r}{q} (x \in [0, n])$，$U$ 和 $R$ 分别为向上和向右的贡献时的答案。$U$ 和 $R$ 初始分别为 $(1, 0, 0)$ 和 $(0, 1, 0)$。<strong>规定 $0 \leq r &lt; q$。</strong></p><p>$f(p, q, r, n, U, R) =$</p><ul><li>$p \geq q$：$f(p \mod q, q, r, n, U, U^{\lfloor \frac{p}{q} \rfloor} R)$</li><li>$m = \lfloor \frac{pn + r}{q} \rfloor = 0$：$R^n$</li><li><p>关于 $y = x$ 做对称，把 $U$、$R$ 交换，直线 $y = \frac{px + r}{q}$ 变成 $y = \frac{qx - r}{p}$，到整点时先记 $R$，<strong>把直线下移为 $y = \frac{qx - r - 1}{p}$ 就可以先记 $U$ 了</strong>；但是 $r’ = -r - 1 \notin [0, p)$，那么先往左后往下平移 $\frac{1}{p}$ 得到 $y = \frac{qx + ((q - r - 1) \mod p)}{p}$。</p><p>  特判 $(0, 1]$ 和 $(m, \frac{pn + r}{q}]$ 的贡献，返回 $R^{\frac{q - r - 1}{p}} <em> U </em> f(q, p, (q - r - 1) \mod p, m - 1, R, U) <em> R^{n - \frac{q </em> m - r - 1}{p}}$（再说一次不满足交换律！）</p></li></ul><p>细节也没什么了 QwQ，就是初始化一些东西，$U$，$R$ 之类的。</p><p>如果从 $0$ 开始，要计入 $0$ 处答案。</p><h3 id="万能欧几里得"><a href="#万能欧几里得" class="headerlink" title="万能欧几里得"></a><a href="https://loj.ac/p/6440" target="_blank" rel="noopener">万能欧几里得</a></h3><p>套用上面的方法，三元组设为 $(X = A^{cnt1}, Y = B^{cnt2}, ans)$，乘法为 $(X, Y, ans) \times (X’, Y’, ans’) = (X <em> X’, Y </em> Y’, ans + X <em> ans’ </em> Y)$</p><p>坑点：要开 __int128</p><p><a href="https://loj.ac/s/1115808" target="_blank" rel="noopener">$Code$</a></p><h3 id="LOJ138-类欧几里得"><a href="#LOJ138-类欧几里得" class="headerlink" title="$LOJ138-$类欧几里得"></a><a href="https://loj.ac/p/138" target="_blank" rel="noopener">$LOJ138-$类欧几里得</a></h3><p>zhèn不是人那！万能欧几里得的代码复杂度可比正宗类欧小多了。</p><p>合并两个结构体的时候需要知道每节线段 $U$ 的个数和 $R$ 的个数，拼接时需要二项式展开，那么<br>设 $(cnt1, cnt2, ans_{a, b})$ 为 ($U$ 个数, $R$ 个数，$k1 = a$、$k2 = b$ 时的答案)</p><p>设 $C = A * B$</p><p>$C.cnt1 = A.cnt1 + B.cnt1$</p><p>$C.cnt2 = A.cnt2 + B.cnt2$</p><p>$C.ans_{a, b} = A.ans_{a, b} + \sum\limits_{i = 0}^a \sum\limits_{j = 0}^b \binom{a}{i} \binom{b}{j} B.ans_{a - i, b - j}$</p><p>$O(10^4 log \max(p, q))$</p><p><a href="https://loj.ac/s/1116456" target="_blank" rel="noopener">$Code$</a></p><p>闲的无聊用万能欧几里得做 luogu 类欧板题（求 $f$、$g$、$h$）：<a href="https://www.luogu.com.cn/record/49481700" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 类欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】网络流</title>
      <link href="2021/02/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>2021/02/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027E、ARC110E 等一类删除计数问题</title>
      <link href="2021/02/08/AGC027E%E3%80%81ARC110E%20%E7%AD%89%E4%B8%80%E7%B1%BB%E5%88%A0%E9%99%A4%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/08/AGC027E%E3%80%81ARC110E%20%E7%AD%89%E4%B8%80%E7%B1%BB%E5%88%A0%E9%99%A4%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Atcoder 好喜欢出诸如此类的题：你有一个由 ‘$a$’ ~ ‘$?$’ 构成的字符串，每次可以按某种规则删去一些再加上一些，问最终能形成多少种本质不同的字符串。</p><p>偏偏是我的克星。完全没得思路啊摔。仅有的两道 套路倒是相同的 qwq</p><h3 id="AGC027E"><a href="#AGC027E" class="headerlink" title="$AGC027E$"></a>$AGC027E$</h3><p>规则：只有 $ab$，每次删 ‘$aa$’ 为 ‘$b$’ 或删 ‘$bb$’ 为 ‘$a$’。</p><p>如果我们将 $a$ 看作 $1$，将 $b$ 看作 $2$，在模 $3$ 意义下字符串不变。令 $p(s)$ 表示 $s$ 字符之和模 $3$。</p><p>一个字符串 $s$ 能规约到字符 $a$，当且仅当 $p(s) = p(a)$ 且 $s$ 中存在两个相邻的相同字符。（归纳证明：$|s| = 1$ 或 $2$ 时显然成立，否则你可以不断操作第一对相邻的相同字符。）</p><p>$t$ 能否被 $s$ 到达？容易贪心的想到「把 $s$ 分段后让 $t$ 的每个字符与对应段匹配」，且让分的段尽量靠前。于是就可以倒着 dp：$f_i$ 表示以 $[i, |s|]$ 为后缀有多少种分段方案数。</p><p>注意：最后可能剩下一段 $abababab$ 这样无法规约的段，但是它总能被前面部分通过调整规约顺序给化为最终串中的空串。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nxt[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    f[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    nxt[n + <span class="number">1</span>][<span class="number">0</span>] = nxt[n + <span class="number">1</span>][<span class="number">1</span>] = nxt[n + <span class="number">2</span>][<span class="number">0</span>] = nxt[n + <span class="number">2</span>][<span class="number">1</span>] = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        (sum += s[i] == <span class="string">'a'</span> ? <span class="number">1</span> : <span class="number">2</span>) %= <span class="number">3</span>;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = s[i] == <span class="string">'a'</span> ? i + <span class="number">1</span> : (s[i + <span class="number">1</span>] == <span class="string">'b'</span> ? i + <span class="number">2</span> : nxt[i + <span class="number">2</span>][<span class="number">0</span>]);  <span class="comment">// 这一段 p = 1</span></span><br><span class="line">        nxt[i][<span class="number">1</span>] = s[i] == <span class="string">'b'</span> ? i + <span class="number">1</span> : (s[i + <span class="number">1</span>] == <span class="string">'a'</span> ? i + <span class="number">2</span> : nxt[i + <span class="number">2</span>][<span class="number">1</span>]);  <span class="comment">// p = 2</span></span><br><span class="line">        f[i] = add(f[nxt[i][<span class="number">0</span>]], f[nxt[i][<span class="number">1</span>]] + (sum == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sub(f[<span class="number">1</span>], sum == <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="ARC110E"><a href="#ARC110E" class="headerlink" title="$ARC110E$"></a>$ARC110E$</h3><p>规则：只有 $ABC$，每次把两个相邻的不同字符替换为和它俩都不同的那个字符。</p><p><em>解题过程与上面那道完全相同。</em></p><p>如果我们将 $A$ 看作 $1$，$B$ 看作 $2$，$C$ 看作 $3$，在异或意义下字符串不变。令 $p(s)$ 表示 $s$ 异或和。</p><p>一个字符串 $s$ 能规约到字符 $a$，当且仅当 $p(s) = p(a)$ 且 $s$ 中存在两个相邻的不同字符。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], lst[<span class="number">4</span>], pre[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) a[i] = s[i] - <span class="string">'A'</span> + <span class="number">1</span>, pre[i] = (pre[i - <span class="number">1</span>] ^ a[i]);</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        f[i] = (pre[n] ^ pre[i]) == <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            f[i] = add(f[i], f[lst[j ^ pre[i]]]);</span><br><span class="line">        &#125;</span><br><span class="line">        lst[pre[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">3</span>) ans = add(ans, f[lst[i]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变中找不变。<del>（苍 白 无 力）</del></p><p>找性质题有什么总结啊【暴躁】</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】线段树分裂、分治、二进制分组、李超线段树</title>
      <link href="2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84/"/>
      <url>2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><p><img src="/images/%E8%A3%82%E5%BC%80.jpg" alt="我裂开"></p><p><img src="/images/%E5%90%88%E4%B8%8A.png" alt="我合上"></p><p>以某个键值为中点（一般是把前 $k$ 个元素分离出来，而不是把前 $k$ 个下标）将线段树分裂为两部分。就把两棵线段树重合的 $log$ 个节点新建出来，所以单次严格 $O(logn)$，实现非常直白！</p><p>应用条件比较苛刻，要有序，才能关于键值裂开。题不太有，比较经典的这道<a href="https://www.luogu.com.cn/problem/P2824" target="_blank" rel="noopener">排序</a>，容易发现每次排序的是连续区间，对于每个区间建权值线段树，新建区间时把波及到的原有区间分裂出重合部分的线段树即可。以后见到应用再回来写。</p><details>    <summary>template</summary>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_5494</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = N * <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], idx, id;</span><br><span class="line"><span class="keyword">int</span> rt[N], ls[M], rs[M];</span><br><span class="line">ll sz[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x] = sz[ls[x]] + sz[rs[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sz[x]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(ls[x], l, mid), build(rs[x], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sz[x] += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p &lt;= mid ? insert(ls[x], l, mid, p, v) : insert(rs[x], mid + <span class="number">1</span>, r, p, v);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        <span class="keyword">return</span> sz[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) ret = query(ls[x], l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) ret += query(rs[x], mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123; x |= y; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sz[x] += sz[y]; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    merge(ls[x], ls[y], l, mid);</span><br><span class="line">    merge(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        x = y, y = <span class="number">0</span>; <span class="keyword">return</span>;  <span class="comment">// 把 y 合并到空子树 x 上去，放心直接 =</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) split(ls[x], ls[y], l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) split(rs[x], rs[y], mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    upd(y);  <span class="comment">// !!!</span></span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || sz[x] &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= sz[ls[x]]) <span class="keyword">return</span> ask(ls[x], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(rs[x], mid + <span class="number">1</span>, r, k - sz[ls[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ++id;</span><br><span class="line">    build(rt[id], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">4</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (!op) &#123;</span><br><span class="line">            ++id;</span><br><span class="line">            split(rt[id], rt[x], <span class="number">1</span>, n, y, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            merge(rt[x], rt[y], <span class="number">1</span>, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            insert(rt[x], <span class="number">1</span>, n, z, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(rt[x], <span class="number">1</span>, n, y, z));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask(rt[x], <span class="number">1</span>, n, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="线段树分治"><a href="#线段树分治" class="headerlink" title="线段树分治"></a>线段树分治</h2><p>把操作复制 $logn$ 份挂在线段树上 $logn$ 个节点下，最后统一做一遍。时间线段树就是这个。</p><h2 id="二进制分组"><a href="#二进制分组" class="headerlink" title="二进制分组"></a>二进制分组</h2><p><a href="https://imilyx.github.io/2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E7%8E%84%E5%AD%A6" target="_blank" rel="noopener">玄学</a></p><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>维护的是坐标系，支持两个操作：</p><ol><li>加入一条直线</li><li>查询所有加入直线与 $x = x_0$ 的最高交点。</li></ol><p>线段树维护覆盖每个区间没被覆盖面积最多的那条线。如果当前区间中，加入的线段和目前面积最多的线段相交，只需看斜率和中点谁高就能判断谁在这个区间占的面积更大，输的那条往下递归。</p><p>这里运用了标记永久化的思想，查询就把沿途线段贡献取 max。</p><p>如果插入的是线段，需要先找到可插入的区间，再分别加，是两只 log 的。</p><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCTree &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line">  <span class="keyword">int</span> ls[M], rs[M], idx;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;x, ll l, ll r, Func cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123; x = ++idx, f[x] = cur; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[x].F(l) &lt; cur.F(l) ? f[x] = cur, (<span class="keyword">void</span>)<span class="number">0</span> : (<span class="keyword">void</span>)<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x].F(mid) &lt; cur.F(mid)) f[x].k &lt; cur.k ? ins(ls[x], l, mid, f[x]) : ins(rs[x], mid + <span class="number">1</span>, r, f[x]), f[x] = cur;</span><br><span class="line">    <span class="keyword">else</span> f[x].k &gt; cur.k ? ins(ls[x], l, mid, cur) : ins(rs[x], mid + <span class="number">1</span>, r, cur);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">-1e16</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[x].F(p);</span><br><span class="line">    <span class="keyword">return</span> max(f[x].F(p), p &lt;= mid ? qry(ls[x], l, mid, p) : qry(rs[x], mid + <span class="number">1</span>, r, p));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="keyword">using</span> <span class="keyword">namespace</span> LCTree;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】BSGS &amp; exBSGS</title>
      <link href="2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BSGS%20&amp;%20exBSGS/"/>
      <url>2021/02/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BSGS%20&amp;%20exBSGS/</url>
      
        <content type="html"><![CDATA[<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>$O(\sqrt{p})$ 求解关于 $x$ 的高次同余方程 $a^x \equiv n \pmod{p}$，其中 $p$ 为质数。</p><p>由 $a^{\phi(p)} \equiv 1 \pmod{p}$ 得 $x \in [0, p - 1)$。设 $x = i <em> k - j$, 则 $(a^k)^i \equiv b </em> a^j \pmod{p}$，取 $k = \sqrt{p}$，对于 $j \in [0, k)$ 把 $b * a^j \pmod{p}$ 存入 hash 表，枚举 $i \in [0, k)$，查找 hash 表中是否有当前的 $(a^k)^i \pmod{p}$。</p><h2 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h2><p>$p$ 非质的版本，$(a, p) &gt; 1$。考虑转化为 $(a, p) = 1$。</p><p>展开为 $a \cdot a^{x - 1} + p * y = b$，必须要 $(a, p) \mid b$，$a^{x - 1}$ 和 $y$ 才有整数解。</p><p>令上柿变为：$a^{x - 1} \cdot \frac{a}{(a, p)} \equiv \frac{b}{(a, p)} \pmod{\frac{p}{(a, p)}}$。</p><p>此时如果 $(a^{x - 1}, \frac{p}{(a, p)}) = 1$，就直接用 BSGS 解 $a^{x - 1} \equiv \frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}} \pmod{\frac{p}{(a, p)}}$（注意这里的模数可能非质，不能用费马小定理求逆元，只能 exgcd 啦）；否则递归分解直到 $(a’, p’) = 1$。</p><p>在递归过程中若出现 $(a’, p’) ∤ \frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}}$，直接无解。<strong>注意：有特例：若 $\frac{\frac{b}{(a, p)}}{\frac{a}{(a, p)}} \equiv 1 \pmod{\frac{p}{(a, p)}}$，表示 $a^{x - k} \equiv 1 \pmod{p}$（递归了 $k$ 层），即 $a^{x - k} <em> a^k \equiv 1 </em> b \pmod{p}$，$k$ 为解。</strong></p><details>    <summary>template</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_4195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">ll n, m, p, ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % mod) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    ll d = exgcd(b, a % b, y, x); y -= a / b * x; <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll p, ll t)</span> </span>&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    ll k = (ll)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)p), x, y;</span><br><span class="line">    exgcd(t, p, x, y), b = (b * x % p + p) % p;</span><br><span class="line">    ll tmp = b, S = qpow(a, k, p);</span><br><span class="line">    rep(i, <span class="number">0</span>, k) &#123;</span><br><span class="line">        mp[tmp] = i;</span><br><span class="line">        tmp = tmp * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = S;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[tmp]) <span class="keyword">return</span> i * k - mp[tmp];</span><br><span class="line">        tmp = tmp * S % p;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll k = <span class="number">0</span>, d = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(n, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ++k, m /= d, p /= d, t = t * (n / d) % p;</span><br><span class="line">        <span class="keyword">if</span> (t == m) <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (d = BSGS(n, m, p, t)) == <span class="number">-1</span> ? <span class="number">-1</span> : d + k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; m &amp;&amp; (n || m || p)) &#123;</span><br><span class="line">        n %= p, m %= p, ans = exBSGS();</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2018]-历史</title>
      <link href="2021/02/07/%5BZJOI2018%5D-%E5%8E%86%E5%8F%B2/"/>
      <url>2021/02/07/%5BZJOI2018%5D-%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uoj.ac/problem/374" target="_blank" rel="noopener">传送门</a></p><h3 id="mathscr-Part-1"><a href="#mathscr-Part-1" class="headerlink" title="$\mathscr{Part.1}$"></a>$\mathscr{Part.1}$</h3><p>不难发现就是最大化 access 更改的边数。考虑不带修怎么做。变换一下问题就是最大化每个点被更改的次数和——每个点都可以独立计算，一个点贡献一次当且仅当相邻两次 access 发源于其不同的子树，并且每个点都可以取到其上限（只要合理安排该点每个子树的 access 顺序就可以了，大概可归纳证明）</p><p>点 $x$ 的上限是啥呢？设 $s_x = \sum\limits_{i \in subtree(x)} a_i$, $mx_x = \max\limits_{y \in son(x)}(s_y)$, 那么就是 $\min( s_x - 1, 2 * (s_x - mx_x) )$（讨论一下发现是否存在「一个 $a_i$ 过大、其他子树安排不完」的情况都符合该柿）</p><p>考虑修改，那么就要应用链剖分啊分治啊树上科技来维护修改点到根的路径了。接下来的操作神仙极了 qaq（细节好多啊摔</p><h3 id="mathscr-Part-2"><a href="#mathscr-Part-2" class="headerlink" title="$\mathscr{Part.2}$"></a>$\mathscr{Part.2}$</h3><p>我们记录每个点 $x$ 当前的贡献类型：是 ①「$s_x - 1$」，还是 ②「$2 <em> (s_x - mx_x)$ 且 $mx_x$ 来自 $x$ 某个子树」，还是 ③「$2 </em> (s_x - mx_x)$ 且 $mx_x$ 来自 $x$ 自己」。</p><p>注意到一次修改只会加，加了可能改变某些点的贡献类型。（改完后的）① 型点增加 $w$，②③ 型点不变。我们要是能快速修改这些贡献类型，就能顺便更新答案。</p><p>我们让 ② 型点 $x$ 向 $mx_x$ 对应的儿子连一条边。通过移项，我们发现了一个更优的性质：这样的儿子最多只有一个！这就和重链剖分契合了。Orz</p><p>我们把 $x$ 向 $mx_x$ 连的边看作实边，向其他儿子连的边看作虚边，形成的实链只有链底是 ① 或者 ③，其余都是 ②。</p><p>然后就是一个类 splay access 的操作，连实边或者断实边。</p><p>关于复杂度，$x$ 到根路径上又轻又虚的边数不超过 $log \sum a$，因为显然一次至少翻一倍。单次 access 最多改 $log \sum a$ 条虚边为实边。$O(nlog\sum a)$。</p><p>用树剖 + 线段树维护虚边位置每次暴改就是对的，但是找虚边这种事怎么能忘了 LCT 本人呢！毕竟这玩意只是有条件的连实边，魔改一发就好了。</p><p>「判断实边的断与连」要用到 $s_x$。设修改点为 $x$。考虑用 lct 维护「 $x$ 到根路径上的」$s$。只改深度比 $x$ 小的所以是个区间加 + 单点查询。为了实现方便，我们利用<strong>差分思想</strong>，设 $val_x = s_x - s_{ch[x, 1]}$，就可以单点修改，并且查询只要把点转到 splay 的根然后询问右子树的 $val$ 和，就不用什么 LCT 套线段树了！伟 大 胜 利</p><p>说了这么多，代码还是挺好写的。</p><details>    <summary>code</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll ans, a[N], s[N], lst[N], val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dir</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] &amp;&amp; ch[fa[x]][dir(x)] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[x] = s[ch[x][<span class="number">0</span>]] + s[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sz = s[x] - s[ch[x][<span class="number">0</span>]];  <span class="comment">// x 的真实 s</span></span><br><span class="line">    ans -= lst[x];</span><br><span class="line">    lst[x] = min(sz - <span class="number">1</span>, <span class="number">2</span> * (sz - max(a[x], s[ch[x][<span class="number">1</span>]])));</span><br><span class="line">    ans += lst[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = dir(x), w = ch[x][k ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (nrt(y)) ch[z][dir(y)] = x;</span><br><span class="line">    ch[y][k] = w, ch[x][k ^ <span class="number">1</span>] = y;</span><br><span class="line">    <span class="keyword">if</span> (w) fa[w] = y;</span><br><span class="line">    fa[y] = x, fa[x] = z;</span><br><span class="line">    up(y), up(x);  <span class="comment">// 这里不能 upd，因为 x 还没旋到根，ch[x][1] 不是 x 所在 splay 上 x 的真实后继；旋到根以后 ch[x][1] 才是。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nrt(x)) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">        <span class="keyword">if</span> (nrt(y)) rot((dir(x) ^ dir(y)) ? x : y);</span><br><span class="line">        rot(x);</span><br><span class="line">    &#125;</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x]) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        s[x] += w;</span><br><span class="line">        <span class="comment">// 底</span></span><br><span class="line">        <span class="keyword">if</span> (!y) a[x] += w;</span><br><span class="line">        val[x] += w;</span><br><span class="line">        </span><br><span class="line">        ll sz = s[x] - s[ch[x][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span> (s[ch[x][<span class="number">1</span>]] * <span class="number">2</span> &lt;= sz + <span class="number">1</span>) &#123;</span><br><span class="line">            val[x] += s[ch[x][<span class="number">1</span>]], ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[y] * <span class="number">2</span> &gt; sz + <span class="number">1</span>) &#123;</span><br><span class="line">            val[x] -= s[y], ch[x][<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[x] = fat;</span><br><span class="line">    ll mx = s[x] = a[x];</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fat) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        s[x] += s[y];</span><br><span class="line">        <span class="keyword">if</span> (s[y] &gt; mx)</span><br><span class="line">            mx = s[y], id = y;</span><br><span class="line">    &#125;</span><br><span class="line">    lst[x] = min(s[x] - <span class="number">1</span>, <span class="number">2</span> * (s[x] - mx));</span><br><span class="line">    ans += lst[x];</span><br><span class="line">    <span class="keyword">if</span> (id &amp;&amp; mx * <span class="number">2</span> &gt; s[x] + <span class="number">1</span>)</span><br><span class="line">        ch[x][<span class="number">1</span>] = id;</span><br><span class="line">    val[x] = s[x] - s[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        g[x].pb(y), g[y].pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, w; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;w);</span><br><span class="line">        access(x, w);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】二次离线莫队</title>
      <link href="2021/02/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E8%8E%AB%E9%98%9F/"/>
      <url>2021/02/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>最近规划的是多做锻炼思维模式的 CF、AT 题，但是这玩意既然 xtr 学长介绍了那为何不学呢？</p><p>普通莫队加入/删除一个位置的贡献是 $T(n)$，复杂度 $O(n\sqrt{n}T(n))$，$T(n)$ 很大的时候就 GG 了。。</p><p><del>于是，神说：要有二次离线莫队。</del></p><p>以<a href="https://www.luogu.com.cn/problem/P4887" target="_blank" rel="noopener">模板题</a>为例，设 $f(i, [l, r])$ 表示 $i$ 对 $[l, r]$ 所产生的贡献。一次移动只会加入 $l - 1$ 或 $r + 1$，以 $r + 1$ 为例，$f(r + 1, [l, r]) = f(r + 1, [1, r]) - f(r + 1, [1, l - 1])$，前面那项可以预处理（根据 $a xor b = c \Leftrightarrow a xor c = b$，我们可以将有 $K$ 个 $1$ 的 $c$ 的 $a xor c$ 存在桶里，到 $b$ 就直接查），后面这个就要<strong>第二次离线下来最后统一做</strong>。所以二次离线莫队这玩意实际上减小了「处理答案的变化量」的复杂度。复杂度变为 $O(nT(n) + n\sqrt{n})$。</p><p>讲一下第二次离线。你可以把 $f(x, [1, l - 1])$ 放在下标为 $l - 1$ 的 vector 里然后从前往后做，但这样空间是 $O(m\sqrt{n})$ 的。不如维护 $(L, R, q[i].l - 1, i, 1/-1)$ 表示当前统计 $x \in [L, R]$ 对 $[1, q[i].l - 1]$ 产生的贡献、来自第 $i$ 个询问时产生的答案变化量、加还是减，空间就是 $2m$ 了。</p><p>算出的答案变化量实际上对后续操作有影响，所以要做前缀和。</p><details>    <summary>code</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu_4887</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cnt(x) __builtin_popcount(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, V = <span class="number">16390</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, unit;</span><br><span class="line"><span class="keyword">int</span> a[N], bin[V];</span><br><span class="line">ll ans[N], pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ques</span> &#123;</span> <span class="keyword">int</span> l, r, id; ll ans; &#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atom</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, op;</span><br><span class="line">    atom(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Id, <span class="keyword">int</span> Op) &#123; l = L, r = R, id = Id, op = Op; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buc;</span><br><span class="line"><span class="built_in">vector</span>&lt;atom&gt; vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Ques a, Ques b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l / unit == b.l / unit ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">14</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unit = n / <span class="built_in">sqrt</span>(m);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">16383</span>)</span><br><span class="line">        <span class="keyword">if</span> (cnt(i) == K) buc.pb(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        pre[i] = bin[a[i]] + pre[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc.size(); j++) ++bin[a[i] ^ buc[j]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = q[i].l, r = q[i].r;</span><br><span class="line">        ll &amp;x = q[i].ans;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; l)</span><br><span class="line">            vec[R].pb(atom(l, L - <span class="number">1</span>, i, <span class="number">1</span>)), x -= pre[L - <span class="number">1</span>] - pre[l - <span class="number">1</span>], L = l;</span><br><span class="line">        <span class="comment">// while (L &gt; l)</span></span><br><span class="line">        <span class="comment">//     --L, x -= pre[L];</span></span><br><span class="line">        <span class="keyword">if</span> (R &lt; r)</span><br><span class="line">            vec[L - <span class="number">1</span>].pb(atom(R + <span class="number">1</span>, r, i, <span class="number">-1</span>)), x += pre[r] - pre[R], R = r;</span><br><span class="line">        <span class="comment">// while (R &lt; r)</span></span><br><span class="line">        <span class="comment">//     ++R, x += pre[R];</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; l)</span><br><span class="line">            vec[R].pb(atom(L, l - <span class="number">1</span>, i, <span class="number">-1</span>)), x += pre[l - <span class="number">1</span>] - pre[L - <span class="number">1</span>], L = l;</span><br><span class="line">        <span class="comment">// while (L &lt; l)</span></span><br><span class="line">        <span class="comment">//     x += pre[L], ++L;</span></span><br><span class="line">        <span class="keyword">if</span> (R &gt; r)</span><br><span class="line">            vec[L - <span class="number">1</span>].pb(atom(r + <span class="number">1</span>, R, i, <span class="number">1</span>)), x -= pre[R] - pre[r], R = r;</span><br><span class="line">        <span class="comment">// while (R &gt; r)</span></span><br><span class="line">        <span class="comment">//     x -= pre[R], --R;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(bin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bin));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buc.size(); j++) ++bin[a[i] ^ buc[j]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].size(); j++) &#123;</span><br><span class="line">            atom t = vec[i][j];</span><br><span class="line">            rep(k, t.l, t.r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &lt;= i &amp;&amp; !K) q[t.id].ans += t.op * (bin[a[k]] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> q[t.id].ans += t.op * bin[a[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) q[i].ans += q[i - <span class="number">1</span>].ans;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) ans[q[i].id] = q[i].ans;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信奥学习建议（来自 xtr 学长）</title>
      <link href="2021/02/06/%E4%BF%A1%E5%A5%A5%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%EF%BC%88%E6%9D%A5%E8%87%AA%20xtr%20%E5%AD%A6%E9%95%BF%EF%BC%89/"/>
      <url>2021/02/06/%E4%BF%A1%E5%A5%A5%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%EF%BC%88%E6%9D%A5%E8%87%AA%20xtr%20%E5%AD%A6%E9%95%BF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>xtr 学长的经历好戳我啊。。他的 HE 大概是每个 oier 憧憬的吧。可爱勤奋的卷怪们都要有 HE 啊。xml 你也去追你的梦吧，虽然梦是什么还不明朗。也许就像 xtr 学长说的那样，为了有站在台上无比荣耀的瞬间，或是驰骋在赛场上的那种快感。</p><p>要对自己的处境和知识掌握情况有充分的了解，然后不顾一切的努力，<strong>做到完全实现自己的想法</strong>。</p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>四种类型</p><ol><li>luogu 模板</li><li>UOJ、LOJ 上清华集训/集训队作业等高水平综合题</li><li>CF、AT 上 更注重思维模式的题</li><li>历年真题</li></ol><p>选择适应自身的。</p><p>可以专题，但<strong>必须适时杂题以确保比赛能力</strong></p><h2 id="学东西"><a href="#学东西" class="headerlink" title="学东西"></a>学东西</h2><ol><li>感兴趣的领域深入，以有所擅长</li><li>不感兴趣的掌握基础，以知识体系完备</li><li>冷门算法浅尝辄止</li></ol><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ol><li>尽快想出</li><li>高效调试</li><li>综合判断、策略能力</li><li>适时放弃</li><li>心态</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>瞄准水平略高的身边人。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>分长期短期，适时调整。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】反演杂烩</title>
      <link href="2021/02/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8D%E6%BC%94%E6%9D%82%E7%83%A9/"/>
      <url>2021/02/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8D%E6%BC%94%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>若有 $g_n = \sum\limits_{i = 1}^n a_{n, i} f_i$, 并且 $f_n = \sum\limits_{i = 1}^n b_{n, i} g_i$，则称 $f$ 和 $g$ 可以反演。证明带就完事了。</p><p>经典套路是 dp 容斥系数。</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><p>广义容斥。</p><p>「恰好」与「至多」：</p><p>$$f_n = \sum\limits_{i = 0}^n \binom{n}{i} g_i \Longleftrightarrow g_n = \sum\limits_{i = 0}^n (-1)^{n - i} \binom{n}{i} f_i$$</p><p>「恰好」与「至少」：</p><p>$$f_k = \sum\limits_{i = k}^n \binom{i}{k} g_i \Longleftrightarrow g_k = \sum\limits_{i = k}^n (-1)^{i - k} \binom{i}{k} f_i$$</p><h2 id="min-max-容斥"><a href="#min-max-容斥" class="headerlink" title="$\min-\max$ 容斥"></a>$\min-\max$ 容斥</h2><p>$$max(S) = \sum\limits_{T \subseteq S} (-1)^{|T| + 1} min(T) \Longleftrightarrow min(S) = \sum\limits_{T \subseteq S} (-1)^{|T| + 1} max(T)$$</p><p>证明大概考虑设 $\max(S) = x$，只有 $T = {x}$ 时的 $\min(T)$ 为 $x$，其余时候必然存在一个 $y$ 使得 $\min(T \cup {y}) = \min(T)$，就抵消了</p><p>这玩意还能应用到期望上去：套个 $E()$ 就好。</p><p>一般来说不用真的枚举集合，信息只和集合大小有关。</p><p>推广：通过求 $\min$ 来求 $kth\ \max$</p><p>$$kth\ \max(S) = \sum\limits_{T \subseteq S} (-1)^{|T| - k} \binom{|T| - 1}{k - 1} \min(T)$$</p><p>习题：<a href="https://www.luogu.com.cn/problem/P4707" target="_blank" rel="noopener">重返现世</a> <a href="http://imilyx.github.io/2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/#%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96" target="_blank" rel="noopener">sol</a></p><p><a href="https://uoj.ac/problem/449" target="_blank" rel="noopener">喂鸽子</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E5%96%82%E9%B8%BD%E5%AD%90" target="_blank" rel="noopener">sol</a></p><h2 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h2><p>就是 FMT 和 FMI。</p><p>$$f_S = \sum\limits_{T \subseteq S} g_T \Longleftrightarrow g_S = \sum\limits_{T \subseteq S} (-1)^{|S| - |T|} f_T$$</p><p>特别的：</p><p>$$\sum\limits_{T \subseteq S} (-1)^{|T|} = [S == \emptyset]$$</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>本质是质因子集合的 FMT 和 FMI。</p><p>$$f(n) = \sum\limits_{d | n} g(d) \Longleftrightarrow g(n) = \sum\limits_{d | n} \mu(d) f(\frac{n}{d})$$</p><p>$$f(n) = \sum\limits_{n | d} g(d) \Longleftrightarrow g(n) = \sum\limits_{n | d} \mu(n) f(\frac{d}{n})$$</p><p>最常用的：</p><p>$$\sum\limits_{d \mid n} \mu(d) = [n == 1]$$</p><h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2><p>$$f_n = \sum\limits_{i = 1}^n {n \brace i} g_i \Longleftrightarrow g_n = \sum\limits_{i = 1}^n (-1)^{n - i} {n \brack i} f_i$$</p><h2 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h2><p>$$[k \mid n] = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni}$$</p><p>证明：若 $k \mid n$，那么：</p><p>$$\frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni} = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} (\omega_k^n)^i = \frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^0 = 1$$</p><p>若 $k \nmid n$，那么根据等比数列求和有：</p><p>$$\frac{1}{k} \sum\limits_{i = 0}^{k - 1} \omega_k^{ni} = \frac{1}{k} \frac{\omega_k^{nk} - \omega_k^0}{\omega_k^n - 1} = 0$$</p><p>应用于 $O(k)$ 提取多项式所有下标为 $k$ 倍数的项或系数（设第 $i$ 项系数为 $a_i$，下面是提系数）：</p><p>$$\sum\limits_{i = 0}^{n / k} [x^{ik}] f(x)$$</p><p>$$= \sum\limits_{i = 0}^n [k \mid i] [x^i] f(x)$$</p><p>$$= \sum\limits_{i = 0}^n \frac{1}{k} \sum\limits_{j = 0}^{k - 1} \omega_k^{ij} [x^i] f(x)$$</p><p>$$= \frac{1}{k} \sum\limits_{j = 0}^{k - 1} \sum\limits_{i = 0}^n a_i (\omega_k^j)^i$$</p><p>$$= \frac{1}{k} \sum\limits_{j = 0}^{k - 1} f(\omega_{k}^j)$$</p><p>现推也非常方便！「提取项」一个道理，就现推一下吧，总是能把单位根搞成函数自变量的。</p><p>习题：<a href="https://uoj.ac/problem/450" target="_blank" rel="noopener">复读机</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#%E5%A4%8D%E8%AF%BB%E6%9C%BA" target="_blank" rel="noopener">sol</a></p><p><a href="http://loj.ac/p/6485" target="_blank" rel="noopener">LJJ 学二项式定理</a> <a href="http://imilyx.github.io/2021/02/28/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Feb%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#LJJ-%E5%AD%A6%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">sol</a></p><p><a href="https://loj.ac/p/6358" target="_blank" rel="noopener">前夕</a></p><p>sol: 题意真是文字游戏。就是选若干个子集满足交集大小是 $k$ 的倍数的方案数。本题 $k = 4$。</p><p>交集至少为 $k$ 的方案数为 $f(k) = \binom{n}{k} (2^{2^{n - k}} - 1)$，恰好为 $k$ 的方案数为 $g(k)$，可以二项式反演出来，但 1e7…… 你也没法 NTT 是吧，所以我们只能把 $f$ 带到 $g$ 里去啦：</p><p>$ans = \sum\limits_{4 \mid k} g(k)$</p><p>$= \frac{1}{4} \sum\limits_k \sum\limits_{i = 0}^3 \omega_4^{ki} g(k)$</p><p>$= \frac{1}{4} \sum\limits_k \sum\limits_{i = 0}^3 \omega_4^{ki} \sum\limits_{j = k}^n \binom{j}{k} (-1)^{j - k} f(j)$</p><p>$= \frac{1}{4} \sum\limits_{j = 0}^n (-1)^j f(j) \sum\limits_{i = 0}^3 \sum\limits_{k = 0}^j (-1)^k \binom{j}{k} \omega_4^{ki}$</p><p>$= \frac{1}{4} \sum\limits_{j = 0}^n (-1)^j f(j) \sum\limits_{i = 0}^3 (-\omega_4^i + 1)^j$</p><p>$O(nK)$</p><p>题解里说的「构造容斥系数」也是实用 trick！</p><p><a href="https://loj.ac/s/1115629" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WC2021 游记</title>
      <link href="2021/02/05/WC2021%20%E6%B8%B8%E8%AE%B0/"/>
      <url>2021/02/05/WC2021%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>线上真·游记</p><p>T1 为什么就没找出来性质呢？CF 做太少了，思维模式太 low！T2 为什么模拟赛出现类似的还是不会呢？没弄懂！T3，T3 你推一半为什么不会了？这是真不会。。。</p><hr><p>又 出 成 绩 了，28 + 60 + 20 = 108 铜，T1 挂了 4 分，然而就算没挂分也是差 6 分银牌（写了那好麻烦的 10 分就银了 /kel</p><p><del>dsy: 赛后算分，庸人自扰</del></p><p>差距没有很大，也没有缩小呢，xml 你要继续努力！</p><hr><h2 id="改题"><a href="#改题" class="headerlink" title="改题"></a>改题</h2><p><a href="https://loj.ac/p?keyword=wc2021" target="_blank" rel="noopener">题目链接</a></p><h3 id="括号路径"><a href="#括号路径" class="headerlink" title="括号路径"></a>括号路径</h3><p>找性质的能力还是太菜了。。。<del>我再不刷 CF 和 AT 我名字倒过来写！</del> 注意到这样的路径是双向的，而且若 (x, y) 是合法对，那么任意点 w 同时与 x、y 有或无路径。</p><p><strong>即有合法路径的对形成的团中，两两互达！</strong></p><p>类似「Joitter 交友」，缩就完事了。并查集维护连通性。记录每个点的出入括号，<del>遇到同种类的就从了</del>。合并点对采用启发式合并。人懒用了 map，两只 log。</p><p><a href="https://loj.ac/s/1061222" target="_blank" rel="noopener">$Code$</a></p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>magic breeding? Ah~ 加强版。每位显然是独立的。考虑二分的思想，$\geq lim$ 的为 $1$，$&lt; lim$ 的为 $0$，那么 $\max$ 为取并，$\min$ 为取交。</p><p>括号很恶心，要建表达式树。我们选择从后往前建。叶子处是操作 id，非叶子处是 $($、$)$、$&lt;$、$&gt;$、$?$</p><p>本题要统计每个集合 $\geq$ 某种取值的方案数才能算出该取值在答案中贡献的次数。</p><p>集合只有 $2^m$ 种，取值却有 $nm$ 种。考虑 dp 预处理, 枚举集合表示这个集合里的数都 $\geq$ 那个值，$dp[x, 0/1]$ 表示在表达式树上 $x$ 节点的子树有多少种方案使得运算结果为 $0$/$1$。</p><p>表达式树是个二叉树。合并答案，记俩儿子 dp 值分别为 $(x0, x1)$, $(y0, y1)$，结果记为 $(z0, z1)$</p><ul><li>对于 $&gt;$: $z0 = x0 <em> y0$, $z1 = x0 </em> y1 + x1 <em> y0 + x1 </em> y1$</li><li>对于 $&lt;$: $z0 = x0 <em> y0 + x0 </em> y1 + x1 <em> y0$, $z1 = x1 </em> y1$</li><li>对于 $?$: 上面两种加起来。</li></ul><p>$O(2^m|E| + nm^2)$.</p><p><a href="https://loj.ac/s/1061278" target="_blank" rel="noopener">$Code$</a></p><h3 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h3><p>这道和「WC2020-猜数游戏」都先咕咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十二省联考2019 乱写</title>
      <link href="2021/02/04/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/02/04/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83" target="_blank" rel="noopener">传送门</a></p><h2 id="异或粽子"><a href="#异或粽子" class="headerlink" title="异或粽子"></a>异或粽子</h2><p>可持久化 Trie 树 + 「超级钢琴」做法。</p><p>加强版：$k \leq \frac{n(n - 1)}{2}$。<a href="https://imilyx.github.io/2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/#T3-1" target="_blank" rel="noopener">题解</a></p><h2 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h2><p>很自然<del>套路</del>的题，容易想到建边用图做，也就是一个 $A$ 向它支配的 $B$ 连边，这个 $B$ 再向以它为前缀的 $A$ 连边，暴力连 $O(n^2)$，考虑优化。</p><p>老套路，考虑图/树优化建边，这里对反串建 $SAM$，把 $A$ 串和 $B$ 串挂在对应的后缀树节点下，同个节点挂着的串相邻连边就避免了一个 $A$ 向一堆 $A$ 连的情况。</p><p><a href="https://loj.ac/s/1017579" target="_blank" rel="noopener">$Code$</a></p><h2 id="骗分过样例"><a href="#骗分过样例" class="headerlink" title="骗分过样例"></a>骗分过样例</h2><p>咕咕</p><h2 id="皮配"><a href="#皮配" class="headerlink" title="皮配"></a>皮配</h2><p>这题不讲唔得，它用繁多的变量来搞你心态！<del>大意了啊没有闪</del></p><p>撇开这点，题并不难（但有点考逻辑</p><p>首先发现派系和阵营是交错的，不管城市选什么阵营，里面的学校都可以任意选派系，城市的决定和学校的决定共同决定了导师。<strong>也就是说城市和学校独立。</strong></p><p>先考虑 $k = 0$ 的情况，分别 $dp$ 算出 $f[i, j]$ 表示前 $i$ 个城市，$j$ 个人在蓝阵营的方案数；<br>$g[i, j]$ 表示前 $i$ 个城市，$j$ 个人在鸭派系的方案数。合法的相乘。</p><p>按照选课的套路，$k = 0$ 的情况，没有限制的城市和学校同上做；<br>$k \neq 0$，有限制的城市需要选同个阵营，同城市的学校就必须捆绑考虑了：$f[i, j, k]$ 表示前 $i$ 个城市蓝阵营人数为 $j$，鸭派系人数为 $k$ 的方案数。</p><p>然后滚掉一维就能 AC 辣!</p><p><a href="https://loj.ac/s/1017744" target="_blank" rel="noopener">$Code$</a></p><h2 id="春节十二响"><a href="#春节十二响" class="headerlink" title="春节十二响"></a>春节十二响</h2><p>撕烤怎么合并链，必然是贪心的大配大、小配小。拿堆维护一下，加个启发式合并就 AC 了。</p><p><a href="https://loj.ac/s/1017408" target="_blank" rel="noopener">$Code$</a></p><h2 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h2><p>别被高大上的题目唬住了！思路就是算一个救援队的答案，然后 $k$ 次方。点 $x$ 子树里和子树外的要分开算。考虑直接算会算重——一个连通块会被算多次，应用经典“点减边”思想——连通块中点数 = 边数 $+ 1$，就用点的答案减去边的答案。</p><p>$f[x, i]$ 表示子树里深度不超过 $i$ 的连通块方案数，$g[x, i]$ 表示不包括子树里（但包括 $x$）的深度不超过 $i$ 的连通块方案数，两个一乘岂不美哉？</p><p>转移方程超好写：</p><ul><li>$f[x, i] = (\prod f[y, i - 1]) + 1$</li><li>$g[x, i] = (g[fa[x], i - 1] \prod f[son[fa[x]], i - 2]) + 1$</li></ul><p>$n$ $1e6$, $dp$ 又与深度有关，于是想到长剖优化。本题的思路到此为止，接下来 都 是 细 节</p><p>$f$ 可以直接算，但是 $g$ 里面那个 $\prod$ 不好搞。</p><p>用回退栈可以维护，做 $f$ 的时候从长到短遍历子树，做 $g$ 的时候从短到长遍历子树。</p><p><a href="https://loj.ac/s/1009842" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[集训队作业2018]-围绕着我们的圆环</title>
      <link href="2021/02/03/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E5%9B%B4%E7%BB%95%E7%9D%80%E6%88%91%E4%BB%AC%E7%9A%84%E5%9C%86%E7%8E%AF/"/>
      <url>2021/02/03/%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018%5D-%E5%9B%B4%E7%BB%95%E7%9D%80%E6%88%91%E4%BB%AC%E7%9A%84%E5%9C%86%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p/6040" target="_blank" rel="noopener">$LOJ6040$</a> 加强版。高妙的线代题，虽然只用到了秩和线性空间的概念（完全不像今天国家队爷讲课那样让人摸不着头发哼！）</p><p>（接下来都用本题中的 $p$、$q$、$s$，这样比较严谨）</p><p>回顾矩阵乘法：$A(x, y) * B(y, z) \rightarrow C(x, z)$（绕晕了就看看这个👈）</p><p>考虑无修改怎么做，毫无头绪（</p><p>观察 $A$ 和 $C$ 的关系：$C$ 的列向量一定在 $A$ 列向量组成的线性空间里。</p><p>设 $A$ 的（列）秩为 $x$，$C$ 的（列）秩为 $r$。对于 $B$ 的每一列都可以列出一个有 $x$ 个线性无关的方程的方程组，那么自由元有 $q - x$ 个，一列的方案数是 $2^{q - x}$。因此<strong>在 $A$ 和 $C$ 的秩确定时</strong>，$B$ 方案数就是 $(2^{q - x})^s$。</p><p>现在我们要统计“秩为 $x$ 且列向量的线性空间包含 $C$ 的 $A$ 方案数”。这不好算。</p><p>dp, $f_{i, j}$ 表示 $i * q$ 的矩阵，秩为 $j$ 的方案数，转移类似线性基 dp。统计“秩为 $x$ 且列向量的线性空间包含秩为 $r$ 的 $C$ 的 $A$ 方案数”，最后答案除以 $g_{p, r}$。那么 $A$ 的方案数就是 $f_{q, x}$，$C$ 的方案数就是 $g_{x, r}$，为什么？</p><p>因为<strong>行秩 = 列秩</strong>，$C$ 中对应 $A$ 的那 $x$ 行确定后剩下的行就像 $A$ 中剩下的行那样能被那 $x$ 行表出的。</p><p>答案就是 $\sum\limits_{x = r}^q f_{q, x} g_{x, r} (2^{q - x})^s$</p><p><a href="https://loj.ac/s/1056871" target="_blank" rel="noopener">$LOJ6040 Code$</a></p><p>本题要我们动态求矩阵的秩。</p><p>大概就是个线性基状物的插入和删除。删除怎么搞？<a href="https://blog.csdn.net/a_forever_dream/article/details/83654397" target="_blank" rel="noopener">大佬比较详细的解说</a> 考虑删除向量 $x$ 后我们要尽量找一个来替代 $x$。对线性基里每个向量记录它插入时异或了哪些向量。找到「受本次删除影响」的基外向量 $y$，如果不存在基外的就找基内最低的（这样在删除时就不会影响更低位的向量），把 $y$ 其它受影响的向量异或上 $y$（$y$ 自己变成 $0$，这样就能消除 $x$ 在线性基里的影响，相当于用 $y$ 替代了 $x$）；如果找的是基内的，秩数 $-1$。</p><p>用 bitset，$O(\frac{n^3}{\omega})$</p><p><a href="https://uoj.ac/submission/453202" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客折腾小记</title>
      <link href="2021/02/02/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/"/>
      <url>2021/02/02/%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九省联考2018 乱写</title>
      <link href="2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/"/>
      <url>2021/02/02/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%20%E4%B9%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p?keyword=%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83" target="_blank" rel="noopener">传送门</a></p><p>按题解篇幅看就知道「秘密袭击」是「切树游戏」那样的神套路题了吧。（不过「切树游戏」毒瘤多了-_-||</p><h2 id="一双木棋"><a href="#一双木棋" class="headerlink" title="$一双木棋$"></a>$一双木棋$</h2><hr><p>有「$pos_i \leq pos_{i - 1}$」的限制，直接状压轮廓状态数就是 $\binom{n + m - 1}{m - 1}$，不到 $10^5$。搜索解决 min-max 博弈。</p><p><a href="https://loj.ac/s/1054666" target="_blank" rel="noopener">$Code$</a></p><h2 id="IIIDX"><a href="#IIIDX" class="headerlink" title="$IIIDX$"></a>$IIIDX$</h2><hr><p>我太菜了！直接贪心在 $d$ 有重复的时候是错的，比如 $n = 4$, $k = 2.0$, $1$ $1$ $1$ $2$ 和 $1$ $1$ $2$ $1$。</p><p>正解挺灵活的。建树，把 $d$ 从大到小排序。对每个权值维护一个 $c_i$ 表示<strong>别的节点至多能在 $i$ 左边拿走几个</strong>。我们知道把 $i$ 填到 $x$ 点就要在 $i$ 左边预留出 $size[x]$ 个空位放到 $x$ 的子树里，但是不能确定是哪些个空位因为会影响后面的判定。这时要把 $[i, n]$ 的 $c$ 减去 $size[x]$。</p><p><strong>$c$ 实际上是用来限制同层的</strong>，所以往下走到儿子时，要把父亲给它预留的位置释放掉。</p><p><a href="https://loj.ac/s/1055202" target="_blank" rel="noopener">$Code$</a></p><h2 id="秘密袭击"><a href="#秘密袭击" class="headerlink" title="$秘密袭击$"></a>$秘密袭击$</h2><hr><p>求树的每个连通块第 $K$ 大权值之和。类似整数概率公式一样的拆分权值：</p><script type="math/tex; mode=display">Ans = \sum\limits_{S} Kth \in S = \sum\limits_{i = 1}^W i \sum\limits_S [Kth \in S == i]</script><script type="math/tex; mode=display">= \sum\limits_{i = 1}^W \sum\limits_{S} [Kth \in S \geq i] = \sum\limits_{i = 1}^W \sum\limits_S [cnt(S, i) \geq K]</script><p>其中 $cnt(S, i)$ 表示连通块 $S$ 中权值 $\geq i$ 的点数。</p><p>问题转化为：枚举权值 $v$，统计 $\geq v$ 的权值出现次数 $\geq K$ 的连通块个数。 </p><p>这似乎可以 dp？！$f_{i, j, k}$ 表示以 $i$ 为最浅点，权值 $\geq j$ 的出现次数为 $k$ 的连通块数。有：$f_{i, j, k} = \prod\limits_{v \in Son(i)} f_{v, j, k’}(\sum k’ = k - (val_i \geq j))$。答案就是 $\sum\limits_{k = K}^n \sum\limits_{i = 1}^n \sum\limits_{j = 1}^W f_{i, j, k}$。令 $g_{i, j, k} = \sum\limits_{x \in subtree(i)} f_{x, j, k}$，我们求的实际上是 $\sum\limits_{k = K}^n \sum\limits_{i = 1}^W g_{1, i, k}$</p><p>（据说 $O(n^2K)$ 能过，但来都来了是吧）</p><p>上面那个背包长得一脸生成函数，那就如它所愿：令 $F_{i, j} = \sum\limits_{k = 0}^n f_{i, j, k} <em> z^k$，$G_{i, j} = \sum\limits_{x \in subtree(i)} F_{x, j}$。有 $F_{i, j} = (val_i \geq j ? z : 1) </em> \prod (F_{son_i, j} + 1)$, $G_{i, j} = F_{i, j} + \sum G_{son_i, j}$</p><p>带 $n + 1$ 个点值 $z$ 进去，让 $F$ 和 $G$ 是点值状态，转移就是<strong>对应位相乘</strong>，最后再拉格朗日插值<a href="https://blog.csdn.net/CRZbulabula/article/details/61210514" target="_blank" rel="noopener"><strong>还原系数</strong></a>得到 $g$。</p><p>对应位相乘？那就用整体 dp 的思想在每个点上维护一棵线段树，线段树每个节点上有个形式幂级数。考虑我们要干什么，区间乘 $z$，全局 $+1$，对应位置相乘，维护全局答案。</p><ul><li>初始化，$(F, G) = (1, 0)$</li><li>如果 $val_i \geq j$ 那么 $(F, G) \rightarrow (F * z, G)$</li><li>合并，$(F, G) \rightarrow (F(1 + F_v), G + G_v)$</li><li>$(F, G) \rightarrow (F, G + F)$</li></ul><p>非常繁琐，我们用矩阵来转移。但是矩阵常数大<del>跑不过暴力</del>，考虑函数复合维护 tag（这一步过于神奇）：观察到 $F$ 只会变成 $aF + b$, $G$ 只会变成 $G + cF + d$，于是每个节点维护一个四元组 $(a, b, c, d)$ 表示 $(aF + b, cF + d + G)$。合并 tag 就是 $(a, b, c, d)$ 和 $(A, B, C, D)$ 相乘，得到 $(Aa, Ab + B, Ca + c, Cb + D + d)$。单位元是 $(1, 0, 0, 0)$。</p><p>hint：要写垃圾回收和 unsigned int。</p><p>复杂度 $O(n^2logW)$。</p><p>感想：整体 dp 好神啊！整体 dp 套生成函数好神啊！</p><p><a href="https://loj.ac/s/1055616" target="_blank" rel="noopener">$Code$</a></p><h2 id="劈配"><a href="#劈配" class="headerlink" title="$劈配$"></a>$劈配$</h2><hr><p>回忆起被「皮配」支配的恐惧 /jk 还好这道比较阳间，一道复杂度分析题</p><p>第一问写一个“扩展”的二分图最大匹配就好了，具体来说每个后期被更改匹配导师的人新匹配的导师必须是同一志愿的，$O(n^3C)$</p><p>第二问有显然的二分性，你可以二分 + 从前往后加人，但是这样是 $O(n^3Clogn)$。我们可以保留前缀不变的匹配状态，就是 $O(n^2Clogn)$ 的样子。</p><p>但是有完全更简单的做法：在做第一问要替换人的时候尽量替换靠后的，顺便记录下来就可以了。</p><p><a href="https://loj.ac/s/1056622" target="_blank" rel="noopener">$Code$</a></p><h2 id="林克卡特树"><a href="#林克卡特树" class="headerlink" title="$林克卡特树$"></a>$林克卡特树$</h2><hr><p>题意：让你选 $K + 1$ 条路径使得权值和最大。</p><p>带权二分，$f[i, 0/1/2]$ 表示点 $i$ 的度数为 $j$ 时 $i$ 子树中的最优解（要记录路径数，写个 struct 就好了），分类讨论。</p><p><a href="https://loj.ac/s/907209" target="_blank" rel="noopener">$Code$</a></p><h2 id="制胡窜"><a href="#制胡窜" class="headerlink" title="$制胡窜$"></a>$制胡窜$</h2><hr><p>大分类讨论题吗。。。有心情再写吧 /cy 被「秘密袭击」搞自闭了</p><p>upd: 我来口胡了</p><p>显然不能每个串都被那两刀切到。考虑容斥，求每个串至少被切到一次的方案数。有下面几种情况：</p><ol><li>第一刀啥都没切到，第二刀切完</li><li>第二刀啥都没切到，第一刀切完</li><li>第一刀切到但没切完，补第二刀切完</li><li>第一刀切完，第二刀随便切</li></ol><p>$1$、$2$、$3$ 不能一刀切完时答案是 $0$，否则算一下。</p><p>$4$ 麻烦一点，第二刀切的位置是一个区间，可以二分出左右端点。答案是个取 $\min$ 形式的，二分出开始取后面的时候。柿子存在平方形式，所以线段树维护区间 $0$、$1$、$2$ 次方和。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21Jan 训练日志</title>
      <link href="2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2021/01/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9121Jan%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】竞赛图</title>
      <link href="2021/01/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%AB%9E%E8%B5%9B%E5%9B%BE/"/>
      <url>2021/01/30/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%AB%9E%E8%B5%9B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>竞赛图(tournament)：有 $\binom{n}{2}$ 条边的有向图</p><a id="more"></a><p>性质：</p><ul><li>竞赛图强连通缩点后的 DAG 是一条链</li><li>竞赛图的强连通块存在一条哈密顿回路</li><li>竞赛图存在一条哈密顿路径</li><li>竞赛图 $size &gt; 1$ 的强连通块中，大小为 $[3, size]$ 的简单环均存在</li><li>兰道定理（竞赛图判定定理）：定义一个竞赛图的比分序列是把竞赛图每个点的出度从小到大排列得到的序列。一个长度为 $n$ 的序列 $s_1 \leq s_2 \leq s_3 \leq … \leq s_n$ 是合法比分序列当且仅当 $\forall i \in [1, n], \sum\limits_{j = 1}^i s_j \geq \binom{i}{2}$，且在 $i = n$ 时取等号，<a href="https://blog.csdn.net/a_crazy_czy/article/details/73611366" target="_blank" rel="noopener">证明</a> 非常巧妙！</li></ul><p>计数：</p><ul><li>$n$ 阶竞赛图个数显然就是 $h_n = 2^{\binom{n}{2}}$ 啦</li><li>强连通 $n$ 阶竞赛图个数为 $f_n = h_n - \sum\limits_{i = 1}^{n - 1} f_i \binom{n}{i} h_{n - i}$，就枚举一个 SCC 连的都是出边。</li><li><p>生成函数加速：<br>  令 $f_0 = 0$</p><p>  有：$h_n = \sum\limits_{i = 0}^n \binom{n}{i} f_i h_{n - i} + [n == 0]$</p><p>  $H = FH + 1 \Rightarrow F = 1 - H^{-1}$</p></li></ul><h3 id="世界是个动物园"><a href="#世界是个动物园" class="headerlink" title="世界是个动物园"></a><a href="https://uoj.ac/problem/451" target="_blank" rel="noopener">世界是个动物园</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">官方题解:</span><br><span class="line"></span><br><span class="line">由于这是竞赛图，不难证明联盟即强连通分量，并且缩完强连通分量之后必然是一条链，前往后连有向边。考虑加入点x之后会发生啥，大概就是找到这条链上第一个有从x出发的边的点和最后一个向x连边的点，把链上这一段删掉，把x插进去代替这一段。我们只要维护一个动态标号，然后把x放在这一段前一个元素里面那一段的后面就好了（记一下每一段的结尾）。</span><br><span class="line"></span><br><span class="line">如果你这个用替罪羊或者treap搞一个double出来，区间min max就只要线段树维护就好了。如果你像我一样蠢拿了个splay强行cmp，那么强行rmq复杂度也是对的（两个log在n上），然后你就MLE了（</span><br></pre></td></tr></table></figure><p>这个“前往后连”不太准确，缩完是一条链，我们要找区间编号最小的有来自 $x$ 的边的 scc $L$，和编号最大的有去 $x$ 的边的 scc $R$，$[L, R]$ 这一段所有 scc 被缩为一个 scc。替罪羊或者 treap 动态维护编号（其实不用真的删除，搞一个并查集，将 fa 指向 $x$，把 $x$ 插到 $L$ 的位置就好了），线段树查询区间 min、max。用 double 是为了方便创造键值。</p><p><a href="https://uoj.ac/submission/452323" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 竞赛图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ Long Round 1</title>
      <link href="2021/01/05/UOJ%20Long%20Round%201/"/>
      <url>2021/01/05/UOJ%20Long%20Round%201/</url>
      
        <content type="html"><![CDATA[<p>好难啊。。</p><h2 id="T1-多线程计算"><a href="#T1-多线程计算" class="headerlink" title="$T1. 多线程计算$"></a>$T1. 多线程计算$</h2><hr><p>首先要知道一个事情：$n$ 个 $[0, 1)$ 数中第 $k$ 小数期望为 $\frac{k}{n + 1}$。根据概率的基本知识，我们不考虑存在灯同时亮起的情况，那么 $n * m$ 个灯依次亮起，有 $k$ 个灯亮的期望时长为 $\frac{1}{nm + 1}$，所以现在我们要算 $k$ 个灯亮且节能的状态个数，最后乘上 $\frac{k!(nm - k)!}{(nm + 1)(nm)!}$.</p><p>每个 $(x, y)$ 独立，分别算贡献即可。现在考虑 $(x, y)$ 给 $k$ 的贡献，容斥计算：枚举全亮的行列为 $i$、$j$，贡献为 $\binom{n}{i} \binom{m}{j} \binom{i}{x} \binom{j}{y} (-1)^{i - x} (-1)^{j - y} \binom{nm - im - jn + ij}{k - im - jn + ij}$。</p><p>最后那个组合数不关键，给它拆走。剩下的看似是个二维 $FFT$，实际上完全更简单——把 $\binom{n}{i} \binom{i}{x} (-1)^{i - x}$ 计到某个数组 $h_{i, y}$ 里（枚举 $y$ 对第一维做卷积），再枚举第一维对第二维做卷积，累计到 $[im + jn - ij]$ 里即可。做 $n$ 遍长度为 $m$ 的卷积和 $m$ 遍长度为 $n$ 的卷积，$O(nmlognm)$.</p><p><a href="https://uoj.ac/submission/446428" target="_blank" rel="noopener">$Code$</a></p><p>upd on 2021.3.2:<br>学习了第一句话那个结论的证明。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>先考虑最大值的期望。枚举最大值 $x$，$\int_0^1 x \cdot x^{n - 1} dx = F(1) - F(0) = \frac{1}{n + 1} 1^{n + 1} - \frac{1}{n + 1} 0^{n + 1} = \frac{1}{n + 1}$，还要再乘 $n$ 表示哪个最大。</p><p>推广：枚举第 $k$ 小值 $x$，$\int_0^1 x \cdot x^{k - 1} \cdot (1 - x)^{n - k} dx$。考虑分部积分，即 $\int_a^b uv’ dx = uv|_a^b - \int_a^b vu’ dx$。</p><p>设 $u = (1 - x)^{n - k}$, $v’ = x^k$，则 $v = \frac{1}{k + 1} x^{k + 1}$，$uv$ 在 $0$ 和 $1$ 处都为 $0$ 所以 $uv = 0$，原柿 $= \frac{n - k}{k + 1} \int_0^1 x^{k + 1}(1 - x)^{n - k - 1} dx$</p><p>设 $a_i = \int_0^1 x^i(1 - x)^{n - k} dx$，则有 $a_i = \frac{n - i}{i + 1} a_{i + 1}$，边界 $a_n = \frac{1}{n + 1}$，可得通项公式 $a_i = \frac{i!(n - i)!}{(n + 1)!}$，乘上 $n \cdot \binom{n - 1}{k - 1}$ 表示选择方案，得 $\frac{k}{n + 1}$。</p><h4 id="其实就是-Beta-函数！"><a href="#其实就是-Beta-函数！" class="headerlink" title="其实就是 $\Beta$ 函数！"></a><em>其实就是 $\Beta$ 函数！</em></h4><p>$\Gamma$ 函数：</p><script type="math/tex; mode=display">\Gamma(x) = \int_0^{+\infty} t^{x - 1} e^{-t} dt</script><p>$\Beta$ 函数（定义域是 $x &gt; 0$, $y &gt; 0$）：</p><script type="math/tex; mode=display">\Beta(x, y) = \int_0^{1} t^{x - 1} (1 - t)^{y - 1} dt</script><p>结论：</p><ul><li><p>$\Gamma(1) = 1$, $\Gamma(x) = (x - 1) \Gamma(x - 1)$, <strong>因此 $\Gamma(x) = (x - 1)!$</strong></p></li><li><p>$\Beta(x, y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}$ <a href="https://blog.csdn.net/xhf0374/article/details/53946146" target="_blank" rel="noopener">证……明？</a></p></li></ul><p><del>这俩基本够用了</del></p><p>我们求的是 $\Beta(k + 1, n - k + 1)$，化简以后乘上方案数就是 $\frac{k}{n + 1}$。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>引入第 $n + 1$ 个随机变量 $x$，可以认为第 $k$ 小变量的期望等于第 $n + 1$ 个变量小于等于第 $k$ 小变量的概率。考虑大小关系，共有 $k * n!$（新变量有 $k$ 个位置可插入），所以概率为 $\frac{k}{n + 1}$。</p><h2 id="T2-光伏元件"><a href="#T2-光伏元件" class="headerlink" title="$T2. 光伏元件$"></a>$T2. 光伏元件$</h2><hr><h2 id="T3-服务器调度"><a href="#T3-服务器调度" class="headerlink" title="$T3. 服务器调度$"></a>$T3. 服务器调度$</h2><hr><h2 id="T4-打击复读"><a href="#T4-打击复读" class="headerlink" title="$T4. 打击复读$"></a>$T4. 打击复读$</h2><hr><h2 id="T5-校验码"><a href="#T5-校验码" class="headerlink" title="$T5. 校验码$"></a>$T5. 校验码$</h2><hr><h2 id="T6-卫星基站建设"><a href="#T6-卫星基站建设" class="headerlink" title="$T6. 卫星基站建设$"></a>$T6. 卫星基站建设$</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6079]-养猫（线性规划转费用流）</title>
      <link href="2021/01/04/%5BLOJ6079%5D-%E5%85%BB%E7%8C%AB%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81%EF%BC%89/"/>
      <url>2021/01/04/%5BLOJ6079%5D-%E5%85%BB%E7%8C%AB%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>先做了 <a href="https://www.luogu.com.cn/problem/P3980" target="_blank" rel="noopener">$志愿者招募$</a>，一样的套路——线性规划转费用流。</p><p>先钦定所有时间吃东西，然后选一些时刻变成睡觉。$x_i = 0/1$ 表示 $i$ 时刻是否睡觉，是的话代价为 $s_i - e_i$。</p><p>可以列出不等式组：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} \geq ms</script><script type="math/tex; mode=display">x_1 + \cdots + x_{k} \leq k - me</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_{n - k + 1} + \cdots + x_n \leq k - me</script><p>变成标准型（就是不等号变等号）：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = ms + y_1</script><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = k - me - z_1</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_{n - k + 1} + \cdots + x_n = k - me - z_{n - k + 1}</script><p>线性规划转费用流要求每个变量恰好出现一次为正、一次为负，于是添加一个等式 $0 = 0$ 并两两做差：</p><script type="math/tex; mode=display">x_1 + \cdots + x_{k} = ms + y_1</script><script type="math/tex; mode=display">y_1 + z_1 = k - ms - me</script><script type="math/tex; mode=display">x_{k + 1} + (k - ms - me) = x_1 + z_1 + y_2</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">k - me = x_{n - k + 1} + \cdots + x_n + z_{n - k + 1}</script><p>这一类线性规划转费用流的建模方法，是把等式看作点，等式平衡对应网络流中的流量平衡。</p><p>那么每个变量看作流，为正则是入，为负则是出。从出的等式向入的等式连 $(cap, val)$ 的边。例如本题中 $x_i$ 连边为 $(1, s_i - e_i)$，而 $y_i$, $z_i$ 等辅助变量连边为 $(\infty, 0)$。</p><p>对于常数（设为 $c$）也要处理，为正则视为源点发出给你的，为负则视为你发出给汇点的：$(|c|, 0)$。</p><p>正确性怎么理解呢qwq？最大流跑完了，每个点的等式都被满足</p><p>回到本题，由于第一个等式的常数 $ms$ 在等式右边，我们把右边看作入，跑最大费用流就完事了。</p><p><a href="https://loj.ac/s/1026388" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】斯特林数</title>
      <link href="2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
      <url>2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这东西看过一遍就忘还是要手敲一遍 $L_AT_EX$ 才可以啊</p><p>第一类斯特林数：$n$ 元置换分为 $k$ 个轮换的方案数。有：$\sum\limits_{k = 0}^n {n \brack k} = n!$</p><p>第二类斯特林数：$n$ 个元素划分为 $k$ 个非空集合的方案数。有：$\sum\limits_{k = 0}^n {n \brace k} = B_n$，其中 $B_n$ 为贝尔数，表示 $n$ 的划分方案数。</p><hr><p>naive 的递推：</p><script type="math/tex; mode=display">{n \brack k} = {n - 1 \brack k - 1} + (n - 1) {n - 1 \brack k}</script><script type="math/tex; mode=display">{n \brace k} = {n - 1 \brace k - 1} + k {n - 1 \brace k}</script><hr><p>展开式 + 通常求法：</p><p>第二类斯特林数的：</p><script type="math/tex; mode=display">{n \brace k} = \frac{1}{k!} \sum\limits_{i = 0}^{k}(-1)^{k - i} \binom{k}{i} i^n</script><p>（证明可以考虑组合意义 + 二项式反演，$k^n = \sum\limits_{i = 0}^k P_k^i {n \brace i} = \sum\limits_{i = 0}^k i!\binom{k}{i} {n \brace i} \Longleftrightarrow k! {n \brace k} = \sum\limits_{i = 0}^k (-1)^{k - i} \binom{k}{i} i^n$）</p><script type="math/tex; mode=display">{n \brace k} = \sum\limits_{i = 0}^k (-1)^{k - i} \frac{i^n}{i!(k - i)!}</script><p>FFT 即可。</p><hr><p>幂之间转换：</p><script type="math/tex; mode=display">x^{\underline{n}} = \sum\limits_{k = 0}^n (-1)^{n - k} {n \brack k} x^k \Longleftrightarrow x^n = \sum\limits_{k = 0}^n {n \brace k} x^{\underline{k}}</script><script type="math/tex; mode=display">x^{\overline{n}} = \sum\limits_{k = 0}^n  {n \brack k} x^k \Longleftrightarrow x^n = \sum\limits_{k = 0}^n (-1)^{n - k} {n \brace k} x^{\overline{k}}</script><hr><p>设 $L(n, k) = \sum_j {n \brack j} {j \brace k} = \binom{n - 1}{k - 1} \frac{n!}{k!}$，则有</p><script type="math/tex; mode=display">x^{\overline{n}} = \sum\limits_{k = 0}^n L(n, k)x^{\underline{k}} \Longleftrightarrow x^{\underline{n}} = \sum\limits_{k = 0}^n (-1)^{n - k} L(n, k) x^{\overline{k}}</script><p>（这是由前两条推出的，目前不知道有什么用</p><p>upd on 2021.3.20: $L(n, k)$ 就是第三类斯特林数，即拉赫数。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】LCT</title>
      <link href="2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LCT/"/>
      <url>2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91LCT/</url>
      
        <content type="html"><![CDATA[<p>之前学的。以 备 重 修 qwq</p><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><p>把树剖成许多链，每条链用 splay 维护，中序遍历深度递增。</p><h3 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h3><ul><li>打通 $x$ 到所在 splay 根的通路，并且完成后 $x$ 为所在 splay 深度最大点。</li></ul><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><ul><li><p>打通 $x$ 到全局根的通路。过程是先把 $x$ 转到 $x$ 所在 splay 的根，然后让 $x$ 带着 $x$ 的左子树并到 $fa_x$ 所在 splay 中充作 $fa[x]$ 右儿子</p></li><li><p>这个过程 $x$ 和 $fa[x]$ 都和它们原本的右儿子断开了，但右儿子依然保留“父亲是谁”的信息）</p></li></ul><h3 id="makeroot"><a href="#makeroot" class="headerlink" title="makeroot"></a>makeroot</h3><ul><li>先 access，此时 $x$ 成了和根在同一 splay 中深度最大、中序遍历最末的点</li><li>再 splay，此时 $x$ 成了所在 splay 的根，但仍是深度最大。为了让 $x$ 成为根、变得深度最小，我们翻转 $x$ 的左右子树。<strong>注意：此操作不影响其他 splay 的深度顺序。</strong></li></ul><h3 id="findroot"><a href="#findroot" class="headerlink" title="findroot"></a>findroot</h3><ul><li>不断跳左儿子</li><li><em>珍爱生命，远离 findroot。。。</em> cut() 里判能否 cut 的部分还是这样吧：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch[y][<span class="number">0</span>] == x &amp;&amp; !ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">    cut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。"><a href="#LCT-好像没法同时保证两个节点的子树信息都是对的。。无奈。。" class="headerlink" title="LCT 好像没法同时保证两个节点的子树信息都是对的。。无奈。。"></a><em>LCT 好像没法同时保证两个节点的子树信息都是对的。。无奈。。</em></h3><p>（模拟赛大爆炸</p><h2 id="关于-LCT-的时间复杂度分析"><a href="#关于-LCT-的时间复杂度分析" class="headerlink" title="关于 LCT 的时间复杂度分析"></a>关于 LCT 的时间复杂度分析</h2><p><a href="https://www.cnblogs.com/zhouzhendong/p/JunTanFenXi.html" target="_blank" rel="noopener">指路周指导博客 <del>对没错我就是贺了一遍</del></a></p><h3 id="access-1"><a href="#access-1" class="headerlink" title="access"></a>access</h3><p>考虑虚实链切换复杂度。</p><p>定义重儿子为 $size_x * 2 \geq size_{fa_x}$ 的点，其余为轻儿子。定义势能函数 $\phi$ 为又重又虚的节点数。考虑一次 splay 操作，当前 splay 根节点 $x$ 的情况：</p><ul><li>若它是轻儿子，则消耗 $1$ 时间，$\Delta \phi \leq 1$</li><li>若它是重儿子，则消耗 $1$ 时间，$\Delta \phi = 1$</li></ul><p>一次 access $x$ 的操作在过程中只会遇到 $logn$ 个轻儿子，因此一次 access 操作的均摊复杂度为 $O(logn)$。</p><h3 id="makeroot、link-cut"><a href="#makeroot、link-cut" class="headerlink" title="makeroot、link/cut"></a>makeroot、link/cut</h3><p>考虑过程中的轻重边变化量。</p><p>「把根从 $x$ 换成 $y$ 」「切除 $x$ 的子树 $y$」「连接以 $x$ 为根和以 $y$ 为根的连通块」的时候改变的轻重边只会是 $x$ 到 $y$ 路径上的，而前后 $x$ 到 $y$ 路径上都只有 $logn$ 条轻边。$O(logn)$</p><h2 id="LCT-维护子树信息"><a href="#LCT-维护子树信息" class="headerlink" title="LCT 维护子树信息"></a>LCT 维护子树信息</h2><p>到这才开始鬼畜起来，其实想清楚还是不难的……</p>]]></content>
      
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】最长反链和它全家（详细揭秘）</title>
      <link href="2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%92%8C%E5%AE%83%E5%85%A8%E5%AE%B6%EF%BC%88%E8%AF%A6%E7%BB%86%E6%8F%AD%E7%A7%98%EF%BC%89/"/>
      <url>2020/12/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E5%92%8C%E5%AE%83%E5%85%A8%E5%AE%B6%EF%BC%88%E8%AF%A6%E7%BB%86%E6%8F%AD%E7%A7%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同志，扫盲了！</span><br></pre></td></tr></table></figure><ul><li><p>链：偏序关系中，链是形如 $a \leq b$ 的许多关系；$DAG$ 上，链是一个点集，其中任意两个点 $x$, $y$ 都能从 $x$ 到 $y$ 或从 $y$ 到 $x$。</p></li><li><p>反链：反链也是点集，不过其中任意两个点都不能走到彼此。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最长反链 = 最小链覆盖（Dilworth 定理：最长反链 = 最小链精确（即不可重）覆盖，通过传递闭包可以转为最小链可重覆盖，然而实现时都用网络流）</span><br><span class="line">最长链 = 最小反链覆盖</span><br></pre></td></tr></table></figure><ul><li><p>最大匹配：$DAG$ 的最大匹配概念同二分图的。</p></li><li><p>最小链覆盖：也叫最小路径覆盖，作用如其名，分为可重和不可重。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小链覆盖 = 顶点数 - 最大匹配（刚开始没有匹配，显然成立；接下来每匹配一对点，匹配数 +1，路径数 -1。匹配数 = 每条路径点数边数和。）</span><br></pre></td></tr></table></figure><ul><li><p>最小不可重链覆盖：拆点，用匈牙利算法或者网络流求解，连 $(x_{out}, y_{in})$</p></li><li><p>最小可重链覆盖：先传递闭包，再在形成的偏序集上做最小不可重链覆盖，跳过的点被当作重复经过，然而实现时一般用网络流建 $(x’, x, \infty)$ 这样的反边表示某些点被当作中间点做了传递闭包。</p></li><li><p>最大独立集：选出最多的点，其中两两无边相连。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大团 = 补图最大独立集</span><br></pre></td></tr></table></figure><ul><li><p>最小点覆盖：选择最少的点覆盖所有边。</p><ul><li>二分图的最小点覆盖可以这么求：先跑一遍最大匹配，令左边点只能走非匹配边，右边点只能走匹配边，最小点覆盖就是左侧未访问点加上右侧已访问点。</li></ul></li><li><p>最小边覆盖：选择最少的边覆盖所有点。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二分图 最大匹配 = 最小点覆盖</span><br><span class="line">    每条边一定连着一个匹配点，否则连两个未匹配点匹配数应该 +1。</span><br><span class="line">二分图 最大独立集 = 顶点数 - 最小点覆盖</span><br><span class="line">    把最小点覆盖剔除，剩下的点就没有边相连了。</span><br><span class="line">二分图 最小边覆盖 = 顶点数 - 最大匹配</span><br><span class="line">    显然。同时也告诉我们最小边覆盖就是在最大匹配的基础上加边，变成完美匹配。</span><br><span class="line">二分图 最小割 = 最小点权覆盖集 = 点权和 - 最大点权独立集</span><br></pre></td></tr></table></figure><p>感觉类似题目（不 sb 的那种）都是用👆上面这套理论搞来搞去，比如 <a href="https://www.luogu.com.cn/problem/P4298" target="_blank" rel="noopener">$CTSC2008-祭祀$</a>：难点在构造方案。</p><p>第二问好想，每个点删除后做一遍最长反链看是否只减小了 $1$。</p><p>第一问，先说结论：选出新图所有 $x_{out}$ 和 $x_{in}$ 都在最大独立集里的点，就是原图最长反链。</p><p>证明：<br>有最大独立集合 $I$ = 顶点数 $2n$ - 最大匹配 $m$，设最长反链集合为 $A$，$I - A$ 为「$x_{out}$ 或 $x_{in}$ 在最大独立集里」的点集，$|I| - |A| \leq n$, $|A| \geq |I| - n = n - m$, 而 $|A| \leq n - m$，所以 $|A| = n - m =$ 原图最长反链。</p><p>所以匈牙利或者 $dinic$ 找最大匹配，再 dfs 找最小点覆盖，最大独立集 = 最小点覆盖补集。注意这题可重。</p><p><em>彩蛋：$dinic$ 在二分图上单次增广是 $O(n\sqrt{n})$ 的哦</em></p><p>upd: $96$ 分我太疑惑了？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】最大权闭合子图</title>
      <link href="2020/12/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
      <url>2020/12/26/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><hr><p>看到一篇很好的博客，终于会了这玩意儿！qwq 咱不来虚的哈，直接上正题</p><ul><li><p>什么是最大权闭合子图：</p><p>  每个点有点权，点权和最大的闭合子图即为最大权闭合子图</p></li><li><p>如何求解</p><p>  先说结论：$S$ 向正权点连，边权为权值，$T$ 向负权点连，边权为权值绝对值。<strong>最大权闭合子图权值即为正权和 - 最大流。</strong></p><p>  证明（半感性）：<strong>$S -&gt; T$ 的流量就是损失。</strong> 尽量选正权点为起点，所以 $S$ 向正权点连。一个正权点选会导致后续选一些负权点，但我们不知道选当前正权点是否优，就先选上，顶多后面被负权点损失掉为 $0$，不会亏。</p></li></ul><p>习题：</p><h3 id="Salty-Fish"><a href="#Salty-Fish" class="headerlink" title="$Salty Fish$"></a><a href="https://vjudge.net/problem/HDU-6634" target="_blank" rel="noopener">$Salty Fish$</a></h3><p>显然的最大权闭合子图模型——选了某个苹果就要黑掉所有能控制它的摄像头。</p><p>建图：</p><ul><li>摄像头和源点连，割掉表示黑掉</li><li>苹果和汇点连，割掉表示放弃</li><li>显然不可能两边都不割！</li></ul><p>考虑模拟费用流。本质是贪心的选苹果，然后优先去流浅的摄像头；反过来看，摄像头也优先流深的苹果。</p><p>从下往上做，与深度有关就长链剖分，开一个 $map$，$mp[x, d]$ 维护 $x$ 子树中深度为 $d$ 的苹果还能提供多少流量，在每个摄像头处从深的流量选起，每种苹果只在所在长链的根处被合并一次，$O((n + m)logn)$</p><p>然而这题要直接继承重儿子的 $map$，不然就 $MLE$。。以后写代码也注意一点。</p><p><a href="http://acm.hdu.edu.cn/viewcode.php?rid=35876699" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[THUWC2017]-大葱的神力</title>
      <link href="2020/12/22/%5BTHUWC2017%5D-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B/"/>
      <url>2020/12/22/%5BTHUWC2017%5D-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>玩玩提答！qwq。看到一句话：提答的本质是模拟退火和找规律。哦这样吗！那我去学模拟退火（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模拟退火算法流程（贺）：</span><br><span class="line">随机变化坐标，幅度为 T</span><br><span class="line">计算新解与当前解的差 delta。</span><br><span class="line">以最大化答案为例，若 delta &gt; 0 则用新解替换当前解；否则以 exp(-delta / T) 的概率用新解替换当前解。</span><br><span class="line">温度乘上一个小于 1 的系数，即降温。</span><br><span class="line">随着温度不断降低，变化幅度也不断减小，接受一个更劣解的概率也越来越小。</span><br></pre></td></tr></table></figure><p>调参看脸。有人说可以观察答案的变化率什么的，总之是个完全玄学的东西。</p><p>好，上正文！（其实是想存代码，好有成就感的说 qwq</p><p>每个 case 都有特性，需要观察找规律。</p><h3 id="Case-1-amp-2"><a href="#Case-1-amp-2" class="headerlink" title="Case 1 &amp; 2"></a>Case 1 &amp; 2</h3><p>暴搜 + （我的垃圾）剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>], b[<span class="number">30</span>], mp[<span class="number">30</span>][<span class="number">30</span>], sum, to[<span class="number">30</span>], ans, pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>], mx[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + mx[x] &lt; ans) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; ans) &#123;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                pos[i] = to[i];</span><br><span class="line">            &#125; ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x + <span class="number">1</span>);</span><br><span class="line">    rep(y, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[y] + a[x] &lt;= b[y]) &#123;</span><br><span class="line">            sum += mp[x][y];</span><br><span class="line">            to[x] = y;</span><br><span class="line">            used[y] += a[x];</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            sum -= mp[x][y];</span><br><span class="line">            used[y] -= a[x];</span><br><span class="line">            to[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("drawer2.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("drawer2.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            mx[i] = max(mx[i], mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) mx[i] += mx[i + <span class="number">1</span>];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pos[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h3><p>抽屉唯一，跑背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>, M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[M], w[M], f[M][N], lst[M][N], ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y ^ lst[x][y]) ans[x] = <span class="number">1</span>;</span><br><span class="line">    work(x - <span class="number">1</span>, lst[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">memset</span>(f, ~<span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">10000</span>) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j], lst[i][j] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= a[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &lt; f[i - <span class="number">1</span>][j - a[i]] + w[i]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - a[i]] + w[i];</span><br><span class="line">                    lst[i][j] = j - a[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">10000</span>) <span class="keyword">if</span> (f[n][i] &gt; f[n][id]) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    work(n, id);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-4-amp-5-amp-6"><a href="#Case-4-amp-5-amp-6" class="headerlink" title="Case 4 &amp; 5 &amp; 6"></a>Case 4 &amp; 5 &amp; 6</h3><p>大葱体积唯一且抽屉体积是大葱体积倍数——裸的费用流。</p><p>值得一提的是有个 Case 大葱体积都在 <del>19260817</del>19900000 左右，可视为微小的扰动，不会影响最终答案，取最大值作为体积就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(rest, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(rest));</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        v = max(v, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        add(i + n, T, b[i] / v, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Mcmf();</span><br><span class="line">    rep(x, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-7"><a href="#Case-7" class="headerlink" title="Case 7"></a>Case 7</h3><p>只有第一个大葱体积不同，枚举它放在哪，跑多次费用流。跑了一分多钟，反正是提答 ~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>, M = <span class="number">205</span>, E = N * M * <span class="number">2</span> + N + M, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> S, T, n, m, Cost, V;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][N], ans[N];</span><br><span class="line"><span class="keyword">int</span> fr[E], to[E], nxt[E], lnk[N * <span class="number">2</span>], val[E], cap[E], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N * <span class="number">2</span>], pre[N * <span class="number">2</span>], inq[N * <span class="number">2</span>], rest[N * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fr[++cnt] = x, to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = w, cap[cnt] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    rep(i, S, T) &#123;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">        pre[i] = <span class="number">0</span>;</span><br><span class="line">        inq[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[S] = <span class="number">0</span>, inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y])</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] &gt; <span class="number">1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += rest[T] * dis[T];</span><br><span class="line">    <span class="keyword">int</span> u = T;</span><br><span class="line">    <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">        cap[pre[u]] -= rest[T];</span><br><span class="line">        cap[pre[u] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        u = fr[pre[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mcmf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    V = a[<span class="number">2</span>];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">48</span>] -= a[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        add(i + n, T, b[i] / V, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(j ,<span class="number">1</span>, m) &#123;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, -mp[i][j]), add(j + n, i, <span class="number">0</span>, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cost = Mcmf() - mp[<span class="number">1</span>][<span class="number">48</span>];</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">48</span>;</span><br><span class="line">    rep(x, <span class="number">2</span>, n) &#123;</span><br><span class="line">        ans[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (!y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cap[i]) &#123;</span><br><span class="line">                ans[x] = y - n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(x, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[x]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-8-amp-9-amp-10"><a href="#Case-8-amp-9-amp-10" class="headerlink" title="Case 8 &amp; 9 &amp; 10"></a>Case 8 &amp; 9 &amp; 10</h3><p>没有任何规律。于是就上模拟退火（学以致用</p><p>我是 rand 排列，随便调参，最优解只有 51 万左右，然而其他人都是 60 万左右，心慌慌</p><p>交一发竟然也是 4 + 2 + 1，开心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> db down = <span class="number">0.986</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[M], mp[N][M], to[N], idb[N], ida[N];</span><br><span class="line"><span class="keyword">int</span> used[N], tmp[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    db T = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">1e-15</span>) &#123;</span><br><span class="line">        random_shuffle(ida + <span class="number">1</span>, ida + n + <span class="number">1</span>);</span><br><span class="line">        random_shuffle(idb + <span class="number">1</span>, idb + m + <span class="number">1</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) tmp[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) used[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[idb[cur]] + a[ida[i]] &lt;= b[idb[cur]]) &#123;</span><br><span class="line">                used[idb[cur]] += a[ida[i]];</span><br><span class="line">                tmp[ida[i]] = idb[cur];</span><br><span class="line">                sum += mp[ida[i]][idb[cur]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cur; --i;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll del = sum - ans;</span><br><span class="line">        <span class="keyword">if</span> (del &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span>(-del / T) * RAND_MAX &gt; rand()) &#123;</span><br><span class="line">                ans = sum;</span><br><span class="line">                rep(i, <span class="number">1</span>, n) to[i] = tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T *= down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(o, <span class="number">1</span>, <span class="number">5</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) ida[i] = idb[i] = i;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>) * clock() % <span class="number">114514</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld :\n"</span>, ans);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://loj.ac/s/1017355" target="_blank" rel="noopener">评测记录</a></p><p>$10 * 7 + 4 + 2 + 1 = 77$，海星</p>]]></content>
      
      
      
        <tags>
            
            <tag> 提交答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】BM 算法 &amp; 常系数齐次线性递推</title>
      <link href="2020/12/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BM%20%E7%AE%97%E6%B3%95%20&amp;%20%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
      <url>2020/12/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91BM%20%E7%AE%97%E6%B3%95%20&amp;%20%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Berlekamp-Massey"><a href="#Berlekamp-Massey" class="headerlink" title="$Berlekamp-Massey$"></a>$Berlekamp-Massey$</h2><p><a href="https://blog.csdn.net/hzj1054689699/article/details/90047110" target="_blank" rel="noopener">大佬1</a>  <a href="https://www.luogu.com.cn/blog/_post/234046" target="_blank" rel="noopener">大佬2</a> <a href="https://blog.csdn.net/qq_42101694/article/details/103811029" target="_blank" rel="noopener">大佬3</a></p><p>实现时下标经常多一位或少一位-_-|| 我预 言不久的将来 BM 会沦为 xml 的脑内黑箱</p><p>大概做题思路就是：矩阵乘法都有递推式，数据范围超过 1000 就考虑 BM 求递推式然后乱搞</p><h2 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h2><p>求出递推式，接下来就要递推啦。</p><p>是照着 <a href="https://www.cnblogs.com/zhouzhendong/p/Cayley-Hamilton.html" target="_blank" rel="noopener">zhouzhendong</a> 和 <a href="https://www.cnblogs.com/Winniechen/p/10246295.html" target="_blank" rel="noopener">Winniechen</a> 和 <a href="https://oi-wiki.org/math/linear-recurrence/" target="_blank" rel="noopener">OI-wiki</a>学习的，oi-wiki 没有那么多线代前置芝士。</p><h3 id="解决什么问题？"><a href="#解决什么问题？" class="headerlink" title="解决什么问题？"></a>解决什么问题？</h3><p>给定一个数列，满足:</p><ul><li>$n \leq k$ 时，$f_n = a_n$</li><li>$n &gt; k$ 时，$f_n = \sum\limits_{i = 1}^k f_{n - i} * a_i$</li></ul><p>众所周知矩阵生来就做这事儿的，但是 $n$ 比较大的时候就没前途。于是就出现了——特征多项式优化矩阵快速幂。求第 $n$ 项复杂度为 $O(k^2 log n)$</p><p>upd: 原先写的不好，删了。复读 oi-wiki。</p><p>从生成函数的角度来理解，就是将每个 $x^{n - i}$ 的系数乘上一个常数转移给了 $x^n$。</p><p>构造一个理论上存在的函数 $F$。</p><p>定义：$F(\sum a_i x^{n - i})$ 表示 $\sum a_i f_{n - i}$。</p><p>显然 $F$ 可以加、乘。$F(x^n) = f_n = F(\sum\limits_{i = 1}^k a_i x^{n - i})$，有 $F(x^n - \sum\limits_{i = 1}^k a_i x^{n - i}) = F(x^{n - k}(x^k - \sum\limits_{i = 1}^k a_i x^{k - i})) = 0$。</p><p>设 $\lambda = x^k - \sum\limits_{i = 1}^k a_i x^{k - i}$（$\lambda$ 也称为该递推式的特征多项式），显然有 $F(\lambda) = 0$</p><p>$F(A(x) + x^d \lambda) = F(A(x)) + F(x^d \lambda) = F(A(x))$（这里的 $A(x)$ 是任意多项式，如果恰好是递推式的多项式那取模就是保留前 $k$ 项啦），就可以将 $A(x)$ 对 $\lambda$ 取模来降低 $A(x)$ 的次数。所以本质是个多项式取模。$O(k^2 logn)$ 的版本比较常用。</p><p>模板：要求 $f_n$，即求 $F(x^n) = F(x^n \mod \lambda)$，求出 $x^n \mod \lambda$ 后带入 $F$ 定义即可。</p><p>可以用多项式科技做到 $O(klogklogn)$。</p><details>  <summary>template</summary>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">luogu_5497</span></span><br><span class="line"><span class="comment">加了常系数齐次线性递推的版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, de, K;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; f[N], ans, lst;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x + y) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> x * y % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> (x - y + mod) % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = x * y % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sub</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x - y + mod) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, Mul(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) Mul(ret, a);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BM</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail = <span class="number">0</span>;</span><br><span class="line">    ll cur = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.size(); j++)</span><br><span class="line">            Add(cur, mul(b[i - <span class="number">1</span> - j], ans[j]));</span><br><span class="line">        <span class="keyword">if</span> (!((b[i] - cur) % mod)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!fail) &#123;</span><br><span class="line">            fail = i;</span><br><span class="line">            de = b[i] - cur;</span><br><span class="line">            rep(j, <span class="number">1</span>, i) ans.pb(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; now = ans;</span><br><span class="line">        ll w = mul(b[i] - cur, qpow(de, mod - <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (ans.size() &lt; lst.size() + i - fail)</span><br><span class="line">            ans.resize(lst.size() + i - fail);</span><br><span class="line">        Add(ans[i - fail - <span class="number">1</span>], w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lst.size(); j++)</span><br><span class="line">            Sub(ans[i - fail + j], mul(w, lst[j]));</span><br><span class="line">        <span class="keyword">if</span> (now.size() &lt; lst.size() + i - fail) &#123;</span><br><span class="line">            lst = now, fail = i, de = b[i] - cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doMul</span><span class="params">(ll x[], ll y[])</span> </span>&#123;</span><br><span class="line">    ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">        rep(j, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">            Add(tmp[i + j], mul(x[i], y[j]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * K - <span class="number">2</span>; i &gt;= K; i--) &#123;  <span class="comment">// 在取模</span></span><br><span class="line">        <span class="keyword">if</span> (!tmp[i]) <span class="keyword">continue</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, K)</span><br><span class="line">            Add(tmp[i - j], mul(a[j], tmp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">2</span> * K - <span class="number">1</span>)</span><br><span class="line">        x[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">ll c[N];  <span class="comment">// 系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fpow</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll tmp[N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    c[<span class="number">0</span>] = tmp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) doMul(c, tmp);</span><br><span class="line">        doMul(tmp, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    BM(n);</span><br><span class="line">    K = (<span class="keyword">int</span>)ans.size();</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>) &#123;</span><br><span class="line">        ans[i] = (ans[i] % mod + mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">        a[i + <span class="number">1</span>] = ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>) b[i] = b[i + <span class="number">1</span>];</span><br><span class="line">    rep(i, K, n) b[i] = <span class="number">0</span>;</span><br><span class="line">    fpow(m);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, K - <span class="number">1</span>)</span><br><span class="line">        Add(ans, mul(b[i], c[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="THUSCH2017-如果奇迹有颜色"><a href="#THUSCH2017-如果奇迹有颜色" class="headerlink" title="$THUSCH2017-如果奇迹有颜色$"></a><a href="https://loj.ac/p/2981" target="_blank" rel="noopener">$THUSCH2017-如果奇迹有颜色$</a></h3><p>这题比洛谷上的 Polya 模板题多了个相邻 $m$ 项颜色不能全不同的限制。</p><p>$|X/G| = \frac{1}{|G|} \sum_g m^{c(g)} = \frac{1}{|G|} \sum_k \varphi(n / k) * f(k)$</p><p>现在要算 $f(gcd = k)$ 的染色方案数。可以状压计算，状态数是 $m^{m}$，直接跑矩阵快速幂能拿到 $55$ 分的好成绩，然后我就不会了</p><p>题解告诉我要去学常系数齐次线性递推，我就滚去学了。厚厚，新知识！（于是就有了这篇拼凑起来的笔记</p><p>猜测递推式长度小于 $m^{m}$，借助超能力（打表）发现 $m = 7$ 就 $409$.</p><p><a href="https://loj.ac/s/1012066" target="_blank" rel="noopener">$Code$</a></p><h3 id="NOI2017-泳池"><a href="#NOI2017-泳池" class="headerlink" title="$NOI2017-泳池$"></a><a href="https://uoj.ac/problem/316" target="_blank" rel="noopener">$NOI2017-泳池$</a></h3><p><strong>恰好</strong>用差分变为<strong>小于等于</strong>。设计 dp：$dp_{i, j}$ 表示有一块宽度为 $j$ 的区域，最下面 $i$ 行都是安全的，从下往上第 $i + 1$ 行及以上部分任意，<strong>且该区域内最大游泳场面积 $\leq K$</strong> 的概率。那么有：</p><p>$$dp_{i, j} = dp_{i + 1, j} p^j + \sum\limits_{k = 1}^j dp_{i + 1, k - 1}dp_{i, j - k}(1 - p)p^{k - 1}$$</p><p>答案是 $dp_{0, n}$。</p><p>如果你打了表。。你就会发现 $dp_0$ 有递推式（谁这么熟练啊= =）于是一顿操作猛如虎<del>回头一看二百五</del></p><p><a href="https://uoj.ac/submission/452703" target="_blank" rel="noopener">$Code$</a></p><h3 id="CF865G-Flowers-and-Chocolate"><a href="#CF865G-Flowers-and-Chocolate" class="headerlink" title="$CF865G-Flowers\ and\ Chocolate$"></a><a href="https://www.luogu.com.cn/problem/CF865G" target="_blank" rel="noopener">$CF865G-Flowers\ and\ Chocolate$</a></h3><p>不错的题，比前两道靠谱。写学习笔记里。</p><p><del>什么呀！做题还能被塞狗粮，真是够了。</del></p><p>题意好绕：买若干朵花和若干盒巧克力，使得花瓣数和巧克力块数相等。花和盒子摆放有顺序。</p><p>$n$ 这么大显然生成函数了。</p><ul><li>花：$F(x) = (\sum x^{p_i})^n$</li><li>巧：$B(x) = \frac{1}{1 - \sum x^{c_i}}$</li><li>$ans = \sum\limits_{n \geq 0} [x^n] F(x) [x^n] B(x)$</li></ul><p>$B(x)$ 是个常系数递推式。可以简单的从组合意义（就是背包 dp = =）来理解：</p><ul><li>设 $bin_i = \sum\limits_{j = 1}^B [c_j == i]$</li><li>设 $k = \max(c_i)$</li><li>$dp_i = \sum\limits_{j = 1}^{k} bin_j dp_{i - j}$</li></ul><p>那么求出递推式的特征多项式 $D(x) = x^k - \sum bin_i x^{k - i}$</p><p>假设知道了 $F(x)$ 某个 $[x^p]$，要知道 $B(x)$ 的 $[x^p]$ 就求出 $B(x) \mod D(x)$，得到一个 $250$ 次多项式，实际上这里取模就是保留前 $k$ 项，背包即可。</p><p>对 $F(x)$ 也求对 $D(x)$ 取模的结果以降次，具体来说是把 $x^{p_i}$ 对 $D(x)$ 取模并加在一起 $n$ 次方</p><p><a href="https://codeforces.com/contest/865/submission/114985231" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线性递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2019]-开关</title>
      <link href="2020/12/11/%5BZJOI2019%5D-%E5%BC%80%E5%85%B3/"/>
      <url>2020/12/11/%5BZJOI2019%5D-%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一-生成函数"><a href="#方法一-生成函数" class="headerlink" title="$方法一:生成函数$"></a>$方法一:生成函数$</h2><p>“神仙题！”（平庸的 xml 发出惊叹）</p><p>生成函数怎么想到的啊？/yiw 但的确很符合，因为按键是有顺序的，而每个键按多少次概率也不同，适合用形式幂级数表示。</p><p>设 $P = \sum p$.</p><p>分开考虑每个键。考虑 $[x^k]F_i(x)$ 表示第 $i$ 个位置按了 $k$ 次的概率贡献。当然是 EGF 啦因为是有顺序的按。</p><script type="math/tex; mode=display">F_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == s_i] \frac{ ( \frac{p_i}{P} ) ^n}{n!} x^n</script><script type="math/tex; mode=display">F(x) = \prod F_i(x)</script><p>写成 OGF <script type="math/tex">f(x) = \sum_k (k! * [x^k]F(x)) * x^k</script></p><p>$[x^k]G_i(x)$ 表示第 $i$ 个位置按了 $k$ 次，状态不变的概率。</p><p>然而只有 $F$ 能干啥呢？我们要求的是<strong>第一次</strong>到达目标状态，所以需要容斥。具体来说，设 $g(x)$ 表示 $k$ 次状态不变的 OGF，可按上述方法求出；设 $h(x)$ 为答案 OGF，则 $f(x) = g(x) \cdot h(x)$, 则 $h(x) = \frac{f(x)}{g(x)}$.</p><p>根据期望的定义，答案形如 $\sum_i if(i)$ 。啊这不就是 $h(1)$ 的导数嘛！$h’(1)$ 就是最终答案。</p><script type="math/tex; mode=display">G_i(x) = \sum\limits_{n \geq 0} [n\ mod\ 2 == 0] \frac{( \frac{p_i}{P} )^n}{n!} x^n</script><script type="math/tex; mode=display">G(x) = \prod G_i(x)</script><p>写成 OGF <script type="math/tex">g(x) = \sum_k (k! * [x^k]G(x)) * x^k</script></p><p>写成封闭形式</p><script type="math/tex; mode=display">F_i(x) = \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">F(x) = \prod \frac{e^{\frac{p_i}{P}x} + (-1)^{s_i} e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">G_i(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}</script><script type="math/tex; mode=display">G(x) = \frac{e^{\frac{p_i}{P}x} + e^{-\frac{p_i}{P}x}}{2}</script><p>将 $F(x)$ 写成 $\sum c_i e^{\frac{i}{P}x}$ 的形式，则有</p><script type="math/tex; mode=display">f(x) = \sum_k \left( k![x^k]F(x) \right) x^k</script><script type="math/tex; mode=display">= \sum_k k![x^k]( \sum_i c_i ( \sum_j \frac{(\frac{i}{P}x)^j}{j!} ) )x^k</script><script type="math/tex; mode=display">= \sum_k ( k! \sum_i c_i \frac{(\frac{i}{P})^k}{k!} ) x^k = \sum_k  (\sum_i c_i (\frac{i}{P})^k) x^k</script><script type="math/tex; mode=display">= \sum_i c_i \sum_k (\frac{i}{P})^k x^k = \sum_i \frac{c_i}{1 - \frac{i}{P}x}</script><p>同理有 $g(x) = \sum_i \frac{d_i}{1 - \frac{i}{P}x}$。$c_i$, $d_i$ 可以简单 $O(nP)$ 背包得出！</p><p>补充求导加减乘除法法则：</p><script type="math/tex; mode=display">(f(x) + g(x))' = f'(x) + g'(x)</script><script type="math/tex; mode=display">(f(x) - g(x))' = f'(x) - g'(x)</script><script type="math/tex; mode=display">(f(x) \cdot g(x))' = f'(x)g(x) + f(x)g'(x)</script><script type="math/tex; mode=display">(\frac{f(x)}{g(x)})' = \frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2}</script><p>所以要求 $h’(x)$，只要计算出 $f(1)$, $f’(1)$, $g(1)$, $g’(1)$.</p><p><strong>然后又是常识问题：无知如我就想直接带 1 进去了，但这不行！！！因为 $i = P$ 项的存在，函数不收敛！！！</strong></p><p>怎么办？乘上 $1 - x$</p><script type="math/tex; mode=display">f(x) = c_P + \sum\limits_{i \neq P} \frac{c_i(1 - x)}{1 - \frac{i}{P}x}</script><script type="math/tex; mode=display">f(1) = c_P</script><script type="math/tex; mode=display">f'(x) = \sum\limits_i \frac{ -c_i(1 - \frac{i}{P}x) - (c_i - c_ix)(-\frac{i}{P}) }{(1 - \frac{i}{P}x)^2} = \sum\limits_i \frac{ (\frac{i}{P} - 1)c_i }{ (\frac{i}{P}x - 1)^2 }</script><script type="math/tex; mode=display">f'(1) = \sum\limits_{i \neq P} \frac{c_i}{\frac{i}{P} - 1}</script><p>同理 $g(1) = d_P$, $g’(1) = \sum\limits_{i \neq P} \frac{d_i}{\frac{i}{P} - 1}$</p><script type="math/tex; mode=display">h'(1) = \sum\limits_{i \neq P} \frac{c_id_P - c_Pd_i}{(i - 1)d_P^2}</script><p>神奇！</p><p><a href="https://loj.ac/s/1010266" target="_blank" rel="noopener">$Code$</a></p><p>从中获得的启示：</p><ul><li>多考虑实际意义，例如本题中期望 -&gt; 导数。</li><li>推柿子：面对多项式束手无策，不如把它变成封闭形式搞事情，多项式的加减乘除和数的加减乘除类似的，还可以求导、ln、exp，多好啊！</li><li>推柿子：把 $\prod_{i = l}^{r}$ 变成一个 $r - l + 1$ 次的多项式，就可以 $\sum$ 啦！$\sum$ 就能搞事情啦！</li></ul><h2 id="方法二：异或卷积"><a href="#方法二：异或卷积" class="headerlink" title="$方法二：异或卷积$"></a>$方法二：异或卷积$</h2><p>咕咕？<del>（生成函数搞累了</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计划】20Dec 训练日志</title>
      <link href="2020/12/07/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Dec%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/"/>
      <url>2020/12/07/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Dec%20%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】生成函数</title>
      <link href="2020/12/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
      <url>2020/12/06/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020赛前训练小结</title>
      <link href="2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E5%B0%8F%E7%BB%93/"/>
      <url>2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 前的做题记录整理</title>
      <link href="2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/"/>
      <url>2020/12/05/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%20%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP2020 总结</title>
      <link href="2020/11/18/CSP2020%20%E6%80%BB%E7%BB%93/"/>
      <url>2020/11/18/CSP2020%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>被 T1 搞得心态爆炸导致 T3 彻底降智，最后一小时浑浑噩噩一分都没捞着，大失败！</p><h2 id="T1-儒略日"><a href="#T1-儒略日" class="headerlink" title="$T1. 儒略日$"></a>$T1. 儒略日$</h2><hr><p>打了一个半小时左右，真的是。。。本场崩的罪魁祸首，关键是年份还算错了一处（取模），只拿到了暴力分。。。。</p><p><del>啊！！！！气死我了！！！！</del></p><p>T1 的使命就是来耗时间的，考察选手代码能力。即选择较优的写法，以缩短时间。。。比如说二分和小范围的预处理就很好。狂码 200 行的选手如我，不崩谁崩？</p><p><a href="https://loj.ac/submission/990046" target="_blank" rel="noopener">$Code$</a></p><h2 id="T2-动物园"><a href="#T2-动物园" class="headerlink" title="$T2. 动物园$"></a>$T2. 动物园$</h2><hr><p>呵，最后 5 min 发现数据范围 $0 \leq k \leq 64$… 再见，这美丽的世界。</p><p>于是比去年更烦了一重：要判 = 64 和 65 的，65 就是先减后加。</p><p><a href="https://loj.ac/submission/990047" target="_blank" rel="noopener">$Code$</a></p><h2 id="T3-函数调用"><a href="#T3-函数调用" class="headerlink" title="$T3. 函数调用$"></a>$T3. 函数调用$</h2><hr><p>被 T1 烦到了，思路完全乱掉，归根结底还是心理素质太差了！</p><p>这题只是简单的加法乘法原理题，只要注意到贡献都是以加为根本，以乘为辅，大概就能想出来。最终答案的原先面目都是一些加操作啊。</p><p>于是考虑维护乘操作对加操作的影响，记一个后缀乘积就好了，拓扑看似难写实则好写。。。</p><p><a href="https://loj.ac/submission/990045" target="_blank" rel="noopener">$Code$</a></p><h2 id="T4-贪吃蛇"><a href="#T4-贪吃蛇" class="headerlink" title="$T4. 贪吃蛇$"></a>$T4. 贪吃蛇$</h2><hr><p>这题看似简单 实则不愧对其第四题的地位。。。思维严密，挺有意思的。</p><p>重要性质（与 16 年的蚯蚓十分相似）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进食的蛇丢进另一个队列里，发现当前丢的一定是进食过的蛇里最弱的</span><br></pre></td></tr></table></figure></p><p>猜想：如果当前 $max$ 吃了 $min$，不会变成 $min$，就一定会吃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证明：之后吃了的 max 会比当前吃完的 max 更小。</span><br></pre></td></tr></table></figure></p><p>所以分为两个阶段：</p><ol><li>当前 $max$ 吃了 $min$，不会变成 $min$，就一直吃</li><li>当前 $max$ 吃了 $min$，会变成 $min$，会一直进行下去直到某条蛇吃了不会变成 $min$ 或总数 $= 2$，这时最后吃的那条会反悔，倒数第二条吃的一定会吃，倒数第三条会反悔。。。发现和递归层数的奇偶性有关。感觉十分nb。<br>$set$ 维护 $max$ &amp; $min$，$O(Tnlogn)$，$70$ 分。</li></ol><p>考虑优化，那必须 $O(n)$ 了</p><p>考虑双端队列</p><p>划一下题目中容易遗漏的条件：保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。</p><p>——不用 $sort$ 了！</p><p>$q1$ 维护没吃过和没被吃过的，$q2$ 维护吃过的。显然都是有序的。</p><p>就是在暴力的基础上改一改</p><p>对于我这种没有🧠的选手来说，先写暴力才有可能优化成正解。。。而且暴力也更稳，考场上要尽力的打高分啊！</p><p><a href="https://loj.ac/submission/989975" target="_blank" rel="noopener">$Code$(暴力)</a></p><p><a href="https://loj.ac/submission/990038" target="_blank" rel="noopener">$Code$(正解)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="$总结$"></a>$总结$</h2><hr><p>不要哀求，学会争取。感觉思维还是太慢了，细节又推不干净，接下来要训练思维的敏捷性，也要注重模拟赛的训练。</p><p>考场情况多，稳住。僵住的状态可以去窗口深呼吸，回来继续拼抢。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020复习计划</title>
      <link href="2020/11/10/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>2020/11/10/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%91NOIP2020%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Comet OJ Contest 75</title>
      <link href="2020/09/25/Comet%20OJ%20Contest%2075/"/>
      <url>2020/09/25/Comet%20OJ%20Contest%2075/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cometoj.com/contest/75/problems" target="_blank" rel="noopener">传送门</a></p><p>sooke 这套真是高质量好题 /dz</p><h2 id="A-绝境"><a href="#A-绝境" class="headerlink" title="$A. 绝境$"></a>$A. 绝境$</h2><hr><p>考虑容斥，答案就是每种 $n - 1$ 个操作的交集减去 $n$ 个操作的交集。求矩形交的前后缀和！</p><p><a href="https://cometoj.com/status/ykj87mpwfh7me0lbi15ciah6vj67ryd4" target="_blank" rel="noopener">$Code$</a></p><h2 id="B-命运"><a href="#B-命运" class="headerlink" title="$B. 命运$"></a>$B. 命运$</h2><hr><p>注意，边不相交这是个很有用而且很强的条件！这样限定了 $i$ 位置取的 $in_i$ 个点只能是上方的底部和下方的顶端一些点。</p><p>特殊性质一是很有启发意义的一档。发现每个点引出的边方向确定了！为什么？若 $p_{i - 1} + 1 = p_i$ 则向右，若 $p_{i - 1} - 1 = p_i$ 则向左。然后可以愉快的dp，$f[i, j]$ 表示到第 $i$ 点处理完后，上方有 $j$ 条边（下方有 $p_i - j$ 条边）</p><p>推广一下发现，每个点的入度和出度都定了！为啥啊</p><ul><li>$in_i + out_i = d_i$</li><li>$p_{i - 1} - in_i + out_i = p_i$</li></ul><p>然后继续用刚才思路做，枚举上方几条入边和出边：$f[i, j] = \sum_x \sum_y f[i - 1, j - x + y]$</p><p>转移是 $n^2$ 的。。。优化：$g[i, j] = \sum\limits_{x = 0}^{in_i} f[i - 1, j + x]$    $f[i, j] = \sum\limits_{y = 0}^{out_i} g[i, j - y]$ 发现都是前缀和形式，前缀和优化。</p><p><a href="https://cometoj.com/status/fxs5bt46b7u243sfjl627cmk3nze4yxb" target="_blank" rel="noopener">$Code$</a></p><h2 id="C-终焉"><a href="#C-终焉" class="headerlink" title="$C. 终焉$"></a>$C. 终焉$</h2><hr><p>答案显然是断边数 + 1。</p><p>技巧/经典套路1：修改是改变一个点和它周围一圈点时，考虑它的<strong>树上结构</strong>，只要修改父亲节点处就好了！</p><p>集合幂级数？FWT、FMT？？好像都只能做部分分</p><p>$f[x, s]$ 表示节点 $x$ 儿子中状态为 $s$ 的数量，发现这样修改和查询一个是 $O(2^m)$，一个是 $O(1)$，这太不均匀了！</p><p>经典套路2：分两段，比如说修改 $x$ 值为 $s$，那么 $f[fa, t]++$，其中前半段 $t$ 和 $s$ 相同，后半段 $s$ 是 $t$ 的子集；<br>查询的话就先 $s = ~s$，$ans += f[fa, t]$，其中后半段 $t$ 和 $s$ 相同，前半段 $t$ 是 $s$ 的子集。但这样时间是 $O(n2^{m / 2})$ 了，空间还是 $O(n2^m)$</p><p>经典套路3：度数分块</p><p>考虑 $bound$，当度数 $&lt; bound$ 时暴力修改/询问，$&gt; bound$ 时用上面的数组做，发现这样空间复杂度是 $O(n / d * 2^{m / 2})$；发现 $d = 2^{m / 2}$ 时最优！</p><p>就做完啦。</p><p><a href="https://cometoj.com/status/n8s13h50ao6gc6fvte6gb5opzqpcanel" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】平面图</title>
      <link href="2020/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
      <url>2020/09/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%B9%B3%E9%9D%A2%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>什么是平面图？除了节点外边没有交点的图。对于一个区域，我们称其为<strong>面</strong>；包围这个区域的边称其为<strong>边界</strong>；边界的长度称为这个面的<strong>度</strong>。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. |E| &lt;= 3|V| - 6</span><br></pre></td></tr></table></figure><p>这告诉我们 <strong>平面图里 m 与 n 同阶</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. V - E + F = K + 1</span><br><span class="line"></span><br><span class="line">任何一个凸多面体（或连通平面图）满足上式，其中 F 为面数，K 为连通块数。</span><br></pre></td></tr></table></figure><p>欧拉定理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 平面图的判定：（以 [HNOI2010]-planar 为例）（其实是只会存在哈密顿回路的）哈密顿回路会连成一个环，每条边就是环上的一条弦，两条边 i 和 j 若 xi &lt; xj &lt; yi &lt; yj 则相交，只能一条放环里、一条放环外——这是个二分图嘛！二分图有无合法染色等价于有无解啦。</span><br></pre></td></tr></table></figure><p>接下来是平面图转对偶图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 对于一个 s-t 平面图（有源点和汇点的平面图），其对偶图中的一个环对应着原图中的一个割。</span><br><span class="line">将平面图最小割或最大流转化成对偶图最短路，效果绝佳。（但我没写过qvq）</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P3209" target="_blank" rel="noopener">HNOI2011-平面图判定</a></p><p>利用哈密顿路径上的编号先后 判断边是否交，转二分图判定就好啦，并查集和 $2-sat$ 都可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 平面图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 总结 &amp; 题解</title>
      <link href="2020/09/14/NOIP2020%20%E6%80%BB%E7%BB%93%20&amp;%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/14/NOIP2020%20%E6%80%BB%E7%BB%93%20&amp;%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="写在-NOIP2020-之后"><a href="#写在-NOIP2020-之后" class="headerlink" title="写在 NOIP2020 之后"></a>写在 NOIP2020 之后</h2><hr><p>T3 构造我直接傻眼，搞了俩小时一分没得（这构造本质是模拟）。最近大赛考非正常题越来越多了，对码力的要求也逐步上升，这俩我都不擅长。对而且我还不擅长思维题。我擅长啥呢？套路题（有手就行的 sb 题）。</p><p>想要多写 LOJ 的神题、套路题、非正常题，想学生成函数。在役的时间，有一天便看一天的风景，dp 套 dp、生成函数这些人类智慧不看会后悔的吧 qvq？ 向前跋涉吧！<strong>“永远不要用行为上的努力来掩盖思维上的懒惰。”</strong></p><h2 id="成绩出了"><a href="#成绩出了" class="headerlink" title="成绩出了"></a>成绩出了</h2><hr><p>丧气话删了。“世上一切不幸都是由于当事者能力不足”</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>先 乘 后 除 /吐血 痛失 30 分，<strong>痛失高一赛季！</strong></p><p>正解就维护指数</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>好吧。。这题就是复杂度优化题。后面东西用树状数组我做到了，前面那个用倍增我真想不到啊。。</p><p>肯定要枚举 AB，然后发现确定了 AB 的长度，C 的奇数个数只有 2 种值，就很简单了。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>据说我写的是 $70$ 分，就每次挑两个柱子，当前柱有 $x$ 个黑，$y$ 个白（显然颜色不重要，我们就看作黑白），然后把两个柱子准备一下，即一个留 $x$ 个空位，一个留 $y$ 个空位，但我调了很久，还写挂了，痛失 $70$ 分。赛后看题解知道自己只想到了几个关键细节中的一个。</p><p>我们钦定总有一个柱子是空的，即每次操作完，有 $n$ 个柱子都是满的，这样可以简化很多。（第二个细节）</p><p>先看 $n = 2$ 的情况。发现可以在不改变其他柱子状态的情况下整理一个柱子，即白的在下，黑的在上。（第三个细节）</p><p>然后可以将柱子整理成同色的，具体就是，通过空柱子，我们可以 $reverse$ 一个柱子；两个柱子选一种颜色的球，<strong>需要保证两个柱子上此颜色的球数之和 $\leq m$</strong>，给丢到空柱子上，用一个柱子上的球填满另一个柱子再将塞到空柱子上的球拿回放在这个柱子上。（第四个细节）</p><p>$n &gt; 2$ 的情况分治就好了，复杂度 $O(5nmlogn)$，极限数据只跑了 $500000$。</p><p>需要注意的是，可能存在一个柱子颜色全是黑或全是白，merge 的时候可能会 $&gt; m$，需要特判。</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>暴 力 写 挂 我是屑</p><p>又是构造又是多项式的，爽啦。</p><p>对于暴力和正解都很重要的一个思想：每维是独立的。</p><p>如果模拟两轮没走完，发现每轮合法位置的变化量是线性的，即对于第 $i$ 维，第一轮走了 $a_i$，第二轮走了 $b_i$，那么再走 $x$ 轮减少的就是 $b_i - (a_i - b_i) * x$</p><p>枚举 $i$，现在计算的是第 $x + 2$ 轮做完第 $i$ 步的答案，合法的位置数是每维的合法位置乘起来。</p><p>将 $x$ 看作自变量，枚举 $i$，第 $x$ 轮走了 $i$ 步的答案是 $f(x) = \prod_j (tot_{j, i} - (a_j - b_j) * x)$，$tot_{j, i}$ 表示第 $j$ 维走了 $i$ 步的合法位置数</p><p>$\prod$ 写作 $\sum$, $f(x) = \sum_i c_i x^i$，最终答案即为 $\sum_i c_i (\sum\limits_{i = 1}^{mx} x_i)$（$mx$ 是走的轮数上限。</p><p>后面这玩意是个自然数幂和，$k \leq 3$ 时有通项公式，$k &gt; 3$ 时可以预处理因为题目保证 $max_{w_i} \leq 1e6$.</p><p>$O(nk^2)$，乘法是 $k^2$, 听说因为 $F$ 变化量小，通过什么拉格朗日插值可以做到 $O(nk)$（蒟蒻不会内个</p><h1 id="「不要在脑海里激情澎湃一会儿就当努力过了。」"><a href="#「不要在脑海里激情澎湃一会儿就当努力过了。」" class="headerlink" title="「不要在脑海里激情澎湃一会儿就当努力过了。」"></a><em>「不要在脑海里激情澎湃一会儿就当努力过了。」</em></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>以 CF1327F 为代表的一类限制计数问题</title>
      <link href="2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这类有限制的计数问题，套路在状态设计上。一般是区间上的问题，切入点是发现 dp 的要点有当前位置和满足限制的位置以及满足了哪些限制；转移就是 对于同一种限制同一个右端点找到最大的左端点，这之间必须有一个满足要求的位置。</p><h2 id="CF1327F"><a href="#CF1327F" class="headerlink" title="$CF1327F$"></a>$CF1327F$</h2><hr><p>按位处理，可以算出每一位的答案然后乘起来。子问题的解决必须是 $O(n)$ 的！！</p><p>限制为 1 很好处理，全部强制为 1 就可以了；为 0 就比较难搞，要求至少有一个位置是 0。</p><p>先只考虑为 0 的限制。对于一个位置 $i$ 找到所有右端点 $\leq i$ 的限制的最大左端点，设其为 $l_i$。$f[i, j]$ 表示填完了前 $i$ 个位置，满足了右端点 $\leq i$ 的所有限制，最后一个 0 的位置在 $j$，其中 $l_i \leq j \leq i$ 的方案数</p><p>那么 $f[i, j] = f[i - 1, j]$ $(j &lt; i)$，$f[i, i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[i - 1, k]$</p><p>想优化空间。发现 $i \neq j$ 的 $f[i, j]$ 好像没什么用，干脆令 $f[i]$ 表示原来的 $f[i, i]$，$f[i] = \sum\limits_{k = l_{i - 1}}^{i - 1} f[k]$。发现求了一个后缀和，又发现 $l_i$ 单调递增，所以 dp 是 $O(n)$ 的。</p><p>那加上 1 的限制怎么办？把那些已经强制为 1 的点拎走，剩下的做 dp。</p><p><a href="https://codeforces.com/problemset/submission/1327/92203899" target="_blank" rel="noopener">$Code$</a></p><h2 id="清华集训2017-某个歌姬的故事"><a href="#清华集训2017-某个歌姬的故事" class="headerlink" title="$[清华集训2017]-某个歌姬的故事$"></a>$[清华集训2017]-某个歌姬的故事$</h2><hr><p>离散化（u1s1这题离散化是大毒瘤。）</p><p>预处理出每个位置的上限 $up_i$，这样就把 $up_i$ 相同的相邻位置缩成了一个点。</p><p>对于限制 $[l_j, r_j, m_j]$ 显然只有 $l_j \leq i \leq r_j$ 中 $up_i = m_j$ 的点能贡献。<br>于是对于每个 $m_j$ 将所有 $up_i = m_j$ 的点拿出来做 dp。</p><p>怎么d？显然是满足每个限制区间内有一个点达到上限即可。<br>令 $f[i, j]$ 表示满足所有 右端点在 $1$ ~ $i$ 的限制，选的最后一个点是 $j$ 的方案数。</p><p>不同的 $m_j$ 是独立的，分别 dp 后把答案乘起来。</p><p><a href="https://loj.ac/submission/927800" target="_blank" rel="noopener">$Code$</a></p><h2 id="NOI2020-D1T2-命运"><a href="#NOI2020-D1T2-命运" class="headerlink" title="$[NOI2020 D1T2]-命运$"></a>$[NOI2020 D1T2]-命运$</h2><hr><p>区 间 上 树（</p><p>这个比赛时连 dp 方程都想不到。。。就写了最暴力的指数级容斥。。<strong>但实际上跟前两题的 dp 设计思路是很相似的！</strong></p><p>$dp[i, j]$ 表示 $i$ 的子树内状态已经确定，没有满足的链顶点的最大深度为 $j$ 的方案数（记录最深是因为深的满足了，浅的也满足了），边界就是链都满足了，$j = 0$</p><script type="math/tex; mode=display">dp[x, i] = (\sum\limits_{j = 0}^{dep_x} dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^i dp[x, i] \times dp[y, j]) + (\sum\limits_{j = 0}^{i - 1} dp[x, j] \times dp[y, i])</script><p>前两部分分别是 $(x, y)$ 这条边为 1 和为 0 的方案数。</p><p>二维dp，前缀和形式。。噫，这个东西和 pkuwc2018-minimax 好像啊！没错，就是整体dp，上线段树合并。</p><p>跟 minimax 一样的，碰到叶子结点就返回，其他节点由儿子节点 upd 上来。</p><p><a href="https://loj.ac/submission/927792" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[COCI2010]-ZUMA</title>
      <link href="2020/09/08/%5BCOCI2010%5D-ZUMA/"/>
      <url>2020/09/08/%5BCOCI2010%5D-ZUMA/</url>
      
        <content type="html"><![CDATA[<p>第一次碰到不会做的区间 dp。。这题的难点在于设计 dp 状态。。</p><p>发现普通的思路 $f[i, j]$ 没有办法做</p><p>$f[i, j, k]$ 表示在区间 $[i, j]$ 前放了 $k$ 个与 $c[i]$ 同色的球，连带着新加的球全部消掉的最小球数。</p><p>$f[i, j, k] =$</p><ol><li>$f[i, j, k + 1] + 1$（在前面加一个球）</li><li>$f[i + 1, j, k + 1]$ $(c[i] = c[i + 1])$</li><li>$f[i + 1, p - 1, 0] + f[p, j, k + 1]$ $(c[i] = c[p])$</li></ol><p>边界：$f[i, i, j] = K - 1 - j$</p><p>$f[i, j, K - 1] =$</p><ol><li>$f[i + 1, j, 0]$</li><li>$f[i + 1, j, K - 1]$ $(c[i] = c[i + 1])$（因为要求 $\geq K$ 个连续的球）</li><li>$f[i + 1, p - 1, 0] + f[p, j, K - 1]$（理由同 2）</li></ol><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, KK = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, c[N], f[N][N][KK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = min(x, y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        rep(j, <span class="number">0</span>, K - <span class="number">1</span>) f[i][i][j] = K - <span class="number">1</span> - j;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(len, <span class="number">2</span>, n) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - len + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][j][K - <span class="number">1</span>]);</span><br><span class="line">            rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                    chkmin(f[i][j][K - <span class="number">1</span>], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][K - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = K - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                chkmin(f[i][j][k], f[i][j][k + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c[i] == c[i + <span class="number">1</span>])</span><br><span class="line">                    chkmin(f[i][j][k], f[i + <span class="number">1</span>][j][k + <span class="number">1</span>]);</span><br><span class="line">                rep(p, i + <span class="number">2</span>, j)</span><br><span class="line">                    <span class="keyword">if</span> (c[i] == c[p])</span><br><span class="line">                        chkmin(f[i][j][k], f[i + <span class="number">1</span>][p - <span class="number">1</span>][<span class="number">0</span>] + f[p][j][k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 664 Div1</title>
      <link href="2020/09/08/Codeforces%20Round%20664%20Div1/"/>
      <url>2020/09/08/Codeforces%20Round%20664%20Div1/</url>
      
        <content type="html"><![CDATA[<p>China-Round 好神仙 &gt; &lt;</p><p>xry 都参与出题啦，我们这届也开始征战四方了！加油，无限可能。</p><h2 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h2><hr><p>小贪心，先分成两个集合，枚举大的集合取几个。</p><p><a href="https://codeforces.com/contest/1394/submission/92126211" target="_blank" rel="noopener">$Code$</a></p><h2 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h2><hr><p>趣题！要求的是<strong>任何</strong>点都能走回到自己，$k$ 这么小显然指数级枚举啦，问题在于怎么快速判断</p><p>考虑 $n$ 条边这个条件，也就是说有 $n$ 个入度，而每个点都能走回到自己，每个点都有一个入度，这意味着 $n$ 条边的终点遍布 $n$ 个点</p><p>那么预处理一些东西，只要能实现集合并就好了。$bitset$ 过不去，怎么办？$hash$！$O(1)$ 合并</p><p>注意写双$hash$！学习一波新写法 :)</p><p><a href="https://codeforces.com/contest/1394/submission/92131053" target="_blank" rel="noopener">$Code$</a></p><h2 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h2><hr><p>好题！</p><p>最大值最小，考虑二分（判定性问题就可做很多啦！</p><p>发现两个串相似的条件是 B 和 N 的个数相等，操作其实是加或减 $B$、$N$、$BN$</p><p>那么问题转化为判定是否存在一个 $t$ 使得对于任何 $i$，$dis(s_i, t) \leq mid$</p><p>来细化一下：在平面上，设 $s_i$ 对应的点为 $(a, b)$, $t$ 对应的点为 $(c, d)$, $dis(s_i, t) =$</p><ol><li>$(a - c)(b - d) &gt; 0$: $max{|a - c|, |b - d|}$</li><li>$(a - c)(b - d) &lt; 0$: $|a - c| + |b - d|$</li></ol><p>显然满足异号限制的点必然满足同号限制，即可以看做同号限制对所有 $s_i$ 都适用</p><p>化开来 $|x - x_i| \leq mid$, $|y - y_i| \leq mid$，即 $x \in [x_i - mid, x_i + mid]$, $y \in [y_i - mid, y_i + mid]$</p><p>对于异号限制，想想怎么把它化作“对所有都适用且刚好限制到异号点”</p><p><strong>这里有个经典trick：$|x| + |y| = |x - y|$，对于同号没有影响，而对于异号是等价的</strong></p><p>所以 $|(x - y) - (x_i - y_i)| \leq mid$，即 $(x - y) \in [x_i - y_i - mid, x_i - y_i + mid]$</p><p>至此我们得到了 $x$, $y$, $x - y$ 的限制，枚举一维就能得到另一维的范围，判断有无交就可以了。</p><p><a href="https://codeforces.com/contest/1394/submission/92186512" target="_blank" rel="noopener">$Code$</a></p><h2 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h2><hr><p><a href="https://blog.aor.sd.cn/archives/1246/" target="_blank" rel="noopener">咕咕，记一下大佬博客</a></p><h2 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG4260]-博弈论与概率统计</title>
      <link href="2020/09/06/%5BLG4260%5D-%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>2020/09/06/%5BLG4260%5D-%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%8E%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>赢的场数都确定了，$p$ 一点用都没有，我们要算出得分之和以后除以 $C(n + m, n)$。所以这是道计数题？</p><p>不能小于 $0$，想到了啥，卡特兰数！考虑平面上向右向上走问题</p><p>假设 $n \geq m$, 从 $(0, 0)$ 走到 $(n, m)$ 贡献是 $n - m$，方案数是 $C(n + m, n) - C(n + m, n + 1)$，就是用总数 - 碰到了边界线的方案数</p><p>从 $(0, 0)$ 走到 $(n, m - 1)$ 贡献是 $n - m + 1$，方案数是 $C(n + m, n + 1) - C(n + m, n + 2)$</p><p>…</p><p>所以总贡献是 $\sum \limits_{i = 0}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = (n - m)C(n + m, n) + \sum\limits_{i = 0}^{m - 1}C(n + m, i)$</p><p>$n &lt; m$ 会怎么样，$\sum \limits_{i = m - n}^{m} (C(n + m, n + i) - C(n + m, n + i + 1))(n - m + i) = \sum\limits_{i = 0}^{n - 1}C(n + m, i)$</p><p>这样就结束啦（</p><p>哦不 多组询问。。</p><p>发现形如 $f(n, k) = \sum\limits_{i = 0}^k C(n, i)$ 的东西很难求</p><p>发现 $f(n, k) = \sum\limits_{i = 0}^k C(n - 1, i - 1) + C(n - 1, i) = 2f(n - 1, k) - C(n - 1, k)$</p><p>发现知道了 $f(n, k)$ 就可以在 $O(1)$ 时间内推出 $f(n \pm 1, k)$ 和 $f(n, k \pm 1)$！</p><p>莫队求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll T, p, unit = <span class="number">500</span>, tot;</span><br><span class="line">ll ans[N], fac[N], inv[N], divv[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> ll n, k, id; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = inv[i] * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.n / unit == b.n / unit ? a.k &lt; b.k : a.n / unit &lt; b.n / unit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; p;</span><br><span class="line">    pre(<span class="number">500000</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= m) &#123;</span><br><span class="line">            ans[i] = (n - m) * C(n + m, n) % mod;</span><br><span class="line">            q[i].k = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].k = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        q[i].n = n + m;</span><br><span class="line">        divv[i] = fac[n] * fac[m] % mod * inv[n + m] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + T + <span class="number">1</span>, cmp);</span><br><span class="line">    q[<span class="number">0</span>].n = <span class="number">-1e9</span>;</span><br><span class="line">    ll nn = <span class="number">0</span>, kk = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].k &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[i - <span class="number">1</span>].k &lt; <span class="number">0</span> || q[i - <span class="number">1</span>].n / unit &lt; q[i].n / unit) &#123;</span><br><span class="line">            nn = q[i].n, kk = q[i].k;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">0</span>, kk) (tot += C(nn, j)) %= mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (nn &lt; q[i].n) tot = (tot * <span class="number">2</span> % mod - C(nn, kk) + mod) % mod, ++nn;</span><br><span class="line">            <span class="keyword">while</span> (nn &gt; q[i].n) --nn, tot = (tot + C(nn, kk)) % mod * inv[<span class="number">2</span>] % mod;</span><br><span class="line">            <span class="keyword">while</span> (kk &lt; q[i].k) ++kk, (tot += C(nn, kk)) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        (ans[q[i].id] += tot + mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, T) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i] * divv[i] % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LnOI2019]-加特林轮盘赌</title>
      <link href="2020/09/05/%5BLnOI2019%5D-%E5%8A%A0%E7%89%B9%E6%9E%97%E8%BD%AE%E7%9B%98%E8%B5%8C/"/>
      <url>2020/09/05/%5BLnOI2019%5D-%E5%8A%A0%E7%89%B9%E6%9E%97%E8%BD%AE%E7%9B%98%E8%B5%8C/</url>
      
        <content type="html"><![CDATA[<p>有意思的题（我不会概率所以它超有意思（</p><p>比较妙的通过“环”的性质，化无限为递推。设 $f[n, k]$ 表示长度为 $n$ 的环中第 $k$ 个人唯一幸存的概率，那么有 $f[n, k] = p0 \times f[n - 1, k - 1] + (1 - p0) \times f[n, k - 1]$, 特别的 $f[n, 1] = (1 - p0) \times f[n, n]$</p><p>这玩意作为 dp 有后效性，想到消元。暴力消元炸没了，但我们发现假设前 $i - 1$ 行都算出来了，第 $i$ 行所有 $f[i, j]$ 只与 $f[i, 1]$ 有关，于是想到经典套路：表示成 $a \times f[i, 1] + b$ 的形式，$\sum\limits_{j = 1}^i f[i, j] = 1$，解出 $f[i, 1]$。</p><p>$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> p0, f[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, K, cur = <span class="number">1</span>, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p0 &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">if</span> (!p0) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(n == <span class="number">1</span> ? <span class="string">"1"</span> : <span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        lst = cur; cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span>, A = <span class="number">0</span>, b = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">2</span>, i) &#123;</span><br><span class="line">            a *= (<span class="number">1</span> - p0);</span><br><span class="line">            A += a;</span><br><span class="line">            b = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * b;</span><br><span class="line">            B += b;</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">1</span>] = (<span class="number">1</span> - B) / (A + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">2</span>, i)</span><br><span class="line">            f[cur][j] = p0 * f[lst][j - <span class="number">1</span>] + (<span class="number">1</span> - p0) * f[cur][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, f[cur][K]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法利用等比数列求和公式。设当前轮 $f[i]$ 表示 $i$ 唯一存活的概率，$g[i]$ 表示 $i$ 被打死的概率，$g[i] = (1 - p0)^{i - 1} p (\sum\limits_{j = 0}^{\infty} ((1 - p)^n)^i) = \frac{(1 - p)^{i - 1}}{1 - ((1 - p)^n)^i}$，然后每打死一个人就得到一个新的局面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2020 题解</title>
      <link href="2020/09/04/ZJOI2020%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/04/ZJOI2020%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="D1T1-字符串"><a href="#D1T1-字符串" class="headerlink" title="$D1T1. 字符串$"></a>$D1T1. 字符串$</h2><hr><h2 id="D1T2-传统艺能"><a href="#D1T2-传统艺能" class="headerlink" title="$D1T2. 传统艺能$"></a>$D1T2. 传统艺能$</h2><hr><h2 id="D1T3-序列"><a href="#D1T3-序列" class="headerlink" title="$D1T3. 序列$"></a>$D1T3. 序列$</h2><hr><h2 id="D2T1-染色游戏"><a href="#D2T1-染色游戏" class="headerlink" title="$D2T1. 染色游戏$"></a>$D2T1. 染色游戏$</h2><hr><h2 id="D2T2-抽卡"><a href="#D2T2-抽卡" class="headerlink" title="$D2T2. 抽卡$"></a>$D2T2. 抽卡$</h2><hr><h2 id="D2T3-密码"><a href="#D2T3-密码" class="headerlink" title="$D2T3. 密码$"></a>$D2T3. 密码$</h2><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 666 Div1</title>
      <link href="2020/09/03/Codeforces%20Round%20666%20Div1/"/>
      <url>2020/09/03/Codeforces%20Round%20666%20Div1/</url>
      
        <content type="html"><![CDATA[<p>最近场都好思维啊</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>巧妙构造，第一次取 n - 1 个，第二次取剩下 1 个，第三次取 n 个，前两次的目的就是把所有元素变成 n 的倍数</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>没有思路，将 a 排序，发现如果最大的比其他和都大那先手显然必胜。这个思路有点东西，继续挖掘发现两个人都尽量避免出现这种不均衡的局面，<strong>所有元素就会被取完</strong>，所以判断奇偶性就可以了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>1 &lt;= r1 &lt;= r2 &lt;= r3 !!! 这个条件有点隐蔽，但是能简化一些分类讨论</p><p>所以要么 1 或 2 将所有的血量减一再用 1 打掉boss，要么 1 打掉小怪再 3 打掉boss</p><p>反复横跳。具体来说是跳一段回一步跳一段回一步…这样</p><p>dp, $f[i, 0/1]$ 表示最远到第 $i$ 关，前 $i - 1$ 关都消灭了，是否消灭了boss，0 代表消灭</p><p>初始 $f[1, 0] = a[1] <em> r1 + r3$, $f[1, 1] = min(r1 </em> (a[1] + 1), r2)$</p><p>$f[i, 0] = min(f[i - 1, 0] + d + (r1 <em> a[i] + r3), f[i - 1, 1] + d + min(r1 </em> (a[i] + 1), r2) + d + r1 + d + r1)$</p><p>$f[i, 1] = min(f[i - 1, 0] + d + min(r1 <em> (a[i] + 1), r2), f[i - 1, 1] + d + min(r1 </em> (a[i] + 1), r2) + d + r1 + d)$</p><p>答案是 $min(f[n, 0], f[n - 1, 1] + d + a[n] * r1 + r3 + d + r1)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO20OPEN (Gold) 题解</title>
      <link href="2020/09/02/USACO20OPEN%20(Gold)%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/USACO20OPEN%20(Gold)%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="T1-Haircut"><a href="#T1-Haircut" class="headerlink" title="T1. Haircut"></a>T1. Haircut</h2><hr><p>设每个点初始贡献是 v[i], 那么发现 v[i] 一定是到了某个时刻（其实就是 h[i]）刷一下变成 0 了，树状数组维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], ans[N], C[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += lowbit(x)) C[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ++a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        num[i] = i - <span class="number">1</span> - query(a[i]);</span><br><span class="line">        tot += num[i];</span><br><span class="line">        add(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        add(<span class="number">1</span>, -num[i]), add(a[i] + <span class="number">1</span>, num[i]);</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(i) + tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2-Favorite-Colors"><a href="#T2-Favorite-Colors" class="headerlink" title="T2. Favorite Colors"></a>T2. Favorite Colors</h2><hr><p>比较暴力的思路，并查集 + 启发式合并，就是很暴力的将每个点的子节点都并起来，O(n log n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, fa[N], col[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x].size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    t[x] = g[x];</span><br><span class="line">    g[x].clear();</span><br><span class="line">    <span class="keyword">int</span> rt = t[x][<span class="number">0</span>];</span><br><span class="line">    rt = getfa(rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = t[x][i];</span><br><span class="line">        y = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (rt == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (g[rt].size() &gt;= g[y].size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[y].size(); j++) g[rt].push_back(g[y][j]);</span><br><span class="line">            g[y].clear();</span><br><span class="line">            fa[y] = rt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[rt].size(); j++) g[y].push_back(g[rt][j]);</span><br><span class="line">            g[rt].clear();</span><br><span class="line">            rt = fa[rt] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[x].push_back(rt);</span><br><span class="line">    dfs(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) dfs(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getfa(i);</span><br><span class="line">        <span class="keyword">if</span> (!col[x]) col[x] = ++idx;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, col[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3-Exercise"><a href="#T3-Exercise" class="headerlink" title="T3. Exercise"></a>T3. Exercise</h2><hr><p>k = lcm(环长)，而 n = sum(环长)</p><p>考虑 lcm 这个东西本质是把质因数每一位取最高次幂乘起来</p><p><a href="https://www.cnblogs.com/123789456ye/p/12739149.html" target="_blank" rel="noopener">这个老清楚了</a></p><p>本题中运用的“最优构造”思想是很常用的，在不会影响答案的情况下贪心的取。</p><p>另外显然并不会重复计算某个 k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, f[N], vis[N], p[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= p[i]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = p[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;= j) &#123;</span><br><span class="line">                f[j] = (f[j] + <span class="number">1l</span>l * f[j - tmp] * tmp % m) % m;</span><br><span class="line">                tmp *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, n) ans = (ans + f[i]) % m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIonline 1~3场题解</title>
      <link href="2020/09/02/NOIonline%201~3%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/NOIonline%201~3%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>来订题（咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019 题解</title>
      <link href="2020/09/02/CSP2019%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/09/02/CSP2019%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>快要 csp2020 了，来补 2019 的题（咕</p><h2 id="D1T1"><a href="#D1T1" class="headerlink" title="D1T1"></a>D1T1</h2><hr><p>手玩就出来了？</p><h2 id="D1T2"><a href="#D1T2" class="headerlink" title="D1T2"></a>D1T2</h2><hr><p>容易想到统计每个节点为右端点的子串数，然后继承给子节点就好了。然后记录每个节点祖先中离它最近的未匹配的 ‘(‘ 是哪个，再记录一下每个节点为右端点的合法的 ‘(…)’ 数，就好了！</p><p>条条大路通罗马，有时候错误的思路也会导出正确的思路。要有信仰！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, res;</span><br><span class="line">ll fa[N], ans[N], lst[N], cur[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">2</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;fa[i]);</span><br><span class="line">    rep(x, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ans[x] = ans[fa[x]];</span><br><span class="line">        lst[x] = lst[fa[x]];</span><br><span class="line">        <span class="keyword">if</span> (s[x] == <span class="string">'('</span>) lst[x] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">')'</span> &amp;&amp; lst[x]) &#123;</span><br><span class="line">            cur[x] = cur[fa[lst[x]]] + <span class="number">1</span>;</span><br><span class="line">            lst[x] = lst[fa[lst[x]]];</span><br><span class="line">            ans[x] += cur[x];</span><br><span class="line">        &#125;</span><br><span class="line">        res ^= (<span class="number">1l</span>l * x * ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D1T3"><a href="#D1T3" class="headerlink" title="D1T3"></a>D1T3</h2><hr><p>部分分推出正解。</p><p>菊花：将数字按照 $(rt, p_1, p_2, … p_{n - 1})$ 排出来，发现相当于每个位置上的数往后移了一位。贪心的构造轮换。</p><p>链：对于在 $u$ 位置的要移到 $v$ 位置（假设 $u &lt; v$），显然 $[u, v]$ 之间的删边顺序是从左到右，$u$ 右边比 $u$ 左边删的早。打标记，$i$ 点 $tag_i = 0, 1, 2$ 表示无标记，先左后右，先右后左</p><p>这是<strong>很有启发性</strong>的两档分！接下来考虑满分做法，显然就是 $u$ 指向 $v$ 的出边是第一个删的，$v$ 指向 $u$ 的出边是第一个删的，$[u, v]$ 之间的点都还没被删。<br>抽象一点就是把图分成很多不相交的链了。</p><p>复杂度 $O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, w[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> deg, beg, end, fa[N];  <span class="comment">// end 和 beg 分别记录该点第一条删除的入边和出边，fa 将成对删除的邻边绑在一起</span></span><br><span class="line">    <span class="keyword">bool</span> st[N], ed[N];  <span class="comment">// ed 和 st 是记录某条边有无作为该边的 入/出 边，至于为什么要分开记录还不是很懂。。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        beg = end = <span class="number">-1</span>, deg = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, n) st[i] = ed[i] = <span class="number">1</span>, fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (~id &amp;&amp; (a[x].end == <span class="number">-1</span> || a[x].end == id)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[x].ed[id] &amp;&amp; (a[x].beg == <span class="number">-1</span> || a[x].deg &lt;= <span class="number">1</span> || a[x].getfa(id) != a[x].getfa(a[x].beg)))</span><br><span class="line">            ret = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == (i &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = (i &gt;&gt; <span class="number">1</span>), y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (~id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == a[x].end || ed == a[x].beg || a[x].getfa(id) == a[x].getfa(ed))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!a[x].ed[id] || !a[x].st[ed]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (~a[x].beg &amp;&amp; ~a[x].end &amp;&amp; a[x].deg &gt; <span class="number">2</span> &amp;&amp; a[x].getfa(id) == a[x].getfa(a[x].beg) &amp;&amp; a[x].getfa(ed) == a[x].getfa(a[x].end))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ret = min(ret, getpos(y, ed));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x].beg == <span class="number">-1</span> || a[x].beg == ed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a[x].st[ed]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (~a[x].end &amp;&amp; a[x].deg &gt; <span class="number">1</span> &amp;&amp; a[x].getfa(ed) == a[x].getfa(a[x].end)) <span class="keyword">continue</span>;</span><br><span class="line">                ret = min(ret, getpos(y, ed));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == p) <span class="keyword">return</span> a[x].end = id, <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == (i &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = (i &gt;&gt; <span class="number">1</span>), y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (Link(y, ed, p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (~id) &#123;</span><br><span class="line">                a[x].ed[id] = a[x].st[ed] = <span class="number">0</span>, --a[x].deg;</span><br><span class="line">                a[x].fa[a[x].getfa(id)] = a[x].getfa(ed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[x].beg = ed;</span><br><span class="line">            &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(lnk, <span class="number">-1</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">            a[i].init();</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            add(x, y), add(y, x);</span><br><span class="line">            ++a[x].deg, ++a[y].deg;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = getpos(w[i], <span class="number">-1</span>);</span><br><span class="line">            Link(w[i], <span class="number">-1</span>, pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, pos);</span><br><span class="line">        &#125; <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T1"><a href="#D2T1" class="headerlink" title="D2T1"></a>D2T1</h2><hr><p>（啊。。这个题目真的恶心。。差点没懂）</p><p>考虑每种食材都不超过 $\lfloor \frac{k}{2} \rfloor$ 这个限制很烦，考虑容斥，统计每种食材打破限制的总方案数然后减掉就好了。</p><p>对于第 $col$ 种食材打破限制，设 $f[i, j]$ 表示前 $i$ 个烹饪方法中选的第 $col$ 种食材的菜与不是第 $col$ 种食材的菜的个数差为 $j$ 的方案数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">102</span>, M = <span class="number">2002</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, tot = <span class="number">1</span>, ans;</span><br><span class="line">ll a[N][M], f[N][N &lt;&lt; <span class="number">1</span>], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i][j]), s[i] = (s[i] + a[i][j]) % mod;</span><br><span class="line">        tot = tot * (s[i] + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(col, <span class="number">1</span>, m) &#123;</span><br><span class="line">        f[<span class="number">0</span>][N] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            rep(j, N - i, N + i)</span><br><span class="line">                f[i][j] = (f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>] * a[i][col] % mod + f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (s[i] - a[i][col] + mod) % mod) % mod;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) ans = (ans + f[n][N + i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (tot - <span class="number">1</span> - ans + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T2"><a href="#D2T2" class="headerlink" title="D2T2"></a>D2T2</h2><hr><p>考场上写了 $n^3$ 暴力后突然聪明了一下，输出了一些东西，发现这玩意是单调的然后就多了 32 分 qvq 论信仰的力量。。</p><p>88 分就是再加个单调队列！100 分再加个高精度。。。</p><p>具体来说，$j$ 能转移到 i 当且仅当 $pre[i] - pre[j] &gt;= len[j]$，$len[j]$ 表示以 $j$ 为结束的段，$pre[i] &gt;= pre[j] + len[j]$。发现 $j$ 越大越好（这就是我考场上发现的单调性），单调队列一波就可以了。</p><p><a href="http://matthew99.blog.uoj.ac/blog/5299" target="_blank" rel="noopener">单调性的证明</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 88 分代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e7</span> + <span class="number">5</span>;</span><br><span class="line">ll n, tp, len[N], f[N], q[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; tp;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;pre[i]);</span><br><span class="line">        pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    q[++r] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; pre[q[l + <span class="number">1</span>]] + len[q[l + <span class="number">1</span>]] &lt;= pre[i]) ++l;</span><br><span class="line">        len[i] = pre[i] - pre[q[l]];</span><br><span class="line">        f[i] = f[q[l]] + (pre[i] - pre[q[l]]) * (pre[i] - pre[q[l]]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; pre[q[r]] + len[q[r]] &gt;= pre[i] + len[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2T3"><a href="#D2T3" class="headerlink" title="D2T3"></a>D2T3</h2><hr><p>学习了 xht37 的思路（是我比较适应的方法）：算出每一个节点为重心的次数。</p><p>选一个重心为根，对于我们考虑的 $x (x\neq rt)$，<strong>割的边一定不在 x 的子树里</strong>。设 $mx[x] = \max\{size[y]\}$, $S$ = 割掉边后不包含 $x$ 的那块的 $size$，那么有：$2(n - S - size[x]) \leq n - S$, $2mx[x] \leq n - S$，也就是要求 $n - 2size[x] \leq S \leq n - 2mx[x]$ 且边不在 $x$ 子树中的边数</p><p>那个不等式用树状数组维护一下，就成了区间求和；第二个约束可以在进出某个子树的时候作差。</p><p>$x = rt$ 时怎么办？设 $size$ 最大的子树是 $u$ 的，次大的是 $v$ 的。割边在 $u$ 子树中时 $2size[u] \leq n - S$, 在 $v$ 子树中时 $2size[v] \leq n - S$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> T, n, rt, u, v;</span><br><span class="line"><span class="keyword">int</span> sz[N], mx[N], C1[N], C2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> C[], <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++x;  <span class="comment">// 使得 x 不为 0 的技巧</span></span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += lowbit(x)) C[x] += v;  <span class="comment">// !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> C[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++x;  <span class="comment">// 查询也一定要啊！！！</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>, mx[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; (n &gt;&gt; <span class="number">1</span>)) ff = <span class="number">0</span>;</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        mx[x] = max(mx[x], sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n - sz[x]) &gt; (n &gt;&gt; <span class="number">1</span>)) ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ff &amp;&amp; !rt) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    add(C1, sz[fa], <span class="number">-1</span>);</span><br><span class="line">    add(C1, n - sz[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x ^ rt) &#123;</span><br><span class="line">        ans += <span class="number">1l</span>l * x * (ask(C1, n - <span class="number">2</span> * mx[x]) - ask(C1, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">        ans += <span class="number">1l</span>l * x * (ask(C2, n - <span class="number">2</span> * mx[x]) - ask(C2, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (mark[fa]) mark[x] = <span class="number">1</span>;</span><br><span class="line">        ans += rt * (sz[x] &lt;= n - <span class="number">2</span> * sz[mark[x] ? v : u]);  <span class="comment">// rt 的贡献直接维护</span></span><br><span class="line">    &#125;</span><br><span class="line">    add(C2, sz[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    add(C1, sz[fa], <span class="number">1</span>);</span><br><span class="line">    add(C1, n - sz[x], <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x ^ rt) &#123;</span><br><span class="line">        ans -= <span class="number">1l</span>l * x * (ask(C2, n - <span class="number">2</span> * mx[x]) - ask(C2, n - <span class="number">2</span> * sz[x] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) g[i].clear();</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            g[x].push_back(y), g[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = rt = <span class="number">0</span>;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dfs1(rt, <span class="number">0</span>);</span><br><span class="line">        u = v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[rt].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = g[rt][i];</span><br><span class="line">            <span class="keyword">if</span> (sz[x] &gt; sz[u]) v = u, u = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sz[x] &gt; sz[v]) v = x;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n + <span class="number">1</span>) C1[i] = C2[i] = <span class="number">0</span>, mark[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) add(C1, sz[i], <span class="number">1</span>);</span><br><span class="line">        mark[u] = <span class="number">1</span>;</span><br><span class="line">        dfs2(rt, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[PKUWC2018]-Minimax</title>
      <link href="2020/08/30/%5BPKUWC2018%5D-Minimax/"/>
      <url>2020/08/30/%5BPKUWC2018%5D-Minimax/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5298" target="_blank" rel="noopener">传送门</a></p><p>以前好像碰到过类似 dp 套路？离散化，$f[i, j]$ 表示第 $j$ 小的数留到了 $i$ 节点的概率。转移：</p><script type="math/tex; mode=display">f[i, j] = f[ls, j] * (p[i] * \sum\limits_{k = 1}^{j - 1} f[rs, k] + (1 - p[i]) * \sum\limits_{k = j + 1}^m f[rs, k]) + f[rs, j] * (p[i] * \sum\limits_{k = 1}^{j - 1} f[ls, k] + (1 - p[i]) * \sum\limits_{k = j + 1}^m f[ls, k])</script><p>发现每个叶子结点的权值都不同，且都只会贡献一次，<strong>想到线段树合并</strong>（注意要合并的东西必须是 $O(n)$ 及以下级别的，不然上不了线段树合并）。然后发现线段树可以很好地维护区间和、区间乘标记等东西！</p><p>（哇线段树合并复杂度是啥呀我又不会了）</p><p>好吧来看看，合并两颗线段树的复杂度约等于它们 <strong>重合</strong> 的点数，设树有 $n$ 个节点，线段长度是 $m$，总复杂度就是 $O(nlogm)$（感性理解就是每加进来一个点最多增加 $logm$ 的复杂度）</p><p>这类题，即用动态开点线段树优化的二维dp，有个新名词叫做“整体dp”！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, M = N * <span class="number">60</span>, inv = <span class="number">796898467</span>, P = mod;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>], h[N], val[N], ans, ls[M], rs[M], tag[M], f[M], rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x] != <span class="number">1</span>) &#123;</span><br><span class="line">        tag[ls[x]] = <span class="number">1l</span>l * tag[ls[x]] * tag[x] % mod;</span><br><span class="line">        tag[rs[x]] = <span class="number">1l</span>l * tag[rs[x]] * tag[x] % mod;</span><br><span class="line">        f[ls[x]] = <span class="number">1l</span>l * f[ls[x]] * tag[x] % mod;</span><br><span class="line">        f[rs[x]] = <span class="number">1l</span>l * f[rs[x]] * tag[x] % mod;</span><br><span class="line">        tag[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    f[x] = (f[ls[x]] + f[rs[x]]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx, tag[idx] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[x] = <span class="number">1</span>; <span class="keyword">return</span>;  <span class="comment">// 概率是 100%</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) insert(ls[x], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> insert(rs[x], mid + <span class="number">1</span>, r, pos);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> la, <span class="keyword">int</span> ra, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (y) psd(y);</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; !y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">1l</span>l * p * lb % mod + <span class="number">1l</span>l * (<span class="number">1</span> - p + mod) % mod * rb % mod) % mod;</span><br><span class="line">        f[x] = <span class="number">1l</span>l * f[x] * t % mod;</span><br><span class="line">        tag[x] = <span class="number">1l</span>l * tag[x] * t % mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">1l</span>l * p * la % mod + <span class="number">1l</span>l * (<span class="number">1</span> - p + mod) % mod * ra % mod) % mod;</span><br><span class="line">        f[y] = <span class="number">1l</span>l * f[y] * t % mod;</span><br><span class="line">        tag[y] = <span class="number">1l</span>l * tag[y] * t % mod;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = f[ls[x]], b = f[ls[y]];</span><br><span class="line">    <span class="keyword">int</span> cur = ++idx; tag[cur] = <span class="number">1</span>;</span><br><span class="line">    ls[cur] = merge(ls[x], ls[y], la, (ra + f[rs[x]]) % mod, lb, (rb + f[rs[y]]) % mod, p);</span><br><span class="line">    rs[cur] = merge(rs[x], rs[y], (la + a) % mod, ra, (lb + b) % mod, rb, p);</span><br><span class="line">    upd(cur);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!son[x][<span class="number">0</span>] &amp;&amp; !son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        insert(rt[x], <span class="number">1</span>, m, val[x]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        dfs(son[x][<span class="number">0</span>]);</span><br><span class="line">        rt[x] = rt[son[x][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(son[x][<span class="number">0</span>]), dfs(son[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1l</span>l * val[x] * inv % mod;</span><br><span class="line">    rt[x] = merge(rt[son[x][<span class="number">0</span>]], rt[son[x][<span class="number">1</span>]], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1l</span>l * l * h[l] % mod * f[x] % mod * f[x] % mod) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    calc_ans(ls[x], l, mid), calc_ans(rs[x], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (!son[x][<span class="number">0</span>]) son[x][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> son[x][<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>]) h[++m] = val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h + <span class="number">1</span>, h + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>])</span><br><span class="line">            val[i] = lower_bound(h + <span class="number">1</span>, h + m + <span class="number">1</span>, val[i]) - h;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    calc_ans(rt[<span class="number">1</span>], <span class="number">1</span>, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
            <tag> 概率与期望 </tag>
            
            <tag> 整体dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2012]-迷失游乐园</title>
      <link href="2020/08/29/%5BNOI2012%5D-%E8%BF%B7%E5%A4%B1%E6%B8%B8%E4%B9%90%E5%9B%AD/"/>
      <url>2020/08/29/%5BNOI2012%5D-%E8%BF%B7%E5%A4%B1%E6%B8%B8%E4%B9%90%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2081" target="_blank" rel="noopener">传送门</a></p><p>看起来巨复杂的一道期望嗷，但是基环树还是比较套路的</p><p>先考虑纯树的情况：设 $f[x]$ 为 $x$ 往下走的期望，$g[x]$ 为往上走的期望</p><p>$f[x] = \frac{1}{son[x]} \sum (f[y] + w(x, y))$，$g[y] = w(x, y) + \frac{g[x] + f[x] \times son[x] - (f[y] + w(x, y))}{son[x] - [x == root]}$ 注意分母可能为 0，要特判。<br>$ans[x] = \frac{f[x] \times son[x] + g[x]}{son[x] + [x \neq root]}$</p><p>好啦 50 分到手，再来想想基环树，发现环上节点好少啊，<strong>不管怎样先用同样的思路撕烤撕烤</strong></p><p>发现 $f$ 和不在环上的点的 $g$ 和 $ans$ 是一样计算的，环上点的 $g$ 搞出来以后可以把不在环上点的 $g$ 也算出来</p><p>对于环上点，对于两个方向都做一遍，以向左为例，$l[x] = \frac{l[nxt] + f[nxt]}{2}$, $g[x] = \frac{l[x] + r[x]}{2}$, $ans[x] = \frac{f[x] \times son[x] + g[x] \times 2}{son[x] + 2}$</p><p>就做完了</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, top, idx;</span><br><span class="line"><span class="keyword">int</span> stk[N], dfn[N], son[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt, w[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> f[N], g[N], ans;</span><br><span class="line"><span class="keyword">bool</span> onc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, w[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        ++son[x];</span><br><span class="line">        getf(y, x);</span><br><span class="line">        f[x] += f[y] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) f[x] /= son[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (son[x] == <span class="number">1</span>) &#123;</span><br><span class="line">                    g[y] = w[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g[y] = w[i] + (f[x] * son[x] - (f[y] + w[i])) / (son[x] - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] + f[x] * son[x] - (f[y] + w[i])) / son[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (onc[x]) &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] * <span class="number">2</span> + f[x] * son[x] - (f[y] + w[i])) / (son[x] + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g[y] = w[i] + (g[x] + f[x] * son[x] - (f[y] + w[i])) / son[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getg(y, x, op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getf(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    getg(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ans = f[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">2</span>, n)</span><br><span class="line">        ans += (f[i] * son[i] + g[i]) / (son[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findcir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findcir(y, x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[y] &lt; dfn[x]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; stk[top] != y) onc[stk[top--]] = <span class="number">1</span>;</span><br><span class="line">            onc[y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --top;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || !onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (y == st) <span class="keyword">return</span> f[x];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (calc(y, x, st) + w[i] + f[x] * son[x]) / (son[x] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!onc[y]) <span class="keyword">continue</span>;</span><br><span class="line">        g[x] += calc(y, x, x) + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    g[x] /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    findcir(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) getf(i, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) calcg(i);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (onc[i]) getg(i, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (!onc[i]) ans += (f[i] * son[i] + g[i]) / (son[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans += (f[i] * son[i] + g[i] * <span class="number">2</span>) / (son[i] + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) solve1();</span><br><span class="line">    <span class="keyword">else</span> solve2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】简单计数题选做（1）</title>
      <link href="2020/08/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E9%A2%98%E9%80%89%E5%81%9A%EF%BC%881%EF%BC%89/"/>
      <url>2020/08/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E9%A2%98%E9%80%89%E5%81%9A%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>容斥、$dp$ 什么的都是基础，我这块不扎实= = 不能就这么心甘情愿被区分了啊，总是要挣扎的对吧。</p><h2 id="LG6075"><a href="#LG6075" class="headerlink" title="LG6075"></a><a href="https://www.luogu.com.cn/problem/P6075" target="_blank" rel="noopener">LG6075</a></h2><hr><p>来做绿题了（。发现每个元素是独立的，那算一个的贡献然后 $n$ 次方就好了。发现一个元素取与不取的情况是左下角引一条向右或向上的折线，一直走直到到达边界，这样折线的方案数是 $2^k$，所以总方案就是 $(2^k)^n$。</p><h2 id="USACO20JAN-Cave-Paintings-P"><a href="#USACO20JAN-Cave-Paintings-P" class="headerlink" title="[USACO20JAN]-Cave Paintings P"></a><a href="https://www.luogu.com.cn/problem/P6008" target="_blank" rel="noopener">[USACO20JAN]-Cave Paintings P</a></h2><hr><p>发现填了一个就要填一块，想到并查集。我们从下往上合并，注意不连通块合并的时候，方案数是相乘的。</p><h2 id="HNOI2015-落忆枫音"><a href="#HNOI2015-落忆枫音" class="headerlink" title="[HNOI2015]-落忆枫音"></a><a href="https://www.luogu.com.cn/problem/P3244" target="_blank" rel="noopener">[HNOI2015]-落忆枫音</a></h2><hr><p>$DAG$ 的树形图个数是 $\prod in[i]$（感性理解就是每个点找一个$fa$，由于不会形成环，怎么找都是合理的，据说可以用矩阵树定理证但蒟蒻不会）用严谨的语言表达，这个定理是<strong>有向无环图的生成外向树个数为所有入度非 0 的点的入度乘积</strong></p><p>再考虑有环的情况，显然要减去一些有环存在的状态（这环一定包含新加进来的那条边啦） 即 $\frac{\prod in[i]}{\prod\limits_{i on circle} in[i]}$。$dp$, $g[x]$ 表示从 $ed$ 到 $x$ 的上面这个东西之和，所以 $g[x] = \frac{1}{in[x]}\sum\limits_y g[y]$。计算 $g$ 数组可以建反图 + 记忆化搜索（注意这里正反的智慧）所以答案就是 $(\prod in[i]) - g[st]$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6289]-花朵</title>
      <link href="2020/08/19/%5BLOJ6289%5D-%E8%8A%B1%E6%9C%B5/"/>
      <url>2020/08/19/%5BLOJ6289%5D-%E8%8A%B1%E6%9C%B5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6289" target="_blank" rel="noopener">传送门</a></p><p>看它 $id$ 跟我 $loj$ $id$ 相同就做了做 =&gt; 调了 $3h+$ 惨败</p><hr><p>$upd$：重构 $AC$ 啦= =</p><p>根据 $dp$ 方程交换二三两维可以得到：</p><script type="math/tex; mode=display">f[x, 0] = \prod (f[y, 0] + f[y, 1])</script><script type="math/tex; mode=display">f[x, 1] = \prod f[y, 0]</script><p>就 nm 像矩阵乘法！但是上树了。说个笑话，暴力卷是 $n^2logn$ 的（</p><p>部分分的链和菊花启示我们要优雅的卷，比如剖成链，每条链先单独卷</p><p>长链还是重链呢？当然是重链啦，一次卷积的时间复杂度取决于卷的数组大小，长链那深度差可大了。</p><p>细一点说，把轻链信息用分治卷 并到轻链顶点的父亲上，一次 $O(size(x)log^2size(x))$，由于 轻儿子点数和$=\sum size(x) = O(nlogn)$，所以总共就是 $O(nlog^3n)$；再用分治卷 卷重链，总共 $O(nlog^2n)$（这里要注意，之前卷轻链的时候只要顾及轻链顶点和父亲的 $0$/$1$ 是否合法，卷重链的时候还要顾及两部分接口处的 $0$/$1$ 是否合法，所以要维护当前段的首尾是否为 $1$）</p><p>就做完啦，厚厚！三只 $log$ 三只 $log$ 跑得快跑得快 ~</p><p><a href="https://loj.ac/s/1020721" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2020网络同步赛体验记</title>
      <link href="2020/08/18/NOI2020%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C%E8%AE%B0/"/>
      <url>2020/08/18/NOI2020%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="$Day1$"></a>$Day1$</h2><hr><p>勤勤恳恳的扣了 114 分，取模错误 wa + 字母打错，fst 成 82 分。。。好难受啊</p><p>整整 32 分啊。这如果是联赛，谁担的起呢。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="$Day2$"></a>$Day2$</h2><hr><p>勤勤恳恳的抠了 ？分（对我自己都不确定正确性），民间数据还没出（出了也不测 qvq）</p><h2 id="出成绩了"><a href="#出成绩了" class="headerlink" title="出成绩了"></a>出成绩了</h2><hr><p>108</p><hr><p>【此处应有题解】</p><hr><p>来补了。</p><h2 id="D1T1-美食家"><a href="#D1T1-美食家" class="headerlink" title="$D1T1. 美食家$"></a>$D1T1. 美食家$</h2><p>我想到矩阵快速幂了！写出 $5n$ 个点的转移柿子了！甚至想到预处理 $2^i$ 的矩阵、行向量去乘是 $n^2$ 的了！</p><p>但我没写出来。。。好吧，不会就是不会，复杂度是 $O((5n)^3 log T + (5n)^2 log T \times K)$。你别看他有 4e8，人家是 O(能过) 耶= =</p><p>upd：考场代码分段乘的时候额外贡献加错位置了= = 我哭</p><p><a href="https://loj.ac/submission/927790" target="_blank" rel="noopener">$Code$</a></p><h2 id="D1T2-命运"><a href="#D1T2-命运" class="headerlink" title="$D1T2. 命运$"></a>$D1T2. 命运$</h2><p><a href="https://imilyx.github.io/2020/09/08/%E4%BB%A5%20CF1327F%20%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E9%99%90%E5%88%B6%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">链接</a></p><h2 id="D1T3-时代的眼泪"><a href="#D1T3-时代的眼泪" class="headerlink" title="$D1T3. 时代的眼泪$"></a>$D1T3. 时代的眼泪$</h2><p>咕咕</p><h2 id="D2T1-制作菜品"><a href="#D2T1-制作菜品" class="headerlink" title="$D2T1. 制作菜品$"></a>$D2T1. 制作菜品$</h2><p>先将 $d$ 排序。</p><p>发现大数据范围里有 $n - 2 \leq m$，部分分 $m = n - 1$ 似乎很有未来。</p><p>考虑部分分 $m = n - 1$，$d_1$ 一定是 $&lt; k$ 的，为什么呢？如果 $d_1 \geq k$, 那么 $\sum d_i \geq n times k &gt; (n - 1) times k = m \times k = \sum d_i$，矛盾。每次削掉第一项，$n$ 转化成 $n - 1$，一定能够构造出来。同时 $d_1 + d_n \neq k$，用反证法也可以证明。</p><p>考虑 $m \geq n$ 时，$d_n \geq k$，证明方法同上面类似。于是将 $d_n -= k$，<strong>就转化成了 $m = n - 1$ 的问题</strong></p><p>最后一步！$m = n - 2$ 怎么搞。。可以证明，$m = n - 2$ 有解的充要条件是可以划分为两个 $m = n - 1$ 的子问题。充分性很好证，必要性就比较妙：考虑一个 n 个点的图，菜品视为边，那么最多只有 n - 2 条边，不会连通，此时必然存在至少两个连通块是树的形态——为什么？如果是环，边就不够用了。</p><p>实现的话，设 $S$ 是分出来的集合之一，$sz = |S|$, 那么 $\sum\limits_{i \in S} d_i = (sz - 1) \times k$，$\sum\limits_{i \in S} (d_i - k) = -k$，这是个 dp，$f[i, j]$ 表示前 i 个任意取能否使得总和为 j，bitset 维护, $O(\frac{n \times (n \times k)}{w})$</p><p><a href="https://loj.ac/submission/927794" target="_blank" rel="noopener">$Code$</a></p><h2 id="D2T2-超现实树"><a href="#D2T2-超现实树" class="headerlink" title="$D2T2. 超现实树$"></a>$D2T2. 超现实树$</h2><p>这题好 AT 的样子，结果是道结论题（脑子不好 死也想不出啊。。</p><p><a href="https://www.luogu.com.cn/blog/startd/solution-p6776" target="_blank" rel="noopener">大佬思路</a></p><p>“几乎完备”这种关系可以传递。太妙了吧！！！！！！！！！</p><p><a href="https://loj.ac/submission/927797" target="_blank" rel="noopener">$Code$</a></p><h2 id="D2T3-翻修道路"><a href="#D2T3-翻修道路" class="headerlink" title="$D2T3. 翻修道路$"></a>$D2T3. 翻修道路$</h2><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 659 Div1</title>
      <link href="2020/08/15/Codeforces%20Round%20659%20Div1/"/>
      <url>2020/08/15/Codeforces%20Round%20659%20Div1/</url>
      
        <content type="html"><![CDATA[<p>最近的场子，做一下。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>贪心就好了？也可以并查集维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, num[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (a[i] &gt; b[i]) &#123; ff = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ff) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">                num[a[i] - <span class="string">'a'</span>][b[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, <span class="number">25</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i][j]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    num[i][j] = <span class="number">0</span>;</span><br><span class="line">                    rep(k, j + <span class="number">1</span>, <span class="number">25</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (num[i][k]) &#123;</span><br><span class="line">                            num[j][k] += num[i][k], num[i][k] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>发现如果有一位 1 的个数是奇数就必然不会平局，然后分类讨论就好了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>C 和 A 的区别在于 C 有环。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO2020 体验记</title>
      <link href="2020/08/15/APIO2020%20%E4%BD%93%E9%AA%8C%E8%AE%B0/"/>
      <url>2020/08/15/APIO2020%20%E4%BD%93%E9%AA%8C%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>平心而论，这一场的暴力并不比 APIO2019 少很多，所以如果策略不失误的话几十分是肯定有的。但是一直在刚 T1，期间短暂的思考过 T2，T1 不知道是什么恶心数据把我卡了= = 于是就爆 0 了 没有体会到拿分的快感</p><p>所以<strong>策略</strong>是多么重要啊，<strong>开题顺序</strong>不会永远是 1-&gt;2-&gt;3 的啊。</p><p>下面就放一些订正的题解吧。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>预处理 + 单调队列，最优性问题 -&gt; 判定性问题</p><p>由于保证了 $\sum f(k)^2 \leq 4e5$，所以 $max(f(k))$ 最大就 600 多，虽然很粗糙但这是我们得到的最为有效的信息</p><p>只讲预处理。$dp[i, j]$ 表示到位置 $i$、承包商 $j$ 的最大粉刷长度，$dp[i, j] \geq m$ 那 $[i - m + 1, i]$ 就能被粉刷。</p><p>$dp[i, j] = dp[i - 1, (j - 1 + m) \% m] + 1(j \in c_i)$，这样时空都是 $O(nm)$ 的，空间可以滚动数组优化，时间可以用 $vector$ 存每个位置合法的 $j$，这样大概是 $O(n * max(f(k)))$，稳得很</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"paint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, C[N], A[M], B[N], f[<span class="number">2</span>][M], dp[N], q[N], l, r;</span><br><span class="line"><span class="keyword">bool</span> valid[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, a, id[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumInstructions</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> K, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, m - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, a[i] - <span class="number">1</span>) &#123;</span><br><span class="line">            id[b[i][j]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        x ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; id[c[i - <span class="number">2</span>]].size(); k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = id[c[i - <span class="number">2</span>]][k];</span><br><span class="line">                f[x][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; id[c[i]].size(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id[c[i]][k];</span><br><span class="line">            f[x][j] = f[x ^ <span class="number">1</span>][(j - <span class="number">1</span> + m) % m] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[x][j] &gt;= m) valid[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[l = r = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &lt; i - m) ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r &amp;&amp; valid[i - <span class="number">1</span>]) dp[i] = dp[q[l]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; dp[q[r]] &gt;= dp[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] &gt; <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>求的是最小非链状瓶颈路，可以在求最小瓶颈路的算法——$kruskal$重构树上略作修改。</p><p>具体来说，加边的时候就不要舍弃边了，都加上。考虑$kruskal$重构树的性质，一个点权为 $w$ 的节点子树内的点组成一个边权不超过 $w$ 的连通块。对于每个重构树上的节点，维护一个标记表示它对应的连通块是否是非链状路。非链状路的关系可以传递，即如果儿子的标记 $= 1$ 那么父亲的标记也 $= 1$。每次询问倍增找第一个标记 $= 1$ 的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, U[N], V[N], W[N], f[N][<span class="number">21</span>], fa[N], idx, deg[N], dep[N], val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u, v, w, g[N];</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, z; &#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.z &lt; b.z; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i];</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    idx = n;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getfa(e[i].x), y = getfa(e[i].y), z = e[i].z;</span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            val[idx] = z;</span><br><span class="line">            f[x][<span class="number">0</span>] = idx;</span><br><span class="line">            fa[x] = fa[idx] = idx;</span><br><span class="line">            mark[idx] = <span class="number">1</span>;</span><br><span class="line">            g[idx].push_back(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val[idx] = z;</span><br><span class="line">            f[x][<span class="number">0</span>] = f[y][<span class="number">0</span>] = idx;</span><br><span class="line">            fa[x] = fa[y] = fa[idx] = idx;</span><br><span class="line">            <span class="keyword">if</span> (mark[x] || mark[y] || (++deg[e[i].x]) &gt; <span class="number">2</span> || (++deg[e[i].y]) &gt; <span class="number">2</span>)  <span class="comment">// 子树中存在非链状块</span></span><br><span class="line">                mark[idx] = <span class="number">1</span>;</span><br><span class="line">            g[idx].push_back(x), g[idx].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mark[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    rep(j, <span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, idx)</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> mm,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w)</span> </span>&#123;</span><br><span class="line">    n = nn, m = mm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        e[i + <span class="number">1</span>] = (edge)&#123;u[i] + <span class="number">1</span>, v[i] + <span class="number">1</span>, w[i]&#125;;</span><br><span class="line">    Kruskal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumFuelCapacity</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xy = lca(++x, ++y);</span><br><span class="line">    <span class="keyword">if</span> (mark[xy]) <span class="keyword">return</span> val[xy];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!mark[f[xy][i]]) xy = f[xy][i];</span><br><span class="line">    xy = f[xy][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> xy ? val[xy] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>咕咕？</p><p>upd：补了</p><p>度数最大为 $3$ ！！！</p><p>考虑知道树的形态了怎么做。「每个点出现一次」暗示了经典模型：有 $sum$ 个物品被划分为若干集合，每次可选两个不同集合的物品匹配并抵消。将子树按最大深度从大到小排，从最深点出发，跳到次深子树，再跳回最深子树，如此反复。显然只要不存在一个子树 $size &gt; n / 2$ 就可以消完。</p><p>所以应该选重心作为根。在 $mx <em> 2 &lt; tot$ 时我们优先选深的。在 $mx </em> 2 = tot$ 时我们开始要每条边都经过 $mx$ 了。</p><p>如何找重心？以 $1$ 为根 $n$ 次询问每个点的子树大小，子树大小 $\geq n / 2$ 且最小的就是。</p><p>再 $n$ 次询问每个点的深度。接下来只要把每个点分到三个子树里去就好了，询问共 $2n$ 次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fun.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bs bitset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ui unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heap priority_queue<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Go(i, x, v) for (int i = 0, x = (i == v.size() ? 0 : v[i]); i &lt; v.size(); i++, x = (i == v.size() ? 0 : v[i]))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">  x = <span class="number">0</span>; <span class="keyword">char</span> ch = gc(); <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = gc()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = gc()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">  x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">cmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = min(x, y); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">cmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = max(x, y); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">return</span> x + y &gt;= mod ? x + y - mod : x + y; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">sub</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">mul</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> <span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Add</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = (x + y &gt;= mod ? x + y - mod : x + y); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Sub</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = (x - y &lt; <span class="number">0</span> ? x - y + mod : x - y); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Mul</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span> x = <span class="number">1l</span>l * x * y % mod; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">qpow</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span> = <span class="title">mod</span> - 2) &#123;</span> T ret = <span class="number">1</span>; <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, Mul(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) Mul(ret, a); <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="comment">/* ============ Header Template ============ */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sz[N], rt, dep[N], son[<span class="number">5</span>], q[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> attractionsBehind(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hR</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hoursRequired(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dep[x] &lt; dep[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mxd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dep[q[x][q[x][<span class="number">0</span>] + y]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">createFunTour</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> Q)</span> </span>&#123;</span><br><span class="line">  rep(i, <span class="number">1</span>, n)</span><br><span class="line">    sz[i] = aB(<span class="number">1</span>, i);</span><br><span class="line">  rep(i, <span class="number">1</span>, n)</span><br><span class="line">    <span class="keyword">if</span> (sz[i] &gt;= (n + <span class="number">1</span>) / <span class="number">2</span> &amp;&amp; (!rt || sz[i] &lt; sz[rt]))</span><br><span class="line">      rt = i;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    dep[i] = hR(rt, i);</span><br><span class="line">    <span class="keyword">if</span> (dep[i] == <span class="number">1</span>)</span><br><span class="line">      son[++son[<span class="number">0</span>]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (i ^ rt) &#123;</span><br><span class="line">    <span class="keyword">bool</span> flg = <span class="number">0</span>;</span><br><span class="line">    rep(j, <span class="number">1</span>, son[<span class="number">0</span>] - <span class="number">1</span>) <span class="keyword">if</span> (dep[i] == <span class="number">1</span> + hR(i, son[j])) &#123;</span><br><span class="line">      flg = <span class="number">1</span>;</span><br><span class="line">      q[j][++q[j][<span class="number">0</span>]] = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flg) q[son[<span class="number">0</span>]][++q[son[<span class="number">0</span>]][<span class="number">0</span>]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">1</span>, son[<span class="number">0</span>]) &#123;</span><br><span class="line">    sort(q[i] + <span class="number">1</span>, q[i] + q[i][<span class="number">0</span>] + <span class="number">1</span>, cmp);</span><br><span class="line">  &#125;</span><br><span class="line">  vi ans; ans.clear();</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">  per(i, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; pre != p)</span><br><span class="line">      cur = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      rep(j, <span class="number">1</span>, son[<span class="number">0</span>]) <span class="keyword">if</span> (j ^ pre) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((q[j][<span class="number">0</span>] * <span class="number">2</span>) &gt; i || (q[j][<span class="number">0</span>] * <span class="number">2</span> == i &amp;&amp; son[<span class="number">0</span>] == <span class="number">3</span> &amp;&amp; (!pre || mxd(pre, <span class="number">1</span>) &gt; mxd(<span class="number">6</span> - j - pre, <span class="number">0</span>)))) &#123;  <span class="comment">// 可以归并了。</span></span><br><span class="line">            cur = p = j;  <span class="comment">// j 占了剩下空位的 1/2 或 1/2 + 1，接下来每条边都有一端在 j 了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[j][<span class="number">0</span>] &amp;&amp; (!cur || mxd(j, <span class="number">0</span>) &gt; mxd(cur, <span class="number">0</span>)))</span><br><span class="line">          cur = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.pb(q[cur][q[cur][<span class="number">0</span>]] - <span class="number">1</span>), --q[cur][<span class="number">0</span>];</span><br><span class="line">    pre = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  ans.pb(rt - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200814 题解</title>
      <link href="2020/08/14/XJOI200814%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/14/XJOI200814%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>今天赛 1 是联赛难度。感到自己有很多不足。</p><p>赛2：什么叫做乱搞啊 /kk</p><p><a href="http://115.236.49.52:83/contest/1587" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1588" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>没想出来但这种题有可能会出现在正式赛场上，<strong>所以要会乱搞啊！</strong></p><p>正解就是选出 K / m 个整行加上 K % m 个在同一行的元素。</p><p>有个伪证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a, b, c, d), e, f</span><br><span class="line">(h, i, j), k, l, m</span><br><span class="line"></span><br><span class="line">划了括号的是选的。</span><br><span class="line">1. j = e 那么不选 (i, j) 改选 (e, f) 不会更劣</span><br><span class="line">2. j &gt; e 不选 (i, j) 改选 (e, f)</span><br><span class="line">3. j &lt; e 那么 b &gt;= c &gt;= d &gt;= e &gt; j &gt;= k &gt;= l &gt;= m，不选 (b, c, d) 改选 (k, l, m)</span><br><span class="line">所以大概可以说明两行可以合并成一行，即必须取满其中一行。</span><br></pre></td></tr></table></figure></p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>图论今天真的要刷起来了，这题 lca 搞一搞就好了啊！都忘光了。。。树上路径就是到 lca 的路径啊。。。</p><p>那么分两种情况：</p><ul><li>$lca(c, d)$ 在 $lca(a, b)$ 子树中：发现 $lca(c, d)$ 不在 $a$ 到 $b$ 路径上即可</li><li>$lca(c, d)$ 不在 $lca(a, b)$ 子树中：$c$ 到 $d$ 的路径不经过连接 $lca(a, b)$ 和 $fa[lca(a, b)]$ 的边即可</li></ul><p>于是预处理一波就可以了。</p><p>（xj数据水，我一个 $O(n(nq + n^2))$ 的暴力跑过去了。。。。）</p><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>神仙构造（noip考构造吗）显然 $S &gt; \frac{n(n - 1)}{2}$ 的时候无解。然后还不会。。咕咕</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>这很 Atcoder 啊。。神仙构造 + 大乱搞题？咕咕</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>竟然给我乱搞出来了！考虑操作序列是形如 $(((S + k_1a)b + k_2a)b + k_3a)b + …$ 这样的。我们枚举有几个 $b$（显然只有 log 种），就变成类似于进制，所以要让 $\sum_i k_i$ 最小，只要“能减则减”就可以了。</p><p>—-分割线—-</p><p>我错了。这题没有一点素质，它的重点根本就是分类讨论，我吐了 思博题💢</p><p>!s   !t   s &lt; t   !a   !b   b = 1 这些你都判了吗</p><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>傻了傻了，枚举<strong>第一个</strong>a、b、c出现的位置就好了呗！这是 $O(n^3)$ 的，然后 $O(n^2)$ 的用树状数组维护就好了（？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200813 题解</title>
      <link href="2020/08/13/XJOI200813%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/13/XJOI200813%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>又是一天两场的 XJOI noi 模拟赛，每天都是暴力选手 被吊着打 /kk</p><p><a href="http://115.236.49.52:83/contest/1583" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1585" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>写了 $n^2$ 的 dp，一遍过样例好评（。）正解是 dp 优化，然而这题 dp 有很多种，我这种没法优化的样子（看起来很笨！）</p><p><a href="https://www.cnblogs.com/Flying2018/p/13498384.html" target="_blank" rel="noopener">来看看flying2018大佬的题解</a></p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>暴力没写就特别不应该。模并不会对正确性有影响。。。30分还是很好拿到的。考虑 $gcd = 1$ 的那档子分，画一画图找规律就好了呗，60分也不难啊。</p><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>60分这么香你为什么不写？啊？啊？？啊？？！$T = 2$ dp, $f[i, j]$ 表示第 $i$ 个区间能否和第 $i + 1$ 个区间交换；$l_i = i$ 的那档子分打个表找规律就出来了，$g[i] = 2g[i - 1] + i - 2$</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>题目好像出锅了，咕咕</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>不会，咕咕</p><p>—-分割线—-</p><p>来订正了。思维有点难度但并不是很毒的图论题，图论我太菜了啊 /kk 专题要刷起来了！</p><p>显然操作二和三建反图预处理一波就好了，难点在操作一。原题是 <a href="https://www.luogu.com.cn/problem/P3573" target="_blank" rel="noopener">[POI2014]RAJ-Rally</a></p><p>考虑 DAG 的性质。设 x 的拓扑序为 dfn[x], 对于一条边 (x, y) 显然 dfn[x] &lt; dfn[y]。强制走 (x, y) 的话显然拓扑序在 dfn[x] ~ dfn[y] 之间的点都不会经过，于是想到用 (x, y) 来更新那些点。</p><p>具体来说，设拓扑序比 x 小的集合为 A，比 x 大的集合为 B，以 x 为终点的最长路径为 dt[x]，为起点的最长路径为 ds[x], $f[x] = \max\limits_{(u, v) \in E, u \in A, v \in B}(dt[u] + 1 + ds[v])$</p><p>预处理这个 f, 发现每次 x 增大，A 只会多一个数，B 只会少一个数，可以动态维护最大值。</p><p><a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p3573" target="_blank" rel="noopener">这篇博客的图非常清晰，可以帮助理解动态维护的过程</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"><span class="keyword">int</span> degt[N], degs[N], dt[N], ds[N], ans[N], id[N], tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;e[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gt[N], gs[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        e[i].x = x, e[i].y = y;</span><br><span class="line">        degt[y]++, degs[x]++;</span><br><span class="line">        gt[x].push_back(y), gs[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!degt[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        id[++tot] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gt[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gt[x][i];</span><br><span class="line">            dt[y] = max(dt[y], dt[x] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(--degt[y])) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!degs[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gs[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gs[x][i];</span><br><span class="line">            ds[y] = max(ds[y], ds[x] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(--degs[y])) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) s.insert(ds[i]);</span><br><span class="line">    rep(o, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = id[o];</span><br><span class="line">        s.erase(s.find(ds[x]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gs[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gs[x][i];</span><br><span class="line">            s.erase(s.find(ds[x] + <span class="number">1</span> + dt[y]));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] = *s.rbegin();</span><br><span class="line">        s.insert(dt[x]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gt[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = gt[x][i];</span><br><span class="line">            s.insert(dt[x] + <span class="number">1</span> + ds[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ty, x; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ty, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ty == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dt[x] + ds[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dt[e[x].x] + ds[e[x].y] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>min25筛和暴搜均可 AC（雾）不会 min25 就只能写暴搜啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll n, P;</span><br><span class="line">ll mark[N], p[N], tot, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) p[++tot] = i, cnt[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; j++) &#123;</span><br><span class="line">            mark[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x, ll t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; tot || x * p[t] &gt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x * p[t] * p[t] &gt; n) <span class="keyword">return</span> cnt[min(P, n / x)] - t + <span class="number">2</span>;  <span class="comment">// 优秀的剪枝们</span></span><br><span class="line">    ll ret = dfs(x, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (; x * p[t] &lt;= n; ) &#123;</span><br><span class="line">        x *= p[t];</span><br><span class="line">        ret += dfs(x, t + <span class="number">1</span>);</span><br><span class="line">        x *= p[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; P;</span><br><span class="line">    sieve(P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200812 题解</title>
      <link href="2020/08/12/XJOI200812%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/12/XJOI200812%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>丧心病狂，打了两场提（n）高（o）组（i）模拟赛。。。一天就这么没了【哭】</p><p><a href="http://115.236.49.52:83/contest/1578" target="_blank" rel="noopener">赛1</a>    <a href="http://115.236.49.52:83/contest/1579" target="_blank" rel="noopener">赛2</a></p><h2 id="1A"><a href="#1A" class="headerlink" title="1A"></a>1A</h2><hr><p>不用 Boruvka，直接 Kruskal，从大到小枚举边权然后能连则连。</p><h2 id="1B"><a href="#1B" class="headerlink" title="1B"></a>1B</h2><hr><p>神仙题！（也可能只是我不会线性代数¯\_(ツ)_/¯）原题是 <a href="https://www.luogu.com.cn/problem/CF388D" target="_blank" rel="noopener">CF388D</a></p><p>考虑异或 一般来说 就是 Trie 和线性基</p><p>诶？线性基好像可以！本题相当于给一组线性基就能产生一堆异或值，线性基和异或值共同组成集合</p><p>一组线性基对应一个集合，但<strong>一个集合可以有多组线性基</strong>，如果能让集合和线性基一一对应，集合的计数就转化成了线性基的计数</p><p>根据“特征点”的思想，我们对每组线性基高斯消元。可以证明高消后，不同的线性基生成的集合一定不同。</p><p>接下来对线性基做 dp 就好了。注意，高消后线性基能异或出来的最大值就是所有元素的异或值</p><p>dp 的状态设计：dp[i, j, k] 表示从最高位到第 i 位选了 j 个基，异或得到的最大值是否顶到上界（是则 k = 1，否则 k = 0）有点类似于数位 dp</p><p><a href="https://blog.csdn.net/C202044zxy/article/details/106119810" target="_blank" rel="noopener">细节</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, dp[<span class="number">32</span>][<span class="number">32</span>][<span class="number">2</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">30</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">30</span> - i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// k = 0</span></span><br><span class="line">            add(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i][j][<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; j) % mod);</span><br><span class="line">            add(dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>], dp[i][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// k = 1</span></span><br><span class="line">            ll x = (j == <span class="number">0</span> ? <span class="number">1</span> : (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))), y = (j == <span class="number">0</span> ? <span class="number">0</span> : (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], x * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], y * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>], dp[i][j][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], x * dp[i][j][<span class="number">1</span>] % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">30</span>) add(ans, (dp[<span class="number">0</span>][i][<span class="number">0</span>] + dp[<span class="number">0</span>][i][<span class="number">1</span>]) % mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1C"><a href="#1C" class="headerlink" title="1C"></a>1C</h2><hr><p>先决题目是 [ZJOI2016]-旅行者，这里写一下题解</p><p>网格图可以分治！找到矩形的长边，用一条中轴线切成两半，当前分治的区间是 (lx, ly) (rx, ry)，处理的询问是 (ql, qr)（类似于整体二分）。对于每个询问：</p><ul><li>起始点在中轴线两侧，对于中轴线上每个点跑最短路更新答案</li><li>起始点在一侧，<strong>可能</strong>最短路也经过中轴线，也更新一波，再递归分治</li></ul><p>卡了小常，加了玄学头文件<br><a href="https://blog.csdn.net/neither_nor/article/details/51733997" target="_blank" rel="noopener">复杂度是 O(S logS sqrt(S))</a><br><a href="https://www.luogu.com.cn/discuss/show/74578" target="_blank" rel="noopener">如果没看懂这里还有一个（还是不懂。。</a></p><p>—-分割线—-</p><p>本题的区别就是有修改啦。我们可以知道每个格子变为不能走的时间（这个整体二分做），定义一条路径的值为这条路径上格子不能走时间的最小值，那我们就需要找一条值最大的路径看这个值是否大于询问的时间。离线，用旅行者的 分治 + dp 做。然而不会写代码，我只会咕咕</p><h2 id="2A"><a href="#2A" class="headerlink" title="2A"></a>2A</h2><hr><p>只会 16 分 O(nT)，告辞（咕咕</p><p><a href="https://www.luogu.com.cn/paste/a8hdc624" target="_blank" rel="noopener">正解是斯特林数相关？？？我谔谔</a></p><p>最后就是个卷积形式了。</p><h2 id="2B"><a href="#2B" class="headerlink" title="2B"></a>2B</h2><hr><p>莫反就有 60 分，可惜 T 了一个点</p><p>正解 要用 ODT 维护？？？我谔谔</p><h2 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h2><hr><p>神仙计算几何题，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 047 题解</title>
      <link href="2020/08/11/AGC%20047%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/11/AGC%20047%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>容易想到乘上 1e9，那么意味着相乘得到的数是 1e18 的倍数。即因子中 2 和 5 的个数都 &gt;= 18，开个桶随便做一下。【注意读入，我没用字符串就 wa 了 qvq 没试过 long double 不知道行不行</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易发现若 T 能和 S 匹配，把 T 第一个字符去掉以后就是 S 的一个后缀。</p><p>题目只给出了<strong>总</strong>串长！这启发我们想到结合 Trie 树等结构实现一个 O(n) 的算法。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>对多项式大师来说是套路题，对我来说。。qvq</p><p>容易想到枚举模后乘积。</p><script type="math/tex; mode=display">F(x) = \sum [a_i == x]</script><script type="math/tex; mode=display">ans = \sum\limits_d d \sum_{(xy\bmod P == d)}F(x)F(y)</script><p>我们想到了卷积，但这还不是卷积形式，于是再化一步：</p><script type="math/tex; mode=display">F(x) = \sum [g^{a_i} == x]</script><p>其中 g 是 P 的原根之一</p><script type="math/tex; mode=display">ans = \sum\limits_d g^d \sum_{((x + y)\bmod P == d)}F(x)F(y)</script><p>那这就是个循环卷积啦。</p><p>关于原根：原根的定义和性质：对于任何 $0$ ~ $P - 1$ 中的数 $i$、$j$($i \neq j$), 有 $g^i \neq g^j(\bmod P)$，即 $g^i$ 在 mod P 意义下可以取遍 $0$ ~ $P - 1$ 所有数。</p><p>关于找原根：原根很小，一般在 100 以内，枚举，若存在 P 的因子 x 使得 $g^{\frac{P - 1}{x}} \equiv 1 (\bmod P)$ 那么 g 就不是原根。否则就是。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>咕咕</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>咕咕</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】概率与期望</title>
      <link href="2020/08/11/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"/>
      <url>2020/08/11/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快乐期望 ~</span><br></pre></td></tr></table></figure><p>期望题往往应用到了期望的线性性质，可以说是解题的基础。</p><p>在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp</p><h2 id="套路1-直接递推-dp"><a href="#套路1-直接递推-dp" class="headerlink" title="套路1. 直接递推/dp"></a><strong>套路1. 直接递推/dp</strong></h2><hr><h3 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="$[NOI2005]-聪聪与可可$"></a><a href="https://www.luogu.com.cn/problem/P4206" target="_blank" rel="noopener">$[NOI2005]-聪聪与可可$</a></h3><p>简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能到达的。<strong>猫和鼠的距离不断减少</strong>，所以状态不会形成环，记忆化搜索就好了。</p><h3 id="SCOI2008-奖励关"><a href="#SCOI2008-奖励关" class="headerlink" title="$[SCOI2008]-奖励关$"></a><a href="https://www.luogu.com.cn/problem/P2473" target="_blank" rel="noopener">$[SCOI2008]-奖励关$</a></h3><p>n 这么小一定是状压啦。首先要明确的是，抛出什么宝物是随机的，但选择与否是我们决定的，也就是说我们要求<strong>最优策略下的最大期望得分</strong></p><p>$f[i, S]$ 表示前 $i - 1$ 轮取到的状态为 $S$，$i$ ~ $K$ 轮的最大期望得分。那么就有 </p><script type="math/tex; mode=display">f[i, S] = \frac{1}{n}(\sum\limits_{k\ is\ valid} max(f[i + 1, S], f[i + 1, S | (1 << (k - 1))] + p_k) + \sum\limits_{k\ isn't\ valid} f[i + 1, S])</script><h3 id="清华集训2017-小-Y-和恐怖的奴隶主"><a href="#清华集训2017-小-Y-和恐怖的奴隶主" class="headerlink" title="$[清华集训2017]-小 Y 和恐怖的奴隶主$"></a><a href="https://www.luogu.com.cn/problem/P4007" target="_blank" rel="noopener">$[清华集训2017]-小 Y 和恐怖的奴隶主$</a></h3><p>n 这么大一定是矩阵快速幂优化 dp 啦（雾）。以 $m = 3$ 为例，设 $f[i, a, b, c]$ 表示 $i$ 轮攻击后有 $a$ 个 1 血随从、$b$ 个 2 血随从、$c$ 个 3 血随从的概率，转移方程就很好想。。然后发现这个东西状态数是 166, 复杂度 $O(T166^3logn)$，考虑把 $2^i$ 的矩阵预处理出来，每次询问就只需用一个行向量去乘 logn 次矩阵，复杂度就变成了 $O(T166^2logn)$，然后还要卡很多常。。。所以这是道毒题</p><h2 id="套路2-无限循环转递推"><a href="#套路2-无限循环转递推" class="headerlink" title="套路2. 无限循环转递推"></a><strong>套路2. 无限循环转递推</strong></h2><hr><p>（这部分好神仙的！要巧妙设计状态，或者错位相减法（等比数列求和必备技能）等方法化柿子 qvq）</p><h3 id="SHOI2002-百事世界杯之旅"><a href="#SHOI2002-百事世界杯之旅" class="headerlink" title="$[SHOI2002]-百事世界杯之旅$"></a><a href="https://www.luogu.com.cn/problem/P1291" target="_blank" rel="noopener">$[SHOI2002]-百事世界杯之旅$</a></h3><p>应用极限的思想 <a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p1291" target="_blank" rel="noopener">题解</a></p><h3 id="六省联考2017-分手是祝愿"><a href="#六省联考2017-分手是祝愿" class="headerlink" title="$[六省联考2017]-分手是祝愿$"></a><a href="https://www.luogu.com.cn/problem/P3750" target="_blank" rel="noopener">$[六省联考2017]-分手是祝愿$</a></h3><p>看起来很神的期望题</p><p>首先 50 分从后往前取，好拿吧</p><p>考虑正解！从后往前取会确定一些<strong>必须要取</strong>的键，那么就相当于除开这些键 按了其他的键 <strong>就得按同一个键按回来</strong>，相当于多了一个必须要按的键（所以 f 的预处理得从 n，不能从 cnt 开始！）。所以 dp 的状态就是 f[i] 表示从 i 个必选的键转移到 i - 1 个必选的键的期望操作次数</p><script type="math/tex; mode=display">f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])</script><p>第一项表示选了一个必选的，一次就到 i - 1 去了；</p><p>第二项表示选了一个其他的，就得 f[i + 1] 次按回来，再 f[i] 次按到 i - 1 去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100003</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, cnt, res;</span><br><span class="line">ll col[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    col[j] ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j * j != i) col[i / j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)  <span class="comment">// !!! 从 n 开始</span></span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] * (ll)(n - i) % mod + n) % mod * quick_pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= K) res = cnt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt; K; --i) res = (res + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) res = res * (ll)i % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UVA10529-Dumb-Bones"><a href="#UVA10529-Dumb-Bones" class="headerlink" title="$[UVA10529]-Dumb Bones$"></a><a href="https://www.luogu.com.cn/problem/UVA10529" target="_blank" rel="noopener">$[UVA10529]-Dumb Bones$</a></h3><p>太神仙了吧woc</p><p>考虑<strong>单独</strong>一张骨牌摆放成功的期望次数 E</p><p>玄学化柿子（感性理解）</p><script type="math/tex; mode=display">E = 1 + pl(1 + pl(...) + pr(...)) + pr(1 + pl(...) + pr(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr)(1 + (pl + pr)(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr) + (pl + pr)^2 + (pl + pr)^3 ... + (pl + pr)^{\infty}</script><script type="math/tex; mode=display">= \frac{1}{1 - pl - pr}</script><p>（别化晕了</p><p>考虑连续的 x 张骨牌成功的期望。<strong>注意采取最优策略</strong></p><p>放第 x 张骨牌时，如果向左/右，就要花费一些步数去扶起左/右边的骨牌。后面那坨东西，根据<strong>期望的线性性质</strong></p><script type="math/tex; mode=display">f[x] = \min\limits_{i = 1}^x\{f[i - 1] \times \frac{1 - pr}{1 - pl - pr} + f[x - i] \times \frac{1 - pl}{1 - pl - pr} + \frac{1}{1 - pl - pr}\}</script><p>以往左倒为例解释一下：左边要重搭 $f[i - 1] \times [往左倒的期望次数] = f[i - 1] \times (E - 1) \times \frac{pl}{pl + pr}$，注意这是重搭的，初始还有一次，所以是 $f[i - 1] \times \frac{1 - pr}{1 - pl - pr}$</p><p>就做完了。uva 数据只有一组，非常的水，我怕了，题解柿子都不一样。</p><p>感想就是，<strong>期望的线性性质真的太重要了！</strong> 不然这种互相影响的问题就没法做了。</p><h3 id="CF908D-New-Year-and-Arbitrary-Arrangement"><a href="#CF908D-New-Year-and-Arbitrary-Arrangement" class="headerlink" title="$[CF908D]-New Year and Arbitrary Arrangement$"></a><a href="https://www.luogu.com.cn/problem/CF908D" target="_blank" rel="noopener">$[CF908D]-New Year and Arbitrary Arrangement$</a></h3><p>这题的关键在处理边界啦。</p><p>容易发现我们需要记录的是当前 a 和 ab 的数量。设 f[i, j] 表示 i 个 a，j 个 ab，那么 $f[i, j] = \frac{pa}{pa + pb}f[i + 1, j] + \frac{pb}{pa + pb}f[i, i + j]$</p><p>开头无限多个 b 怎么办？忽略掉，因为对 ab 的数量没有影响。</p><p>结尾无限多个 a 怎么办？这个就要搞一搞了。如果 i + j &gt;= k，那么只要加一个 b 就能结束。设 $P_a = \frac{pa}{pa + pb}$, $P_b = \frac{pb}{pa + pb}$</p><script type="math/tex; mode=display">f[i, j] = P_b \sum\limits_{k = 0}^{\infty} P_a^k (i + j + k)</script><script type="math/tex; mode=display">= P_b\sum\limits_{k = 0}^{\infty} P_a^k \times k + P_b(i + j)\sum\limits_{k = 0}^{\infty}P_a^k</script><script type="math/tex; mode=display">= i + j + \frac{P_a}{P_b}</script><h3 id="「PKUWC2018」猎人杀"><a href="#「PKUWC2018」猎人杀" class="headerlink" title="$「PKUWC2018」猎人杀$"></a><a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">$「PKUWC2018」猎人杀$</a></h3><p>很妙的概率题。</p><p>分母是变化的，很不好求。</p><p>问题可以转化一波，变成：死掉的猎人依旧算在概率里面，每一轮一直开枪直到射死一个没死过的猎人。这样每次能选的就是全集了。</p><p>设 $W = \sum w_i$, $T = \{w_i | (i has died)\}$, $sum(T) = \sum\limits_{i has died} w_i$</p><p>转化前射死 $i$ 的概率 $P = \frac{wi}{(W - T)}$</p><p>转化后射死 $i$ 的概率 $P = \frac{T}{W}P + \frac{wi}{W} = \frac{wi}{W - T}$</p><p>两者相等。</p><p>。</p><p>。</p><p>然后考虑容斥，钦定一个不包含 1 的猎人集合 T 在 1 之后死去。除了集合 T 和猎人 1 以外的剩余的猎人不用考虑，因为他们可以任意摆放在 1 的前面后面（也就是说概率是 1）</p><p>集合为 T 的人在 1 后面死的概率：</p><script type="math/tex; mode=display">P = \frac{w_1}{W}\sum\limits_{i = 0}^{\infty} (1 - \frac{sum(T) + w_1}{W})^i = \frac{w_1}{sum(T) + w_1}</script><p>容斥</p><script type="math/tex; mode=display">ans = \sum\limits_{T} (-1)^{|T|} \frac{w_1}{sum(T) + w_1}</script><p>枚举 $T$ 再背包预处理容斥系数可以做到 $n^2$，50 pts：</p><script type="math/tex; mode=display">ans = \sum\limits_{num = 0}^{W} \frac{w_1}{num + w_1} (\sum\limits_T (-1)^{|T|} [sum(T) == num])</script><p>好妙【吐血而亡</p><p>100 pts 的话就是后面那坨容斥系数用分治的 NTT 卷一下了（下标是 T），注意不是 cdq 分治，就是普通的分治。或者也可以堆优化，即每次选两个长度最小的卷。nlog^2n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, w[N], lim, sum[N], stk[<span class="number">32</span>], top, g[<span class="number">32</span>][N], ans, f[N], L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll f[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>, f[w[l]] = mod - <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ls, rs;</span><br><span class="line">    ls = stk[top--], solve(g[ls], l, mid);</span><br><span class="line">    rs = stk[top--], solve(g[rs], mid + <span class="number">1</span>, r);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= sum[r] - sum[l - <span class="number">1</span>]) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    get_rev();</span><br><span class="line">    NTT(g[ls], <span class="number">1</span>), NTT(g[rs], <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) f[i] = g[ls][i] * g[rs][i] % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) g[ls][i] = g[rs][i] = <span class="number">0</span>;</span><br><span class="line">    stk[++top] = ls, stk[++top] = rs;  <span class="comment">// 垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]), sum[i] = sum[i - <span class="number">1</span>] + w[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) stk[++top] = i;</span><br><span class="line">    solve(f, <span class="number">2</span>, n);</span><br><span class="line">    rep(i, <span class="number">0</span>, sum[n] - w[<span class="number">1</span>])</span><br><span class="line">        ans = (ans + w[<span class="number">1</span>] * quick_pow(i + w[<span class="number">1</span>], mod - <span class="number">2</span>) % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="套路3-高斯消元"><a href="#套路3-高斯消元" class="headerlink" title="套路3. 高斯消元"></a><strong>套路3. 高斯消元</strong></h2><hr><p>终于到了我最喜欢的部分 ~ 高消！</p><p>我纠结了很久的问题：图上游走问题 是以出发点度数作为分母还是终点度数作为分母，但这其实应题而异，主要跟你设计的 dp 状态有关。</p><h3 id="USACO10HOL-Driving-Out-the-Piggies-G"><a href="#USACO10HOL-Driving-Out-the-Piggies-G" class="headerlink" title="$[USACO10HOL]-Driving Out the Piggies G$"></a><a href="https://www.luogu.com.cn/problem/P2973" target="_blank" rel="noopener">$[USACO10HOL]-Driving Out the Piggies G$</a></h3><p>$f[x]$ 表示走到 x 不爆炸的概率（爆炸只要乘上 $\frac{p}{q}$ 就好了）</p><p>对于非起始点的 x，$f[x] = \sum \frac{(1 - \frac{p}{q})f[y]}{deg_y}$</p><h3 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="$[HNOI2013]-游走$"></a><a href="https://www.luogu.com.cn/problem/P3232" target="_blank" rel="noopener">$[HNOI2013]-游走$</a></h3><p>几个月前做的，现在来看却有了新的体会。</p><p>根据期望的线性性质，$E[分数之和] = \sum_{(u, v) \in G} E[(u, v)分数] = \sum_{(u, v) \in G} E[经过(u, v)的次数] \times val(u, v)$，那么算出每条边被经过次数后从小到大排序，贪心的从大到小赋边权就可以了。</p><p>边经过的期望次数可以转化成点经过的期望次数。$E[u, v] = \frac{E[u]}{deg_u} + \frac{E[v]}{deg_v}$, $E[u] = \sum \frac{E[v]}{deg_v} + [u == 1]$</p><h3 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="$[HNOI2011]-XOR和路径$"></a><a href="https://www.luogu.com.cn/problem/P3211" target="_blank" rel="noopener">$[HNOI2011]-XOR和路径$</a></h3><p>整个做不好做。根据期望的线性性质，按位考虑，计算出每一位为 1 的概率直接相加。$f[x]$ 表示从 x 到 n 当前位为 1 的概率。</p><script type="math/tex; mode=display">f[x] = \sum\limits_{(x, y) = 0} \frac{f[y]}{deg_y} + \sum\limits_{(x, y) = 1} \frac{1 - f[y]}{deg_y}</script><p>移项以后高消。注意边界，$f[n] = 0$</p><h2 id="套路4-分开考虑贡献"><a href="#套路4-分开考虑贡献" class="headerlink" title="套路4. 分开考虑贡献"></a><strong>套路4. 分开考虑贡献</strong></h2><hr><p>这部分主要是期望的线性性质的应用。其实前面的题目也有体现。</p><h3 id="仓鼠找sugar-II"><a href="#仓鼠找sugar-II" class="headerlink" title="$仓鼠找sugar II$"></a><a href="https://www.luogu.com.cn/problem/P3412" target="_blank" rel="noopener">$仓鼠找sugar II$</a></h3><p>数据范围这么大 不能高消 =&gt; 我不会做了！</p><p>把目标节点看作根，这样答案就成了到达根的期望步数和</p><p>设 $f[x]$ 表示从 x 向上走一步的期望步数，那么 $f[x] = \frac{1}{deg_x} + \frac{deg_x - 1}{deg_x}(1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x - 1} + f[x]) = 1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x} + f[x] = deg_x + \sum\limits_{y \in Son(x)}f[y]$, 叶子 $x$ 的 $f[x] = 1$</p><p>树形dp $n$ 次能获得 50 分的好成绩，考虑再优化——换根法。</p><p>设 $g[x]$ 表示在 $fa[x]$ 的儿子中除了 $x$ 以外的 $f$ 值之和。根从 $u$ 变成 $v$ 实际上只会影响 $u$ 和 $v$ 的 $f$ 值和子树大小，即 $f[u] = deg_u + g[v], f[v] = 0$，子树和随便搞一下。$ans = \frac{\sum\limits_{rt = 1}^n\sum\limits_{x = 1}^n f[x] \times sz[x]}{n^2}$</p><h3 id="小魔女帕琪"><a href="#小魔女帕琪" class="headerlink" title="$小魔女帕琪$"></a><a href="https://www.luogu.com.cn/problem/P3802" target="_blank" rel="noopener">$小魔女帕琪$</a></h3><p>根据期望的线性性质，$E[总数] = \sum\limits_i E[从 i 开始的七个魔法都不相同]$，每个位置 i 的连续七个不相同的概率都是相同的。答案就是 $7! \times \prod\limits_{i = 1}^7 \frac{a_i}{N - i + 1} \times (N - 6)$</p><h3 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="$[HNOI2015]-亚瑟王$"></a><a href="https://www.luogu.com.cn/problem/P3239" target="_blank" rel="noopener">$[HNOI2015]-亚瑟王$</a></h3><p>根据期望的线性性质，考虑每张牌对答案的贡献。发现第 $i$ 张牌被考虑到的次数<strong>只</strong>和前 $i - 1$ 张牌产生贡献的<strong>数量</strong>有关（设其为 $j$），因为这 $j$ 张牌产生贡献的时间和顺序不论怎样变换，第 $i$ 张牌都能被考虑到 $r - j$ 次。</p><p>于是想到 dp。$f[i, j]$ 表示在 $r$ 轮中前 $i$ 张牌有 $j$ 张产生贡献的概率，$g[i]$ 表示第 $i$ 张牌产生贡献的概率。那么</p><script type="math/tex; mode=display">f[i, j] = [j <= i - 1] \times f[i - 1, j] \times (1 - p[i])^{r - j} + [j > 0] \times f[i - 1, j - 1] \times (1 - (1 - p[i])^{r - j + 1})</script><script type="math/tex; mode=display">g[i] = \sum\limits_{j = 0}^{min(i - 1, r)}f[i - 1, j] \times (1 - (1 - p[i])^{r - j})</script><p>最终 $ans = \sum\limits_{i = 1}^n g[i] \times d[i]$</p><p>最终答案就是 $f[1, 0]$</p><h2 id="套路5-整数概率公式"><a href="#套路5-整数概率公式" class="headerlink" title="套路5. 整数概率公式"></a><strong>套路5. 整数概率公式</strong></h2><hr><p>这部分是真的没怎么练过。。</p><p>反正要知道公式：对于随机变量 $k &gt;= 0$, $E(k) = \sum\limits_{i = 0}^{\infty} P(k \ge i)$</p><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="$随机数生成器$"></a><a href="https://www.luogu.com.cn/problem/P3600" target="_blank" rel="noopener">$随机数生成器$</a></h3><p>根据上面那个公式，我们就是要计算出 $P(ans \ge i)$。发现 $\ge$ 不好求，$\leq$ 挺好求，因为每个区间里至少有一个 $\leq i$ 的就算满足条件了，所以考虑将 $P(ans \ge i)$ 转化为 $1 - P(ans &lt; i)$。</p><p>我们发现两个区间是包含关系的话，大的区间对答案没有贡献，于是操作一波使得区间们的左右端点不减。考虑某个位置的数，如果它 $\leq i - 1$ 就能对覆盖自己的区间产生贡献，而且覆盖自己的区间编号连续。考虑将点和区间互换，问题等价于每个点能覆盖一些区间，且覆盖的概率为 $p = \frac{i - 1}{x}$，用一些点去覆盖所有区间的概率。</p><p>容易想到 dp，设 $l[i]$ 表示点 i 覆盖的最左边的区间，$r[i]$ 是最右边的，$f[i]$ 表示强制选第 i 个点，然后覆盖了 $1$ ~ $r[i]$ 所有区间的概率，那么</p><script type="math/tex; mode=display">f[i] = p \times (\sum\limits_{r[j] \ge l[i] - 1} f[j] \times (1 - p)^{i - 1 - j} + [l[i] = 1](1 - p)^{i - 1})</script><p>最终答案就是 $\sum\limits_{r[i] = Q}f[i] \times (1 - p)^{n - i}$</p><p>直接做是 $n^3$ 的，前缀和维护一下就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">666623333</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, Q, top, L, R;</span><br><span class="line"><span class="keyword">int</span> stk[N], l[N], r[N];</span><br><span class="line">ll f[N], ans, pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &gt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; q[stk[top]].r &gt;= q[i].r) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = top;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) q[i] = q[stk[i]];</span><br><span class="line">    L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; Q &amp;&amp; q[R + <span class="number">1</span>].l &lt;= i) ++R;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R &amp;&amp; q[L].r &lt; i) ++L;</span><br><span class="line">        l[i] = L, r[i] = R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    prework();</span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        ll p = (i - <span class="number">1</span>) * qpow(x, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        ll pp = mod + <span class="number">1</span> - p;</span><br><span class="line">        ll invp = qpow(pp, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lst &lt; j &amp;&amp; r[lst] &lt; l[j] - <span class="number">1</span>)</span><br><span class="line">                tot = (tot - f[lst] * qpow(invp, lst) % mod + mod) % mod, ++lst;</span><br><span class="line">            f[j] = p * tot % mod * qpow(pp, j - <span class="number">1</span>) % mod;</span><br><span class="line">            tot = (tot + f[j] * qpow(invp, j) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &amp;&amp; r[j] == Q; --j) sum = (sum + f[j] * qpow(pp, n - j) % mod) % mod;</span><br><span class="line">        ans = (ans + <span class="number">1</span> - sum + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SHOI2016]-成绩比较</title>
      <link href="2020/08/11/%5BSHOI2016%5D-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83/"/>
      <url>2020/08/11/%5BSHOI2016%5D-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>首先发现恰好 K 名碾压的好难算啊！计数题嘛，想到容斥，f 恰好，g 至少，套路一波。</p><script type="math/tex; mode=display">g(k) = C^{k}_{n - 1} \times ( \prod_{i = 1}^m C^{n - r_i - k}_{n - k - 1} \sum\limits_{j = 1}^{U_i} j^{n - r_i} (U_i - j)^{r_i - 1} )</script><p>发现很有希望，但是后面那个 sigma 不太好搞，考虑拿出来预处理，运用二项式定理得</p><script type="math/tex; mode=display">\sum\limits_{l = 0}^{r_i - 1} C_{r_i - 1}^l (-1)^l U_i^{r_i - 1 - l} \sum\limits_{j = 1}^{U_i} j^{n - r_i + l}</script><p>后面那个 sigma 是个自然数幂求和，用拉格朗日插值法求，然而我不会所以<strong>咕咕</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 拉格朗日插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 复赛</title>
      <link href="2020/08/11/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/"/>
      <url>2020/08/11/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>A 变化的期望就是 (m - B 攻击成功的期望次数)，挺简单的一题</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><hr><p>题目读错了（这也能错？）我看成在任意位置加一了就不会做啊啊啊</p><p>操作二只会执行一次或不执行，因为把前面一串清零了还要变成 1 才能再做操作二，目的仅仅为了将后面一位变成 1，这显然用操作一就够了。。枚举操作二把多长的前缀变成 0 就好了。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>小构造题。最小和最大是相似的情况，这里就考虑最大的。考虑我们想要大的数贡献尽量大，可以这样构造：l = 8, k = 3，000001110000011100000111… 从大到小依次给 1 赋值。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>咕咕</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>攻击总共有四种情况，其中如果同一轮中两个人都 miss 了相当于没有贡献，具体来说</p><p>设 $f(n, m)$ 为从 (n, m) 出发，Alice 活下来的概率。那么</p><p>$f(n, m) = f(n, m)(1 - p)(1 - q) + f(n, m - 1)p(1 - q) + f(n - 1, m)q(1 - p) + f(n - 1, m - 1)pq$</p><p>$f(n, m) = \frac{f(n, m - 1)p(1 - q) + f(n - 1, m)q(1 - p) + f(n - 1, m - 1)pq}{1 - (1 - p)(1 - q)}$</p><p>可以看作 </p><ul><li>case 1: $(n, m)$ 有 $a = \frac{pq}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n - 1, m - 1)$</li><li>case 2: 有 $b = \frac{p(1 - q)}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n, m - 1)$</li><li>case 3: 有 $c = \frac{q(1 - p)}{1 - (1 - p)(1 - q)}$ 的概率转到 $(n - 1, m)$</li></ul><p>设最终移动到了 $(r, 1)$ <strong>(为什么不是 $(r, 0)$？因为最后一次 Alice 把 Bob 打死，Bob 没有机会攻击 Alice)</strong> ，case 1 操作了 $x$ 次，那么 case 2 操作了 $m - 1 - x$ 次，case 3 操作了 $n - r - x$ 次，就可以写出柿子：</p><p>$\sum\limits_{r = 1}^n \sum\limits_{x = 0}^{min(n - r, m - 1)} C(m - 1, x) \times C(m - 1 + n - r - x, m - 1) \times a^x b^{m - 1 - x} c^{n - r - x}$</p><p>这个不好搞，继续推，设 i = n - r - x</p><p>$\sum\limits_{x = 0}^{min(n - 1, m - 1)} a^xb^{m - 1 - x} C(m - 1, x) \sum\limits_{i = 0}^{n - 1 - x} C(m - 1 + i, i) c^i$</p><p>其中后面那个 sigma 可以前缀和预处理。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】SAM</title>
      <link href="2020/08/10/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SAM/"/>
      <url>2020/08/10/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91SAM/</url>
      
        <content type="html"><![CDATA[<p>以 备 重 修（我觉得至少还得重修个三四次 QAQ）</p><p><a href="https://oi-wiki.org/string/sam/" target="_blank" rel="noopener">OI-wiki</a>（图片非常清晰直观）</p><p><a href="https://www.cnblogs.com/Flying2018/p/13444085.html" target="_blank" rel="noopener">Flying2018大佬的讲解</a></p><p>几个概念/一点理解：</p><ul><li>$len[u]$ 表示以节点 $u$ 为尾巴的最长路径。也等于它插入时的字符串长度。</li><li>不恰当的比喻：$SAM$ 的肉体是一棵压缩的 $Trie$ 树，骨架是 $parent$ 树。</li><li>起点到每个终止节点是一条 $S$ 的后缀，每个节点代表某个长度为 $len[u]$ 的前缀的一些_长度大于某一长度的后缀_。更确切的，$u$ 表示的子串长度是 $(len[fa], len[u]]$ 范围内的。本质不同的子串数等于从起点出发的路径数，也等于 $\sum len[u] - len[fa[u]]$。（$SAM$ 当然是个 $DAG$ 啦</li><li>根据 $endpos$ 的概念，有祖先关系的节点 $endpos$ 是子集（完全包含）关系，没有祖先关系的节点 endpos 就是不交的。</li><li>每次加入一个节点最多会增加两个节点，空间复杂度是 $O(n)$ 的。</li></ul><p>坑点：</p><ul><li>空间两倍 QWQ</li></ul><h3 id="CF1037H"><a href="#CF1037H" class="headerlink" title="$CF1037H$"></a>$CF1037H$</h3><p>思路是贪心。</p><p>如果 $l = 1$，$r = n$，由于要找的是字典序严格大于 $T$ 的，我们考虑找一个 $S$ 的前缀，后面跟一个稍大的字符 $ch$。用 SAM 求出每一位的 $ch$，没有的话就是 $-1$. 最后倒着找第一个不为 $-1$ 的。</p><p>考虑 $l$ 和 $r$ 有限制怎么做，增加一步：找 $ch$ 的时候判断 $endpos$ 集合里有无区间 $[l, r]$ 的串。</p><p>$endpos$ 集合在这道题里必须求出，我们可以用经典套路——$parent$树上跑线段树合并。</p><h3 id="CF700E"><a href="#CF700E" class="headerlink" title="$CF700E$"></a>$CF700E$</h3><p>子串啊什么的考虑 SAM。</p><p>考虑到 $s_i$ 必然是 $s_{i + 1}$ 的前缀和后缀（不然削掉前/后缀不会更劣），在 $parent$ 树上体现为 $s_i$ 是 $s_{i + 1}$ 的祖先，于是想到 $dp$，找最长链</p><p>怎么判断出现了两次呢？记录任意一个 $s_{i + 1}$ 的位置，$endpos$ 集合用线段树合并，就能查询了。</p><h3 id="区间本质不同子串个数"><a href="#区间本质不同子串个数" class="headerlink" title="$区间本质不同子串个数$"></a><a href="https://www.luogu.com.cn/problem/P6292" target="_blank" rel="noopener">$区间本质不同子串个数$</a></h3><p>类似于“区间元素数”，我们离线询问，给每种元素选一个特征点，对于每个右端点维护左端点的答案。具体来说，每次更新以当前位置为右端点的串的 $lstpos$，一个长度为 $T$ 的串对左端点在 $[1, lstpos - T + 1]$ 的询问有贡献。</p><p>考虑 $SAM$，区间右端点右移至 $r$ 在 $SAM$ 上就要把一整条路径集合里的子串 $lstpos$ 更改为 $r$。暴力做显然补星。这是个链赋值操作，于是考虑 $LCT$ + $tag$。每个位置 $access$ 后到根的路径上 $lstpos$ 都相同，且代表的子串长度连续（根据 $endpos$ 的定义），可以直接区间修改区间查询。</p><h3 id="事情的相似度"><a href="#事情的相似度" class="headerlink" title="$事情的相似度$"></a><a href="https://loj.ac/p/6041" target="_blank" rel="noopener">$事情的相似度$</a></h3><p>两个前缀 $x$ 和 $y$ 的最长公共后缀就是 $parent$ 树上的 $len[lca(x, y)]$。现在要求区间最深 $len[lca]$。</p><p>考虑离线询问，每次右移考虑 $r$ 的贡献。$SAM$ 上每个点维护它到目前被到达的最大时间，$LCT$ $access$ 赋值打标记（同一条链上的最大时间肯定相同），每次跳 $parent$ 树更新答案，注意更新的是一个区间的答案，线段树取 $\max$。</p><p>还有一种做法：容易想到 $dfn$ 序越近的对越优秀，不是最近的对对于答案没有贡献。想到启发式合并 $endpos$ 集合，$set$ 维护，找前驱后继。——查询区间啊，怎么办？注意到是三元组 $(l, r, v)$ ，丢到二维平面上二维数点就好。</p><p>记录 xml 的每日 sb：<strong>$parent$ 树上节点 $x$ 的祖先 $id$ 一定都小于 $x$，后代不一定小于 $x$。为什么？怎么建树的你看看去。</strong> 所以要处理一个按长度从大到小的操作序列。</p><p>都是两只 $log$ 的。因为「区间本质不同子串」写过第一种做法啦，这里想试试第二种！（哦呼</p><p><a href="https://loj.ac/s/1022230" target="_blank" rel="noopener">$Code$</a></p><h3 id="BJWC2018-Border-的四种求法"><a href="#BJWC2018-Border-的四种求法" class="headerlink" title="$BJWC2018-Border 的四种求法$"></a><a href="https://www.luogu.com.cn/problem/P4482" target="_blank" rel="noopener">$BJWC2018-Border 的四种求法$</a></h3><p>神题，比「区间本质不同子串」和「事情的相似度」高到不知道哪里去了。</p><p>往 $SAM$ 想，简直一脸蒙蔽啊。。这时候我们需要一些<strong>形式化</strong>：寻找最大的 $i$ 满足 $i - l + 1 \leq lcs(r, i)$，$lcs$ 是最长公共后缀</p><p>如果数据随机，那 $parent$ 树长得就比较平衡，树高 $log$，暴跳 + 查询每个 $r$ 的祖先 $endpos$ 集合里满足限制的 $i$ 最大值，线段树合并 $endpos$ 即可。</p><p>如果不随机呢？树高就 $O(n)$ 啦。不会做啦，$GG$ 啦。看题解啦。 <a href="https://www.luogu.com.cn/blog/c2522943959/solution-p4482" target="_blank" rel="noopener">题解</a></p><p>树分治/链分治，对重边的处理和轻边的合并及处理往往具有优秀的实现方法及复杂度，被套在树上问题也是很常见的啊啦啦！！</p><p>考虑一个询问查询了其子树的贡献和其所有祖先及祖先其他子树的贡献，子树贡献可以线段树合并照旧算。祖先呢？</p><p>考虑重链剖分后把询问复制 $log$ 份挂到祖先重链上（与它到根的路径交叉部分的末端），这样就只要分别处理每条链的询问了。总点数 $O(nlogn)$。</p><p>每条链从上到下把轻儿子的贡献合并进来，可以暴力插贡献因为轻儿子总数也就 $O(nlogn)$，拿一个下标为 $i$、权值为 $i - len[lca] + 1$ 的线段树维护区间最小值，这样查询在线段树上二分、根据最小值做出决策就可以了。</p><p>说说就好烦了呢qwq，写了一晚上 + 调了半个上午 200 行终于 AC 了呢qwq！多想，多思考。</p><p><a href="https://www.luogu.com.cn/record/44414778" target="_blank" rel="noopener">$Code$</a></p><h3 id="NOI2018-你的名字"><a href="#NOI2018-你的名字" class="headerlink" title="$NOI2018-你的名字$"></a><a href="https://loj.ac/p/2720" target="_blank" rel="noopener">$NOI2018-你的名字$</a></h3><p>问啥？询问串有多少个子串不是另一个询问串的子串。我们要求的是用 T 的本质不同子串个数 - 两串本质不同公共子串个数。</p><p>假设 $l = 1$, $r = |S|$, 答案就是 $\sum\limits_{i = 2}^{T.cnt} max(0, len[i] - max(len[fa[i]], 第一次走到 i 的 T 串位置与 S 的 LCS))$ 为什么是第一次走到？第一次走到就是最远的嘛，是 $(len[fa[i]], len[i]]$ 的 $len[i]$ 而不是 $len[fa[i]] + 1$。为什么要最远？本质不同公共子串个数等于要在 $parent$ 树上取路径并啊。</p><p>若 $l$ 和 $r$ 任意，加一个线段树合并 $endpos$ 集合帮助在跳 $S$ 的 $parent$ 树时判断当前位置是否合法，就可以了。</p><hr><p>广义 SAM！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200808 题解</title>
      <link href="2020/08/08/XJOI200808%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/08/XJOI200808%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>咕咕</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>部分分提醒正解。考虑 n &lt;= 2 时，设 $a_1 = A$, $a_2 = B$，那么 A 先取完时期望个数就是 $a_1 + \sum\limits_{i = 0}^{B - 1} \frac{C(A - 1 + i, i)}{2^{B + 1}} i$，B 先取完时就是 $a_1 + \sum\limits_{i = 0}^{A - 1} \frac{C(B - 1 + i, i)}{2^{B + 1}} B$。</p><p>根据期望的线性性质，$ans = (\sum\limits_{i = 2}^n \{第 i 个被拿的期望个数\}) + a_1$。现在就是怎么求解每种球的期望个数。我们设第 i 种球的期望个数为 $f_i$。</p><p>注意到选颜色是<strong>等概率</strong>的。本题中唯一的限制就是第一种球必须取完，那么 $f_i$ 只与在第一种球取完前 取了多少个第 i 种球有关，取其他球对它们没有影响，而且它们被取的概率是相同的，那就等价于之前的部分分算法。这样是 60 分。</p><p>考虑优化：将上面的方法看作从 $(a_1, a_i)$ 出发每次随机向下或向左走一步，直到走到坐标轴。走到 $(0, a)$ 的贡献是 $a_i - a$，走到 $(a, 0)$ 的贡献是 $a_i$，就能列出贡献柿子：</p><script type="math/tex; mode=display">f_i = \sum\limits_{j = 0}^{a_i - 1} \frac{C(a_1 - 1 + j, j)}{2^{a_1 + j}} \times j + a_i(1 - \sum\limits_{j = 0}^{a_i - 1} \frac{C(a_1 - 1 + j, j)}{2^{a_1 + j}})</script><p>容易发现 $a_i$ 增加 1 的时候 两部分的贡献分别都只会增加一项，可以 O(1) 算！这样就能线性求解了，是 O(值域) 的。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ310]-黎明前的巧克力</title>
      <link href="2020/08/08/%5BUOJ310%5D-%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/"/>
      <url>2020/08/08/%5BUOJ310%5D-%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>求的就是 $\sum\limits_{xor(S) = 0} 2^{|S|}$</p><p><strong>考虑它的生成函数</strong>: $\prod (1 + 2x^{\{a_i\}})$，其中这里的 $\prod$ 表示异或卷积</p><p>直接 FWT + 点乘 肯定不行。。</p><p>发现对 $(1 + 2x^{a_i})$ 做 FWT 后的点值不是 -1 就是 3（1 也就是 $x^0$，它对每位的贡献是 1，$2x^{a_i}$ 对每位的贡献是 2 或 -2），那么我们只要知道每位有多少个 -1/3 就好了</p><p>有个性质：线性变换的和 = 和的线性变换，于是我们把所有多项式加起来做一遍 FWT，对于第 $i$ 位设有 $k$ 个 -1，那么 $-k + 3(n - k) = f_i$（$f_i$ 就是和的 FWT），就能解出 $k$，也就得到了第 $i$ 位点乘的结果！然后一遍 IFWT 就好了！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">2e6</span> + <span class="number">10</span>, inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">ll n, a[N], f[N], bit3[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(ll a[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!((j &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                ll x = a[j], y = a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))];</span><br><span class="line">                a[j] = (x + y) % mod, a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] = (x - y + mod) % mod;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">-1</span>) (a[j] *= inv2) %= mod, (a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] *= inv2) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = n;</span><br><span class="line">    bit3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        bit3[i] = bit3[i - <span class="number">1</span>] * <span class="number">3</span> % mod;</span><br><span class="line">        f[a[i]] += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FWT_xor(f, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">    ll inv4 = quick_pow(<span class="number">4</span>, mod - <span class="number">2</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = ((<span class="number">3</span> * n - f[i] + mod) % mod) * inv4 % mod;</span><br><span class="line">        f[i] = (k &amp; <span class="number">1</span> ? mod - bit3[n - k] : bit3[n - k]);</span><br><span class="line">    &#125;</span><br><span class="line">    FWT_xor(f, <span class="number">20</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (f[<span class="number">0</span>] - <span class="number">1</span> + mod) % mod);  <span class="comment">// 减去空集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】集合幂级数</title>
      <link href="2020/08/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
      <url>2020/08/07/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200807 题解</title>
      <link href="2020/08/07/XJOI200807%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/07/XJOI200807%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>这题就是典型的部分分提醒正解。</p><p>01 那部分可以引导想到 bitset，但 $O(q <em> n / 32)$ 的显然不对，于是想到 $O(q </em> 2^k / 32)$ 的，即 $f[i, s]$ 表示在第 i 个所在集合 s 中有没有值“扩散”到第 i 个，然后 or 和 and 操作能分别代替 max 和 min 操作，就做完了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, Q, cnt;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>][N], b[<span class="number">13</span>][N], t[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">bitset</span>&lt;4096&gt; B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, K) rep(j, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, K) t[i] = a[i][j];</span><br><span class="line">        sort(t + <span class="number">1</span>, t + K + <span class="number">1</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, K) b[i][j] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, K) <span class="keyword">if</span> ((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) B[i][s] = <span class="number">1</span>;</span><br><span class="line">    cnt = K;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            B[++cnt] = (B[x] | B[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            B[++cnt] = (B[x] &amp; B[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = K; j; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                rep(i, <span class="number">1</span>, K) <span class="keyword">if</span> (a[i][y] &gt;= b[j][y]) s |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (B[x][s]) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[j][y]); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>显然要枚举最终颜色 $i$。问题抽象成有 $s + 1$ 个点 $0 ~ s$，当前在 $a_i$，每步可以向左向右或不动，问走到 $s$ 的期望步数，其中在 $0$ 点和 $s$ 点时都是 0。</p><p><a href="https://www.luogu.com.cn/blog/cjyl/solution-cf850f" target="_blank" rel="noopener">题解</a>，等差数列那里还是比较妙的！其实期望题多是从概念出发，我还是概念不清啊。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>看起来就很套路的题。想到转化就好不少= =</p><p>这个平方很难搞啊！考虑它的实际意义：连通块路径数期望的两倍。根据期望的线性性质，我们可以把大期望化成小期望，分别考虑每条路径的贡献。（套路！有碰到过好几次啊啊啊）</p><p>设 $p(i, x, y)$ 表示 $x$、$y$ 在 $i$ 天后还在同一连通块的概率，显然前 $i - 1$ 天 $x$ 到 $y$ 的路径上的边都没被砍，因此</p><script type="math/tex; mode=display">p(i, x, y) = \frac{ C(n - 1 - dist(x, y), i - 1) }{ C(n - 1, i - 1) } = \frac{(n - i)!(n - 1 - dist(x, y))!}{(n - 1)!(n - i - dist(x, y))!}</script><p>设 $E(i)$ 表示第 $i$ 天的路径数期望，那么</p><script type="math/tex; mode=display">E(i) = \sum\limits_{x, y \in V} p(i, x, y) \times 1</script><p>枚举 $z = dist(x, y)$ 就能把组合数拆开，就可以化成卷积形式了。设 $g(z)$ 表示 $dist(x, y) = z$ 的 $(x, y)$ 对数（点分治 + FFT），那么</p><script type="math/tex; mode=display">E(i) = \frac{(n - i)!}{(n - 1)!} \sum\limits_z g(z) \times (n - 1 - z)! \times \frac{1}{(n - i - z)!}</script><p>卷积形式，FFT 就做完了。</p><p>调到去世，发现是三处sb错误 ：）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, l, lim;</span><br><span class="line">ll f[N][<span class="number">20</span>], rev[N];</span><br><span class="line">ll fac[N], inv[N], F[N], G[N], A[N], B[N];</span><br><span class="line">ll sz[N], rt, T, mark[N], len[N], tot, bin[N], mxdep, num[N], mx[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) inv[i] = inv[i] * inv[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    l = <span class="number">0</span>, lim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n) l++, lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) (a[i] *= Inv) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>, mx[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        getrt(y, x);</span><br><span class="line">        sz[x] += sz[y], mx[x] = max(mx[x], sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[x] = max(mx[x], T - sz[x]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x] &lt; mx[rt]) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, ll dep)</span> </span>&#123;</span><br><span class="line">    ++bin[dep];</span><br><span class="line">    mxdep = max(mxdep, dep);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa || mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        getdis(y, x, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    get_rev(mxdep &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, mxdep) A[i] = B[i] = bin[i], bin[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, mxdep + <span class="number">1</span>, lim - <span class="number">1</span>) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) A[i] = (A[i] * B[i]) % mod;</span><br><span class="line">    NTT(A, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, min(n, mxdep &lt;&lt; <span class="number">1</span>)) num[i] = (num[i] + op * A[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mark[x] = <span class="number">1</span>, mxdep = <span class="number">0</span>, getdis(x, <span class="number">0</span>, <span class="number">0</span>), calc(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        mxdep = <span class="number">0</span>, getdis(y, x, <span class="number">1</span>), calc(<span class="number">-1</span>);  <span class="comment">// 容斥出一定经过 x 的路径数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (mark[y]) <span class="keyword">continue</span>;</span><br><span class="line">        T = sz[y], mx[rt = <span class="number">0</span>] = <span class="number">1e9</span>, getrt(y, x), solve(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    init(n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    T = n, mx[rt = <span class="number">0</span>] = <span class="number">1e9</span>, getrt(<span class="number">1</span>, <span class="number">0</span>), solve(rt);</span><br><span class="line">    get_rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) num[i] = (num[i] + mod) % mod;</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) A[i] = num[i] * fac[n - <span class="number">1</span> - i] % mod, B[i] = inv[i];</span><br><span class="line">    rep(i, n, lim - <span class="number">1</span>) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) A[i] = (A[i] * B[i]) % mod;</span><br><span class="line">    NTT(A, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, A[n - i - <span class="number">1</span>] * fac[n - i - <span class="number">1</span>] % mod * inv[n - <span class="number">1</span>] % mod);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[PKUWC2018]-随机游走</title>
      <link href="2020/08/06/%5BPKUWC2018%5D-%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/"/>
      <url>2020/08/06/%5BPKUWC2018%5D-%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/</url>
      
        <content type="html"><![CDATA[<p>终于来搞这个早就想搞的题了！！著名（雾）的 $minmax$ 题</p><p>据说可以<a href="https://www.cnblogs.com/Mychael/p/9229291.html" target="_blank" rel="noopener">不用 $minmax$ 容斥</a>，设 $f[i, S]$ 表示从 $i$ 出发走完 $S$ 集合的期望 + 把 dp 柿子表示成 $Ax + B$ 的形式就可以做到 $O(n2^n)$ 的复杂度。。。大同小异吧</p><p>考虑 $minmax$ 容斥，设 $f[i]$ 为从 $i$ 点出发，到达集合 $S$ 中第一个点的期望时间，那么只要计算 $f[x]$ 就好了。</p><p>本题是树的形态，可以推得：</p><ul><li>$x \in S$, $f[x] = 0$</li><li>$x \notin S$, $f[x] = \frac{f[fa_x]}{deg_x} + (\sum\limits_{y \in Son(x)}\frac{f[y]}{deg_x}) + 1$</li></ul><p>发现父亲和儿子很不好搞，而每个节点只有一个父亲，我们就用到一个套路：将 $f[x]$ 表示为 $A * f[fa] + B$ 的形式</p><p>从下往上做，推得：$A_x = \frac{1}{deg_x - \sum A_y}$, $B_x = \frac{\sum B_y + deg_x}{deg_x - \sum A_y}$</p><p>复杂度 $O(n2^n)$。可以用 FMT 或者 FWT_and 做容斥。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, M = <span class="number">20</span>, N = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, Q, st, S;</span><br><span class="line">ll f[N], g[N], deg[M], a[M], b[M];</span><br><span class="line"><span class="keyword">int</span> to[M &lt;&lt; <span class="number">1</span>], nxt[M &lt;&lt; <span class="number">1</span>], lnk[M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((S &gt;&gt; (x - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        a[x] = b[x] = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] = b[x] = deg[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        a[x] = (a[x] - a[y] + mod) % mod;</span><br><span class="line">        b[x] = (b[x] + b[y]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] = quick_pow(a[x], mod - <span class="number">2</span>);</span><br><span class="line">    b[x] = a[x] * b[x] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i += (k &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)</span><br><span class="line">                f[i + j + k] = (f[i + j + k] + f[i + j] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> ((j &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>)</span><br><span class="line">                f[j] = (f[j] + f[j - (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q &gt;&gt; st;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">        ++deg[x], ++deg[y];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">1</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &#123;</span><br><span class="line">        S = s; dfs(st, <span class="number">0</span>);</span><br><span class="line">        f[s] = (__builtin_popcount(s) &amp; <span class="number">1</span>) ? b[st] : mod - b[st];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FWT_or();  // 两个等价的。都可以。</span></span><br><span class="line">    FMT();</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x, bit = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), bit |= (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[bit]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> minmax容斥 </tag>
            
            <tag> 集合幂级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[清华集训2017]-无限之环</title>
      <link href="2020/08/06/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%5D-%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/"/>
      <url>2020/08/06/%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%5D-%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>好神奇的题！</p><p>与联通性相关的最优性问题，先考虑插头dp，但是数据范围过大，gg。</p><p>观察图形发现是有限种上下左右的接口（注意直管不能翻转），而且是<strong>网格图</strong>，于是考虑费用流。（根本想不到且就算知道了也依旧不会做啊啊啊）</p><ul><li>怎么判断图是否漏水？</li></ul><p>发现水在相邻的格子间流动，<strong>不漏等价于相邻格子间接口能对上</strong>，那么把接口抽象成管道就是 容量为 1 且必须满流。那么黑白染色，白点连 S，黑点连 T，每个格子分成上下左右中五个点，对于白点，中间指向周围；对于黑点，周围指向中间。这样满流，即流量等于接口数，就是不漏。（同时也有了让水流动的动力！）</p><p>考虑旋转怎么处理：改变的接口对应连边，注意容量都是 1，这样跑费用流的时候一个格子只能选一种状态。</p><p>代码在 uoj 上并没有 AC，T 了很多发，大概是建边不够优秀，然而不想改了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, st, ed, idx, t1, t2, num;</span><br><span class="line"><span class="keyword">int</span> id[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = N * <span class="number">5</span>, MM = N * <span class="number">100</span>;  <span class="comment">// 开足了！！！</span></span><br><span class="line">    <span class="keyword">int</span> lnk[M], fr[MM], to[MM], nxt[MM], cnt = <span class="number">1</span>, cap[MM], val[MM];</span><br><span class="line">    <span class="keyword">int</span> level[M], dis[M], pre[M], inq[M];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++num;</span><br><span class="line">        to[++cnt] = y, fr[cnt] = x, nxt[cnt] = lnk[x], lnk[x] = cnt, cap[cnt] = c, val[cnt] = v;</span><br><span class="line">        to[++cnt] = x, fr[cnt] = y, nxt[cnt] = lnk[y], lnk[y] = cnt, cap[cnt] = <span class="number">0</span>, val[cnt] = -v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        add(x, y, c, v), add(y, x, c, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, T) dis[i] = inf, pre[i] = inq[i] = <span class="number">0</span>;</span><br><span class="line">        inq[S] = <span class="number">1</span>;</span><br><span class="line">        q.push(S);</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = to[i];</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &amp;&amp; dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                    dis[y] = dis[x] + val[i];</span><br><span class="line">                    pre[y] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[y]) q.push(y), inq[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != inf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">McMf</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (spfa(S, T)) &#123;</span><br><span class="line">            --t1;</span><br><span class="line">            cost += dis[T];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = T; x != S; x = fr[pre[x]]) &#123;</span><br><span class="line">                cap[pre[x]]--, cap[pre[x] ^ <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t1 ? <span class="number">-1</span> : cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> MCMF;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) rep(k, <span class="number">0</span>, <span class="number">4</span>) id[i][j][k] = ++idx;</span><br><span class="line">    st = <span class="number">0</span>, ed = ++idx;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add(id[i][j][<span class="number">4</span>], id[i][j][k], <span class="number">1</span>, <span class="number">0</span>), ++cnt;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = i + dx[k], ty = j + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (tx &amp;&amp; ty &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m) add(id[i][j][k], id[tx][ty][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(st, id[i][j][<span class="number">4</span>], cnt, <span class="number">0</span>);</span><br><span class="line">            t1 += cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add(id[i][j][k], id[i][j][<span class="number">4</span>], <span class="number">1</span>, <span class="number">0</span>), ++cnt;</span><br><span class="line">            add(id[i][j][<span class="number">4</span>], ed, cnt, <span class="number">0</span>);</span><br><span class="line">            t2 += cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">5</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                add2(id[i][j][(k + <span class="number">1</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][(k + <span class="number">3</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], id[i][j][k], <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> (!((x &gt;&gt; k) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">1</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">3</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add2(id[i][j][k], id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">3</span>) <span class="keyword">if</span> ((x &gt;&gt; k) &amp; <span class="number">1</span>) add2(id[i][j][k], id[i][j][(k + <span class="number">2</span>) &amp; <span class="number">3</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("%d\n", cnt);</span></span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, McMf(st, ed));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 011 题解</title>
      <link href="2020/08/05/AGC%20011%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/05/AGC%20011%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>AB 水题= =</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>C 比 D 难诶 /kk</p><p><a href="https://blog.csdn.net/WerKeyTom_FTD/article/details/78216823?locationNum=5&amp;fps=1" target="_blank" rel="noopener">看了题解</a></p><p>特——别好的题！二分图真香</p><p>$C = V - E + F$ 学呆了，用不到就有点难受= = ？</p><p>原图中的独立点是最好搞的，设独立点个数为 p，则贡献为 $np * 2 - p^2$</p><p>考虑题目条件：$(a, b)$ 到 $(c, d)$ 有边当且仅当 $a -&gt; c$，$b -&gt; d$，等价于 $a、b$ 同时移动了一步到达 $c、d$。因此推得状态 $(a, b)$ 能到达状态 $(c, d)$ ，显然当且仅当路径 $a -&gt; c$ 和 $b -&gt; d$ 的<strong>奇偶性相同</strong>。由此联想到<strong>二分图</strong>。</p><p>考虑“特征点”$(x, y)$ 即无法在新图连通块内到达 $(t, k)$ 使得 $t &lt; x$ 或到达 $(x, z)$ 使得 $z &lt; y$。可以理解为字典序最小。<strong>显然特征点个数就是连通块个数。</strong></p><p>我们发现，特征点第一维 $x$ 必须是原图连通块中最小的点。第二维 $y$ 可以是最小的点。但如果 $y$ 所在连通块是二分图，且和所在连通块里的最小点 $z$ 不在同一边，就无法变成 $z$（ $(x, y) -&gt; (x, z)$，$x -&gt; x$ 的奇偶性可以看作偶，那么 $y -&gt; z$ 的奇偶性如果是奇就不行）。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>找规律发现滚一次球后串变为取反后左移一位，末尾补位A。大致原因就是</p><ul><li>A-&gt; B 变成 A A-&gt;</li><li>A-&gt; A 变成 B A-&gt;</li><li>开头和结尾也符合规律</li></ul><p>发现 2n 步（不是 n 步，因为串的奇偶性有影响）必然会把初始的串给替换掉（可以理解为一位一位溢出了，其中有至多 n 步是第一位为 A 的要弹回），串就变成了 ABABAB… 或者 BABABA… 的形式，讨论一下奇偶性就好了</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>咕咕</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】xza《Graph Theory》</title>
      <link href="2020/08/04/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91xza%E3%80%8AGraph%20Theory%E3%80%8B/"/>
      <url>2020/08/04/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91xza%E3%80%8AGraph%20Theory%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TC10947-TwoSidedCards"><a href="#TC10947-TwoSidedCards" class="headerlink" title="$TC10947-TwoSidedCards$"></a><a href="https://vjudge.net/problem/TopCoder-10947" target="_blank" rel="noopener">$TC10947-TwoSidedCards$</a></h2><hr><p>正-反，二元关系，想到正反面数字对应连边，每张卡都变成了一条有向边。</p><p>我们发现形成的图是一个环！！因为正反都是排列，每个数字的度数都是 2。</p><p>分环讨论，设当前环长度为 $L$，选了 $k$ 个数字，显然相邻的不能选，所以方案数就是 $C(L, 2k)$ 还要 $*2$。</p><p>背包合并。</p><h2 id="CF547D-Mike-and-Fish"><a href="#CF547D-Mike-and-Fish" class="headerlink" title="$CF547D-Mike and Fish$"></a><a href="https://codeforces.com/problemset/problem/547/D" target="_blank" rel="noopener">$CF547D-Mike and Fish$</a></h2><hr><p><a href="https://blog.csdn.net/PoPoQQQ/article/details/46125833" target="_blank" rel="noopener">题解</a></p><p>和上一题有异曲同工之妙。行-列，想到二元关系，于是行列建点，每个点都变成了一条有向边。设红色表示入边，蓝色表示出边，我们要给边定向，使得新图每个点的入度出度之差不超过 1。</p><p>怎么做？考虑<strong>构造欧拉回路</strong>。复习一波欧拉回路的定义：欧拉回路是经过图 G 中<strong>所有</strong>边的回路。但目前二分图中有偶数个（一定是偶数个，因为保证有解）奇数度点。有奇数度点就很难处理！</p><p>可以将奇数度点两两配对（通过连一些无关紧要的辅助边），对于每个连通块选一个初始为奇数度的点跑（注意先跑辅助边），没有就跑初始为偶数度的点，欧拉回路红蓝染色，就很好写。</p><p>这个正确性比较显然：欧拉回路上每个点入度出度都想同，每个点连的辅助边最多 1 条，删去辅助边后仍能满足限制。</p><p>复习欧拉回路基本写法：套圈法，其实就是把不同的环连在一起，<strong>dfs 函数还是有不少细节的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">            mark[i] = mark[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            lnk[x] = nxt[i];  <span class="comment">// 当前弧优化</span></span><br><span class="line">            dfs(to[i]);</span><br><span class="line">            stk[++top] = id[i];</span><br><span class="line">            i = lnk[x];  <span class="comment">// !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TC12330-CoinsGame"><a href="#TC12330-CoinsGame" class="headerlink" title="$TC12330-CoinsGame$"></a><a href="https://vjudge.net/problem/TopCoder-12330" target="_blank" rel="noopener">$TC12330-CoinsGame$</a></h2><hr><p>假装你已经知道这是“等价类”的题目。考虑两个格子等价，当且仅当任意操作后原本在两个格子上的硬币要么同时在棋盘上，要么同时移出了棋盘，那么合法的方案至少有一个这样的格子对。</p><p>发现正做很难，考虑补集转化。发现等价的关系是可以传递的，那么就形成了很多个团。等价关系可以 bfs 找，并查集维护。用总方案减去只选这些团的方案数就好了。</p><h2 id="CF19E-Fairy"><a href="#CF19E-Fairy" class="headerlink" title="$CF19E-Fairy$"></a><a href="https://codeforces.com/problemset/problem/19/E" target="_blank" rel="noopener">$CF19E-Fairy$</a></h2><hr><p>很好的题。</p><p><strong>对于环的题目，可以考虑 dfs 树，因为有个很优的性质：所有环在 dfs 树上的体现就是 树边 + 返祖边（没有横叉边，因为是 dfs 树）</strong></p><p><strong>而环到 {返祖边集合} 是单射</strong></p><p>设奇环数为 $x$</p><ul><li>$x = 0$，删任何一条边都可以</li><li>$x = 1$，只能删奇环上的边</li><li>$x &gt; 1$，不能删返祖边。考虑所有的树边，能被删掉当且仅当所有的奇环经过了它且<strong>没有偶环经过它</strong></li></ul><p>树上差分就好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO2019 题解</title>
      <link href="2020/08/04/APIO2019%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/08/04/APIO2019%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="T1-奇怪装置"><a href="#T1-奇怪装置" class="headerlink" title="$T1. 奇怪装置$"></a><a href="https://loj.ac/problem/3144" target="_blank" rel="noopener">$T1. 奇怪装置$</a></h2><hr><p>考虑到这有周期性，我们思考时刻 $t1$ 和 $t2$ $(t1 &lt; t2)$ 在何时意义相同：设 $L = t2 - t1$ （$L$ 即是周期大小）</p><script type="math/tex; mode=display">L + \lfloor \frac{L}{B} \rfloor \equiv 0 (mod\ A)</script><script type="math/tex; mode=display">L \equiv 0 (mod\ B)</script><p>那么那个下取整就可以拆了，整理一下：</p><script type="math/tex; mode=display">\frac{L(B + 1)}{B} \equiv 0 (mod\ A)</script><p>有一个定理：$ac \equiv bc(mod m)$，则 $a \equiv b(mod \frac{m}{gcd(m, c)})$，于是</p><script type="math/tex; mode=display">L \equiv 0 (mod\ \frac{AB}{gcd(AB, B + 1)})</script><p>而因为 $gcd(x, x + 1) = 1$ 恒成立，所以</p><script type="math/tex; mode=display">L \equiv 0 (mod\ \frac{AB}{gcd(A, B + 1)})</script><p>得到了周期大小，我们将区间在模 $L$ 意义下求区间覆盖就好了。</p><h2 id="T2-桥梁"><a href="#T2-桥梁" class="headerlink" title="$T2. 桥梁$"></a><a href="https://loj.ac/problem/3145" target="_blank" rel="noopener">$T2. 桥梁$</a></h2><hr><p>1、2、4档部分分都挺好拿的？那不就有 43 pts 了</p><p>考虑没有修改操作：对于每个询问，将值大于等于 wi 的边加入并查集，最终答案就是 si 所在并查集大小。但加入修改的话，枚举所有边或者所有操作都 TLE。显然这是因为，询问太多的时候枚举边会炸，修改太多的时候枚举操作会炸。</p><p>考虑<strong>均摊，把操作分块</strong>，设块大小为 S，每过 S 个操作就暴力重构一次。</p><p>具体来说，分块处理，将一个块内的所有询问按照重量从大到小排序，边枚举询问边将块内不修改的边插入；而对于块内修改的边，顶多 S 条，用可撤销并查集维护，暴力插入再暴力删除。</p><p>O(Q/S * mlogm + QS)，S 取 sqrt(mlogm) 的时候最优。我觉得这个分块很难想到，很神仙（虽然最终复杂度其实是 1e8，需要卡常</p><p>代码也太难写了吧！！！啊！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, Q, unit;</span><br><span class="line">ll fa[N], sz[N], pos[M], mark[M], pre[M], nxt[M];</span><br><span class="line">ll fax[M], fay[M], szx[M], szy[M], ans[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, z, id; &#125;e[M], e2[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> x, y, id; &#125;q1[M], q2[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpe</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.z &gt; b.z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpq2</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.y &gt; b.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz[x] &gt; sz[y]) swap(x, y);</span><br><span class="line">    fa[x] = y, sz[y] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">1</span>, ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) ch == <span class="string">'-'</span> ? ff = <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    x = ch &amp; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch = getchar())) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch &amp; <span class="number">15</span>);</span><br><span class="line">    x = x * ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unit = max(unit, <span class="number">1l</span>l);  <span class="comment">// !!!!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span>; o &lt;= (Q - <span class="number">1</span>) / unit + <span class="number">1</span>; ++o) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = (o - <span class="number">1</span>) * unit + <span class="number">1</span>, r = min(o * unit, Q), l1 = <span class="number">0</span>, l2 = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) mark[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> op; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                ++l1;</span><br><span class="line">                read(q1[l1].x), read(q1[l1].y);</span><br><span class="line">                <span class="keyword">if</span> (pre[q1[l1].x]) nxt[pre[q1[l1].x]] = l1;</span><br><span class="line">                pre[q1[l1].x] = l1;</span><br><span class="line">                nxt[l1] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mark[q1[l1].x])  <span class="comment">// !!!!</span></span><br><span class="line">                    mark[q1[l1].x] = i;</span><br><span class="line">                q1[l1].id = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++l2;</span><br><span class="line">                read(q2[l2].x), read(q2[l2].y);</span><br><span class="line">                q2[l2].id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(e2, e, <span class="keyword">sizeof</span>(*e) * (m + <span class="number">1</span>));  <span class="comment">// ！！！！！！注意这么写会快很多</span></span><br><span class="line">        sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmpe);</span><br><span class="line">        sort(q2 + <span class="number">1</span>, q2 + l2 + <span class="number">1</span>, cmpq2);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, n) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, l2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= m &amp;&amp; e[pos].z &gt;= q2[i].y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mark[e[pos].id]) &#123;</span><br><span class="line">                    merge(e[pos].x, e[pos].y);</span><br><span class="line">                &#125;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(j, <span class="number">1</span>, l1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((!nxt[j] || q1[nxt[j]].id &gt; q2[i].id) &amp;&amp; q1[j].y &gt;= q2[i].y &amp;&amp; q1[j].id &lt; q2[i].id) ||  <span class="comment">// 询问前最后一次修改或修改在询问后但之前的边重量符合条件</span></span><br><span class="line">                    (mark[q1[j].x] &gt; q2[i].id &amp;&amp; e2[q1[j].x].z &gt;= q2[i].y)) &#123; <span class="comment">// e 排序了，要有个 e2 来存原来的顺序</span></span><br><span class="line">                    <span class="keyword">int</span> x = getfa(e2[q1[j].x].x), y = getfa(e2[q1[j].x].y);</span><br><span class="line">                    fax[j] = x, fay[j] = y, szx[j] = sz[x], szy[j] = sz[y];</span><br><span class="line">                    merge(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[q2[i].id] = sz[getfa(q2[i].x)];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l1; j; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fax[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = fax[j], y = fay[j];</span><br><span class="line">                    fa[x] = x, fa[y] = y, sz[x] = szx[j], sz[y] = szy[j];</span><br><span class="line">                    fax[j] = fay[j] = szx[j] = szy[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(e, e2, <span class="keyword">sizeof</span>(*e) * (m + <span class="number">1</span>));</span><br><span class="line">        rep(i, <span class="number">1</span>, l1)</span><br><span class="line">            e[q1[i].x].z = q1[i].y;</span><br><span class="line">        rep(i, <span class="number">1</span>, r - l + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (ans[i]) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    unit = <span class="built_in">sqrt</span>(m * <span class="built_in">log</span>(m) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].z);</span><br><span class="line">        e[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3-路灯"><a href="#T3-路灯" class="headerlink" title="$T3. 路灯$"></a><a href="https://loj.ac/problem/3146" target="_blank" rel="noopener">$T3. 路灯$</a></h2><hr><p>两道数据结构题！！！。。。1、2、4 档分好好拿呀= = 看题解学了正解。</p><p>考虑在连通区间 $[l, r]$ 中去掉一条边 $[k, k + 1]$，影响的只是 $[l, k]$ 到 $[k + 1, r]$ 的联通性。</p><p>考虑将贡献差分，时间段 = 时间点相减：</p><ul><li>加入边，$[l, k]$ 到 $[k + 1, r]$ 所有答案 $- i$</li><li>删除边，$[l, k]$ 到 $[k + 1, r]$ 所有答案 $+ i$</li></ul><p>同时对于询问的时刻 t，若两个点连通，答案要 $+ t$</p><p>看到点对，想到转化成平面问题。把区间抽象成坐标，就是二维数点问题，离线用树状数组套线段树或者 CDQ 分治。$O(nlog^2n)$</p><p>然而代码先咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Boruvka</title>
      <link href="2020/08/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Boruvka/"/>
      <url>2020/08/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Boruvka/</url>
      
        <content type="html"><![CDATA[<p>$Boruvka..Bvrouka…Brouvka….???$</p><p>$Boruvka$ 是一个古老的最小生成树算法，综合了 $Kruskal$ 和 $Prim$.（我觉得更像是进阶版 $Prim$）</p><p>它的算法流程是：初始时每个节点都是一个连通块，每次从<strong>每个</strong>块伸出去一条最短边，然后把新形成的连通块缩成一个新的块。每次 块个数至少减半，所以时间复杂度是 log 的。算法正确性可以参考 $Prim$ 的，相当于每次扩展多棵子树。</p><p>B <strong>合并只有 log 次</strong>，这是 K 和 P 做不到的。</p><p>通常它作为一种<strong>思想</strong>会很有用，比如<strong>位运算生成树</strong>，通常是边权难以直接维护的。</p><h2 id="CF888G"><a href="#CF888G" class="headerlink" title="$[CF888G]$"></a>$[CF888G]$</h2><hr><p>题意：边 $<i, j>$ 边权为 $a_i XOR a_j$ 的最小生成树</i,></p><p>考虑 $Trie$ 树，共有 $n - 1$ 个 $LCA$（$n - 1$ 个有两个儿子的节点）</p><p>根据 B 算法的<strong>思想</strong>，（将每个子树视为一个块），容易发现若 $x$ 同时有 $0/1$ 子树，两个子树就会连边</p><p>遍历 $Trie$ 树，在每个 $LCA$ 处做启发式合并、查左右子树连边的最小值</p><h2 id="CF1305G"><a href="#CF1305G" class="headerlink" title="$[CF1305G]$"></a>$[CF1305G]$</h2><hr><p>题意：连边 $<i, j>$ 规则为 $a_i AND a_j = 0$ 的最大生成树</i,></p><p>注意到这是一棵树，且它的特性在于，每个点的入度仅为 1.</p><p>于是有个很妙的方法：将每条边权值改为 $a_i + a_j$，最终答案是边权和 $- \sum{a_i}$，那么答案就转化成最大生成树。</p><p>$boruvka$ 算法直接做，每一轮子集 dp 维护出每个二进制集合内最大和次大的点权，<strong>两个点所在集合不同</strong>，这样查询的时候查询补集，就算最大的点权和当前点在同一集合里，也能“撞”掉，选到次大点。可以用 pair 记录 &lt;点权，集合的id&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, a[N], fa[N], cnt;</span><br><span class="line">ll ans;</span><br><span class="line">pii mx[M][<span class="number">2</span>], cur[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), fa[i] = i;</span><br><span class="line">        ans -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, M - <span class="number">1</span>)</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                mx[i][j] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            pii t = make_pair(a[i], getfa(i));</span><br><span class="line">            <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>] &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>].se != t.se) mx[a[i]][<span class="number">1</span>] = mx[a[i]][<span class="number">0</span>];</span><br><span class="line">                mx[a[i]][<span class="number">0</span>] = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[a[i]][<span class="number">1</span>] &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mx[a[i]][<span class="number">0</span>].se != t.se) mx[a[i]][<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, M - <span class="number">1</span>) &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">18</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mx[i][<span class="number">0</span>] &lt; mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mx[i][<span class="number">0</span>].se != mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k].se) mx[i][<span class="number">1</span>] = mx[i][<span class="number">0</span>];</span><br><span class="line">                            mx[i][<span class="number">0</span>] = mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[i][<span class="number">1</span>] &lt; mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mx[i][<span class="number">0</span>].se != mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k].se) mx[i][<span class="number">1</span>] = mx[i ^ (<span class="number">1</span> &lt;&lt; j)][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, n)</span><br><span class="line">            cur[i] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = getfa(i);</span><br><span class="line">            <span class="keyword">int</span> t = ((M - <span class="number">1</span>) ^ a[i]);</span><br><span class="line">            <span class="keyword">if</span> (mx[t][<span class="number">0</span>].se != <span class="number">-1</span> &amp;&amp; mx[t][<span class="number">0</span>].se != f) &#123;</span><br><span class="line">                cur[f] = max(cur[f], make_pair(mx[t][<span class="number">0</span>].fi + a[i], mx[t][<span class="number">0</span>].se));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx[t][<span class="number">1</span>].se != <span class="number">-1</span> &amp;&amp; mx[t][<span class="number">1</span>].se != f) &#123;</span><br><span class="line">                cur[f] = max(cur[f], make_pair(mx[t][<span class="number">1</span>].fi + a[i], mx[t][<span class="number">1</span>].se));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == i &amp;&amp; merge(i, cur[i].se)) &#123;</span><br><span class="line">                cnt--, ans += cur[i].fi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(2^{18} <em> 18 </em> logn)$</p><h2 id="UOJ176"><a href="#UOJ176" class="headerlink" title="$[UOJ176]$"></a>$[UOJ176]$</h2><hr><p>题意：边 $<i, j>$ 边权为 $a_i AND a_j$ 的最大生成树</i,></p><p>通过 cf1305g，我们积累了一定的经验。直接想到 B 算法，现在的问题就是怎么维护 a &amp; b 最大。</p><p>枚举子集的话应该可以做，不过是 3^18 的？</p><p>再想想 trie 树，我们发现跟 XOR 不同的是，1 的话走 1，0 的话走 0/1 皆可，可这样的复杂度是不对的啊，$O(n<em>2^m</em>logn)$ ！</p><p>这时只要<strong>自底向上</strong>（不然会出问题）将 1 子树合并到 0 子树上就好了！就变成了 1 走 1，0 走 0！复杂度就是 $O((n + 2^m) * mlogn)$</p><p>实现细节跟前一题一样，保留两个最大的 id，保证“撞”掉还有，查询的时候要求每时每刻走到的子树都有 和当前点不在同一集合的点</p><p>总之就是走 保证存在合法解的最优路径！</p><p>（还有一个完全不同、而且特别简单易懂的<a href="http://vfleaking.blog.uoj.ac/blog/1244" target="_blank" rel="noopener">好办法</a>，详见算法七）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, M = <span class="number">8e6</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;  <span class="comment">// 无语子😓 M 开 2 &lt;&lt; 18 就 MLE，开 8e6 就 AC。。。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, idx, rt, cas;</span><br><span class="line"><span class="keyword">int</span> a[N], fa[N], ch[M][<span class="number">2</span>], mx[M][<span class="number">2</span>];</span><br><span class="line">ll ans;</span><br><span class="line">pii cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] == mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">1</span>], mx[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &lt; mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">0</span>], mx[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &gt; mx[y][<span class="number">0</span>]) mx[x][<span class="number">1</span>] = max(mx[x][<span class="number">1</span>], mx[y][<span class="number">0</span>]);</span><br><span class="line">    mx[x][<span class="number">0</span>] = max(mx[x][<span class="number">0</span>], mx[y][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++idx;</span><br><span class="line">    ch[idx][<span class="number">0</span>] = ch[idx][<span class="number">1</span>] = <span class="number">0</span>, mx[idx][<span class="number">0</span>] = mx[idx][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">int</span> t = newnode();</span><br><span class="line">    ch[t][<span class="number">0</span>] = merge(ch[x][<span class="number">0</span>], ch[y][<span class="number">0</span>]);</span><br><span class="line">    ch[t][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], ch[y][<span class="number">1</span>]);</span><br><span class="line">    upd(t, x), upd(t, y);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>], rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (ls) dfs(ls, dep - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rs) dfs(rs, dep - <span class="number">1</span>);</span><br><span class="line">    ch[x][<span class="number">0</span>] = merge(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> dep, <span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx[x][<span class="number">0</span>] != id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx[x][<span class="number">0</span>] &lt; id) mx[x][<span class="number">1</span>] = mx[x][<span class="number">0</span>], mx[x][<span class="number">0</span>] = id;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mx[x][<span class="number">1</span>] &lt; id) mx[x][<span class="number">1</span>] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = ((val &gt;&gt; dep) &amp; <span class="number">1</span>);</span><br><span class="line">    insert(ch[x][c], dep - <span class="number">1</span>, val, id);</span><br><span class="line">    mx[x][<span class="number">0</span>] = mx[x][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    upd(x, ch[x][<span class="number">0</span>]), upd(x, ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>, (id == mx[x][<span class="number">0</span>] ? mx[x][<span class="number">1</span>] : mx[x][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = ((val &gt;&gt; dep) &amp; <span class="number">1</span>), ls = ch[x][<span class="number">0</span>], rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rs || (id == mx[rs][<span class="number">0</span>] &amp;&amp; mx[rs][<span class="number">1</span>] == <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(ls, dep - <span class="number">1</span>, val, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pii t = query(rs, dep - <span class="number">1</span>, val, id);</span><br><span class="line">            t.fi += (<span class="number">1</span> &lt;&lt; dep);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(ls, dep - <span class="number">1</span>, val, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ++cas;</span><br><span class="line">        rep(i, <span class="number">0</span>, idx) &#123;</span><br><span class="line">            ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            mx[i][<span class="number">0</span>] = mx[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = rt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            insert(rt, m, a[i], getfa(i));</span><br><span class="line">            cur[i] = make_pair(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(rt, m);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = getfa(i);</span><br><span class="line">            pii t = query(rt, m, a[i], f);</span><br><span class="line">            cur[f] = max(cur[f], t);</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == i &amp;&amp; cur[i].se &gt; <span class="number">0</span> &amp;&amp; unite(i, cur[i].se)) &#123;</span><br><span class="line">                cnt--, ans += cur[i].fi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Jul CF&amp;AT 练题汇总</title>
      <link href="2020/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jul%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/07/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jul%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CF1039D"><a href="#CF1039D" class="headerlink" title="CF1039D"></a><a href="https://www.luogu.com.cn/problem/CF1039D" target="_blank" rel="noopener">CF1039D</a></h2><hr><p>树的每个节点至多属于其中一条路径!!!</p><p>看到题目：这能做？能做？？能做？？？？</p><p>对不起，用根号分治就是能做（皮</p><ul><li>k &lt;= sqrt(n) 的暴力算，O(nsqrt(n))</li><li>k &gt; sqrt(n) 的，容易发现答案一定在 (0, sqrt(n)) 的区间内单调不增，最多只有 sqrt(n) 种，所以对于当前的 k 二分出与它答案相同的最右位置，更新这一段的答案</li></ul><p>复杂度 O(nsqrt(n)*logn)</p><p>HINT：常数巨大，普通 dfs 递归会 T。。要先处理 dfs 序然后从下往上 dp。。。5070ms。。。</p><p>据说能用整体二分做，先咕咕</p><h2 id="CF1039E"><a href="#CF1039E" class="headerlink" title="CF1039E"></a><a href="https://www.luogu.com.cn/problem/CF1039E" target="_blank" rel="noopener">CF1039E</a></h2><hr><p>LCT + 分块，先咕咕</p><h2 id="CF455D"><a href="#CF455D" class="headerlink" title="CF455D"></a><a href="https://www.luogu.com.cn/problem/CF455D" target="_blank" rel="noopener">CF455D</a></h2><hr><p>操作 1 每次只移动两位，而且操作 2 询问的信息可合并，可以用分块 + 双端队列，O(n <em> sqrt(n) </em> logn) cf 神评测机就跑过去了！</p><h2 id="CF1045B"><a href="#CF1045B" class="headerlink" title="CF1045B"></a><a href="https://www.luogu.com.cn/problem/CF1045B" target="_blank" rel="noopener">CF1045B</a></h2><hr><p><a href="https://www.cnblogs.com/yyf0309/p/9808323.html" target="_blank" rel="noopener">题解</a></p><p>妙题，容易想到 无法构成的数可以全用 A 中或全用 B 中的数构成。设不能构成的数为 t，A 中构成 t 的数为 X 和 Y。</p><p>由模的性质得，若 X &lt; t 则 Y &lt; t, 若 X &gt; t 则 Y &gt; t，所以任何一个 t 将 A 集合划为两半，每一部分首尾配对后，每对的和都等于 t</p><p>如何判 1 ~ i 首尾配对的值相同？设 1 &lt;= a &lt; b &lt; c &lt; d &lt;= i, 若 a + d = b + c 则 a - b = c - d，做一个差分然后跑 manacher 或 hash 判回文就好了，妙啊。</p><h2 id="CF1249D2"><a href="#CF1249D2" class="headerlink" title="CF1249D2"></a><a href="https://www.luogu.com.cn/problem/CF1249D2" target="_blank" rel="noopener">CF1249D2</a></h2><hr><p>贪心，我真的不行。。按左端点排序，从左往右扫，大根堆维护右端点，若左端点覆盖次数超过 K 则弹出堆顶线段</p><h2 id="CF255E"><a href="#CF255E" class="headerlink" title="CF255E"></a><a href="https://www.luogu.com.cn/problem/CF255E" target="_blank" rel="noopener">CF255E</a></h2><hr><p>第一次感觉博弈论没那么高冷哈哈哈</p><p>打出 1e6 的表发现 sg 值很小，只为 0 ～ 3。将 a 从小到大排序，尺取法做（就是双指针一样的，左端点挪+右端点挪）。</p><p>或者可以前缀和，记录 sum(i, j) 表示 1 ~ i 内 sg = j 的个数，这样就可以 O(1) 算！！</p><h2 id="CF280C"><a href="#CF280C" class="headerlink" title="CF280C"></a><a href="https://www.luogu.com.cn/problem/CF280C" target="_blank" rel="noopener">CF280C</a></h2><hr><p>一个节点有贡献 1 ，当且仅当它到根的路径上没有点染黑。所以选到它的概率是 1 / dep[x], 期望是 1 * 1 / dep[x]，跟除祖先们外的节点无关（其他不产生影响的就可以不管了，反正对于一个局部来说啥都没发生）</p><h2 id="CF200A"><a href="#CF200A" class="headerlink" title="CF200A"></a><a href="https://www.luogu.com.cn/problem/CF200A" target="_blank" rel="noopener">CF200A</a></h2><hr><p>暴力优化，非常之厉害</p><p>考虑多次询问一个位置，暴力查询的话会重复查询一些距离，开数组存一下就好了。</p><p>每次询问时更新，O(能过) 系列但真的跑的很快！</p><h2 id="CF208B"><a href="#CF208B" class="headerlink" title="CF208B"></a><a href="https://www.luogu.com.cn/problem/CF208B" target="_blank" rel="noopener">CF208B</a></h2><hr><p>n 很小，记忆化搜索。注意到每一位只受后第一位和后第三位影响，状态只要记录连续三位。</p><h2 id="CF187D"><a href="#CF187D" class="headerlink" title="CF187D"></a><a href="https://www.luogu.com.cn/problem/CF187D" target="_blank" rel="noopener">CF187D</a></h2><hr><p>发现被一个红灯卡了后，之后的花费都是可以预处理的（求一下每个点从 0 时刻走到终点的时间）。把 dist 都 mod(g + r)，问题就变成了求右边最近的 dist 在 [g, r - 1] 内的位置，权值线段树维护区间最小值</p><h2 id="CF190E"><a href="#CF190E" class="headerlink" title="CF190E"></a><a href="https://www.luogu.com.cn/problem/CF190E" target="_blank" rel="noopener">CF190E</a></h2><hr><p>复杂度是关于 m 的。。链表或 set 优化 bfs，每个点只会被访问度数次，复杂度 O(mlogn)</p><h2 id="CF191E"><a href="#CF191E" class="headerlink" title="CF191E"></a><a href="https://www.luogu.com.cn/problem/CF191E" target="_blank" rel="noopener">CF191E</a></h2><hr><p>求第 K 大连续区间的 val 和。考虑二分判定，离散化 + 树状数组维护。</p><h2 id="CF185D"><a href="#CF185D" class="headerlink" title="CF185D"></a><a href="https://www.luogu.com.cn/problem/CF185D" target="_blank" rel="noopener">CF185D</a></h2><hr><p>很好的数学题</p><p>设 $x = k^{2^l} + 1$</p><p>$k^{2^{l + 1}} + 1 = (x - 1)^2 + 1$</p><p>$gcd(x, (x - 1)^2 + 1) = gcd(x, x^2 - 2x + 1) = gcd(x, 2)$</p><ul><li>k 为奇数：ans = $\frac{PROD}{2^{r - l}}$</li><li>k 为偶数：ans = $PROD$</li></ul><p>根据等比数列的知识，$PROD = \frac{(k^{2^{r + 1}} - 1)}{(k^{2^l} - 1)}$</p><h2 id="CF432D"><a href="#CF432D" class="headerlink" title="CF432D"></a><a href="https://www.luogu.com.cn/problem/CF432D" target="_blank" rel="noopener">CF432D</a></h2><hr><p><a href="https://ouuan.github.io/post/cf432d-prefixes-and-suffixeskmp/" target="_blank" rel="noopener">讲得好的题解</a></p><p>KMP 性质题，f[nxt[i]] = 1 + sum{f[i]}</p><h2 id="CF1107F"><a href="#CF1107F" class="headerlink" title="CF1107F"></a><a href="https://www.luogu.com.cn/problem/CF1107F" target="_blank" rel="noopener">CF1107F</a></h2><hr><p>贷款有三种：不用，付完，没付完</p><p>考虑没付完的贷款，b 大的靠后买更优，所以可以先将 b 从大到小排序</p><p>f[i, j] 表示在前 i 个中选，j 个没付完的 C 最大值</p><h2 id="CF687C"><a href="#CF687C" class="headerlink" title="CF687C"></a><a href="https://www.luogu.com.cn/problem/CF687C" target="_blank" rel="noopener">CF687C</a></h2><hr><p>问能拼出哪些，就想到了 bitset：f[i, j] 表示前 i 个共 j 元能拼出的集合，f[i, j] = f[i - 1, j] | f[i - 1, j - c[i]] | (f[i - 1, j - c[i]] &lt;&lt; c[i])</p><h2 id="LightOJ1422"><a href="#LightOJ1422" class="headerlink" title="LightOJ1422"></a><a href="https://vjudge.net/problem/LightOJ-1422" target="_blank" rel="noopener">LightOJ1422</a></h2><hr><p>区间 dp，f[l, r] = min(f[l + 1, r] + 1, (f[l + 1, i - 1] + 1) + (f[i, r] - 1)(其中 c[l] = c[i]))</p><p>小细节是 f[i, r] - 1，由于 i 可能对 [i + 1, r] 同颜色的衣服有影响，所以不是 f[i + 1, r]; 但要减去重复买的钱。</p><h2 id="CF840C"><a href="#CF840C" class="headerlink" title="CF840C"></a><a href="https://www.luogu.com.cn/problem/CF840C" target="_blank" rel="noopener">CF840C</a></h2><hr><p><a href="https://blog.csdn.net/can919/article/details/80154917" target="_blank" rel="noopener">好的题解</a></p><p>将相乘为完全平方数的数放在同一组里，问题转化成了经典问题：有多少个排列使得相邻两数不在同一组里。</p><p>容斥 + dp，ans = (至少 0 相邻相同的方案数) - (至少 1 相邻相同的方案数) + (至少 2 相邻相同的方案数) …</p><p>dp[i, j] 表示前 i 种数分为 j 块的方案数（无序），相同块中的数相同。即至多 j - 1 不相同，即至少 (n - 1) - (j - 1) = n - j 相同。</p><p>$dp[i, k] = \sum{ dp[i - 1, k - j] \times C(ni - 1, j - 1) \times \frac{n_i!}{j!} }$</p><p>除以 j! 表示使块无序，乘以 n_i! 表示总排列数（迷惑）</p><hr><p>upd：<a href="https://blog.csdn.net/qq_31759205/article/details/77487920" target="_blank" rel="noopener">另一好的题解</a></p><p>还是这个好懂且正常👍</p><p>转移的时候枚举把当前集合分成多少段，有多少段插在之前相同的相邻元素间</p><p>注意由于 size 之和是 n，复杂度不是 O(n^4) 是 O(n^3)</p><h2 id="CF15E"><a href="#CF15E" class="headerlink" title="CF15E"></a><a href="https://www.luogu.com.cn/problem/CF15E" target="_blank" rel="noopener">CF15E</a></h2><hr><p><a href="https://www.cnblogs.com/yyf0309/p/8418287.html" target="_blank" rel="noopener">题解题++ qwq</a></p><p>找规律容易发现：路线是从 H 一直沿着边沿斜线走，拐一圈走到 H 正下方第一个点再拐一圈走到另一斜线，走回 H。</p><p>但后面就不知道怎么做了qaq？看大佬博客吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200731 题解</title>
      <link href="2020/07/31/XJOI200731%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/31/XJOI200731%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我仿佛智障了= =</span></span><br><span class="line"><span class="comment">这一看就很可以递推的样子啊，数位 dp 真的不是很难，是我数位 dp 太弱了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll T, K, l, r, f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">65</span>], bit2[<span class="number">65</span>];</span><br><span class="line"><span class="comment">// f[0, ,] 是已经有一位取小、后面就没有限制的方案数</span></span><br><span class="line"><span class="comment">// f[1, ,] 是受/不受到数位限制的总方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> (a - b + mod) % mod; &#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> (a + b + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    bit2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        bit2[i] = bit2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;  <span class="comment">// 这里的 0 是 (1 &lt;&lt; 0)，也就是 1！1 有 3 种方案！！！</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][i] = (f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>][i] = (f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod + bit2[i] * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2</span>][i] = (f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] % mod + <span class="number">2</span> * f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod * bit2[i] % mod + bit2[i] * bit2[i] % mod * f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// !!!</span></span><br><span class="line">    ll cnt = <span class="number">0</span>, x = n;</span><br><span class="line">    <span class="keyword">while</span> (x) x &gt;&gt;= <span class="number">1</span>, ++cnt;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">3</span> : <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>] = (n &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">0</span>][i] = (f[<span class="number">0</span>][<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">1</span>][i] = (f[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod + bit2[i] * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">            f[<span class="number">1</span>][<span class="number">2</span>][i] = (f[<span class="number">0</span>][<span class="number">2</span>][i - <span class="number">1</span>] + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">2</span>][i - <span class="number">1</span>] % mod + <span class="number">2</span> * f[<span class="number">1</span>][<span class="number">1</span>][i - <span class="number">1</span>] % mod * bit2[i] % mod + bit2[i] * bit2[i] % mod * f[<span class="number">1</span>][<span class="number">0</span>][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">                f[<span class="number">1</span>][j][i] = f[<span class="number">1</span>][j][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][K][cnt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; K;</span><br><span class="line">    init(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sub(calc(r, K), calc(l - <span class="number">1</span>, K)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>考虑贪心，不断合并平均值最大的块和它的父亲所在连通块。</p><p>证明的话，sum1 <em> num2 &lt; sum2 </em> num1, sum1 / num1 &lt; sum2 / num2，按平均值从大到小排序，堆维护。</p><p>进阶版的 poj-2054，很像 AGC023f-01 on tree，经典贪心了。</p><p><strong>注意！！！我自己写的时候用了priority_queue，但对 sum 和 num 的操作却是在外面做的，也就是说对pq没有修改！而且这样还破坏了pq的结构！！！最后 WA 成了 15pts！！！痛心</strong> </p><p><strong>正确的做法是每次将 fa 从堆里弹出来，对 fa 的操作做完后再 push 一个新的 fa 进去。为了方便执行“弹出操作”，我们用 set 维护优先队列。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, rt, c[N], fa[N], num[N], sum[N], ans, fat[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        ll t2 = sum[id] * num[a.id], t1 = sum[a.id] * num[id];</span><br><span class="line">        <span class="keyword">return</span> t1 &lt; t2 || (t1 == t2 &amp;&amp; id &gt; a.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fat[x] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; rt;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[i]);</span><br><span class="line">        num[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt, rt);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (i != rt) q.insert((node)&#123;i&#125;);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.begin()-&gt;id;</span><br><span class="line">        q.erase(q.begin());</span><br><span class="line">        <span class="keyword">int</span> f = getfa(fat[x]);</span><br><span class="line">        q.erase((node)&#123;f&#125;);</span><br><span class="line">        ans += sum[x] * num[f];</span><br><span class="line">        sum[f] += sum[x], num[f] += num[x];</span><br><span class="line">        fa[x] = f;</span><br><span class="line">        <span class="keyword">if</span> (f != rt) q.insert((node)&#123;f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans + sum[rt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 数位dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】zzd《FFT入门》</title>
      <link href="2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91zzd%E3%80%8AFFT%E5%85%A5%E9%97%A8%E3%80%8B/"/>
      <url>2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91zzd%E3%80%8AFFT%E5%85%A5%E9%97%A8%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="套路1-字符串匹配"><a href="#套路1-字符串匹配" class="headerlink" title="套路1. 字符串匹配"></a><strong>套路1. 字符串匹配</strong></h1><hr><p>我们发现匹配的字符对<strong>下标之差是定值</strong>，翻转其中一个串以后就变成了，匹配的字符对<strong>下标之和是定值</strong>，这是满足卷积形式的。（好妙啊QAQ，卷积形式真的万能</p><h2 id="BZOJ4503"><a href="#BZOJ4503" class="headerlink" title="${[BZOJ4503]}$"></a>${[BZOJ4503]}$</h2><p>不能直接 kmp 啊，通配符的 fail 指针不好定。考虑卷积。</p><p>我们希望通过某一位是否为 0 来判断能否在某位匹配上。可以让相同字符差为 0，做一个平方就不会有“正 + 负 = 零”的情况发生。</p><p>但通配符怎么搞？它可以与任何字符配啊。我们希望有通配符存在 就是 0，那么通配符值 = 0，乘到柿子里去就好了。</p><h3 id="sum-limits-i-1-n-sum-limits-j-1-m-S-i-T-j-2-S-i-T-j"><a href="#sum-limits-i-1-n-sum-limits-j-1-m-S-i-T-j-2-S-i-T-j" class="headerlink" title="\sum\limits_{i = 1}^n\sum\limits_{j = 1}^ m (S_i - T_j)^2 S_i T_j"></a><script type="math/tex">\sum\limits_{i = 1}^n\sum\limits_{j = 1}^ m (S_i - T_j)^2 S_i T_j</script></h3><p>这个东西拆开来，做三次 FFT。</p><h2 id="CF528D"><a href="#CF528D" class="headerlink" title="${[CF528D]}$"></a>${[CF528D]}$</h2><p>按照上一题的套路，我们设 $f[i, c]$ 表示 $[A 的位置 i 匹配字符 c]$，$g[i, c]$ 表示 $[B 的位置 i == c]$。相减之后做平方，这个东西展开太困难了，而且要做很多次 FFT，常数爆炸，考虑别的方法。</p><p>显然 $f[i, c]$ 和 $g[i, c]$ 只是 0/1，若 $A[i]$ 能匹配上 $B[j]$，那么存在一个 $c$，$f[i, c] \times g[j, c] = 1$。</p><p>发现字符集很小，我们分别对每种字符做一次卷积，若位置 i 的四种值之和 == $|B|$ 则位置 $i - |B| + 1$ 可以匹配。复杂度$O(4nlogn)$.</p><h1 id="套路2-卷积形式变形"><a href="#套路2-卷积形式变形" class="headerlink" title="套路2. 卷积形式变形"></a><strong>套路2. 卷积形式变形</strong></h1><hr><p>常用技巧是翻转和更换求和指标。</p><h2 id="ZJOI2014-力"><a href="#ZJOI2014-力" class="headerlink" title="${[ZJOI2014]-力}$"></a>${[ZJOI2014]-力}$</h2><p>自己还推了一部分，hh</p><p>设 $F(i) = \frac{1}{i^2}$，$G(i) = q_i$，一些不合法的下标，值为 0.</p><script type="math/tex; mode=display">E(i) = (\sum\limits_{j = 0}^iF(j) \times G(i - j)) - (\sum\limits_{j = i}^m F(j - i) \times G(j))</script><p>第一个括号里是裸的卷积形式，第二个括号要再做一做。</p><p>更换求和指标：</p><script type="math/tex; mode=display">\sum\limits_{j = 0}^{m - i} F(j) \times G(j + i)</script><p>翻转：（其中 $G^r(i)$ 表示 $G(m - i)$）</p><script type="math/tex; mode=display">\sum\limits_{j = 0}^{m - i} F(j) \times G^r(m - i - j)</script><h1 id="套路3-背包问题相关"><a href="#套路3-背包问题相关" class="headerlink" title="套路3. 背包问题相关"></a><strong>套路3. 背包问题相关</strong></h1><hr><h2 id="CF286E-Ladies’-Shop"><a href="#CF286E-Ladies’-Shop" class="headerlink" title="${[CF286E]-Ladies’ Shop}$"></a>${[CF286E]-Ladies’ Shop}$</h2><p>比较自然的想法，f[a[i]] = 1，f[0] = 1，f 与自己做卷积，做最多 m 次就得到了所有能表示的数。但这样是 O(m log^2 m)的。</p><p>但其实并不用做 m 次。实际上一次卷积就能得出答案。</p><p>一次卷积后，那些 f[i] &gt; 2 的 i 就是可以省略的。为什么？初始一次，f[i] 与 f[0] 相乘一次，还有其他能组成 i 的数字的贡献… 反过来说，f[i] = 2 的 i 就是必选的。</p><h1 id="套路4-分治FFT"><a href="#套路4-分治FFT" class="headerlink" title="套路4. 分治FFT"></a><strong>套路4. 分治FFT</strong></h1><hr><p>（好难啊 QAQ 我没有脑子）</p><h2 id="Lydsy1704月赛-二元运算"><a href="#Lydsy1704月赛-二元运算" class="headerlink" title="${[Lydsy1704月赛]-二元运算}$"></a>${[Lydsy1704月赛]-二元运算}$</h2><p>先不考虑括号里的限制。加法可以直接算，减法要变一下：</p><script type="math/tex; mode=display">ans_k = \sum\limits_{i = k}^n a_i \times b_{i - k}</script><script type="math/tex; mode=display">ans_k = \sum\limits_{i = 0}^{n - k} a_{i + k} \times b_i</script><p>翻转，再将 ans 下标加 n，凑一个卷积形式：</p><script type="math/tex; mode=display">ans_{n + k} = \sum\limits_{i = 0}^{n - k}a_{i + k} \times b_{n - i}^r</script><p>考虑括号里的限制，容易发现在值域上，左区间对右区间一定有贡献，于是想到<strong>分治值域</strong>。具体来说，对于每个数值区间 [l, r]：</p><ul><li>$x = y$: 贡献给 $0$</li><li>$x &lt; y$: $a[l, mid]$ 卷 $b[mid + 1, r]$</li><li>$x &gt; y$: $a[mid + 1, r]$ 卷 $b[l, mid]$</li></ul><p>（我今天才知道在递归过程中计算一个子问题对另一个子问题的贡献的分治就叫 CDQ 分治？？？）</p><h2 id="CF553E-Kyoya-and-Train"><a href="#CF553E-Kyoya-and-Train" class="headerlink" title="${[CF553E]-Kyoya and Train}$"></a>${[CF553E]-Kyoya and Train}$</h2><p>乍一看更像是 dp 题，于是考虑 dp：$f[i, j]$ 表示到 $i$ 位置耗时 $j$ 的最小期望代价，$f[x, t] = min\{c(x, y) + f[y, t + k] \times P_{e, k}\}$，其中 P 表示经过 e 边耗时 k 的概率。</p><p>注意到后面那坨东西可以翻转变成卷积形式，然后这玩意就是分治 FFT 啦，分治时间，对于 $[l, r]$ 先做 $[mid, r]$ 再做 $[l, mid)$。复杂度 $O(mTlog^2T)$.</p><h1 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a><strong>杂题</strong></h1><hr><h2 id="BZOJ3160-万径人踪灭"><a href="#BZOJ3160-万径人踪灭" class="headerlink" title="${[BZOJ3160]-万径人踪灭}$"></a>${[BZOJ3160]-万径人踪灭}$</h2><p>我们先忽略条件 2，最后减去条件 2 的就好了（用 manacher 算）</p><p>按照朴素的解法，展开做多次 FFT 也是可以的，然而还有更简便的方法。考虑<strong>只有 a 和 b</strong>，分开来做再同一位置的相乘，正确性显然。</p><h2 id="Cerc2015-Frightful-Formula"><a href="#Cerc2015-Frightful-Formula" class="headerlink" title="${[Cerc2015]-Frightful Formula}$"></a>${[Cerc2015]-Frightful Formula}$</h2><p>首先假装已经知道这是 FFT 题！然后快乐推柿子。显然答案只分为 $(i, 1)/(1, i)$ 初始值的贡献 和 $(i, j)$ 额外加上的 $c$ 的贡献。</p><p>$(i, 1)/(1, i)$:</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n C(n - i + n - 1, n - i)\times  a^{n - i} b^{n - 1}</script><p>$(i, j)$:</p><script type="math/tex; mode=display">\sum\limits_{i = 2}^n \sum\limits_{j = 2}^n C(n - i + n - j, n - i) \times a^{n - i} b^{n - j} c</script><p>设 $A_i = \frac{a^{n - i}}{(n - i)!}$, $B_i = \frac{b^{n - i}}{(n - i)!}$:</p><script type="math/tex; mode=display">c\sum\limits_{i = 2}^n \sum\limits_{j = 2}^n (2n - i - j)! \times A_iB_j</script><p>枚举 i + j:</p><script type="math/tex; mode=display">c\sum\limits_{i = 4}^{2n} (2n - i)! \sum\limits_{j = 2}^{i - 2} A_jB_{i - j}</script><p>这就是卷积形式了。</p><h2 id="Hnoi2017-礼物"><a href="#Hnoi2017-礼物" class="headerlink" title="${[Hnoi2017]-礼物}$"></a>${[Hnoi2017]-礼物}$</h2><p>我们设得到序列为 a 和 b，设给 a 每一位加 c</p><script type="math/tex; mode=display">ans = \sum (a_i + c - b_i)^2</script><script type="math/tex; mode=display">ans = \sum a_i^2 + \sum b_i^2 + n \times c^2 + 2c \times (\sum a_i - \sum b_i) - 2 \sum a_ib_i</script><p>和 c 有关的项可以枚举或用二次函数求极值，最后一项用卷积求，考虑怎么搞，显然将 a 翻转后复制一份就好啦。</p><h2 id="CF958F3-Lightsabers-hard"><a href="#CF958F3-Lightsabers-hard" class="headerlink" title="${[CF958F3]-Lightsabers(hard)}$"></a>${[CF958F3]-Lightsabers(hard)}$</h2><p>把每种颜色能选的 01 生成函数乘起来，朴素做法会 TLE，考虑<strong>启发式合并</strong>，堆 + vector 维护。$O(nlog^2n)$</p><p>（分治也能做！</p><h2 id="CF623E-Transforming-Sequence"><a href="#CF623E-Transforming-Sequence" class="headerlink" title="${[CF623E]-Transforming Sequence}$"></a>${[CF623E]-Transforming Sequence}$</h2><p>显然 $n &gt; k$ 的时候无解。</p><p>容易发现跟数值具体大小没有关系，关键是每次都有<strong>新的二进制位被填上</strong>。</p><p>小数据的话可以 dp，$f[i, j]$ 表示前 $i$ 个数有 $j$ 个二进制位为 $1$，转移 $f[i, j] = \sum\limits_{k = 0}^{j - 1} f[i - 1, k] \times 2^k \times C(j, k)$，其中 $2^k$ 表示原来已有的可放可不放。</p><p>考虑优化：</p><script type="math/tex; mode=display">\frac{f[i, j]}{j!} = \sum\limits_k \frac{f[i - 1, k] \times 2^k}{k!} \times \frac{1}{(j - k)!}</script><p>这样是 $O(n^2 log n)$ 的，然后我就想不出了。。但还能优化！！考虑到这样一次一次转移太慢了，我们<strong>加大转移的步长</strong>，倍增，合并每段的 dp 值，相当于 dp[n &amp; (2 ^ 0)] 卷 dp[n &amp; (2 ^ 1)] … 卷dp[n &amp; (2 ^ 最高位)]，这样就能在 $O(k log^2 k)$ 的时间复杂度内求出了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jcvb《组合计数问题》题解</title>
      <link href="2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91Jcvb%E3%80%8A%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E3%80%8B/"/>
      <url>2020/07/30/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91Jcvb%E3%80%8A%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>组合数、stirling数</li><li>生成函数 + FFT/NTT</li><li>一些特定的结论（矩阵树，burnside，prufer…）</li><li>一些思想（容斥、补集转化）</li></ul><p>都是常用的技巧！</p><p>DP 每道都是吧 qvq 太重要了，有时用 FFT/NTT 加速。</p><h2 id="TC12004-SetAndSet"><a href="#TC12004-SetAndSet" class="headerlink" title="$[TC12004]-SetAndSet$"></a><a href="https://vjudge.net/problem/Topcoder-12004" target="_blank" rel="noopener">$[TC12004]-SetAndSet$</a></h2><hr><p>按位考虑。</p><p>若对于某一位，存在一个数当前位为 0，则这一位为 0 的数不能全在一边。</p><p>不能全在一边 就很难做，考虑<strong>补集转化</strong>，计算 全在一边 的。我们发现这样会算重，准确来说算的是“至少有几位不同”。</p><p>考虑<strong>容斥思想</strong>，答案 = 总数 - 至少 1 位不同 + 至少 2 位不同 - …</p><p>用 dfs 枚举，并查集维护即可，将枚举位为 0 的并到一块儿去。</p><h2 id="BZOJ1471-不相交路径"><a href="#BZOJ1471-不相交路径" class="headerlink" title="$[BZOJ1471]-不相交路径$"></a>$[BZOJ1471]-不相交路径$</h2><hr><p>不相交难做，相交好做。考虑<strong>容斥</strong>第一个相交的点。计算总方案数的时候用到了拓扑序（路径上排在 x 前面的点 y，拓扑序一定比 x 小）</p><h2 id="SHOI2009-舞会"><a href="#SHOI2009-舞会" class="headerlink" title="$[SHOI2009]-舞会$"></a>$[SHOI2009]-舞会$</h2><hr><p>就是那道-已经没有什么好害怕的了，dp 计算 g 数组，f[i, j] 表示前 i 个女生有 j 个匹配了。</p><h2 id="某CEOI题"><a href="#某CEOI题" class="headerlink" title="$[某CEOI题]$"></a>$[某CEOI题]$</h2><hr><p>什么容斥小于号改为大于号的，咕咕</p><h2 id="TC14170-Divfree"><a href="#TC14170-Divfree" class="headerlink" title="$[TC14170]-Divfree$"></a>$[TC14170]-Divfree$</h2><hr><p>想不到的容斥dp。。</p><p>不合法的状态 (A, B) 是 B 是 A 的真约数时。数字 k 的真约数只有 log(k) 个，k 是 50000，也就是说不合法的链的长度最多 16。</p><p>考虑容斥，f[i] 表示<strong>合法的</strong>长度为 i 的链方案数，g[i] 表示<strong>不合法的</strong>长度为 i 的链方案数。g 可以预处理。</p><p>$f[n] = f[n - 1] <em> g[1] - f[n - 2] </em> g[2] + f[n - 3] * g[3]…$ 太妙了。</p><h2 id="稳定多米诺覆盖"><a href="#稳定多米诺覆盖" class="headerlink" title="$[稳定多米诺覆盖]$"></a>$[稳定多米诺覆盖]$</h2><hr><p><a href="https://imilyx.github.io/2020/07/30/[51nod1518]-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/" target="_blank" rel="noopener">链接</a></p><h2 id="TC13891-Gxor"><a href="#TC13891-Gxor" class="headerlink" title="$[TC13891]-Gxor$"></a>$[TC13891]-Gxor$</h2><hr><p>一道斯特林数相关的数学题</p><p>f[i] 表示至少 i 个连通块，g[i] 表示恰好 i 个连通块，我们要求 g[1]</p><p>考虑一个实际连通块数量为 p 的图，它会在我们枚举 k 个连通块的时候被算 $S_2(p, k)$ 次</p><p>有个柿子：$\sum_i (-1)^{i - 1} S_2(n, i) * (i - 1)! = [n = 1]$</p><p><a href="https://blog.csdn.net/qq_35950004/article/details/106126524" target="_blank" rel="noopener">比较清楚的证明</a></p><p>好神奇啊，消化消化。。。</p><p>$g[1] = \sum\limits_{i = 1}^n f[i] <em> S_1(i, 1) </em> (-1)^{i - 1}$</p><p>f[k] 很难算的样子，怎么办？注意到 n 只有 9，暴搜，强制块与块之间的边不能连（这个高斯消元解异或方程组来搞）。C(17, 9) 左右，嗯很稳！</p><p>代码有一些小细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gxor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll T, n, ans, len, tot;</span><br><span class="line">    ll fac[<span class="number">15</span>], a[N], b[N], col[N], lg[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">15</span>][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            rep(u, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                rep(v, u + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (col[u] != col[v]) a[tot++] = b[t];</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[tot] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">0</span>, T - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((a[cur] &gt;&gt; i) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    rep(j, cur + <span class="number">1</span>, tot - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                            swap(a[j], a[cur]); <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rep(j, cur + <span class="number">1</span>, tot - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// swap(a[j], a[cur]);</span></span><br><span class="line">                        a[j] ^= a[cur];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((a[cur] &gt;&gt; i) &amp; <span class="number">1</span>) ++cur;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += fac[d] * (<span class="number">1l</span>l &lt;&lt; (T - cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = x; t; t = (t - <span class="number">1</span>) &amp; x)</span><br><span class="line">            <span class="keyword">if</span> (t &amp; (x &amp; -x)) &#123;  <span class="comment">// 包含 x 的末尾 1 位置，这样不会重复枚举</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u; u = (u - <span class="number">1</span>) &amp; u)</span><br><span class="line">                    col[lg[u &amp; -u]] = lg[x &amp; -x];</span><br><span class="line">                dfs(x - t, d + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">countsubs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s)</span> </span>&#123;</span><br><span class="line">        T = s.size();</span><br><span class="line">        len = s[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) <span class="keyword">if</span> (i * (i - <span class="number">1</span>) / <span class="number">2</span> == len) &#123; n = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        rep(i, <span class="number">0</span>, T - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            rep(u, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">                rep(v, u + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i][t] == <span class="string">'1'</span>) b[t] |= (<span class="number">1l</span>l &lt;&lt; i);</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, <span class="number">10</span>) lg[(<span class="number">1</span> &lt;&lt; i)] = i;</span><br><span class="line">        rep(i, <span class="number">2</span>, <span class="number">10</span>) fac[i] = fac[i - <span class="number">1</span>] * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i += <span class="number">2</span>) fac[i] = -fac[i];</span><br><span class="line">        dfs((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[51nod1518]-稳定多米诺覆盖</title>
      <link href="2020/07/30/%5B51nod1518%5D-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/"/>
      <url>2020/07/30/%5B51nod1518%5D-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<p>我们发现恰好 k 条线不被跨过很难搞，但是至少 k 条线不被跨过就可以 dp，想到容斥（二项式反演）。</p><p>同时枚举行和列的复杂度太高，但是枚举一维后，另一维就可以 dp 了。</p><p>我们选择枚举列，行做 dp：</p><ul><li>f[i, j] 表示 i 行 j 列恰好填满的方案数（插头dp预处理），</li><li>g[k] 表示<strong>至少</strong> k 条<strong>列线</strong>，0 条行线的方案数（0 条行线 通过容斥实现）</li></ul><p><strong>注意：这里插头dp 轮廓线 和回路计数的<a href="https://www.cnblogs.com/iiyiyi/p/5846864.html" target="_blank" rel="noopener">不太一样</a></strong></p><p>（所以要就题论题的设计轮廓线啊！！！）</p><p>重点总结：1. 想到容斥 2. 想到枚举一维后 dp 另一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>], f[<span class="number">20</span>][<span class="number">20</span>], ans, g[<span class="number">20</span>], row[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> tot = (<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>, p = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][tot] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, lim) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp[p], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[p]));</span><br><span class="line">            rep(s, <span class="number">0</span>, tot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((s &gt;&gt; (lim - <span class="number">1</span>)) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    (dp[p][(s &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 竖放一块 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(s &amp; <span class="number">1</span>) &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">                        (dp[p][(s &lt;&lt; <span class="number">1</span> | <span class="number">3</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 横放一块</span></span><br><span class="line">                    (dp[p][(s &lt;&lt; <span class="number">1</span>) &amp; tot] += dp[p ^ <span class="number">1</span>][s]) %= mod;  <span class="comment">// 不放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][lim] = dp[p ^ <span class="number">1</span>][tot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) calc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = m = <span class="number">16</span>;</span><br><span class="line">    prework();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        rep(s, <span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>), (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>) &#123;</span><br><span class="line">            vec.clear();</span><br><span class="line">            <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, m)</span><br><span class="line">                <span class="keyword">if</span> ((s &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>) vec.push_back(i - lst), lst = i;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                row[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.size(); j++)</span><br><span class="line">                    (row[i] *= f[i][vec[j]]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                g[i] = row[i];</span><br><span class="line">                rep(j, <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                    (g[i] -= row[i - j] * g[j] % mod) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((vec.size()) &amp; <span class="number">1</span>) (ans += g[n]) %= mod;</span><br><span class="line">            <span class="keyword">else</span> (ans -= g[n]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> 插头dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200730 题解</title>
      <link href="2020/07/30/XJOI200730%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/30/XJOI200730%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>求最小生成树边权期望。</p><p>“保证距离值相同的道路数小于 30”，显然可以用矩阵树定理。</p><p>根据期望的可加性，整棵树的期望 = 每条边的期望 之和。考虑最小生成树的性质（具体可见 JSOI2008-最小生成树计数），我们分别处理不同长度的边。而每条边的概率是：（包含这条边的生成树个数）/（总生成树个数）。分开做就可以过了，虽然时间复杂度是不对的。</p><p>然而还有一个神仙做法：<a href="https://www.cnblogs.com/Flying2018/p/13406278.html" target="_blank" rel="noopener">flying2018大佬博客</a></p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>为什么没往数据结构想呢。。。要反思，这一看就很线段树嘛</p><p>忽略 limit 的限制——最左的位置可以二分。</p><p>max值是<strong>单调不增</strong>的。</p><p>线段树维护每一个 f[i] 和 max{…}。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 矩阵树定理 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】插头dp</title>
      <link href="2020/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8F%92%E5%A4%B4dp/"/>
      <url>2020/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%8F%92%E5%A4%B4dp/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zinthos/p/3897854.html" target="_blank" rel="noopener">这个讲的还不错</a></p><p>重修插头dp！今日主题：讲讲那些奇怪的插头们</p><ul><li>划分阶段（从上到下、从左到右逐格递推）：qvq，轮廓线以上就是已经处理好的状态，只等着根据当前格的插头状态往下推了。</li><li>根据当前格有无左、上插头，推向有无右、下插头的状态。</li><li>关于换行，我们编号 m + 1 个位置 0 ~ m, 显然当前行 0 ~ m - 1 的会转移到 1 ~ m，右移一位就好了。</li><li>朴素的轮廓线只有 0/1 表示有无插头，但以洛谷那道例题为例，这样处理是会出现多个回路的情况的。这时候需要用括号表示法 + X进制（X &gt; 2, 通常取X = 4为宜因为位运算很快且写起来方便）来维护插头之间的联通性（限制了一些非法状态的转移），当然，分类情况也多了不少。。。</li><li>Hash表可以通过去重以及排除无用状态极大的加速插头dp的速度。</li><li>理解不了的话，建议画图 qvq！</li></ul><h2 id="hdu1693"><a href="#hdu1693" class="headerlink" title="hdu1693"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1693" target="_blank" rel="noopener">hdu1693</a></h2><hr><p>可以有多个回路。朴素轮廓线，可以开 f[i, j, s]，也可以滚动数组（细节注意！！！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, m, cas;</span><br><span class="line">ll mp[<span class="number">15</span>][<span class="number">15</span>], f[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            rep(j, <span class="number">1</span>, m)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>, tot = (<span class="number">1</span> &lt;&lt; (m + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            swap(cur, pre);  <span class="comment">// !!!</span></span><br><span class="line">            <span class="built_in">memset</span>(f[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[cur]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; s &gt;= <span class="number">0</span>; --s)</span><br><span class="line">                f[cur][s &lt;&lt; <span class="number">1</span>] = f[pre][s];</span><br><span class="line">            rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">                swap(pre, cur);</span><br><span class="line">                <span class="built_in">memset</span>(f[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[cur]));</span><br><span class="line">                rep(s, <span class="number">0</span>, tot) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> is_r = (s &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span>, is_d = (s &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!mp[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!is_r &amp;&amp; !is_d)</span><br><span class="line">                            f[cur][s] = f[pre][s];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (is_r &amp;&amp; is_d) &#123;</span><br><span class="line">                            f[cur][s] = f[pre][s - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) - (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_r ^ is_d) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ss = s | (<span class="number">1</span> &lt;&lt; j) | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                            f[cur][s] = f[pre][ss - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] + f[pre][ss - (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            f[cur][s] = f[pre][s + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) + (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: There are %lld ways to eat the trees.\n"</span>, ++cas, f[cur][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷模板"><a href="#洛谷模板" class="headerlink" title="洛谷模板"></a><a href="https://www.luogu.com.cn/problem/P5056" target="_blank" rel="noopener">洛谷模板</a></h2><hr><p>只能有一个闭合回路。</p><p>（一些废话：这是我上来对着题解写的第一道插头dp，hash优化 + 括号表示一个没少。。qwq 被毒死了呀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">590027</span>, N = <span class="number">6e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, ans, ex, ey, pre, cur = <span class="number">1</span>;</span><br><span class="line">ll bits[<span class="number">30</span>], tots[<span class="number">2</span>], lnk[N], nxt[N], to[N], cnt, sta[<span class="number">2</span>][N], dp[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsh</span><span class="params">(ll state, ll val)</span> </span>&#123;</span><br><span class="line">    ll x = state % mod;</span><br><span class="line">    <span class="keyword">for</span> (ll i = lnk[x]; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> (sta[cur][to[i]] == state) &#123;</span><br><span class="line">            dp[cur][to[i]] += val; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    tots[cur]++;</span><br><span class="line">    sta[cur][tots[cur]] = state;</span><br><span class="line">    dp[cur][tots[cur]] = val;</span><br><span class="line"></span><br><span class="line">    to[++cnt] = tots[cur], nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll cursta, curans;</span><br><span class="line">    <span class="keyword">int</span> is_d, is_r;</span><br><span class="line">    dp[cur][tots[cur] = <span class="number">1</span>] = <span class="number">1</span>, sta[cur][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, tots[cur]) sta[cur][j] &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            swap(pre, cur);</span><br><span class="line">            <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">            tots[cur] = cnt = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, tots[pre]) &#123;</span><br><span class="line">                cursta = sta[pre][k], curans = dp[pre][k];</span><br><span class="line">                is_r = (cursta &gt;&gt; bits[j - <span class="number">1</span>]) % <span class="number">4</span>, is_d = (cursta &gt;&gt; bits[j]) % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!is_r &amp;&amp; !is_d)</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!is_r &amp;&amp; !is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j] &amp;&amp; mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta + (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) + <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r &amp;&amp; !is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta - is_r * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) + is_r * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j])</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!is_r &amp;&amp; is_d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp[i][j + <span class="number">1</span>])</span><br><span class="line">                        hsh(cursta, curans);</span><br><span class="line">                    <span class="keyword">if</span> (mp[i + <span class="number">1</span>][j])</span><br><span class="line">                        hsh(cursta + is_d * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - is_d * (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">1</span> &amp;&amp; is_d == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                    rep(l, j + <span class="number">1</span>, m) &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = (cursta &gt;&gt; bits[l]) % <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">1</span>) ++cnt;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">2</span>) --cnt;</span><br><span class="line">                        <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">                            hsh(cursta - (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - (<span class="number">1</span> &lt;&lt; bits[j]) - (<span class="number">1</span> &lt;&lt; bits[l]), curans);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">2</span> &amp;&amp; is_d == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = j - <span class="number">2</span>; l; --l) &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = (cursta &gt;&gt; bits[l]) % <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">1</span>) ++cnt;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="number">2</span>) --cnt;</span><br><span class="line">                        <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">                            hsh(cursta - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j]) + (<span class="number">1</span> &lt;&lt; bits[l]), curans);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">2</span> &amp;&amp; is_d == <span class="number">1</span>) &#123;</span><br><span class="line">                    hsh(cursta - <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bits[j - <span class="number">1</span>]) - (<span class="number">1</span> &lt;&lt; bits[j]), curans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (is_r == <span class="number">1</span> &amp;&amp; is_d == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == ex &amp;&amp; j == ey)</span><br><span class="line">                        ans += curans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) ex = i, ey = j, mp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">25</span>) bits[i] = (i &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    DP();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51nod1518-稳定多米诺覆盖"><a href="#51nod1518-稳定多米诺覆盖" class="headerlink" title="51nod1518-稳定多米诺覆盖"></a><a href="https://vjudge.net/problem/51Nod-1518" target="_blank" rel="noopener">51nod1518-稳定多米诺覆盖</a></h2><hr><p>终于到你了，感动中国！</p><p><a href="https://imilyx.github.io/2020/07/30/[51nod1518]-%E7%A8%B3%E5%AE%9A%E5%A4%9A%E7%B1%B3%E8%AF%BA%E8%A6%86%E7%9B%96/" target="_blank" rel="noopener">链接</a></p><p>暂时就更这么多吧，后续还会做题 &amp; 写单篇博（可能</p>]]></content>
      
      
      
        <tags>
            
            <tag> 插头dp </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200728 题解</title>
      <link href="2020/07/28/XJOI200728%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/28/XJOI200728%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>两道数据结构题给我搞吐了。。。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>原题是 CF418E</p><p>容易发现矩阵的奇数行（除了1）和偶数行是相同的. 感性理解就是把很多串 1，2，3 … 穿插在一起，每次转换一下。</p><p>分块做，f[i, j] 表示第一行前 i 块中数字 j 出现的次数，g[i, j] 表示第二行前 i 块中数字 j 出现的次数</p><p>维护的时候注意 f 和 g 的加减顺序！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> h, n, m, idx, unit = <span class="number">1000</span>, num;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][N], g[M][N], val[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    num = n / unit + (n % unit &gt; <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (!mp[a[i]]) &#123;</span><br><span class="line">            mp[a[i]] = ++idx;</span><br><span class="line">            val[idx] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = mp[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, num) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = (i - <span class="number">1</span>) * unit + <span class="number">1</span>, r = min(i * unit, n);</span><br><span class="line">        rep(j, <span class="number">1</span>, n)  <span class="comment">// 上界取 idx 是不行的！！！g数组最大值为 n！！！</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j], g[i][j] = g[i - <span class="number">1</span>][j];</span><br><span class="line">        rep(j, l, r)</span><br><span class="line">            f[i][a[j]]++, g[i][f[i][a[j]]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp[y]) &#123;</span><br><span class="line">                mp[y] = ++idx;</span><br><span class="line">                val[idx] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            y = mp[y];</span><br><span class="line">            rep(i, (x - <span class="number">1</span>) / unit + <span class="number">1</span>, num)</span><br><span class="line">                g[i][f[i][a[x]]]--, f[i][a[x]]--;</span><br><span class="line">            a[x] = y;</span><br><span class="line">            rep(i, (x - <span class="number">1</span>) / unit + <span class="number">1</span>, num)</span><br><span class="line">                f[i][a[x]]++, g[i][f[i][a[x]]]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, val[a[y]]); <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, y / unit * unit + <span class="number">1</span>, y) &#123;</span><br><span class="line">                f[y / unit][a[i]]++, g[y / unit][f[y / unit][a[i]]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x &amp; <span class="number">1</span> ? g[y / unit][f[y / unit][a[y]]] : f[y / unit][a[y]]);</span><br><span class="line">            rep(i, y / unit * unit + <span class="number">1</span>, y) &#123;</span><br><span class="line">                g[y / unit][f[y / unit][a[i]]]--, f[y / unit][a[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>结论题，就是删掉前 n 个</p><p>这种题应该要打表 + 找规律 + 特判啊，别愣在那里。。。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>考虑没有操作 2，显然一遍 dfs 就能解决（考虑节点 x，它作为 lca 的贡献可以用 询问的a在子树中的个数 和 子树中黑色点的id和 来算）</p><p>考虑有操作 2，本质上多了时间这一维度（经典套路），用线段树合并（时间为下标）</p><p>点 x 作为 lca 的贡献就在合并的时候算。显然时间较小的id和对时间较大的询问有影响。因此要计算 左半边的id和 与 右半边的询问个数 之积（线段树上分治处理）</p><p>O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx;</span><br><span class="line"><span class="keyword">int</span> col[N], lst[N], rt[N];</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> cnt, ls, rs; ll sum; &#125;tr[N * <span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = tr[x].ls, rs = tr[x].rs;</span><br><span class="line">    tr[x].cnt = tr[ls].cnt + tr[rs].cnt;</span><br><span class="line">    tr[x].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[x].cnt += v1;</span><br><span class="line">        tr[x].sum += v2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tr[x].ls, l, mid, pos, v1, v2);</span><br><span class="line">    <span class="keyword">else</span> modify(tr[x].rs, mid + <span class="number">1</span>, r, pos, v1, v2);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">        x = (x | y); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[x].cnt += tr[y].cnt, tr[x].sum += tr[y].sum; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    val[id] += <span class="number">1l</span>l * tr[tr[x].rs].cnt * tr[tr[y].ls].sum;</span><br><span class="line">    val[id] += <span class="number">1l</span>l * tr[tr[x].ls].sum * tr[tr[y].rs].cnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(tr[x].ls, tr[y].ls, l, mid, id);</span><br><span class="line">    merge(tr[x].rs, tr[y].rs, mid + <span class="number">1</span>, r, id);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        merge(rt[x], rt[y], <span class="number">0</span>, m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">        <span class="keyword">if</span> (col[i]) modify(rt[i], <span class="number">0</span>, m, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            modify(rt[x], <span class="number">0</span>, m, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (col[x]) val[x] += x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            col[x] ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (col[x]) &#123;</span><br><span class="line">                modify(rt[x], <span class="number">0</span>, m, i, <span class="number">0</span>, x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                modify(rt[x], <span class="number">0</span>, m, i, <span class="number">0</span>, -x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, val[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 线段树合并 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XJOI200727 题解</title>
      <link href="2020/07/28/XJOI200727%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/28/XJOI200727%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>只订了 A B，题真好（nán）啊 ~</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>答案是 $\sum (ai + k - a[i] mod k)$</p><p>考虑 a[i] &lt; k 的时候，这段长度就是 k</p><p>所以我们可以将 k 从小到大排序，对于每个 k 删掉 &lt; k 的 a[i]，对于剩下的点做前缀和、二分，边界特殊处理</p><p>为什么这样复杂度是对的呢？<strong>每个 a[i] 被计算它的大小次</strong>，所以是 O(n + Qlogn) 的（瓶颈在于二分）</p><p>太妙了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, Q, tot;</span><br><span class="line">ll cur[N], a[N], b[N], pos[N], pre[N], ans[M];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span> &#123;</span> ll l, r, k, id; &#125;q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span> </span>&#123; <span class="keyword">return</span> a.k &lt; b.k; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            pos[++tot] = i;</span><br><span class="line">            a[tot] = i - <span class="number">1</span> - pos[tot - <span class="number">1</span>];</span><br><span class="line">            b[tot] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">        cur[i] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].k);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        ll l = q[i].l, r = q[i].r, k = q[i].k;</span><br><span class="line">        <span class="keyword">if</span> (k != q[i - <span class="number">1</span>].k) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">1</span>, tot)</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt;= k) a[++cnt] = a[j], b[cnt] = b[j];</span><br><span class="line">            tot = cnt;</span><br><span class="line">            rep(j, <span class="number">1</span>, tot) pre[j] = pre[j - <span class="number">1</span>] + a[j] / k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur[l - <span class="number">1</span>] == cur[r]) &#123;</span><br><span class="line">            ans[q[i].id] = r - l + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(b + <span class="number">1</span>, b + tot + <span class="number">1</span>, cur[l - <span class="number">1</span>] + <span class="number">2</span>) - b;</span><br><span class="line">        <span class="keyword">int</span> y = upper_bound(b + <span class="number">1</span>, b + tot + <span class="number">1</span>, cur[r]) - b - <span class="number">1</span>;</span><br><span class="line">        ans[q[i].id] = (r - pos[cur[r]]) + k * (cur[r] - cur[l - <span class="number">1</span>] + (pre[y] - pre[x - <span class="number">1</span>]) + (pos[cur[l - <span class="number">1</span>] + <span class="number">1</span>] - l) / k);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易列出 dp 柿子 $f[i, j] = \sum\limits_k f[i - 1, j - a_k]$，答案就是 $f<a href="i\ mod\ n = 0">l, i</a>$</p><p>容易想到矩阵快速幂，但是复杂度太高会爆炸</p><p>从生成函数的视角出发，设 $g(x) = \sum\limits_i x^{a_i}$，则 $[j + a_k] f^i = \sum [j]f^{i - 1} \times [a_k] g$，这是<a href="https://www.cnblogs.com/birchtree/p/12287474.html" target="_blank" rel="noopener">循环卷积</a>的形式。所以说我们平时写的 fft/ntt 其实就是忽视了 2^? 的循环卷积！本题 n 是 2^?，若不是，则需要做任意长度fft了。（我不会</p><p>卷积快速幂其实就是转化成点值形式，点对点直接做快速幂。</p><p>m 个限制可以分段做再乘起来，每做完一个限制就把下一个限制位置的方案数置为 0，复杂度是 O(mnlog^2n)</p><p><a href="https://www.cnblogs.com/Flying2018/p/13387482.html" target="_blank" rel="noopener">据说还能容斥？？？咕咕</a></p><p>code（分段做）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">66000</span> * <span class="number">2</span>, G = <span class="number">3</span>, G1 = (mod + <span class="number">1</span>) / G;</span><br><span class="line">ll n, L, m, Q, lim = <span class="number">1</span>;</span><br><span class="line">ll r[N], f[N], g[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">limits</span> &#123;</span> ll x, y; &#125;li[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(limits a, limits b)</span> </span>&#123; <span class="keyword">return</span> a.x &lt; b.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G : G1, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;li[i].x, &amp;li[i].y);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); f[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    li[++m] = (limits)&#123;L, <span class="number">0</span>&#125;;</span><br><span class="line">    sort(li + <span class="number">1</span>, li + m + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, ++l;  <span class="comment">// &lt; n 哦，是循环卷积</span></span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">    ntt(f, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        ntt(g, <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">0</span>, n - <span class="number">1</span>) g[j] = g[j] * quick_pow(f[j], li[i].x - li[i - <span class="number">1</span>].x) % mod;  <span class="comment">// 点值直接做快速幂</span></span><br><span class="line">        ntt(g, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) g[li[i].x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, g[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>看了 <a href="https://www.cnblogs.com/Flying2018/p/13399374.html" target="_blank" rel="noopener">Flying2018大佬博客</a> 来订正了。。。</p><p><strong>本题所有思考基于一个性质：对于 $gcd(a, b) = 1$，$l = a \times b$, $len(l) = lcm(len(a), len(b))$</strong></p><p>所以只要考虑所有 = 质数的 m 就好了。</p><p>考虑 f(n) 怎么算，显然 $f(n) = x \times a^n + \sum\limits_{i &lt; n} c \times a^i$</p><p>那么就是要求 $x \times a^n + \sum\limits_{i &lt; n} c \times a^i \equiv x (mod m)$ 的最小 n</p><p>即 $\frac{a^n - 1}{a - 1} \equiv x(1 - a^n) (mod m)$ </p><p>然后开始分讨：</p><ul><li>a = 0：循环节为 1</li><li>a = 1：</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> NTT优化 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ455]-雪灾与外卖</title>
      <link href="2020/07/27/%5BUOJ455%5D-%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96/"/>
      <url>2020/07/27/%5BUOJ455%5D-%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<p><a href="http://uoj.ac/problem/455" target="_blank" rel="noopener">传送门</a></p><p>感觉这题好神啊，可撤销贪心什么的傻傻想不明白，模拟费用流也太高级了吧</p><hr><p>复习一下网络流</p><p>注意反悔边</p><p>如果裸的跑，即 EK，会 T，$O(nm^2)$</p><p>优化就是在最短路上跑，（更准确地说是保留在原来的残量网络中可以被增广的边即连的点）dinic，$O(n^2m)$</p><hr><p>回到本题</p><p>裸的费用流 或者 根据贪心用单调队列做 是 25 分</p><p>正解是用可撤销贪心来模拟费用流（什么）</p><p><a href="https://www.cnblogs.com/yinwuxiao/p/10325138.html" target="_blank" rel="noopener">学习了这篇博客</a></p><p>重点在于模拟退流，即反悔操作</p><p>考虑将人和餐厅按坐标排序，从左往右做，维护两个堆分别储存人和餐厅的贡献们</p><p>先忽略 $c$ 的限制，即将餐厅拆点</p><p><strong>对于人</strong>，把它与左边最优的餐厅匹配，贡献是 $x_i + v_j$, 其中 $v_j$ 是左边餐厅的贡献</p><p>如果人要反悔，贡献就是 $-2x_i - v_j$</p><p>注意这里餐厅没有反悔的必要，因为餐厅与人的匹配不会相交，只需要保证人反悔再反悔能匹配上原餐厅就好了</p><p><strong>对于餐厅</strong>，把它与左边最优的人匹配，贡献是 $y_i + w_i + v_j$，其中 $v_j$ 是左边人的贡献</p><p>如果人要反悔，贡献就是 $-y - w$</p><p>如果餐厅要反悔，$-v_j - 2y$</p><p>这样复杂度是 $O((n + \sum c)log(n + \sum c))$</p><p>考虑去掉拆点，发现当前暂时匹配同一个餐厅的人 的反悔贡献是相同的，于是可以把它们压在一起</p><p>$O((n + m)log(n + m))$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;  <span class="comment">// 第二位是个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line">ll n, m, X[N], Y[N], W[N], C[N];</span><br><span class="line">ll ans, tot;</span><br><span class="line">priority_queue&lt;pll, <span class="built_in">vector</span>&lt;pll&gt;, greater&lt;pll&gt; &gt; A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_x</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y;</span><br><span class="line">    <span class="keyword">if</span> (B.empty()) y = inf;</span><br><span class="line">    <span class="keyword">else</span> y = B.top().first;</span><br><span class="line">    ans += x + y;</span><br><span class="line">    A.push(make_pair(<span class="number">-2</span> * x - y, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (B.size()) &#123;</span><br><span class="line">        ll t = B.top().second;</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) B.push(make_pair(y, t - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_y</span><span class="params">(ll y, ll w, ll c)</span> </span>&#123;</span><br><span class="line">    ll m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c != m &amp;&amp; A.size() &amp;&amp; y + w + A.top().first &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ll x = A.top().first;</span><br><span class="line">        ll t = A.top().second, tt = min(c - m, t);</span><br><span class="line">        ans += tt * (x + y + w);</span><br><span class="line">        A.pop();</span><br><span class="line">        <span class="keyword">if</span> (tt != t) A.push(make_pair(x, t - tt));</span><br><span class="line">        B.push(make_pair(-x - <span class="number">2</span> * y, tt));</span><br><span class="line">        m += tt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m) A.push(make_pair(-y - w, m));</span><br><span class="line">    <span class="keyword">if</span> (c != m) B.push(make_pair(-y + w, c - m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;X[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;Y[i], &amp;W[i], &amp;C[i]), tot += C[i];</span><br><span class="line">    <span class="keyword">if</span> (tot &lt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; j &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[i] &lt; Y[j]) push_x(X[i]), ++i;</span><br><span class="line">        <span class="keyword">else</span> push_y(Y[j], W[j], C[j]), ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) push_x(X[i]), ++i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= m) push_y(Y[j], W[j], C[j]), ++j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 可撤销贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UOJ513]-清扫银河</title>
      <link href="2020/07/27/%5BUOJ513%5D-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/"/>
      <url>2020/07/27/%5BUOJ513%5D-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<p><a href="http://peehs-moorhsum.blog.uoj.ac/blog/5486" target="_blank" rel="noopener">官方题解</a> 逻辑很清晰！</p><p>若有解则必然可以在 m + 1 次操作里出解。</p><p><strong>证明：</strong><br>首先要知道一个性质：无向图的任何环都可以由若干个非树边覆盖的环异或得到。也就是说有用的操作一只有 m - n + 1 个。</p><p>而操作二等价于每次选一个点，将与这个点相邻的边全部反转，也就是说有用的操作二有 n 个。</p><p>总共操作数为 m + 1 个，解异或方程组，必然可以在 m + 1 次操作里出解，况且多个操作二还可以合成一个呢。</p><p>但真的这样做却是 O(m^3 / 32) 的，考虑优化。</p><p>将所有 1 边形成的图称为目标子图。</p><p>根据<strong>欧拉回路</strong>的知识，若目标子图中每个节点的度数都是偶数，则必然可以通过不超过 m - n + 1 次操作一将边权都变成 0.</p><p>因此只要考虑，仅用操作二能否让目标子图中每个节点度数变成偶数。</p><p>这样是 O(n^3 / 32) 的。</p><p>异或什么的想想方程组啊，，，虽然暴力，但到底是个切入口。不过后续就需要找性质了。</p><p>正式做题时，逆推回去比较好：环上点的度数都是偶数…所以blabla</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; a[N], x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i][i]) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, n) <span class="keyword">if</span> (a[j][i]) &#123; swap(a[i], a[j]); <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!a[i][i]) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) <span class="keyword">if</span> (a[j][i]) a[j] ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i][n + <span class="number">1</span>];</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) t ^= (a[i][j] * x[j]);</span><br><span class="line">        <span class="keyword">if</span> (!a[i][i] &amp;&amp; t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x[i] = t;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            a[x][x].flip(), a[y][y].flip(), a[x][y] = <span class="number">1</span>, a[y][x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (z) a[x][n + <span class="number">1</span>].flip(), a[y][n + <span class="number">1</span>].flip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(Gauss() ? <span class="string">"yes"</span> : <span class="string">"no"</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) a[i].reset();</span><br><span class="line">        x.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 017 题解</title>
      <link href="2020/07/27/AGC%20017%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/27/AGC%20017%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>A dp 一下就好了</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>枚举减了多少次，算出这个 n - 1 项数列末项的最小值和最大值，显然这个范围内任何一个数都是可达的</p><p>check b 是否在范围内就好了</p><h2 id="C"><a href="#C" class="headerlink" title="*C"></a>*C</h2><hr><p>设 f[i] 表示按 ai 排序的某个前缀 i 个球，是否合法</p><p>显然 f[i + num[j]] 在 i + num[j] = j 的时候也是合法的</p><p>到这里就不会了，，，</p><p>题解巧妙的转化成了线段覆盖，i 号球的是 [i - num[i], i] 这一段，答案就是 [0, n] 间没被覆盖的线段数</p><p>为什么？首先所有线段被覆盖次数之和为 n，那么没被覆盖的线段需要从 重复覆盖的线段 移过去，正确性显然。</p><h2 id="D"><a href="#D" class="headerlink" title="*D"></a>*D</h2><hr><p>竟然是经典套路。。学习一波</p><p>Hackenbush删边游戏，<strong>sg[x] = XOR( sg[son] + 1 )</strong>，好像归纳法可证</p><p>这玩意还有一些奇奇怪怪的扩展，比如无向连通图上玩游戏。。。</p><p>这就需要用环搞事情了（不会</p><h2 id="E"><a href="#E" class="headerlink" title="*E"></a>*E</h2><hr><p>大概想到要转化成图上问题了，但暴力建边 n^2 + 哈密顿路径显然不可做。。。</p><p>考虑欧拉路径，h 只有 200，我们将左边贴地高度 k 的形状 和右边离地高度 k 的形状 标号 k，左边离地高度 k 的形状 和右边贴地高度 k 的形状 标号 -k，那么每个积木就成了连接两个形状的有向边</p><p>问题就转化成了：能否找到若干条 s -&gt; t 的路径，包含所有边且 s &gt; 0, t &lt; 0</p><p>这需要满足条件：</p><ul><li>x &gt; 0, in[x] &lt;= out[x]</li><li>x &lt; 0, in[x] &gt;= out[x]</li><li>在每个（弱）连通分量中，必须有一个点 x, in[x] != out[x]</li></ul><p>正确性还是比较显然的，证明考虑不断拿环就好了。</p><p>upd: 别忘了连双向边（可以从 t 搜回 s）</p><h2 id="F"><a href="#F" class="headerlink" title="*F"></a>*F</h2><hr><p>咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 015 题解</title>
      <link href="2020/07/27/AGC%20015%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/27/AGC%20015%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>AB均为水题</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>网格图常见套路：C = V - E + F，前缀和，处理一下临界的行和列</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>一般的位运算题都是一位一位分开来搞，但这题没法这么做。</p><p>整体考虑。首先 A 和 B 前面相同的位可以忽略。</p><p>设第一个不同的位为 p，我们将区间划分为 $[A, 2^p)$ 和 $[2^p, B]$。</p><p>单取 $[A, 2^p)$，可以 or 出 $[A, 2^p)$</p><p>单取 $[2^p, B]$，设 B 中除 p 以外的最高位为 d，可以 or 出 $[2^p, 2^{d + 1})$</p><p>两个区间都取，可以 or 出 $[2^p + A, 2^{p + 1})$</p><p>答案就是这三个区间的并集。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>看染了点 i 能染哪些点 j：</p><ul><li>xi &gt; xj, vi &lt; vj</li><li>xi &lt; xj, vi &gt; vj</li></ul><p>可以将 v 升序排列，设 li 表示最左的 xj &gt;= xi 的 j，ri 表示最右的 xj &lt;= xi 的 j。那么 i 能染到的区间就是 [li, ri]（这个区间中有些点是被 li 和 ri 染到的）</p><p>问题就转化成：给你若干个区间 [li, ri] 满足 li、ri 递增，求有多少种区间集合能覆盖所有的点？</p><p>dp，f[i] 表示选第 i 区间，覆盖 [1, ri] 的方案数，显然当 j &lt; i 且 Rj &gt;= li - 1 时 f[j] 可以转移到 f[i]</p><p>若 f[j] 能转移到 f[i]，则 f[j + 1] 也能转移到 f[i]，所以设 L 为最左边的 j, [L, i - 1] 的都能转移到 f[i]。容易发现 L 是单调递增的，维护 L 和前缀和就可以做了！</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>结论题，不是很懂（据说官方题解挂掉了？</p><p>逆推一波想到斐波那契数列，这很优的样子</p><p>证明看<a href="https://blog.csdn.net/corsica6/article/details/88579827" target="_blank" rel="noopener">这个博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week4测试题解</title>
      <link href="2020/07/26/Week4%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/26/Week4%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/contest/385165#overview" target="_blank" rel="noopener">传送门</a></p><p><a href="https://zybuluo.com/Cyani/note/1727491" target="_blank" rel="noopener">GHIK的题解</a></p><p>吐槽一句，我是罚时巨怪无疑了，noip可不会给你罚时的机会啊！！！</p><p>提高准确度，力求一遍写对！！！</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>double 会爆精度，可以用 hash（其实就是为了不爆 longlong 而加模数罢了）</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p><strong>可以三分套三分</strong>的题都是单谷函数。据说可以模拟退火，而我并不会那个。。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>题目看错了。。。n^2 做即可</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>随着行的数增大，每个数的位数也会增大，但<strong>至多 log 次</strong>。因此行的位数总变化次数为 O(n log10^9)，因此可以求出每一行的位数，这个大概二分什么的皆可吧。</p><p>然后对于询问，二分行，二分列，再用主席树或者离线树状数组维护一下吧，我也不会，咕咕。</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><hr><p>没看懂，咕咕</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><hr><p>考虑最终棋盘每行每列不会超过 1 个棋子，且所有留到最后的棋子都是在初始位置上</p><p>想到二分图匹配。最多留下来，是平面最大独立集问题，行列建点连边，跑二分图最大匹配。</p><p>那么最少留下来呢？并查集，将所有能互相吃的棋子连一条边，答案就是连通块数。</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><hr><p>二维 FFT，告辞，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJU-ACM 7.23 F 以及类似模型总结</title>
      <link href="2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在讲此题之前，我们先来看看两个问题：</p><ul><li>n 个点的有标号无向连通图计数（poj1737）</li><li>左边 n 个点、右边 m 个点的有标号连通二分图计数</li></ul><p>我们采取 dp 来解决这一类图的计数问题。</p><p>f[n] 表示 n 个点都和点 1 相连的连通图数，g[n] 表示 n 个点的图数</p><p>显然 $f[n] = g[n] - \sum\limits_{i = 1}^{n - 1} C(n - 1, i - 1) <em> f[i] </em> g[n - i]$</p><p>后面这一坨是不连通的图数，为了防止重复计数，我们枚举<strong>与点 1 相连</strong>的块。</p><p>那么第二个问题也是一样的套路，f[n, m] 表示左边 n 个点、右边 m 个点都和左边第 1 个点相连的连通图数，g[n, m] 表示左 n 右 m 的图数, $f[n, m] = g[n, m] - \sum\limits_{i = 1}^{n - 1} \sum\limits_{j = 1}^{m} C(n - 1, i - 1) <em> C(m, j) </em> f[i, j] * g[n - i, m - j]$</p><p>显然上面这两个柿子都是卷积形式，可以用 FTT/NTT 优化。</p><hr><p>回到本题！</p><p>f[n, m] 表示 n 个点 m 条边的连通图数</p><p>$f[n, m] = g[n, m] - \sum\limits_{i = 1}^{n - 1} \sum\limits_{j = 1}^m C(n - 1, i - 1) <em> f[i, j] </em> g[n - i, m - j]$</p><p>这也是卷积形式，但是 NTT 是 O(n^4 logn) 的。考虑我们重复计算了 DFT 和 IDFT 很多次，保留 f 的 DFT 形式（点值形式），就可以优化到 O(n^4 logn)。据说卡卡常就能过，但是 TLE 了= = 假装 AC</p><p>（挂一个<a href="https://www.kdocs.cn/l/sfiEGXVVWPTR?f=201" target="_blank" rel="noopener">官方题解</a>，我没看懂 F 的复杂度分析，，咕咕）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (register int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">2e4</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>, G = <span class="number">3</span>, G1 = (mod + <span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, lim = <span class="number">1</span>;</span><br><span class="line">ll fac[M], inv[M], r[M], h[M], f[N][M], g[N][M], c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, m) inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    rep(i, <span class="number">2</span>, m) inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; m * <span class="number">2</span>) lim &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G : G1, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    m = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    init();</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, i * (i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            g[i][j] = C(i * (i - <span class="number">1</span>) / <span class="number">2</span>, j);</span><br><span class="line">        NTT(g[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, lim - <span class="number">1</span>) &#123;</span><br><span class="line">            h[j] = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                h[j] = (h[j] + c[i - <span class="number">1</span>][k - <span class="number">1</span>] * f[k][j] % mod * g[i - k][j] % mod) % mod;  <span class="comment">// 保留 DFT 形式，省一个 log</span></span><br><span class="line">            f[i][j] = (g[i][j] - h[j] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(f[n], <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, m) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NTT优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 初赛（B）</title>
      <link href="2020/07/26/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BB/"/>
      <url>2020/07/26/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BB/</url>
      
        <content type="html"><![CDATA[<p>A B C 均为水题（A它卡我精度！必须整型处理，吐了</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>我是 10^5 枚举，可以过，但是更正经的解法是状压 dp 阿。。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>这题不对劲！这，这不是（简化版的）第一场的 G 嘛！费用流裸题</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>这看上去像一道傻*题，不是吗不是吗不是吗（有诈</p><p>咕咕</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>大观察题</p><p>首先我们知道 Alice 囤题是为了耽误 Bob 的时间</p><p>若 Alice 能在 \sum_{i = 1}^p {b_i} 的时间内写完第 p 题，就可以拿到 1 分，因为她可以等 Bob 刚好写完第 p 题的时候提交</p><ul><li>那么 Bob 按顺序写了所有题！（好惨阿</li></ul><p>设 Alice 能拿 1 分的题的集合为 S，显然 Alice 按编号从小到大做 S 中的题最优，因为对后面题的影响最少</p><ul><li>那么顺序这个难搞的东西就被解决了！</li></ul><p>然后就可以 dp 了，考虑到 n 只有 2000，我们设计 n^2 的 dp</p><p>显然重要量就三个：位置，分数，时间，其中时间的范围很大</p><p>f[i, j] 表示前 i 道题，Alice 拿了 j 分的最小时间，转移考虑是否选当前的题</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>神题，需要仔细思考 hanoi 游戏的进程</p><p>显然是，为了移动一个大盘子，让其他小盘子聚拢到一根柱子的过程的重复版本，那么我们就有了子问题</p><p>然后后面就看不懂了，咕咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC 016 题解</title>
      <link href="2020/07/24/AGC%20016%20%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/24/AGC%20016%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>016 的难度比 015 高 ~</p><p>智商被完虐了。。【失去梦想.jpg】</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>枚举最终变成哪个字母</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>容易发现 min 与 max 相差不超过 1</p><p>若 min = max，则要么每种颜色都是 1 个，要么每种颜色都有 2 个以上</p><p>若 min + 1 = max，分类讨论就好了，样例大良心 qvq</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>透过样例 2 我们看出，若 n 是 h 的倍数且 m 是 w 的倍数，不可能构造</p><p>那么我们应该使得 n % h、m % w 的部分的贡献尽量大。这边提供一种乱搞思路：定一个较大的值为 d，对于 (h 倍数，w 倍数) 的位置放 -(hw - 1)d - 1，其余位置放 d</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>不错的思维题</p><p>容易发现，若将异或值视为 n + 1 位的序列元素，整个操作就等价于不断将 x (1 &lt;= x &lt;= n) 位置与 n + 1 位置的元素交换</p><p>题解方法非常神仙：</p><p>若 ai != bi，则从 ai 向 bi 连边</p><p>最终答案 = 总边数 + 连通块数 - 1</p><p>注意这里的总边数是不考虑 n + 1 的</p><p>大小为 x 连通块需要 x - 1 次，块与块之间 n + 1 位置的转换需要 1</p><p>对于第 n + 1 个位置单独考虑，若它独一个点则是要考虑到连通块里的</p><p>正确性可以分类讨论一下，比较显然。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>伪概率题，超级无敌妙！解法容易理解，却想不到哇。。</p><p>考虑钦定一只活到最后的鸡，设它为 i。</p><p>它能活着，必然有其他的鸡为它而死，那么我们维护一个集合，表示为 i 死的鸡有哪些。</p><p>考虑时间倒流。每当集合里的鸡出现时，我们将另一只鸡加入集合；若另一只鸡已经在集合中，那么这只钦定的鸡活不到最后。</p><p>枚举两只活到最后的鸡，判他们的集合是否交，若交则无解，因为一只鸡不能死两次。</p><p>真就 留着你是为了炖了你呗（</p><p>具体实现用 bitset，O(nm + n^3 / 32)，注意 bitset &amp; 操作是 O(n) 的</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>sg(1) ^ sg(2) != 0 不好考虑，正难则反，我们用 2^m - ( sg(1) = sg(2) 的方案数 )</p><p>考虑边集显然不现实，我们考虑点集。</p><p>将 DAG 中的点按照 sg 值分层，显然点 1 和点 2 在同一层</p><p>根据分层，想到子集dp，f[S] 表示只考虑 S 这个点集使得 sg(1) = sg(2) 的方案数（注意 S 必须同时包含或不包含 1 和 2）</p><p>转移就枚举 S 的子集 T，设 U 为补集，其中 T 中 sg 值都不为 0，U 中 sg 值都为 0（U 其实就是底层点集），也就是说 1 和 2 必须同时在 T 中或者 U 中</p><p>统计方案的四条规则：</p><ul><li>U 不能内部连边</li><li>T 内部就是 f[T]</li><li>T 中每个点都至少有一条到 U 的边（T 中 sg 值 += 1）</li><li>U 到 T 随便连</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第三轮选讲</title>
      <link href="2020/07/22/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/22/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kdocs.cn/l/srN6cUALrHvX?f=201" target="_blank" rel="noopener">7.21 题解</a></p><h2 id="7-21-A"><a href="#7-21-A" class="headerlink" title="[7.21 A]"></a>[7.21 A]</h2><hr><p>是斐波那契数列啊啊啊啊！所以当然 S(i, j) + S(i, j + 1) = S(i, j + 2)，精妙。</p><p>但是后面的矩阵设计就不知道了，咕咕。</p><p>upd: 还有另一种<a href="https://www.cnblogs.com/Flying2018/p/13356497.html" target="_blank" rel="noopener">神仙做法</a></p><p>upd: 还有一种 <a href="https://www.cnblogs.com/Wendigo/p/13357673.html" target="_blank" rel="noopener">矩阵 + 倍增</a></p><p><a href="https://www.kdocs.cn/l/shvH8qsctES4?f=201" target="_blank" rel="noopener">7.22 题解</a></p><h2 id="7-22-E"><a href="#7-22-E" class="headerlink" title="[7.22 E]"></a>[7.22 E]</h2><hr><p>实在是太妙了orz。。再说一次，枚举顺序要想到状压啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll n, pos[<span class="number">25</span>][<span class="number">30</span>], dp[<span class="number">1</span> &lt;&lt; <span class="number">21</span>][<span class="number">30</span>], ans;</span><br><span class="line"><span class="comment">// pos[i, j] 表示接上 i 串前 1 在位置 j，接上后的位置</span></span><br><span class="line"><span class="comment">// dp[s, i] 表示已接上的串的集合为 s，1 在位置 i 的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">26</span>) &#123;  <span class="comment">// 枚举接上 i 串前的 1 在哪（ 0 表示 sum</span></span><br><span class="line">            pos[i][j] = j;</span><br><span class="line">            rep(k, <span class="number">1</span>, len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k] - <span class="string">'a'</span> + <span class="number">1</span> == pos[i][j]) pos[i][j] = <span class="number">0</span>;  <span class="comment">// 与 sum 交换了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!pos[i][j]) pos[i][j] = s[k] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">26</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[s][j]) &#123;</span><br><span class="line">                rep(i, <span class="number">1</span>, n)</span><br><span class="line">                    <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))))</span><br><span class="line">                        dp[s | (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][pos[i][j]] += dp[s][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">26</span>) ans += dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-22-F"><a href="#7-22-F" class="headerlink" title="[7.22 F]"></a>[7.22 F]</h2><hr><p>cf453b 的加强版</p><p>bi 大于 100 显然不优，所以考虑 100 以内的数。</p><p>100 以内质数有 25 个，不能直接状压。考虑到 50 以内的质数有 15 个，而 50 以上的质数必然只会单独出现且越小越好。选 ai 去匹配，更大一些的 ai 显然不会更差。</p><p>所以考虑将 a 从小到大排序，枚举 i，先用 50 以内的质数处理出前 i 个数的结果，再考虑贪心选取大于 50 的质数、与后 n - i 个数一一匹配的结果。</p><hr><p><a href="https://www.kdocs.cn/l/sfiEGXVVWPTR?f=201" target="_blank" rel="noopener">7.23 题解</a></p><h2 id="7-23-C"><a href="#7-23-C" class="headerlink" title="[7.23 C]"></a>[7.23 C]</h2><hr><p>原题是 <a href="http://uoj.ac/contest/51/problem/513" target="_blank" rel="noopener">清扫银河</a> ！</p><p>我的题解是<a href="https://imilyx.github.io/2020/07/27/[UOJ513]-%E6%B8%85%E6%89%AB%E9%93%B6%E6%B2%B3/" target="_blank" rel="noopener">这个</a></p><h2 id="7-23-D"><a href="#7-23-D" class="headerlink" title="[7.23 D]"></a>[7.23 D]</h2><hr><p>数论题，咕咕</p><h2 id="7-23-E"><a href="#7-23-E" class="headerlink" title="[7.23 E]"></a>[7.23 E]</h2><hr><p>概率 + 生成函数，咕咕</p><h2 id="7-23-F"><a href="#7-23-F" class="headerlink" title="[7.23 F]"></a>[7.23 F]</h2><hr><p>我写的题解是<a href="https://imilyx.github.io/2020/07/26/ZJU-ACM%207.23%20F%20%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%BC%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">这个</a></p><p>据说还能斯特林反演？咕咕</p><h2 id="7-23-G"><a href="#7-23-G" class="headerlink" title="[7.23 G]"></a>[7.23 G]</h2><hr><p>burnside引理 + 生成函数，特别神仙的题，咕咕</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SDOI2017选讲</title>
      <link href="2020/07/21/SDOI2017%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/21/SDOI2017%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h2><hr><p>至少有一个数是质数的情况 = 忽略质数的情况 - 无质数的情况，矩乘加速</p><h2 id="新生舞会"><a href="#新生舞会" class="headerlink" title="新生舞会"></a>新生舞会</h2><hr><p>很裸的分数规划 + km或费用流判是否合法，我不会km qwq。。</p><p>网络流，要计算空间啊。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;  <span class="comment">// 空间要开足</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>][<span class="number">105</span>], b[<span class="number">105</span>][<span class="number">105</span>], S, T;</span><br><span class="line"><span class="keyword">int</span> to[N], fr[N], lnk[N], cnt, nxt[N], cap[N], pre[N], rest[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="keyword">double</span> val[N], dis[N], ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">double</span> v)</span> </span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    to[cnt] = y, fr[cnt] = x, nxt[cnt] = lnk[x], lnk[x] = cnt, cap[cnt] = c, val[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> &amp;flow, <span class="keyword">double</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    rep(i, S, T) dis[i] = <span class="number">-1e18</span>, inq[i] = pre[i] = <span class="number">0</span>;</span><br><span class="line">    inq[S] = <span class="number">1</span>, rest[S] = inf, pre[S] = <span class="number">0</span>, dis[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (cap[i] &gt; <span class="number">0</span> &amp;&amp; dis[y] &lt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                rest[y] = min(rest[x], cap[i]);</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) &#123;</span><br><span class="line">                    inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[T] == <span class="number">-1e18</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += rest[T];</span><br><span class="line">    cost += dis[T] * rest[T];</span><br><span class="line">    <span class="keyword">int</span> x = T;</span><br><span class="line">    <span class="keyword">while</span> (x != S) &#123;</span><br><span class="line">        cap[pre[x]] -= rest[T], cap[pre[x] ^ <span class="number">1</span>] += rest[T];</span><br><span class="line">        x = fr[pre[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        add(S, i, <span class="number">1</span>, <span class="number">0</span>), add(i, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + n, T, <span class="number">1</span>, <span class="number">0</span>), add(T, i + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">double</span> v = a[i][j] - b[i][j] * mid;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, v);</span><br><span class="line">            add(j + n, i, <span class="number">0</span>, -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>; <span class="keyword">double</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(S, T, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; b[i][j];</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) ans = mid, l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬币游戏"><a href="#硬币游戏" class="headerlink" title="硬币游戏"></a>硬币游戏</h2><hr><p>神仙题，想不出来orz</p><p>直接 AC 自动机 + 高斯消元是 O((nm)^3) 的，因为有 nm 个方程</p><p>最终复杂度应该在 O(n^3) 以内，方程数应该是 O(n) 级别的</p><p>关键点是用 N 来表示没有人获胜的状态，将方程数压缩到 n + 1 个，然后解方程</p><p>例如：A = TTH, B = HTT</p><p>N + TTH = A赢 + (B赢 + H) + (B赢 + TH)</p><p>0.125N = A赢 + 0.75B赢</p><p>n + 1 个变量，n + 1 个方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> ull P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> g[N][N], bit2[N], x[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ull pre[N][N], sub[N][N], pw[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = i;</span><br><span class="line">        rep(j, i, n) <span class="keyword">if</span> (g[j][i] &gt; eps) id = j;</span><br><span class="line">        swap(g[i], g[id]);</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = g[j][i] / g[i][i];</span><br><span class="line">            rep(k, i + <span class="number">1</span>, n + <span class="number">1</span>) g[j][k] -= g[i][k] * t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">        x[i] = g[i][n + <span class="number">1</span>] / g[i][i];</span><br><span class="line">        rep(j, <span class="number">1</span>, i - <span class="number">1</span>) g[j][n + <span class="number">1</span>] -= g[i][n + <span class="number">1</span>] * (g[j][i] / g[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bit2[<span class="number">0</span>] = pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) bit2[i] = bit2[i - <span class="number">1</span>] * <span class="number">0.5</span>, pw[i] = pw[i - <span class="number">1</span>] * P;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            pre[i][j] = pre[i][j - <span class="number">1</span>] + (s[j] == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">0</span>) * pw[j];</span><br><span class="line">            sub[i][j] = sub[i][j - <span class="number">1</span>] * P + (s[m - j + <span class="number">1</span>] == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">0</span>) * P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        g[i][n + <span class="number">1</span>] = -bit2[m];</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(a, <span class="number">1</span>, m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[i][a] == sub[j][a]) &#123;</span><br><span class="line">                    g[i][j] += bit2[m - a];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) g[n + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    g[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    Gauss(n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, x[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】数学2</title>
      <link href="2020/07/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%95%B0%E5%AD%A62/"/>
      <url>2020/07/20/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%95%B0%E5%AD%A62/</url>
      
        <content type="html"><![CDATA[<h2 id="Flowers-and-Chocolate"><a href="#Flowers-and-Chocolate" class="headerlink" title="Flowers and Chocolate"></a><a href="https://vjudge.net/problem/CodeForces-865G" target="_blank" rel="noopener">Flowers and Chocolate</a></h2><hr><p>生成函数题，好想做出来啊，，杠了一天半了，只能咕咕</p><h2 id="加权约数和"><a href="#加权约数和" class="headerlink" title="加权约数和"></a><a href="https://vjudge.net/problem/51Nod-1584" target="_blank" rel="noopener">加权约数和</a></h2><hr><p>咕咕<br><a href="https://zybuluo.com/mayiyang/note/1725968" target="_blank" rel="noopener">题解</a></p><h2 id="概率好题"><a href="#概率好题" class="headerlink" title="概率好题"></a><a href="https://vjudge.net/problem/51Nod-1667" target="_blank" rel="noopener">概率好题</a></h2><hr><p>求 sum{a_i} &lt; sum{b_i} 的方案数，其中 a_i 和 b_i 有取值范围</p><p>考虑到 a_i 和 b_i 有一个下限 l，将柿子化为 sum{l_i + x_i} &lt; sum{l_i + x_i} 的形式，其中 0 &lt;= x_i &lt;= r_i</p><p>隔板法 + 容斥即可</p><h2 id="小Q的集合"><a href="#小Q的集合" class="headerlink" title="小Q的集合"></a><a href="https://vjudge.net/problem/51Nod-1778" target="_blank" rel="noopener">小Q的集合</a></h2><hr><p>看到 n 这么大，模数却只有 1e6 应该想到 lucas 定理啊</p><p>m 又是质数，(T^k - (S - T)^k) % m 成一个周期为 m 的数列</p><p>然后一发乱搞就好了（</p><h2 id="BBQ-Hard"><a href="#BBQ-Hard" class="headerlink" title="BBQ Hard"></a><a href="https://vjudge.net/problem/AtCoder-agc001_e" target="_blank" rel="noopener">BBQ Hard</a></h2><hr><p>C(Ai + Aj + Bi + Bj, Ai + Aj) 就是求从 (0, 0) 走到 (Ai + Aj, Bi + Bj) 的方案数</p><p>移位，变成求从 (-Ai, -Bi) 走到 (Aj, Bj) 的方案数</p><p>那么对于每个点，我们计算从它左下区域走上来的方案数之和</p><p>显然 dp[i, j] = dp[i - 1, j] + dp[i, j - 1]。坐标值都很小，可以枚举。最后别忘了减去 (-Ai, -Bi) 对 (Ai, Bi) 的贡献。</p><h2 id="Leftmost-Ball"><a href="#Leftmost-Ball" class="headerlink" title="Leftmost Ball"></a><a href="https://vjudge.net/problem/AtCoder-agc002_f" target="_blank" rel="noopener">Leftmost Ball</a></h2><hr><p>转化一下就是求已放白球数 &gt;= 已放彩球种类的方案数，容易想到每放一种颜色就把 K 个全放完的想法。</p><p>其实真正重要的只有那 n 个白球和那 n 个第一次放下的彩球。dp，f[i, j] 表示已放 i 白球，j 种彩球的方案数。</p><h2 id="Card-game-for-three"><a href="#Card-game-for-three" class="headerlink" title="Card game for three"></a><a href="https://vjudge.net/problem/AtCoder-arc061_d" target="_blank" rel="noopener">Card game for three</a></h2><hr><p>并不是很难的题，第一步想懂了后面就好办了。</p><p>将 a、b、c 的赢看作又抽了一张卡，即 b 抽了第 m + 1 张，c 抽了第 k + 1 张，而 a 抽了第 n 张（a 先手）枚举 a 赢之前 b 和 c 各抽了几张卡，化柿子 + 分类讨论即可。</p><h2 id="Unicyclic-Graph-Counting"><a href="#Unicyclic-Graph-Counting" class="headerlink" title="Unicyclic Graph Counting"></a><a href="https://vjudge.net/problem/AtCoder-asaporo2_f" target="_blank" rel="noopener">Unicyclic Graph Counting</a></h2><hr><p><a href="https://www.cnblogs.com/zwfymqz/p/8869956.html" target="_blank" rel="noopener">prufer序列重修</a></p><p>度数建图，容易想到 prufer 序列，但这是基环树。</p><p>定义本题的 prufer 序列为将树删完后的 prufer 序列，只剩下一个环 和连着环的编号最大的点。</p><p>想到树上节点在 prufer 序列中出现次数为 deg - 1，环上只有一个节点出现次数为 deg - 3，其他都是 deg - 2（特判只有一个环的情况）。</p><p>环大小为 k 时，环排列数为 (k - 1)! / 2（环有旋转同构和翻转同构），prufer 序列数为 (n - k + 1)! / prod{ (di - ?)! }</p><p>dp计算分母那玩意，f[i, j, k] 表示前 i 个点有 j 个环上点，k 为 0/1 表示是否选了出现次数 deg - 3 的点。</p><p>所以最后答案就是 $\sum\limits_{i = 3}^{n - 1} f[n, i, 1] \times (n - i - 1)! \times \frac{(i - 1)!}{2}$</p><h2 id="Team-Work"><a href="#Team-Work" class="headerlink" title="Team Work"></a><a href="https://vjudge.net/problem/CodeForces-932E" target="_blank" rel="noopener">Team Work</a></h2><hr><p><a href="https://www.cnblogs.com/gzy-cjoier/p/8426987.html" target="_blank" rel="noopener">第二类斯特林数</a></p><p>柿子很好列出来，<a href="https://www.cnblogs.com/cjyyb/p/9706019.html" target="_blank" rel="noopener">怎么推呢？</a></p><ul><li>看到 i^k 的形式想想斯特林数</li><li>循环复杂度高时想想替换枚举顺序</li><li>碰到阶乘形式想想凑组合数</li></ul><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a><a href="https://vjudge.net/problem/HDU-1521" target="_blank" rel="noopener">排列组合</a></h2><hr><p>指数型生成函数模板题，回去就重修生成函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 排列组合 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 百度之星程序设计大赛 - 初赛（A）</title>
      <link href="2020/07/20/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BA/"/>
      <url>2020/07/20/2020%20%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9BA/</url>
      
        <content type="html"><![CDATA[<p>A, B, C 均为水题。。rk306，进复赛了 ~</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>D 其实也是水题，这题目是真的难懂。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, sx, sy, a[<span class="number">505</span>][<span class="number">505</span>], ans, tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1e9</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">int</span> ren = <span class="number">0</span>, rnd = <span class="number">0</span>;</span><br><span class="line">                rnd = (<span class="built_in">abs</span>(i - sx) + <span class="built_in">abs</span>(j - sy) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                tot = <span class="number">0</span>;</span><br><span class="line">                val.clear();</span><br><span class="line">                rep(k, <span class="number">-3</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                    rep(l, <span class="number">-3</span>, <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">abs</span>(k) + <span class="built_in">abs</span>(l) &gt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!k &amp;&amp; !l) <span class="keyword">continue</span>;  <span class="comment">// 城市建成后第一个工作者不会移动到别的格子去。。。错失AC</span></span><br><span class="line">                        <span class="keyword">if</span> (i + k &lt; <span class="number">1</span> || i + k &gt; n || j + l &lt; <span class="number">1</span> || j + l &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                        val.push_back(a[i + k][j + l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sort(val.begin(), val.end());</span><br><span class="line"></span><br><span class="line">                ren = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>, food = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (ren &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tt = <span class="number">8</span> * ren * ren;</span><br><span class="line">                    <span class="keyword">if</span> (food &lt; tt) &#123;</span><br><span class="line">                        tt -= food;</span><br><span class="line">                        <span class="keyword">int</span> k = tt / cur + (tt % cur &gt; <span class="number">0</span>);</span><br><span class="line">                        rnd += k, food += k * cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++ren;</span><br><span class="line">                    <span class="keyword">if</span> (!val.size()) <span class="keyword">continue</span>;</span><br><span class="line">                    cur += val.back(), val.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                ans = min(ans, rnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>不是很难但理解了很久的期望题</p><p>由于 a 从外到内递减，必然会形成很多从内向外的树，所以连通块数的期望其实就是树根数的期望。</p><p>考虑每个段作为树根的贡献。</p><p>第一层是 a[i] / 2</p><p>第 i 层每个段是 (1 / a[i - 1] - 1 / a[i]) <em> (a[i - 1] / 2) </em> (a[i] / 2) = (a[i] - a[i - 1]) / 4</p><p>其中，1 / a[i - 1] 是上一层白块概率，但是黑块要完全待在白块里就要减去 1 / a[i]</p><p>那么如果出现只有一个点相碰的情况，这概率怎么算呢？</p><p>其实不用算它，它的概率为 0。</p><p>因为在连续空间下，计算一个子空间的概率就是在算这个空间的测度 (可以理解成一维是长度, 二维是面积, 三维是体积)</p><p>在Lebesgue测度(欧氏空间下最常用的测度定义, 我们学到的微积分基本都基于它)下，一维空间中的一个点测度就是 0</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>选点必然是从小到大选，所以可以二分最后选的点（权值最大的点），对于每块区域讨论一下（不想写，代码就让它咕咕吧（）</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>时刻具有可二分性。设二分的值为 t，容易想到对于每个格点，与每个在 t 时刻内能到达它的窗户连边，跑网络流，但是这样节点个数是 nm 级别的。考虑优化，窗户只有 6 个，那用二进制表示窗户到格点的到达状态，将状态相同的点们缩成一个点，跑最大流就好了。</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>官方题解太毒瘤，，我看的<a href="https://blog.csdn.net/weixin_44282912/article/details/107454309" target="_blank" rel="noopener">这个</a></p><p>时间复杂度应该是跑不满的 sqrt(n) * log(sqrt(n))</p><p>思考了一波推柿子的意义，把 sigma 化掉、去掉无效枚举状态（比如 n / d^2，d &gt; sqrt(n) 就是无效的），判断当前柿子能否预处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】矩阵树定理</title>
      <link href="2020/07/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
      <url>2020/07/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>upd on 2021.3.26: 感性证明一下！？：</p><p>设点数为 $n$。</p><p>我们都知道 kirchhoff 矩阵 $[i, j]$ 位置上的值表示 $i$ 走到 $j$ 的走法个数。减去度数矩阵是减去自环的走法。</p><p>然后开始容斥，容斥掉所有轮换个数 $&gt; 1$ 的排列。而「$n$ - 轮换个数」与「排列逆序对数」的奇偶性相同，证明你就考虑给排列排序时每个轮换依次排，交换一对时逆序对的奇偶性也会变，总共交换「$n$ - 轮换个数」次，最后排列逆序对为 $0$。所以直接算行列式就好啦。</p><p>对容斥系数的另外一种理解是，$(-1)^{n - 环数} = (-1)^{n + 环数} = (-1)^{偶环数}$，所以图的邻接矩阵的行列式 $= \sum\limits_{G 的所有分解方式，分解为若干环} (-1)^{偶环数}$</p><hr><p><a href="https://oi-wiki.org/graph/matrix-tree/" target="_blank" rel="noopener">OIWiki上的矩阵树相关</a></p><hr><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a><a href="https://blog.csdn.net/qq_36396104/article/details/89298227" target="_blank" rel="noopener">行列式</a></h2><p>$n \times n$ 的矩阵 $A$ 的行列式可以理解为行或列向量所构成的超平行多面体的有向面积或有向体积，是一个标量。</p><p>矩阵 $A$ 的行列式用 $det(A)$ 表示。</p><script type="math/tex; mode=display">det(A) = \sum\limits_{j_1 j_2 \cdots j_n} (-1)^{\sigma(j_1 j_2 \cdots j_n)} a_{1, j_1} a_{1, j_2} \cdots a_{n, j_n}</script><p>其中 $\sigma(j_1 j_2 \cdots j_n)$ 表示 $j_1 j_2 \cdots j_n$ 的逆序对数。</p><p><a href="https://baike.baidu.com/item/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/10648400?fr=aladdin#2" target="_blank" rel="noopener">行列式初等变换(最下面)</a></p><ul><li>行列互换，行列式值不变</li><li>行列式一行或一列的公因子可以提出去</li><li>行列式中若有某一行是两组数的和，则该行列式等于两个行列式的和</li><li>两行或两列交换，行列式变号（区别于第一条）</li><li>两行或两列相同，行列式为 0</li><li>两行或两列成比例，行列式为 0</li></ul><hr><h2 id="高斯消元化为上三角矩阵："><a href="#高斯消元化为上三角矩阵：" class="headerlink" title="高斯消元化为上三角矩阵："></a>高斯消元化为上三角矩阵：</h2><p>运用了行列式的初等变换。</p><ul><li>实数：直接处理</li><li>模意义：1. 模为质 可用逆元  2. 模不为质 用辗转相除法，复杂度会多一个 log（详情见例题代码）</li></ul><hr><h2 id="基尔霍夫矩阵"><a href="#基尔霍夫矩阵" class="headerlink" title="基尔霍夫矩阵"></a>基尔霍夫矩阵</h2><p>A 为邻接矩阵，D 为度数矩阵，Kirchhoff矩阵为 K = D - A</p><p>行列式 a[i, i] 记录点 i 度数，a[i, j] 表示 i, j 之间边数的相反数。</p><p>具体实现的话，设 kirchhoff 矩阵为 a，若存在边 (u, v) 则 a[u, u]++, a[v, v]++, a[u, v]—, a[v, u]—</p><p>Kirchhoff矩阵每行内数的和和每列内数的和都为 0，所以行列式为 0</p><hr><h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><p>用于求解图上的生成树个数。</p><p>无向图生成树个数 = Kirchhoff 矩阵任何一个 N - 1 阶<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%90%E5%BC%8F/2671796?fr=aladdin" target="_blank" rel="noopener">主子式</a>的行列式的绝对值.</p><p>有向图相关见<a href="https://www.xht37.com/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">这里</a> （由于本人过于菜 连有向图生成树是啥都不会 先咕咕 后续做到题了再来填坑！）</p><p>可能是，去掉根所在的那行那列，度数矩阵外向树就是入度，内向树就是出度。</p><p>无向图，谁是根并不重要所以随便去掉哪一行&amp;列都可以；</p><p>有向图，删去指定的根所在的行和列，求剩下的矩阵行列式即可。</p><p>如果图不连通，那么任意 N - 1 阶主子式为 0。证明：如果图不连通，那么每个连通块内的点构成的矩阵仍然是 Kirchhoff 矩阵，而连通块不止一个，所以去掉第 i 行第 i 列之后，一定有一个连通块仍然是 Kirchhoff 矩阵，也就是行列式为 0 。</p><hr><h2 id="变元矩阵树定理"><a href="#变元矩阵树定理" class="headerlink" title="变元矩阵树定理"></a>变元矩阵树定理</h2><p>求所有生成树总边积的和。行列式 a[i, i] 记录点 i 边权和，a[i, j] 表示 i, j 之间边权的相反数。</p><hr><h2 id="例题1-HEOI2015-小Z的房间"><a href="#例题1-HEOI2015-小Z的房间" class="headerlink" title="例题1. [HEOI2015]-小Z的房间"></a>例题1. <a href="https://www.luogu.com.cn/problem/P4111" target="_blank" rel="noopener">[HEOI2015]-小Z的房间</a></h2><p>模板题，注意模数非质</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dir[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, a[<span class="number">100</span>][<span class="number">100</span>], id[<span class="number">10</span>][<span class="number">10</span>], idx;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) id[i][j] = ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i][j]) &#123;</span><br><span class="line">                rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tx = i + dir[k][<span class="number">0</span>], ty = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tx &gt; n || ty &gt; m || !id[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> x = id[i][j], y = id[tx][ty];</span><br><span class="line">                    a[x][x]++, a[y][y]++, a[x][y]--, a[y][x]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, idx - <span class="number">1</span>) &#123;  <span class="comment">// n - 1 阶主子式</span></span><br><span class="line">        rep(j, i + <span class="number">1</span>, idx - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j][i]) &#123;  <span class="comment">// 在模意义下用辗转相除法，类比 gcd(a, b) = gcd(b, a % b) 直到 b = 0，用第 i 行消第 j 行</span></span><br><span class="line">                ll d = a[i][i] / a[j][i];</span><br><span class="line">                rep(k, i, idx - <span class="number">1</span>)</span><br><span class="line">                    a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                swap(a[i], a[j]), ans = -ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans * a[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题2-SHOI2016-黑暗前的幻想乡"><a href="#例题2-SHOI2016-黑暗前的幻想乡" class="headerlink" title="例题2. [SHOI2016]-黑暗前的幻想乡"></a>例题2. <a href="https://www.luogu.com.cn/problem/P4336" target="_blank" rel="noopener">[SHOI2016]-黑暗前的幻想乡</a></h2><p>容斥 + 矩阵树定理</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">ll n, a[<span class="number">20</span>][<span class="number">20</span>], res;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; g[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, x, y; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            g[i].push_back(make_pair(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(s, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = g[i][j].first, y = g[i][j].second;</span><br><span class="line">                    a[x][x]++, a[y][y]++, a[x][y]--, a[y][x]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            rep(j, i + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                    ll d = a[i][i] / a[j][i];</span><br><span class="line">                    rep(k, i, n - <span class="number">1</span>)</span><br><span class="line">                        a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                    swap(a[i], a[j]), ans = -ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans * a[i][i] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + ((n - <span class="number">1</span> - cnt) &amp; <span class="number">1</span> ? <span class="number">-1l</span>l : <span class="number">1l</span>l) * ans + mod) % mod;  <span class="comment">// !!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题3-SDOI2014-重建"><a href="#例题3-SDOI2014-重建" class="headerlink" title="例题3. [SDOI2014]-重建"></a>例题3. <a href="https://www.luogu.com.cn/problem/P3317" target="_blank" rel="noopener">[SDOI2014]-重建</a></h2><p>推柿子 + 变元矩阵树定理，显然边权跟概率有关</p><p>$\sum\limits_{T}(\prod\limits_{e \in T} P_e \prod\limits_{e \not\in T}(1-P_e))$</p><p>$\sum\limits_T( \prod\limits_{e \in T} P_e \frac{ \prod\limits_e (1 - P_e) }{ \prod\limits_{e \in T} (1 - P_e) } )$</p><p>$\prod\limits_e (1 - P_e) \sum \prod\limits_{e \in T} \frac{P_e}{1 - P_e}$</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> D[N][N], ans = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = n - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, N) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = i;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, N)</span><br><span class="line">            <span class="keyword">if</span> (D[mx][i] &lt; D[j][i]) mx = j;</span><br><span class="line">        <span class="keyword">if</span> (mx != i) ff ^= <span class="number">1</span>, swap(D[mx], D[i]);</span><br><span class="line">        <span class="keyword">if</span> (D[i][i] &gt; -eps &amp;&amp; D[i][i] &lt; eps) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, N) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = D[j][i] / D[i][i];</span><br><span class="line">            rep(k, i, N) D[j][k] -= t * D[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">        ret *= D[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) ret *= <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(D[i][j]) &lt; eps) D[i][j] = eps;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">1.0</span> - D[i][j]) &lt; eps) D[i][j] = <span class="number">1.0</span> - eps;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) ans *= (<span class="number">1</span> - D[i][j]);</span><br><span class="line">            D[i][j] /= (<span class="number">1.0</span> - D[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">                D[i][i] += D[i][j], D[i][j] *= <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans * solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="例题4-JSOI2008-最小生成树计数"><a href="#例题4-JSOI2008-最小生成树计数" class="headerlink" title="例题4. [JSOI2008]-最小生成树计数"></a>例题4. <a href="https://www.luogu.com.cn/problem/P4208" target="_blank" rel="noopener">[JSOI2008]-最小生成树计数</a></h2><p><strong>最小生成树性质：对于所有最小生成树，每种边权的边数相同；且对于所有生成树，某种权值的边连完后图的联通性相同</strong></p><p>所以可以分别处理每种权值，乘起来。</p><p>算同种边权的边的贡献，由于具有相同权值的边不超过 10 条，暴搜也可以过。。（2^10 很稳的！</p><p>正解是矩阵树。注意，同种边权的边联通性相同并不等于连通，因此要连一些桥，并不影响矩阵树算答案。</p><details>    <summary>code</summary>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">31011</span>, N = <span class="number">105</span>, M = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, ans = <span class="number">1</span>, num;</span><br><span class="line">ll fa[N], fat[N], id[M &lt;&lt; <span class="number">1</span>], a[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; a.w; &#125;</span><br><span class="line">&#125;e[M], t[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fat[x] == x ? x : fat[x] = getfa2(fat[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j][i]) &#123;</span><br><span class="line">                ll d = a[i][i] / a[j][i];</span><br><span class="line">                rep(k, i, n - <span class="number">1</span>)</span><br><span class="line">                    a[i][k] = (a[i][k] - d * a[j][k] % mod + mod) % mod;</span><br><span class="line">                swap(a[i], a[j]), ret = -ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = (ret * a[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    rep(i, l, r) &#123;</span><br><span class="line">        t[i] = e[i];</span><br><span class="line">        <span class="keyword">int</span> u = getfa(t[i].u), v = getfa(t[i].v);</span><br><span class="line">        t[i].u = u, t[i].v = v;  <span class="comment">// 类似于缩点</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        id[++cnt] = u, id[++cnt] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>);</span><br><span class="line">    cnt = unique(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>) - id - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, cnt) fat[i] = i;</span><br><span class="line">    rep(i, l, r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i].u == t[i].v) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = getfa(t[i].u), v = getfa(t[i].v);</span><br><span class="line">        <span class="keyword">if</span> (u != v) --num, fa[u] = v;</span><br><span class="line"></span><br><span class="line">        u = lower_bound(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>, t[i].u) - id;</span><br><span class="line">        v = lower_bound(id + <span class="number">1</span>, id + cnt + <span class="number">1</span>, t[i].v) - id;</span><br><span class="line">        a[u][u]++, a[v][v]++, a[u][v]--, a[v][u]--;</span><br><span class="line"></span><br><span class="line">        u = getfa2(u), v = getfa2(v);</span><br><span class="line">        <span class="keyword">if</span> (u != v) fat[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, cnt) &#123;  <span class="comment">// 有可能不连通，那么连一些桥，并不影响矩阵树算答案</span></span><br><span class="line">        <span class="keyword">int</span> u = getfa2(i), v = getfa2(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">        a[u][u]++, a[v][v]++, a[u][v]--, a[v][u]--;</span><br><span class="line">        fat[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * Gauss(cnt) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    num = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i = j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= m &amp;&amp; e[i].w == e[j].w) ++j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= m; ++j) <span class="keyword">if</span> (e[i].w != e[j].w) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; j) &#123;</span><br><span class="line">            calc(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> u = getfa(e[i].u), v = getfa(e[i].v);</span><br><span class="line">            <span class="keyword">if</span> (u != v) fa[u] = v;</span><br><span class="line">            --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);  <span class="comment">// 判定最小生成树的存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 矩阵树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第二轮选讲</title>
      <link href="2020/07/17/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/17/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="7-17-A"><a href="#7-17-A" class="headerlink" title="7.17 A"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/A" target="_blank" rel="noopener">7.17 A</a></h2><hr><p>算简单题里的偏难题吧。。</p><ul><li>操作 2 次数至少为 max{a_i}</li><li>所有数必须同时减到 0</li></ul><p>进行减一后再加倍不会优于先加倍再减一（我也不知道为啥），所以在最大值 max 没进行一次减一操作时让每个数翻倍，尽可能靠近 max；然后一起减一，比 max 小的数在途中必然会有减到 max 的一半的时候，这时候再翻倍就好了。</p><h2 id="7-17-D"><a href="#7-17-D" class="headerlink" title="7.17 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/D" target="_blank" rel="noopener">7.17 D</a></h2><hr><p><a href="https://www.luogu.com.cn/blog/zyxxs/post-717-d-ti-ti-xie" target="_blank" rel="noopener">数学大佬的博客</a></p><p>反射性质的转化很有意思！代码就先咕咕</p><h2 id="7-17-E"><a href="#7-17-E" class="headerlink" title="7.17 E"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/E" target="_blank" rel="noopener">7.17 E</a></h2><hr><p><a href="https://www.kdocs.cn/l/sf6G7oaScGQm?f=201" target="_blank" rel="noopener">题解</a></p><p>很妙的dp！我不会设计状态。。。</p><h2 id="7-17-F"><a href="#7-17-F" class="headerlink" title="7.17 F"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102657/problem/F" target="_blank" rel="noopener">7.17 F</a></h2><hr><p>1 &lt;= |B| &lt;= |A|</p><p>B 串拼起来的东西只要是 A 的最小循环节就好了。</p><p>有个很妙的转化：将与 A 中 [i, j] 匹配的 B 串看作从 i 指向 j + 1 的<strong>有向边</strong>（注意取模）</p><p>那么问题就变成了求最小环，floyd 可以跑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浙大ACM第一轮选讲</title>
      <link href="2020/07/15/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%80%89%E8%AE%B2/"/>
      <url>2020/07/15/%E6%B5%99%E5%A4%A7ACM%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="7-13-D"><a href="#7-13-D" class="headerlink" title="7.13 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102643/problem/D" target="_blank" rel="noopener">7.13 D</a></h2><hr><p><a href="https://www.luogu.com.cn/blog/zyxxs/post-713-d-ti-ti-xie" target="_blank" rel="noopener">挂一个大佬博客</a></p><p>为啥第一个柿子等于第二个柿子：</p><p>左边式子 = </p><p>P(lca = L) * L +</p><p>P(lca = L - 1) * (L - 1) +</p><p>P(lca = L - 2) * (L - 2) + </p><p>… + </p><p>P(lca = 0) * 0</p><p>重新整理一下就是</p><p>P(lca = L) + </p><p>P(lca = L) + P(lca = L - 1) +</p><p>P(lca = L) + P(lca = L - 1) + P(lca = L - 2) +</p><p>P(lca = L) + P(lca = L - 1) + P(lca = L - 2) + P(lca = L - 3) +</p><p>… +</p><p> P(lca = L) + P(lca = L - 1) + P(lca = L - 2) + P(lca = L - 3) + … P(lca = 1)</p><p>那么左边就等于 sum{1 to L}{P(lca &gt;= i)}</p><p>由于 P(lca &gt;= 0) = 1</p><p>那么进而等于 sum{0 to L}{P(lca &gt;= i)} - 1</p><p>关于本题卷积：</p><p>g(n) = 1 / n! <em> (-1)^n </em> (1 - c^{-n * (l + 1)}) / (1 - c^n)</p><p>h(n) = 1 / n!</p><p>f(n) = \sum_{1 &lt;= j &lt;= n - 1} (n - 1)! <em> g(j) </em> h(n - j - 1)</p><p>其实就是把组合数拆开来了</p><p>最后柿子的 l + 1 是 c = 1 的贡献</p><p>不得不说太妙了，杠了一晚上，数学是短板啊</p><h2 id="7-14-A"><a href="#7-14-A" class="headerlink" title="7.14 A"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/A" target="_blank" rel="noopener">7.14 A</a></h2><hr><p>和<a href="https://codeforces.com/contest/1230/problem/E" target="_blank" rel="noopener">这道</a>一样都用到了 gcd 个数不超过 logn 的性质</p><h2 id="7-14-B"><a href="#7-14-B" class="headerlink" title="7.14 B"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/B" target="_blank" rel="noopener">7.14 B</a></h2><hr><p>听说是广义 sam + 线段树合并，咕咕（题解已存</p><h2 id="7-14-C"><a href="#7-14-C" class="headerlink" title="7.14 C"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/C" target="_blank" rel="noopener">7.14 C</a></h2><hr><p>听说是 wqs 二分，咕咕</p><h2 id="7-14-D"><a href="#7-14-D" class="headerlink" title="7.14 D"></a><a href="https://zjusummer.contest.codeforces.com/group/clkkguw3vK/contest/102647/problem/D" target="_blank" rel="noopener">7.14 D</a></h2><hr><p>有思路的题，对于每个第一步走到的 (x, y)，延长直线经过的整点个数是 n / max(x, y)</p><p>也就是说 n / max(x, y) + 1 = m 且 gcd(x, y) = 1</p><p>枚举左上半边，x 大于 y 的部分，就是求 n / x(下取整) = m - 1 的 x</p><p><strong>x_min = n / m + 1, x_max = n / (m - 1)</strong></p><p>求个 phi 的前缀和就好了</p><h2 id="7-14-E"><a href="#7-14-E" class="headerlink" title="[7.14 E]"></a>[7.14 E]</h2><hr><p><a href="https://www.cnblogs.com/Flying2018/p/13297095.html" target="_blank" rel="noopener">https://www.cnblogs.com/Flying2018/p/13297095.html</a></p><p><a href="https://www.luogu.com.cn/blog/zkdxlpro/post-713-acm-bu-fen-jian-yao-ti-xie" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/zkdxlpro/post-713-acm-bu-fen-jian-yao-ti-xie</a></p><p>咕咕咕</p><h2 id="7-15-A"><a href="#7-15-A" class="headerlink" title="[7.15 A]"></a>[7.15 A]</h2><hr><p>算出最大生成树和最小生成树，判断之间是否有斐波那契数存在（必然可以用一些 1 边替换掉 0 边</p><h2 id="7-15-B"><a href="#7-15-B" class="headerlink" title="[7.15 B]"></a>[7.15 B]</h2><hr><p>考虑一个序列自动机（就是每个位置向之后离自己最近的26个字符的位置分别连一条边）</p><p>相当于在序列自动机上选一个黑点，选任意个后继染黑</p><p>$sg(x) = mex_{T \subset nxt(x)}(XOR_{k\in T}sg(k))$</p><p>而 sg 只会是 2^0, 2^1, 2^2…</p><p>这也很好想，归纳可得，若当前节点的 sg 是 2^i, 后继的 sg 只会是 2^0, 2^1 … 2^{i - 1}，选任意个 sg 值异或起来得到的是 0 ~ 2^i - 1，因此 mex 出来就是 2^i。</p><p>这就等价于对后继的重标号取 mex，非常喵喵</p><h2 id="7-15-E"><a href="#7-15-E" class="headerlink" title="[7.15 E]"></a>[7.15 E]</h2><hr><p>真就 O(nlogn) 算法满地爬呗。。。比赛时没想有点可惜</p><p>可以 dfs 序上建主席树，或者 dsu on tree + 树状数组，或者线段树合并，etc。。</p><h2 id="7-15-F"><a href="#7-15-F" class="headerlink" title="[7.15 F]"></a>[7.15 F]</h2><hr><p>巧妙的构造。题意其实就是构造一个没有等差数列的排列。每次按奇偶位排序，例如奇数位放前面、偶数位放后面，这样就消除了跨越左右的等差数列，分治思想</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Week2测试题解</title>
      <link href="2020/07/15/Week2%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/"/>
      <url>2020/07/15/Week2%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="AIZU2989"><a href="#AIZU2989" class="headerlink" title="AIZU2989"></a><a href="https://vjudge.net/contest/381744#problem/B" target="_blank" rel="noopener">AIZU2989</a></h2><hr><p>giao，全想着 L、R 逆推了，但是写挂了，爬。。实际上有更好写的做法</p><p>发现 ai 相对顺序无关，可以先从小到大排序。容易发现操作都是 小于某数的向左 大于某数的向右，ai 一直具有单调性（这个我想到了。。）  二分就好了</p><h2 id="AIZU2990"><a href="#AIZU2990" class="headerlink" title="AIZU2990"></a><a href="https://vjudge.net/contest/381744#problem/C" target="_blank" rel="noopener">AIZU2990</a></h2><hr><p>注意，初始只能往右走。就是个 sb 题！！题目读错了哭</p><p>一直在想 set，但这题用 set 会很麻烦。</p><p>序列差分，算出每个点经过的次数 x，来回的次数就是 max{x}，减去的前后缀也必定是 经过 x 次点的最左和最右。。。</p><h2 id="AGC041B"><a href="#AGC041B" class="headerlink" title="AGC041B"></a><a href="https://atcoder.jp/contests/agc041/tasks/agc041_b" target="_blank" rel="noopener">AGC041B</a></h2><hr><p>不错的题，容易想到答案满足单调性，可以二分。二分的位置只要奋力超过或赶上 p 即可，那么 m 位评委尽量不投 p 就好了。</p><h2 id="AIZU2992"><a href="#AIZU2992" class="headerlink" title="AIZU2992"></a><a href="https://vjudge.net/contest/381744#problem/E" target="_blank" rel="noopener">AIZU2992</a></h2><hr><p>不是很难的dp，可惜题目读不懂。。</p><p>显然 a，r，b 从大到小排序最优。dp，红色总数不能超过 totr，黑色总数不能超过 totb，所以 f[i, j, k] 表示前 i + j 中有 i 红，j 黑，红色总数为 k 的最大不改变颜色的气球数量</p><h2 id="AIZU2995"><a href="#AIZU2995" class="headerlink" title="AIZU2995"></a><a href="https://vjudge.net/contest/381744#problem/F" target="_blank" rel="noopener">AIZU2995</a></h2><hr><p>好题！</p><p>考虑整棵树，每个点选 ci 还是 di，这跟“树”这个结构没有关系，就是一个经典问题：一个 n 个点 m 条边的图，每条边连接 ci 和 di，可以染黑 ci 或 di，问最大黑点数</p><p>显然是 min{|V|, |E|}：首先最多有 |V| 个，其次如果边为 V - 1（是树）那就是 V - 1</p><p>min{|V|, |E|} = |V| - 1 + [是否存在非树边]，并查集维护就好了。</p><p>对于每个子树：dsu on tree。考虑到 有删除操作，用可撤销并查集维护。是真的难写（</p><h2 id="AIZU2991"><a href="#AIZU2991" class="headerlink" title="AIZU2991"></a><a href="https://vjudge.net/contest/381744#problem/G" target="_blank" rel="noopener">AIZU2991</a></h2><hr><p>2^{n+1} 中选 2^n 个，也就是选一半</p><p>v 和 v ^ X 必然选一个，&amp;值为 A 的对必然不选一个，|值为 O 的对必然不选一个（找这样的对，枚举子集即可</p><p>2-sat，输出卡行末空格恶心了我半天</p><h2 id="AIZU2994"><a href="#AIZU2994" class="headerlink" title="AIZU2994"></a><a href="https://vjudge.net/contest/381744#problem/H" target="_blank" rel="noopener">AIZU2994</a></h2><hr><p>C = V - E + F</p><p>C：连通块数   V：点数   E：边数   F：内部区域数</p><p>（注意网格图经常考这个）</p><p>由期望的线性性得，E(C) = E(V) - E(E) + E(F)</p><p>而本题是树，F 为 0</p><p>所以 E(c1c2) = E(v1v2) + E(e1e2) - E(v1e2) - E(v2e1)</p><ul><li><p>点点贡献：可以推柿子（别忘了组合数），也有更灵活的解法。考虑一对点 (a, b) 的贡献（a 在树 1 中，b 在树 2 中），是 1 / 4, 而总共有 n(n - 1) 对点，所以就是 n(n - 1) / 4</p></li><li><p>点边贡献：枚举树 2 中一条边 (u, v)，与树 1 中点 x 的贡献是 1 / 8, 总共是 (n - 1)(n - 2) / 8</p></li><li><p>边边贡献：这个就不能 O(1) 算了，枚举树 2 中一条边 (u, v)，与树 1 中边的总贡献是 (n - 1 - u和v在树 1 中连的边) / 16</p></li></ul><p>套路，据我哥说在他们那个时候，乘积期望也是套路题哇！多练多练</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】树的进阶</title>
      <link href="2020/07/15/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6/"/>
      <url>2020/07/15/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>难度递增！</p><h2 id="CF1305D"><a href="#CF1305D" class="headerlink" title="CF1305D"></a><a href="https://codeforces.com/problemset/problem/1305/D" target="_blank" rel="noopener">CF1305D</a></h2><hr><p>n / 2 次询问，想到每次删至少两个节点。最暴力的思路是选任意两个节点，将 lca 为根的两个节点所在的子树删掉，但是这会被一条链的情况卡成询问 n 次。考虑选任意两个叶子，若 lca 等于其中之一那么那个叶子就是根，否则删除两个叶子。</p><h2 id="CF1210C"><a href="#CF1210C" class="headerlink" title="CF1210C"></a><a href="https://codeforces.com/problemset/problem/1210/C" target="_blank" rel="noopener">CF1210C</a></h2><hr><p>询问每条链的 gcd 之和。考虑 gcd 一个很重要的性质：长度为 n 的区间所有子区间的 gcd 不会超过 logn 个。log 级别，开 vector 或者 map 存每个节点为下端点的链gcd，每次更新只有 logn 复杂度。</p><h2 id="CF980E"><a href="#CF980E" class="headerlink" title="CF980E"></a><a href="https://codeforces.com/problemset/problem/980/E" target="_blank" rel="noopener">CF980E</a></h2><hr><p>考虑到 2^i 是个很特殊的东西，必然贪心的选 i 大的节点。按 i 从大到小排序，i 节点保证被选的前提是 i 到根的所有节点都保留，暴力判保留节点后是否超过 n - K 会 TLE，可以用 dfs 序上树状数组。做标记暴力跳就好了，反正是 O(n).</p><h2 id="CF1098C"><a href="#CF1098C" class="headerlink" title="CF1098C"></a><a href="https://codeforces.com/problemset/problem/1098/C" target="_blank" rel="noopener">CF1098C</a></h2><hr><p>考虑 K（最大分支）满足二分性质，先二分出最终答案 ans，判能否构成树的条件是：一条链形式的子树和 &gt;= S, K 叉树形式的子树和 &lt;= S。构造也很容易，我的方法是将一条链的末尾节点不断挂上来，填一棵 K 叉树。</p><h2 id="CF1149C"><a href="#CF1149C" class="headerlink" title="CF1149C"></a><a href="https://codeforces.com/contest/1149/problem/C" target="_blank" rel="noopener">CF1149C</a></h2><hr><p>有意思的题，考虑直径的括号序列，必然是 )))())))…(((((()(((( 这样 ‘)))))’ + 匹配括号 + ‘(((((‘ 的形式。经典套路，将 ( 设为 1，) 设为 -1，答案就是相邻的两段序列之差最大值，可以用线段树维护（各种细节啊啊啊。。</p><h2 id="CF1083C"><a href="#CF1083C" class="headerlink" title="CF1083C"></a><a href="https://codeforces.com/contest/1083/problem/C" target="_blank" rel="noopener">CF1083C</a></h2><hr><p>有意思的题+1，询问每条链最大的 mex。神仙做法。首先，能线段树维护的信息都具有<strong>可合并性</strong>。容易想到二分 mex，判能否构成链。线段树 [l, r] 节点表示 权值为 l ~ r 的节点能否构成链，合并时枚举端点用 lca 判点是否在路径上即可。最后外面那个二分也可以省掉，直接在线段树上“二分”，统计答案。</p><h2 id="AGC023F"><a href="#AGC023F" class="headerlink" title="AGC023F"></a><a href="https://atcoder.jp/contests/agc023/tasks/agc023_f" target="_blank" rel="noopener">AGC023F</a></h2><hr><p>神仙题++</p><p>先考虑前置问题：两个 01 序列相接，逆序对尽量小</p><p>设它们 01 个数分别为 sx0, sx1, sy0, sy1, x &lt; y</p><p>显然 sx1 <em> sy0 &lt;= sx0 </em> sy1 时不必交换两者。</p><p>变形：sx1 / sx0 &lt;= sy1 / sy0.</p><p>考虑此题，初始时将点看作连通块，取出目前没有被选且 s1 / s0 最小的连通块（堆维护）</p><p>若它的父亲已经被选，就选了它；否则容易证明它一定会在它的根的父亲被选后立刻被选，就将它和根的父亲所在连通块合并，得到新的连通块</p><p>类似的还有 POJ2054-Color a Tree，贪心的每次将最大的点和它父亲合并</p><h2 id="CF1168D"><a href="#CF1168D" class="headerlink" title="CF1168D"></a><a href="https://codeforces.com/contest/1168/problem/d" target="_blank" rel="noopener">CF1168D</a></h2><hr><p>充要条件是所有叶子的深度相同，设为 mxdep, 设 lenx = mxdep - depx</p><p>且对于任何节点 x，sum{f(x, c)} &lt;= lenx，其中 f(x, c) 表示任何一条 x 到其子树中叶子的链上 c 出现次数的最大值</p><p>证必要性：显然       证充分性：据说用归纳法证明</p><p>怎么处理修改？总不能每次暴力往上跳修改 f(x, c) 吧。</p><p>注意到当节点只有一个孩子时不需要判上面那个东西，相当于可以忽视</p><p>因此想到将父亲只有自己一个孩子的节点向上压缩，修改的复杂度就是深度</p><p>而满足每一层的节点个数都严格大于上一层（不然就压缩了），深度只有 sqrt(n)</p><p>总复杂度就是 O(Qsqrt(n)), 非常的喵！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】字符串</title>
      <link href="2020/07/09/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/07/09/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="POJ3167"><a href="#POJ3167" class="headerlink" title="[POJ3167]"></a>[POJ3167]</h2><hr><p>KMP + 树状数组，注意细节</p><h2 id="CF547E"><a href="#CF547E" class="headerlink" title="[CF547E]"></a>[CF547E]</h2><hr><p>套路好题（</p><p>首先有个性质：AC自动机 fail 树上的父亲节点是子节点的子串。</p><p>然后就有个经典套路：AC自动机上找一个串的出现次数可以在 fail 树上跑。</p><p>将询问离线，从小到大插入 AC 自动机（插入方法是节点 val = 1），树状数组维护 dfs 序算询问点子树中 1 的个数。</p><h2 id="965E"><a href="#965E" class="headerlink" title="[965E]"></a>[965E]</h2><hr><p>考虑在 Trie 上做。然后就变成一棵有许多黑点的 Trie 树，要将黑点尽可能地放到祖先节点去。</p><p>优先队列维护，优先放原本深度大的点。</p><h2 id="HDU3336"><a href="#HDU3336" class="headerlink" title="[HDU3336]"></a>[HDU3336]</h2><hr><p>KMP 性质题。AC 自动机上找串出现次数可以跑 fail 树，但本题要所有前缀，会TLE。</p><p>考虑 fail 指针意义，设计 DP：f[i] 表示以 i 结尾的所有前缀个数，f[i] = f[fail[i]] + 1.</p><h2 id="HDU5536"><a href="#HDU5536" class="headerlink" title="[HDU5536]"></a>[HDU5536]</h2><hr><p>套路题直接上 01 trie，值得注意的是：本题 n^3 会 TLE，因为重复插入了很多串； n^2 枚举 i 和 j 再减掉 Trie 中 i 和 j 串的贡献就可以过啦。</p><hr><p>总结：</p><ul><li><p>KMP 和 AC 自动机可解决出现位置（分别用 fail 指针和 fail 树）；</p></li><li><p>想除去 Trie 或 AC 自动机中某个串时只要将 串沿途的 val -= 1 就好了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU4653]-我的微积分初探</title>
      <link href="2020/07/08/%5BHDU4653%5D-%E6%88%91%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E5%88%9D%E6%8E%A2/"/>
      <url>2020/07/08/%5BHDU4653%5D-%E6%88%91%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://coderoj.gitee.io/2020/07/01/3880663/" target="_blank" rel="noopener">同班大佬刚了一晚的博客</a></p><p>真的很神了，从他的博客里也能学到理论知识，本篇博客主要对上文中部分文字做解释 ~</p><ul><li><p>原函数：对于一个定义在某区间的已知函数 $f(x)$，如果存在可导函数 $F(x)$，使得在该区间内的任一点都存在 $dF(x)=f(x)dx$，则在该区间内就称函数$F(x)$ 为函数 $f(x)$ 的原函数。</p></li><li><p>牛顿-莱布尼茨公式（微积分基本定理）：一个连续函数在区间 $[a，b]$ 上的定积分等于它的任意一个原函数在区间 $[a，b]$ 上的增量</p></li></ul><p>——用<a href="https://www.shuxuele.com/calculus/integration-introduction.html" target="_blank" rel="noopener">点这里</a> 注水那个例子来解释，连续函数就是 $f(x) = 2x$, 原函数就是 $F(x) = x^2 + C$</p><ul><li><p>根据<a href="https://www.shuxuele.com/calculus/integration-rules.html" target="_blank" rel="noopener">积分法则</a>可以得到 $\int^1_0 y^{p-1}<em>dx = (\frac{1}{p}</em>y^p)|^1_0$，其中等式右边表示 将 $1$ 和 $0$ 代入 $\frac{1}{p}*y^p$ 后相减，原理是👆微积分基本定理</p></li><li><p>对于两个不相关的事件，乘积的期望 = 期望的乘积，且本题在单位球中（半径为 $1$），因此 $k$ 扩展那里 $ans(p, n, k) = ans(p, n - 1, k - 1) * ans(p, n, 0)$，相当于把第 $k$ 个的距离缩到第 $0$ 个的距离范围内。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】贪心</title>
      <link href="2020/07/07/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%B4%AA%E5%BF%83/"/>
      <url>2020/07/07/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>专题助我发现：我贪心弱的一！！！多练！！！</p><h2 id="CF1373F"><a href="#CF1373F" class="headerlink" title="CF1373F"></a><a href="https://codeforces.com/problemset/problem/1373/F" target="_blank" rel="noopener">CF1373F</a></h2><hr><p>做法一：二分 + 贪心 O(nlogn)（题解做法）</p><p>本题单调性体现在哪呢？？显然当第一个电站供应量确定时，所有电站的供应量都确定了</p><p>设 b[1] 流给 a[1] 的量为 x</p><p>有两种情况：<br>· “断流”，即 x 太大，导致 b[1] 给 a[2] 供应太少，导致后面断流<br>· 流一圈后从 b[n] 流回 a[1] 的量加上 x 不 &gt;= a[1]，因为中途可能有点满流</p><p>也就是说 x 太大太小都不行，二分传回值标记一下就行了。</p><p>做法二：差分约束 O(n)</p><p>观察到有很多限制，设 x[i] 表示 b[i] 给 a[i] 的量就可以差分约束，但是 spfa 跑是 n^2 的好像会被卡，，观察建成的图，是一朵菊花的样子，而我们只要判是否有正权环就行，这个可以 O(n) 做。</p><p>做法二 Code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), tot -= a[i];</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]), tot += b[i];</span><br><span class="line">        <span class="keyword">if</span> (tot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">ll mn = b[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, <span class="number">2</span> * n) &#123;</span><br><span class="line">sum += a[i % n + <span class="number">1</span>] - b[i % n + <span class="number">1</span>];</span><br><span class="line">mn = min(mn, sum + b[i % n + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (sum - mn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">puts</span>(ff ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NOIP2012国王游戏"><a href="#NOIP2012国王游戏" class="headerlink" title="NOIP2012国王游戏"></a><a href="https://www.luogu.com.cn/problem/P1080" target="_blank" rel="noopener">NOIP2012国王游戏</a></h2><hr><p>很经典的题，贪心 + 高精度</p><p>邻项交换，微扰可以证明贪心正确性</p><h2 id="CF1251E2"><a href="#CF1251E2" class="headerlink" title="CF1251E2"></a><a href="https://codeforces.com/problemset/problem/1251/E2" target="_blank" rel="noopener">CF1251E2</a></h2><hr><p>考虑选择 x 人时，所有 mi &lt; x 的人都会自动投票，所以将 m 降序排列且降序处理</p><h2 id="CF1329C"><a href="#CF1329C" class="headerlink" title="CF1329C"></a><a href="https://codeforces.com/problemset/problem/1329/C" target="_blank" rel="noopener">CF1329C</a></h2><hr><p>一句话题意：拿掉元素和尽可能大的同时维护二叉堆性质</p><p>我们肯定贪心的取靠近根结点的位置，每个位置取到不能取为止。</p><p>什么叫不能取？它扯上来那条链的末尾节点深度为 g 了。所以我们对于每个节点维护链尾节点就好了！</p><h2 id="AtCoder-cf17-final-d"><a href="#AtCoder-cf17-final-d" class="headerlink" title="AtCoder-cf17_final_d"></a><a href="https://atcoder.jp/contests/cf17-final/tasks/cf17_final_d?lang=en" target="_blank" rel="noopener">AtCoder-cf17_final_d</a></h2><hr><p><a href="https://img.atcoder.jp/cf17-final/editorial.pdf" target="_blank" rel="noopener">https://img.atcoder.jp/cf17-final/editorial.pdf</a></p><p>· 贪心 + dp</p><p>关于为什么按 hi + pi 升序排列，官方题解说的很有道理，大致意思就是 显然对于高度的限制<strong>越松越好</strong>，通过邻项微扰来证明贪心正确性。</p><p>这边提供另外一种证明：考虑一个合法的选的序列，对于每一个 i 必须满足 sum_{j &lt;= i}{h_j} &lt;= h_i + p_i,<br>因为前缀和递增所以 hi + pi 也必须递增。</p><p>总之是一道很妙的题！</p><h2 id="HDU5380"><a href="#HDU5380" class="headerlink" title="HDU5380"></a><a href="https://vjudge.net/problem/HDU-5380" target="_blank" rel="noopener">HDU5380</a></h2><hr><p><a href="https://www.cnblogs.com/keximeiruguo/p/7684032.html" target="_blank" rel="noopener">https://www.cnblogs.com/keximeiruguo/p/7684032.html</a></p><p>把糖果视作价格高低不同，就可以贪心了（这题好hard</p><h2 id="luogu1484种树"><a href="#luogu1484种树" class="headerlink" title="luogu1484种树"></a><a href="https://www.luogu.com.cn/problem/P1484" target="_blank" rel="noopener">luogu1484种树</a></h2><hr><p>这类问题选择当前最优解时可能不是全局最优解，那怎么办？<strong>反悔贪心</strong> 可以使得贪心随便选择，都能到达正解。</p><p>具体操作用优先队列。对于限制采用缩点（用了 i 就将 l[i]、i、r[i] 缩在一起，反悔了选择了 l[i] 和 r[i] 就将 l[l[i]]、l[i]、i、r[i]、r[r[i]] 缩在一起），反悔就将权值为 val[l[i]] + val[r[i]] - val[i] 的点入队，每次取队首就好了。</p><h2 id="SP27102"><a href="#SP27102" class="headerlink" title="SP27102"></a><a href="https://www.luogu.com.cn/problem/SP27102" target="_blank" rel="noopener">SP27102</a></h2><hr><p>我们优先格式化 a &lt;= b 的硬盘，按 a 从小到大排序，可以尽量用少的空间来换多的空间，贪心，使得策略最可能成功。</p><hr><p>总结：做贪心题直觉很重要，限制越松越好之类的 要体会到啊，多练。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2369]-Ants on a Circle</title>
      <link href="2020/07/04/%5BAT2369%5D-Ants%20on%20a%20Circle/"/>
      <url>2020/07/04/%5BAT2369%5D-Ants%20on%20a%20Circle/</url>
      
        <content type="html"><![CDATA[<p>两人碰面后方向相反速度不变——这种题有个名字：弹性碰撞（还挺形象</p><p>网络上也有类似的：<a href="https://www.cnblogs.com/liuchanglc/p/12700770.html#_label6" target="_blank" rel="noopener">点我</a></p><p>弱化版1：（上面博客 $T1$）要求所有最终的位置，从小到大输出，不要求一一对应</p><p>解法：可以看作相遇的蚂蚁们穿过了彼此，发生碰撞了</p><p>弱化版2：（上面博客 $T2$）</p><p>解法：碰撞的过程可以看作交换编号，因此可以得出结论：编号为 $i$ 的蚂蚁碰到 $x$ 个逆向的蚂蚁后编号变为 $i + x$。</p><p>本题：一个道理，可以看作一只蚂蚁穿过 $0$ ~ $l - 1$，所有编号都会左移/右移一位</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, L, T, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; T;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="keyword">int</span> w; <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;a[i], &amp;w);</span><br><span class="line">a[i] += (w == <span class="number">1</span> ? T : -T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">pos += a[i] / L - (a[i] % L &lt; <span class="number">0</span>);</span><br><span class="line">a[i] = (a[i] % L + L) % L;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">pos = (pos % n + n) % n + <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[pos]);</span><br><span class="line">pos = (pos == n ? <span class="number">1</span> : pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Jun CF&amp;AT 练题汇总</title>
      <link href="2020/06/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jun%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/06/30/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Jun%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="CF1076E-Vasya-and-a-Tree"><a href="#CF1076E-Vasya-and-a-Tree" class="headerlink" title="[CF1076E]-Vasya and a Tree"></a>[CF1076E]-Vasya and a Tree</h2><hr><p>· 巧妙的dfs</p><p>没有数据结构可以直接维护，数据范围是3e5所以考虑dfs（？）  到达节点 x 时将 x 的操作执行掉（方法：根据深度维护一个树状数组，回溯时统计答案并消除影响）</p><h2 id="CF731F-Video-Cards"><a href="#CF731F-Video-Cards" class="headerlink" title="[CF731F]-Video Cards"></a>[CF731F]-Video Cards</h2><hr><p>· 利用“倍数”<br>· 观察数据范围：ai &lt;= 2e5!!!</p><p>y 要减到 x 的 k 倍时，y 在 xk ～ x(k + 1) - 1 的区间内。所以只要记录每个区间有几个数就可以算了，前缀和正解！！</p><p>再抽象化。求的是 sum{ 下取整(ai / x) * x }，那么枚举 下取整(ai / x) 就好了。</p><p>所以是.. nlogn?</p><p>P.S. 注意重复的 a[i] 别重复枚举qwq，200000个 1 就炸飞了啊嗷？</p><h2 id="CF1163C1-Power-Transmission-Easy-Edition"><a href="#CF1163C1-Power-Transmission-Easy-Edition" class="headerlink" title="[CF1163C1]-Power Transmission(Easy Edition)"></a>[CF1163C1]-Power Transmission(Easy Edition)</h2><hr><p>恶·心的计算题</p><h2 id="CF981D-Bookshelves"><a href="#CF981D-Bookshelves" class="headerlink" title="[CF981D]-Bookshelves"></a>[CF981D]-Bookshelves</h2><hr><p>·位运算+dp</p><p>从高位到低位chk：能否在已chk的高位取 1/0 的情况下，该位取 1。</p><h2 id="CF599D-Spongebob-and-Squares"><a href="#CF599D-Spongebob-and-Squares" class="headerlink" title="[CF599D]-Spongebob and Squares"></a>[CF599D]-Spongebob and Squares</h2><hr><p>推式子题，算出 m 关于 k 和 n 的关系式。枚举 n，算出 m。根据式子可得，n 大约是 1e6 级别的，所以不会 T！</p><h2 id="CF148E-Porcelain"><a href="#CF148E-Porcelain" class="headerlink" title="[CF148E]-Porcelain"></a>[CF148E]-Porcelain</h2><hr><p>·分组背包</p><p>先处理第 i 组容量为 j 时的最大价值和 val[i, j], 再注意到每组只能取一个 val[]，想到分组背包。</p><p>【惊！1e8 竟然可以 AC？</p><h2 id="CF1311F-Moving-Points"><a href="#CF1311F-Moving-Points" class="headerlink" title="[CF1311F]-Moving Points"></a>[CF1311F]-Moving Points</h2><hr><p>·树状数组+离散化</p><p>分类讨论，可得出结论：xi &lt; xj 且 vi &lt; vj，i 和 j 就不能相遇了（代价为 xj - xi）。</p><p>于是用树状数组计算 xj - xi 之和。</p><h2 id="CF1043E-Train-Hard-Win-Easy"><a href="#CF1043E-Train-Hard-Win-Easy" class="headerlink" title="[CF1043E]-Train Hard, Win Easy"></a>[CF1043E]-Train Hard, Win Easy</h2><hr><p>·妙题！</p><p>min(xi + yj, xj + yi) 这样子涉及到不同组的就很不爽，没法处理</p><p>xi + yj - (xj + yi) = (xi - xj) - (yi - yj)</p><p>讨论 (xi - xj) - (yi - yj) 的正负就好了</p><h2 id="CF1360H-Binary-Median"><a href="#CF1360H-Binary-Median" class="headerlink" title="[CF1360H]-Binary Median"></a>[CF1360H]-Binary Median</h2><hr><p>·二分</p><p>m 才 60。。要注意编号计算，很恶心</p><h2 id="CF1157D-N-Problems-During-K-Days"><a href="#CF1157D-N-Problems-During-K-Days" class="headerlink" title="[CF1157D]-N Problems During K Days"></a>[CF1157D]-N Problems During K Days</h2><hr><p>·构造</p><p>只要想到“在 1 2 .. k 的基础上修改”就好了，注意“2倍关系”的限制</p><h2 id="CF1015E2-Stars-Drawing-Hard-Edition"><a href="#CF1015E2-Stars-Drawing-Hard-Edition" class="headerlink" title="[CF1015E2]-Stars Drawing (Hard Edition)"></a>[CF1015E2]-Stars Drawing (Hard Edition)</h2><hr><p>·套路题</p><p>并没有数量限制啊，凡是上下左右都有’<em>‘的位置都可以画十字啊，size根据上下左右’</em>‘的长度来定，别忘了check是否完全覆盖，，，</p><h2 id="CF792D-Paths-in-a-Complete-Binary-Tree"><a href="#CF792D-Paths-in-a-Complete-Binary-Tree" class="headerlink" title="[CF792D]-Paths in a Complete Binary Tree"></a>[CF792D]-Paths in a Complete Binary Tree</h2><hr><p>·找规律</p><p>把每个数分解成 2 的幂次乘奇数的形式</p><h2 id="CF1012C-Hills"><a href="#CF1012C-Hills" class="headerlink" title="[CF1012C]-Hills"></a>[CF1012C]-Hills</h2><hr><p>·DP</p><p>设置的状态包括位置（第 i 个山坡）、已修建房屋数量（j）、当前位置是否受上一座房屋影响（k）</p><h2 id="CF19B-Checkout-Assistant"><a href="#CF19B-Checkout-Assistant" class="headerlink" title="[CF19B]-Checkout Assistant"></a>[CF19B]-Checkout Assistant</h2><hr><p>·背包</p><p>选了 k 个, 时间为 T,  T = t1 + t2 + … + tk,</p><p>T &gt;= n - k, T + k &gt;= n</p><p>所以 (t1 + 1) + (t2 + 2) + … + (tk + k) &gt;= n.</p><p>由此想到将 ti ++。</p><p>问题转化为：选择总体积 &gt;= n 的物品使得总费用最小，01背包</p><h2 id="CF9D-How-many-trees"><a href="#CF9D-How-many-trees" class="headerlink" title="[CF9D]-How many trees?"></a>[CF9D]-How many trees?</h2><hr><p>·DP</p><p>设计状态应包含节点数(i), 高度(j)</p><p>好写好调OvO</p><h2 id="CF730J-Bottles"><a href="#CF730J-Bottles" class="headerlink" title="[CF730J]-Bottles"></a>[CF730J]-Bottles</h2><hr><p>·背包</p><p>第一问比较好想，贪心，优先用 b[i] 大的杯子，算出答案为 k；</p><p>第二问<strong>是在第一问基础上的</strong>，设 tot = sigma(a[i]), 选中的杯子 a[i] 之和为 A，b[i] 之和为 B</p><p>那么必须满足 tot - A &lt;= B - A, 即 tot &lt;= B</p><p>现在有三条：</p><ol><li>选 k 个杯子；</li><li>B &gt;= tot；</li><li>A 最大。</li></ol><p>背包！写的时候数组开错了，越界，各种灵异事件 ಥ_ಥ 时间复杂度其实是 1e8 的，但 93ms 就过了，emm？</p><h2 id="CF946G-Almost-Increasing-Array"><a href="#CF946G-Almost-Increasing-Array" class="headerlink" title="[CF946G]-Almost Increasing Array"></a>[CF946G]-Almost Increasing Array</h2><hr><p>·树状数组维护dp</p><p>经典题，撇开“去掉一个”的限制，严格增加就是 j &gt; i, a[j] &gt; a[i], a[j] - a[i] &gt;= j - i 即 a[j] - j &gt;= a[i] - i; 那么维护一个 LIS 就好了</p><p>枚举去掉的位置，该位置后面的 要从 a[i] - i 变成 a[i] - i + 1（哎呀就这意思你懂的吧</p><p>倒腾倒腾就出来了</p><h2 id="CF478D-Red-Green-Towers"><a href="#CF478D-Red-Green-Towers" class="headerlink" title="[CF478D]-Red-Green Towers"></a>[CF478D]-Red-Green Towers</h2><hr><p>·线性DP</p><p>最大高度要先算qwq，f[i, j] 表示从上往下数第 i 层，用了 j 个红色的方案数，然后滚动数组优化空间</p><h2 id="CF1132F-Clear-the-String"><a href="#CF1132F-Clear-the-String" class="headerlink" title="[CF1132F]-Clear the String"></a>[CF1132F]-Clear the String</h2><hr><p>·区间DP</p><p>（完了我怎么简单题也不会</p><p>考虑当前字符，两种删除方法：1. 直接单个删除 2. 和后面同色的一起删除</p><p>所以就是 f[l, r] = min(f[l + 1, r] + 1, f[l + 1, i - 1] + f<a href="i 与 l 同色">i, r</a>)</p><h2 id="CF1344A-Hilbert’s-Hotel"><a href="#CF1344A-Hilbert’s-Hotel" class="headerlink" title="[CF1344A]-Hilbert’s Hotel"></a>[CF1344A]-Hilbert’s Hotel</h2><hr><p>·喵题！</p><p>观察样例第三组，找规律：</p><p>区间 [0, 1, 2, 3] 变为 [5, 6, 7, 4]</p><p>区间 [4, 5, 6, 7] 变为 [9, 10, 11, 8]</p><p>…</p><p>区间 [0 + nk, 1 + nk, 2 + nk, 3 + nk] 变为 [5 + nk, 6 + nk, 7 + nk, 4 + nk]</p><p>如果集合 [5 + nk, 6 + nk, 7 + nk, 4 + nk] 含有相同的数字那就是 NO 啦</p><p>若 k 相同时，这四个数有 % n 同余的，那就是 NO</p><p>为什么呢？a + nk = b + nk (% n)   =&gt;   a + nk’ = b</p><h2 id="CF140A-New-Year-Table"><a href="#CF140A-New-Year-Table" class="headerlink" title="[CF140A]-New Year Table"></a>[CF140A]-New Year Table</h2><hr><p>几何题，最近也看了高中数学必修四的三角函数，正好用到！吸吸。注意，c++函数都是弧度制，pi = acos(-1)。</p><h2 id="CF141C-Queue"><a href="#CF141C-Queue" class="headerlink" title="[CF141C]-Queue"></a>[CF141C]-Queue</h2><hr><p>考虑把 1 ~ n 作为身高分给 n 个人。每个人的排名只受前面人的影响，所以我们倒着来分。</p><h2 id="CF141D-Take-off-Ramps"><a href="#CF141D-Take-off-Ramps" class="headerlink" title="[CF141D]-Take-off Ramps"></a>[CF141D]-Take-off Ramps</h2><hr><p>一眼最短路。注意：起点 x - p, 终点 x + d, 费用 p + t</p><p>容易想到起点向终点连边，但是题目还可以不选跳板，甚至逆行。不用从一个位置向其他每个位置连边，那样时空都是 n^2 的！考虑到每次徒步走都是有目标的，没有无缘无故的逆行，只要在出发点和目标之间连边就好了。</p><h2 id="CF145B-Lucky-Number-2"><a href="#CF145B-Lucky-Number-2" class="headerlink" title="[CF145B]-Lucky Number 2"></a>[CF145B]-Lucky Number 2</h2><hr><p>·找规律</p><p>最基本的性质：4开头7结尾：47比74多1；  7开头4结尾：74比47多1；  4开头4结尾 / 7开头7结尾：相同</p><p>因此 |num(47) - num(74)| &gt; 1 的情况都是无解。再根据 num(47) 和 num(74) 的大小关系进行分讨（呕</p><h2 id="CF242E-XOR-on-Segment"><a href="#CF242E-XOR-on-Segment" class="headerlink" title="[CF242E]-XOR on Segment"></a>[CF242E]-XOR on Segment</h2><hr><p>·数据结构康复训练（</p><p>维护区间异或和。因为区间和无法直接异或，我们想到对二进制每一位分别开线段树！异或变成 0/1 个数的转换了。</p><h2 id="CF380C-Sereja-and-Brackets"><a href="#CF380C-Sereja-and-Brackets" class="headerlink" title="[CF380C]-Sereja and Brackets"></a>[CF380C]-Sereja and Brackets</h2><hr><p>刚开始想到是 r 前的对数 - l 前的对数 - 过交界处的对数，但是最后一项不会维护T T</p><p>区间括号配对数直接线段树维护就好了嘛，记录每个区间多余的 ‘(‘’)’ 个数和已配对的个数</p><h2 id="CF1244C-The-Football-Season"><a href="#CF1244C-The-Football-Season" class="headerlink" title="[CF1244C]-The Football Season"></a>[CF1244C]-The Football Season</h2><hr><p>x = (p - yd) / w.</p><p>因此要满足两个限制：1. x为整数 2. x + y &lt;= n</p><p>第一个用 exgcd 应该也能做。。但 w 很小呀，枚举 y = 0 ~ w - 1 也能过</p><h2 id="CF1359D"><a href="#CF1359D" class="headerlink" title="[CF1359D]"></a>[CF1359D]</h2><hr><p>枚举最大值，统计每个连续自序列的最大值</p><h2 id="CF181D-Word-Cut"><a href="#CF181D-Word-Cut" class="headerlink" title="[CF181D]-Word Cut"></a>[CF181D]-Word Cut</h2><hr><p>可以发现就是一个字符串不断循环。n^2 找出 s 与 t 相配的所有位置，dp就可以了</p><h2 id="CF176C-Playing-with-Superglue"><a href="#CF176C-Playing-with-Superglue" class="headerlink" title="[CF176C]-Playing with Superglue"></a>[CF176C]-Playing with Superglue</h2><hr><p>需要手玩的一道题。容易发现 max(abs(x1 - x2), abs(y1 - y2)) &gt; 4 的时候是后手赢，= 4 且 min = 3 或 4 的时候是后手赢，其余时间都是先手，至于为什么。。这跟这个游戏的规则有关系。</p><h2 id="CF180E"><a href="#CF180E" class="headerlink" title="[CF180E]"></a>[CF180E]</h2><hr><p>套路——用vector维护同一颜色的位置，查找就很方便</p><h2 id="CF148D"><a href="#CF148D" class="headerlink" title="[CF148D]"></a>[CF148D]</h2><hr><p>期望概率什么的 Qaq dp算是最善良的了。。</p><p>f[i, j] 表示袋子里还有 i 个白的、j 个黑的，公主赢的概率，转移方程不难，因为在一轮转移中龙的情况一并考虑掉了。</p><p>还有一种方法，因为有精度限制，枚举几千轮模拟操作也是可以过的，，</p><h2 id="CF453B"><a href="#CF453B" class="headerlink" title="[CF453B]"></a>[CF453B]</h2><hr><p>b不会 &gt;= 59, 因为选 1 必然不会更差！</p><p>58 以内有 16 个质数，每个只能用一次。想到什么了？状压dp. （3e8 2000ms丝毫不慌</p><h2 id="CF453C"><a href="#CF453C" class="headerlink" title="[CF453C]"></a>[CF453C]</h2><hr><p>思路不难想，来回震荡着走。选一个走奇数次的点作为根结点，dfs，每次走出子树时保证子树的点都满足要求了，子树的根结点就和它的父亲震荡，根结点和儿子震荡，可以证明这样一个节点最多走 4 次（</p><h2 id="CF182C"><a href="#CF182C" class="headerlink" title="[CF182C]"></a>[CF182C]</h2><hr><p>正着倒着各做一遍，对于每个区间，维护正负性相反的数中绝对值 K 大的。说白了就是动态维护 K 大和，我们用小根堆维护（注意实现的时候用两个 multiset，细节多</p><h2 id="CF187B"><a href="#CF187B" class="headerlink" title="[CF187B]"></a>[CF187B]</h2><hr><p>想法是 f[i, j, T] 表示 i 到 j 转换了 T 次，f[i, j, T] = min(f[i, k, T - 1] + f[k, j, 0])</p><p>floyd 大有学问啊（</p><h2 id="CF198E"><a href="#CF198E" class="headerlink" title="[CF198E]"></a>[CF198E]</h2><hr><p>x和y的限制可以缩为距离初始点(x, y)的距离的限制</p><p>所以就是对于队列中每个(r, p) 找到还没被删除的点集中 dis &lt;= r 且 m &lt;= p 的点，删除并加入队列</p><p>可以线段树 + set 维护，每个 dis 处都有个 set，迷惑操作但是很好写（</p><p>这是题解做法，要是真比赛碰到我八成会杠二维数点，留坑待填</p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Mar CF&amp;AT 练题汇总</title>
      <link href="2020/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Mar%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/03/31/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Mar%20AT&amp;CF%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AT2164"><a href="#AT2164" class="headerlink" title="[AT2164]-"></a>[AT2164]-</h2><hr><h2 id="AT2167-Blackout"><a href="#AT2167-Blackout" class="headerlink" title="[AT2167]-Blackout"></a>[AT2167]-Blackout</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 156</title>
      <link href="2020/03/01/Atcoder%20Beginner%20Contest%20156/"/>
      <url>2020/03/01/Atcoder%20Beginner%20Contest%20156/</url>
      
        <content type="html"><![CDATA[<p>ABC自动水过…</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><hr><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">所以才知道单算 C(n, m) 是 O(m) 复杂度的？？？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a, b, fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        ll a = (n + i - m) % mod;</span><br><span class="line">        ll b = i % mod;</span><br><span class="line">        res = res * (a * quick_pow(b, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ans = (quick_pow(<span class="number">2</span>, n) - <span class="number">1</span> + mod) % mod;</span><br><span class="line">    ans = (ans - C(n, a) + mod) % mod;</span><br><span class="line">    ans = (ans - C(n, b) + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><hr><p>首先 k &gt;= n 的时候答案是 C(2 * n - 1, n - 1)</p><p>然后 k &lt; n 的时候就可以枚举 位置空着的人数 了！就好了！我也好奇我当时在想啥呀</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, fac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[<span class="number">2</span> * n] = quick_pow(fac[<span class="number">2</span> * n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; i--) inv[i - <span class="number">1</span>] = inv[i] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (K &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, C(<span class="number">2</span> * n - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        rep(k, <span class="number">0</span>, K)</span><br><span class="line">            tot = (tot + C(n, k) * C(n - (n - k) + (n - k - <span class="number">1</span>), n - k - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><hr><p>这题挺好</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco20Feb (Gold)</title>
      <link href="2020/03/01/Usaco20Feb%20(Gold)/"/>
      <url>2020/03/01/Usaco20Feb%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p>这次的 gold 比前两场都水？！？T2已经离正解很近了唉。。T3就是个大暴力唉。。。。</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><hr><p>差分约束，大于小于搞清楚就可以</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, C, s[N], dis[N], inq[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], val[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[x] + val[i];</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) inq[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"timeline.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"timeline.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; C;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]), add(<span class="number">0</span>, i, -s[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, C) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, x; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        add(a, b, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><hr><p>赛时想了个 DP，最后发现少考虑一种情况。。</p><p>但赛后才知道加上那个情况就可以不用 DP 这么麻烦了！！！</p><p>不过口胡了一个与此题无关的、算区间内区间的 O(nlogn) 算法。。也算小小小有收获了！！！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单独算每个区间 [l, r] 的贡献（就是 2^&#123;n - 1 - 不包含[l - 1, l]的区间数&#125;）</span></span><br><span class="line"><span class="comment">赛时降智。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt[N], mi[N] = &#123;<span class="number">1</span>&#125;, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"help.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"help.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; e[i].l &gt;&gt; e[i].r, cnt[e[i].l]++, cnt[e[i].r]--;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * n) cnt[i] += cnt[i - <span class="number">1</span>], mi[i] = mi[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = (ans + mi[n - <span class="number">1</span> - cnt[e[i].l - <span class="number">1</span>]]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><hr><p>一个大暴力，没啥好说_(´ཀ`」 ∠)_ 怪我太菜。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">正常每次dfs，递归常数大。。写checker⬇️就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, sz[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        num[x].push_back(sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">1</span>) num[x].push_back(n - sz[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bin[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((n - <span class="number">1</span>) % k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k - <span class="number">1</span>) bin[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num[i][j] % k;</span><br><span class="line">            <span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (bin[k - x]) bin[k - x]--, cnt--;</span><br><span class="line">            <span class="keyword">else</span> bin[x]++, cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"deleg.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); freopen(<span class="string">"deleg.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, chk(i)); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Feb CF&amp;AT 练题汇总</title>
      <link href="2020/02/29/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Feb%20CF&amp;AT%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/02/29/%E3%80%90%E8%AE%A1%E5%88%92%E3%80%9120Feb%20CF&amp;AT%20%E7%BB%83%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="AT1984-Wide-Swap"><a href="#AT1984-Wide-Swap" class="headerlink" title="[AT1984]-Wide Swap"></a>[AT1984]-Wide Swap</h2><hr><p><a href="https://imilyx.github.io/2020/02/09/%5BAT1984%5D-Wide%20Swap/" target="_blank" rel="noopener">见此篇</a></p><h2 id="AT2004-Anticube"><a href="#AT2004-Anticube" class="headerlink" title="[AT2004]-Anticube"></a>[AT2004]-Anticube</h2><hr><p><a href="https://imilyx.github.io/2020/02/10/%5BAT2004%5D-Anticube/" target="_blank" rel="noopener">见此篇</a></p><h2 id="CF17C-Balance"><a href="#CF17C-Balance" class="headerlink" title="[CF17C]-Balance"></a>[CF17C]-Balance</h2><hr><ul><li>找性质：定义一个字符串的最简化为删除相邻同类字符后的字符串，例如：aabbbc 最简化为 abc。变化后的 B 的最简化是变化前 A 的最简化的子序列。不难懂，但是很难想。。。</li></ul><p>我觉得这个性质应该切入点是：字符串 S 中 l 的位置要同化 [l, r] 这个区间，显然是像推土机一样推过去的，它以自己替换了 [l, r] 的最简化。</p><p>简单 DP 即可。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">51123987</span>, N = <span class="number">160</span>;</span><br><span class="line"><span class="keyword">int</span> n, nxt[N][<span class="number">3</span>], f[N][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>], ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">2</span>) nxt[n + <span class="number">1</span>][i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">2</span>) nxt[i][j] = nxt[i + <span class="number">1</span>][j];</span><br><span class="line">        nxt[i][s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lim = (n + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(a, <span class="number">0</span>, lim)</span><br><span class="line">            rep(b, <span class="number">0</span>, lim)</span><br><span class="line">                rep(c, <span class="number">0</span>, lim) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a + b + c == n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(a - c) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(b - c) &lt;= <span class="number">1</span>)</span><br><span class="line">                            upd(ans, f[i][a][b][c]);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">0</span>] != <span class="number">-1</span>)  <span class="comment">// 用 nxt 来 和用 s 最简化后的字符串来是一个道理</span></span><br><span class="line">                        upd(f[nxt[i][<span class="number">0</span>]][a + <span class="number">1</span>][b][c], f[i][a][b][c]);  <span class="comment">// 有可能会无限停留在当前位置，不过没有关系，a + b + c = n 的时候就会停止</span></span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                        upd(f[nxt[i][<span class="number">1</span>]][a][b + <span class="number">1</span>][c], f[i][a][b][c]);</span><br><span class="line">                    <span class="keyword">if</span> (nxt[i][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">                        upd(f[nxt[i][<span class="number">2</span>]][a][b][c + <span class="number">1</span>], f[i][a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CF17D-Notepad"><a href="#CF17D-Notepad" class="headerlink" title="[CF17D]-Notepad"></a>[CF17D]-Notepad</h2><hr><p>没有什么好说的，一眼不是高精度！。没错就是—</p><ul><li>扩展欧拉函数板子题！【啊怎么又是欧拉</li></ul><p><a href="https://www.cnblogs.com/ywwyww/p/8510981.html" target="_blank" rel="noopener">这个大佬精辟总结了</a></p><p>题目没有保证底数(b)和模数(c)互质所以不能用数论中的欧拉定理，要用扩展版本。<strong>还有一点，注意指数小于 phi(模数) 的时候定理不成立！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧拉函数 降幂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll b, b2, n, c, phi;</span><br><span class="line"><span class="keyword">char</span> s1[N], s2[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % c;</span><br><span class="line">        a = a * a % c;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s%lld"</span>, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>, &amp;c);</span><br><span class="line">    phi = getphi(c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b</span></span><br><span class="line">    rep(i, <span class="number">1</span>, len) b = (b * <span class="number">10</span> + (s1[i] - <span class="string">'0'</span>)) % c;</span><br><span class="line">    <span class="comment">// b - 1</span></span><br><span class="line">    b2 = (b - <span class="number">1l</span>l + c) % c;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, len) n = (n * <span class="number">10</span> + (s2[i] - <span class="string">'0'</span>)) % phi;</span><br><span class="line">    <span class="comment">// n - 1</span></span><br><span class="line">    n = (n - <span class="number">1l</span>l + phi) % phi + phi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        ll realN = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, len) realN = realN * <span class="number">10</span> + (s2[i] - <span class="string">'0'</span>);</span><br><span class="line">        realN -= <span class="number">1l</span>l;</span><br><span class="line">        <span class="keyword">if</span> (realN &lt; phi) n -= phi;  <span class="comment">// !!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = b2 * quick_pow(b, n) % c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans ? ans : c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF17E-Palisection"><a href="#CF17E-Palisection" class="headerlink" title="[CF17E]-Palisection"></a>[CF17E]-Palisection</h2><hr><p>有点意思啊！</p><p>题目要求相交回文串对数，考虑到存在包含关系，直接处理细节会很多很不好写。</p><p>俗话说得好，<strong>正难则反！</strong></p><ul><li>相交对数 = 总数 - 不相交对数。manacher + 前缀和维护</li></ul><p>计算一个位置左边的回文串右端点个数，与该位置右边的回文串左端点个数相乘，这样是会<strong>算重</strong>的！！</p><p>所以我们固定一个位置，该位置作为左端点的串个数 与该位置左边的回文串右端点相乘，这样显然不会重。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e6</span> + <span class="number">10</span>, mod = <span class="number">51123987</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, len, p[N], pos, mx, l[N], r[N];  <span class="comment">// l[x]/r[x]: x 位置作为左/右端点的字符串个数</span></span><br><span class="line">ll ans, sum;</span><br><span class="line"><span class="keyword">char</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">            p[i] = min(p[pos * <span class="number">2</span> - i], mx - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + p[i]) mx = i + p[i], pos = i;</span><br><span class="line"></span><br><span class="line">        ++l[i - p[i] + <span class="number">1</span>], --l[i + <span class="number">1</span>];  <span class="comment">// 中心到每一个 [左端点，中心] 的点 都有一个回文串</span></span><br><span class="line">        ++r[i], --r[i + p[i]];</span><br><span class="line"></span><br><span class="line">        ans = (ans + (p[i] &gt;&gt; <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans * (ans - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">    len = n;</span><br><span class="line">    s[n = <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, len) s[++n] = a[i], s[++n] = <span class="string">'#'</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'['</span>, s[n + <span class="number">1</span>] = <span class="string">']'</span>;</span><br><span class="line"></span><br><span class="line">    manacher();</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        l[i] += l[i - <span class="number">1</span>], r[i] += r[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (ans - (ll)l[i] * sum % mod + mod) % mod;  <span class="comment">// 正难则反</span></span><br><span class="line">            sum = (sum + r[i]) % mod;  <span class="comment">// 相当于二阶差分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2301-Solitaire"><a href="#AT2301-Solitaire" class="headerlink" title="[AT2301]-Solitaire"></a>[AT2301]-Solitaire</h2><hr><p>取数前肯定是 V 字形的（1 是谷底）</p><ul><li>一个取数序列，只要存在一种 V 字形的安排，就是合法的</li></ul><p><a href="https://blog.csdn.net/weixin_30820077/article/details/96464019" target="_blank" rel="noopener">这个大佬讲的比我清楚</a></p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, K, f[N][N], sum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    per(i, n, <span class="number">2</span>) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, K - <span class="number">2</span>) &#123;</span><br><span class="line">        sum = f[i][n - i + <span class="number">1</span>];</span><br><span class="line">        per(j, n - i, <span class="number">2</span>) &#123;</span><br><span class="line">            sum = (sum + f[i][j]) % mod;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = (f[i + <span class="number">1</span>][j] + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">2</span>, n - (K - <span class="number">1</span>) + <span class="number">1</span>) ans = (ans + f[K - <span class="number">1</span>][i]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n - K - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">        rep(i, <span class="number">1</span>, n - K - <span class="number">1</span>) ans = (ans &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2005-Sequential-operations-on-Sequence"><a href="#AT2005-Sequential-operations-on-Sequence" class="headerlink" title="[AT2005]-Sequential operations on Sequence"></a>[AT2005]-Sequential operations on Sequence</h2><hr><p><a href="https://imilyx.github.io/2020/02/11/[AT2005]-Sequential%20operations%20on%20Sequence/" target="_blank" rel="noopener">见此篇</a></p><h2 id="AT2043-AND-Grid"><a href="#AT2043-AND-Grid" class="headerlink" title="[AT2043]-AND Grid"></a>[AT2043]-AND Grid</h2><hr><p>构造题，以前做到过！很神仙的思路，想不到qwq 构造形状如嵌在一起的手指一般</p><h2 id="AT2046-Namori"><a href="#AT2046-Namori" class="headerlink" title="[AT2046]-Namori"></a>[AT2046]-Namori</h2><hr><p>简介（雾）：一道绝妙的转化好题</p><p><strong>树 是 二 分 图！！！</strong></p><p><a href="https://www.luogu.com.cn/blog/flashblog/solution-at2046" target="_blank" rel="noopener">这个大佬就写的到位，偶环部分写得特别好</a></p><p>然后来谈谈自己的理解：</p><ol><li><p>这种转化下，将相邻两个同色同时反转 等价于 将相邻两个是否有硬币情况交换一下</p></li><li><p>也许看到这种反转题第一步就应该按照深度什么的来个黑白反转。。？这样才能进展qwq。。<strong>模型转化靠做题练</strong></p></li><li><p>奇环和偶环要分开考虑（偶环是二分图，奇环不是）<strong>奇环中断掉的边只有分摊部分转移、加快运输的作用</strong></p></li></ol><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans, stx, sty, fx, fy;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], s[N], a[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    s[x] = val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x], y; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> ((y = to[i]) != f)</span><br><span class="line">            dfs(y, x, -val), s[x] += s[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">    stx = sty = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> ((fx = getfa(x)) != (fy = getfa(y))) fa[fx] = fy;</span><br><span class="line">        <span class="keyword">else</span> &#123; stx = x, sty = y; <span class="keyword">continue</span>; &#125;  <span class="comment">// 环上边，给它断掉！</span></span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(stx, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) a[++top] = s[i];</span><br><span class="line">        <span class="keyword">if</span> ((dep[stx] - dep[sty]) &amp; <span class="number">1</span>) &#123;  <span class="comment">// 偶环</span></span><br><span class="line">            <span class="keyword">if</span> (s[stx]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">            sort(a + <span class="number">1</span>, a + top + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) s[i] -= a[top &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 奇环</span></span><br><span class="line">            <span class="keyword">if</span> (s[stx] &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sty; i; i = fa[i]) s[i] -= s[stx] &gt;&gt; <span class="number">1</span>;  <span class="comment">// 环上的树们只管把多余的往外输送就好了，主要是环上边决定运输方向！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[stx]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans += <span class="built_in">abs</span>(s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AT2063-Sugigma-The-Showdown"><a href="#AT2063-Sugigma-The-Showdown" class="headerlink" title="[AT2063]-Sugigma: The Showdown"></a>[AT2063]-Sugigma: The Showdown</h2><hr><p>我哥解说太赞了！！！超好评</p><p>在一棵树上，先手不被抓到的唯一情况是：红树上存在一条边 x-&gt;y, 蓝树上 x 到 y 的距离 &gt; 2。</p><p>接下来说明为什么除此之外都会被抓到。</p><p>首先，在一棵<strong>普通</strong>树上，后手可以把先手往角落里逼（因为没有环），先手挂了。</p><p>回到这题，“蓝树上 x 到 y 的距离 &lt;= 2”，首先不用考虑距离 = 1 的情况（这就是普通树的情况）</p><p>现在距离 = 2，后手站在两条蓝边的中间节点上，先手在 x 或 y 上，显然如瓮中捉鳖，先手挂了。</p><p>因此先手要逃离这个结构，但一逃离就是距离 = 1 的情况，还是会挂。。</p><p>我哥讲的真好，就这个道理！</p><p>所以时间就是两倍的后手步数，先手只要找到离后手最远且他能比后手抢先到达的点呆着就好。。。</p><h2 id="AT2064-Many-Easy-Problems"><a href="#AT2064-Many-Easy-Problems" class="headerlink" title="[AT2064]-Many Easy Problems"></a>[AT2064]-Many Easy Problems</h2><hr><p>一道非模板的 NTT~ 可以想到算每个点在多少联通块里出现，但这显然不好算，正难则反，继而转为算每个点在多少联通块里不出现</p><p><a href="https://m-sea-blog.com/archives/4576/" target="_blank" rel="noopener">挂一个大佬博客，推的式子就是这个亚子</a></p><p>然后感触比较深的就是：设 F = f ✖️ g， {\sum_{i, 0, n} f(n - i)·g(i)} = F(n) ！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">感慨：卷积原来是这么用的啊..</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">924844033</span>, N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, lim = <span class="number">1</span>, l;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], ecnt;</span><br><span class="line"><span class="keyword">int</span> sz[N], cnt[N], r[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll f[N], g[N], fac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++ecnt] = y, nxt[ecnt] = lnk[x], lnk[x] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = quick_pow(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) inv[i - <span class="number">1</span>] = inv[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x], y; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> ((y = to[i]) != fa)</span><br><span class="line">            dfs(y, x), sz[x] += sz[y], cnt[sz[y]]++;</span><br><span class="line">    cnt[n - sz[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? <span class="number">5</span> : <span class="number">554906420</span>, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll x = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    pre();</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) f[i] = <span class="number">1l</span>l * cnt[i] * fac[i] % mod;</span><br><span class="line">    reverse(f, f + n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n) g[i] = inv[i];</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n * <span class="number">2</span>) lim &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">    NTT(f, <span class="number">1</span>), NTT(g, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim) f[i] = (f[i] * g[i]) % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (n * C(n, i) % mod - inv[i] * f[n - i] % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> CF&amp;AT往届 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 618 Div1</title>
      <link href="2020/02/29/Codeforces%20Round%20618%20Div1/"/>
      <url>2020/02/29/Codeforces%20Round%20618%20Div1/</url>
      
        <content type="html"><![CDATA[<p>第一次 vp Div1 ~</p><h3 id="A-Anu-Has-a-Function"><a href="#A-Anu-Has-a-Function" class="headerlink" title="A. Anu Has a Function"></a>A. Anu Has a Function</h3><hr><p>考虑 (x | y) - y 的意义：等同于保留所有<strong>只有 x 为 1</strong>的二进制位</p><p>那么就很好办：选择不和其他数撞位的、有最高位的数放第一个</p><ul><li>二进制题要考虑意义</li></ul><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, a[N], id[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">if</span> ((x &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (id[j] &gt; <span class="number">0</span>) id[j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!id[j]) id[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (id[i] &gt; <span class="number">0</span>) &#123; swap(a[<span class="number">1</span>], a[id[i]]); <span class="keyword">break</span>; &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Water-Balance"><a href="#C-Water-Balance" class="headerlink" title="C. Water Balance"></a>C. Water Balance</h3><hr><p>有点意思。最终，若将相邻、值相等的位置归为一块，必不存在第 i 块的值大于第 i + 1 块的情况。第 i 块如果很小，它肯定会优先与 i - 1 合并而不是和 i + 1（字典序嘛。。）单调栈维护！！</p><p>还有一种思路：维护下凸壳，也一样可以做</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N], s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; <span class="keyword">double</span> ave; &#125;stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]), s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        stk[++top] = (node)&#123;i, i, a[i]&#125;;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top].ave &lt; stk[top - <span class="number">1</span>].ave) &#123;</span><br><span class="line">            top--, stk[top].r = stk[top + <span class="number">1</span>].r;</span><br><span class="line">            stk[top].ave = (s[stk[top].r] - s[stk[top].l - <span class="number">1</span>]) / (stk[top].r - stk[top].l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, top) rep(j, stk[i].l, stk[i].r) <span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, stk[i].ave);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2005]-Sequential operations on Sequence</title>
      <link href="2020/02/11/%5BAT2005%5D-Sequential%20operations%20on%20Sequence/"/>
      <url>2020/02/11/%5BAT2005%5D-Sequential%20operations%20on%20Sequence/</url>
      
        <content type="html"><![CDATA[<p>又是道大好题，，</p><ul><li>思维题，概括不了</li></ul><ol><li>这步必须想到，是根基。对照样例应该也能发现这个性质：用单调栈将 $q$ 变成上升的序列，<strong>第 $i$ 步操作后得到的序列就是第 $i - 1$ 步操作得到序列的几倍 + 前缀</strong></li><li>见过推土机吗？这题实现起来就是这样。设 $f[i]$ 表示第 $i$ 步操作后的序列在最终序列中出现的次数，显然 $f[i] = f[i + 1] * (len[i + 1] / len[i])$，余数部分找循环节，诸如此类，递规处理。不断被肢解，最后剩下的一小撮没有循环节了，那一小撮长这样：1 2 3 4 … 也就是初始序列的前缀，提前累计到 ans[] 里</li><li>复杂度分析：余数部分处理，每次对一个比自己小的循环节长度取模，至少减小一半，即 $logn$; 二分找小于余数部分长度的最大循环节，$logn$，所以最后是 $O(n log^2 n)$</li></ol><p>其实想想，就好像一个序列不断被打乱，把它复原就可以了。。很抽象了</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有没有思路都先分析完样例！！！说不定会有启发！！！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, Q, m, q[N], x, f[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = upper_bound(q + <span class="number">1</span>, q + m + <span class="number">1</span>, x) - q - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">        ans[<span class="number">1</span>] += v, ans[x + <span class="number">1</span>] -= v;  <span class="comment">// 提前累计</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[k] += v * (x / q[k]), solve(x % q[k], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    q[++m] = n;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (m &amp;&amp; q[m] &gt;= x) --m;</span><br><span class="line">        q[++m] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">2</span>; i--)</span><br><span class="line">        f[i - <span class="number">1</span>] += f[i] * (q[i] / q[i - <span class="number">1</span>]), solve(q[i] % q[i - <span class="number">1</span>], f[i]);</span><br><span class="line"></span><br><span class="line">    ans[<span class="number">1</span>] += f[<span class="number">1</span>], ans[q[<span class="number">1</span>] + <span class="number">1</span>] -= f[<span class="number">1</span>];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans[i] += ans[i - <span class="number">1</span>], <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2004]-Anticube</title>
      <link href="2020/02/10/%5BAT2004%5D-Anticube/"/>
      <url>2020/02/10/%5BAT2004%5D-Anticube/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/AtCoder-2004" target="_blank" rel="noopener">传送门</a></p><p>题意：从 n 个数中选最多的数使得它们两两相乘不是立方数。</p><p><a href="https://blog.csdn.net/WerKeyTom_FTD/article/details/78361615" target="_blank" rel="noopener">大佬博客</a></p><p>大致思路就是 <strong>质因数分解 + 贪心</strong> 了，本题重点在质因数分解！！</p><p>首先，将每个 $s_i$ 看作 $prod{p_i ^ {a_i}}$. 立方数 ✖️ 立方数 = 立方数，这启发我们简化指数，即 $a_i$ 对 $3$ 取模</p><p>但是质因数分解理论上时间复杂度太大了！！怎么办！！！</p><p>设 $s_i <em> s_j = x^3$, $s_i </em> s_j \leq 10^{20}$, $x \leq 10^{20/3}$。$x$ 可能有一个 $[10^{10/3}, 10^{20/3}]$ 的质因子，但是如果这个质因子大于 $10^5$, $s_i$ 和 $s_j$ 总共也不可能有 $3$ 个，<strong>所以 $x$ 的每个质因子都是 $[2, 10^5]$ 范围内的，其中 $[10^{10/3}, 10^5]$ 以内的数最多只有一个。</strong></p><p>对于大佬最后一行，我的理解是，$s_i$ 中 $&gt; 10^{10/3}$ 的质因子，在 $[10^{10/3}, 10^5]$ 范围内的部分 指数只会是 $1$ 或 $2$，而 $&gt; 10^5$ 的部分最多只有 $1$ 个，不影响大局。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, s[N], a[N], b[N], ans;  <span class="comment">// a[i] 存的是 s[i] 的最简数，b[i] 是 a[i] 的补数</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line"><span class="keyword">int</span> mark[N], p[N], tot;</span><br><span class="line"><span class="comment">// 拓展：10^&#123;10/3&#125; 以内质数有 326 个，10^&#123;10/3&#125;~10^5 以内质数有 9267 个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) p[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; p[j] * i &lt;= n; j++) &#123;</span><br><span class="line">            mark[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    euler(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line">    ll k, tmp;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        k = s[i]; a[i] = b[i] = <span class="number">1</span>;</span><br><span class="line">        rep(o, <span class="number">1</span>, tot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ll j = p[o];</span><br><span class="line">            <span class="keyword">if</span> (j * j * j &gt;= <span class="number">1e10</span>) <span class="keyword">break</span>;  <span class="comment">// 10^&#123;10/3&#125; 以内</span></span><br><span class="line">            <span class="keyword">if</span> (mark[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            tmp = <span class="number">1l</span>l * j * j * j;</span><br><span class="line">            <span class="keyword">while</span> (k % tmp == <span class="number">0</span>) k /= tmp;  <span class="comment">// 简化</span></span><br><span class="line">            tmp = <span class="number">1l</span>l * j * j;</span><br><span class="line">            <span class="keyword">if</span> (k % tmp == <span class="number">0</span>) a[i] *= tmp, b[i] *= j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k % j == <span class="number">0</span>) a[i] *= j, b[i] *= tmp;</span><br><span class="line">            <span class="keyword">while</span> (k % j == <span class="number">0</span>) k /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = (ll)<span class="built_in">sqrt</span>(k);</span><br><span class="line">            <span class="keyword">if</span> (tmp * tmp == k) a[i] *= k, b[i] *= tmp;</span><br><span class="line">            <span class="keyword">else</span> a[i] *= k, b[i] *= k * k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) num[a[i]]++;  <span class="comment">// a[i] 是 s[i] 去掉指数是 3 倍数质因子的结果</span></span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a[i]] = vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">        ans += (a[i] == b[i] ? <span class="number">1</span> : max(num[a[i]], num[b[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT1984]-Wide Swap</title>
      <link href="2020/02/09/%5BAT1984%5D-Wide%20Swap/"/>
      <url>2020/02/09/%5BAT1984%5D-Wide%20Swap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/AtCoder-1984" target="_blank" rel="noopener">传送门</a></p><p>这题太神了！！！我爱死 atcoder 了！！！！！</p><p><a href="https://www.cnblogs.com/cjoierShiina-Mashiro/p/12233486.html" target="_blank" rel="noopener">这位大佬讲的好，我再补充些自己的理解</a></p><p>总结出来解题的常用步骤，也就是最重要的技能是 <strong>转化</strong> 和 <strong>找性质</strong>。</p><p>好！本题必须转化。本来必须满足两条限制（见题目），但大佬这么一转化就限定好只能交换相邻位置，两条限制一下变成一条了！</p><p>求 $p$ 最小字典序等同于求 $q$ 最小字典序，为什么？$q_{p_i}$ 表达的是什么？$q_{p_i}$ 表示 $p_i$ 目前放的位置。</p><p>$q$ 的下标从小到大递增。对于 $p_i &lt; p_j$, $q_{p_i} &lt; q_{p_j}$（即更小的值位置更前）显然是比较优的。所以求 $p$ 最小字典序等同于求 $q$ 最小字典序。</p><p>$q$ 中，如果 $1 \leq i, j \leq n$, $|qi - qj| &lt; K$, 显然 $q_i$ 和 $q_j$ 的相对位置不会发生变化。存在着很多诸如此类的限制，我们又想要 $q$ 字典序最小，怎么办呢？</p><p>最小拓扑序。对于 $1 \leq i &lt; j \leq n$, $|qi - qj| &lt; K$, 从 $q_i$ 向 $q_j$ 连一条边，这样不仅满足了所有限制，也使 $q$ 的字典序最小了。<strong>这是套路，一定要掌握！！！</strong></p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题常用步骤：转化 找性质</span></span><br><span class="line"><span class="comment">// 本题第一步转化起到了简化的作用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], x, ans[N];</span><br><span class="line"><span class="keyword">int</span> mn[N &lt;&lt; <span class="number">2</span>], deg[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;q;  <span class="comment">// 用 pq 来求最小拓扑序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; mn[x] = min(mn[x &lt;&lt; <span class="number">1</span>], mn[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; mn[x] = v; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(x &lt;&lt; <span class="number">1</span>, l, mid, pos, v);</span><br><span class="line">    <span class="keyword">else</span> modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, v);</span><br><span class="line">    upd(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rx &lt; l || lx &gt; r) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> mn[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> min(query(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx), query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), a[x] = i;</span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j = query(<span class="number">1</span>, <span class="number">1</span>, n, a[i] + <span class="number">1</span>, a[i] + K - <span class="number">1</span>)) != inf)</span><br><span class="line">            ++deg[a[j]], e[a[i]].push_back(a[j]);</span><br><span class="line">        <span class="keyword">if</span> ((j = query(<span class="number">1</span>, <span class="number">1</span>, n, a[i] - K + <span class="number">1</span>, a[i] - <span class="number">1</span>)) != inf)</span><br><span class="line">            ++deg[a[j]], e[a[i]].push_back(a[j]);</span><br><span class="line">        modify(<span class="number">1</span>, <span class="number">1</span>, n, a[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!deg[i]) q.push(i);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        a[++tot] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[x][i];</span><br><span class="line">            <span class="keyword">if</span> (!(--deg[y])) q.push(y); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans[a[i]] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco20Jan (Gold)</title>
      <link href="2020/02/02/Usaco20Jan%20(Gold)/"/>
      <url>2020/02/02/Usaco20Jan%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.usaco.org/index.php?page=jan20results" target="_blank" rel="noopener">传送门</a></p><p>题都很好，我太菜了，加油！冲冲冲</p><h3 id="A-Time-is-Mooney"><a href="#A-Time-is-Mooney" class="headerlink" title="A. Time is Mooney"></a>A. Time is Mooney</h3><hr><p>可以发现，点权最大是 1000，C 最小是 1，也就意味着 1000t - t^2 &gt;= 0, t &lt;= 1000!!</p><p>那么枚举 t 就可以啦，ans = max(从 1 出发，经过 t 步走回 1 的 maxval)</p><p>设 dp[t, i] 表示走 t 步到 i 节点的最大点权和，这样就能求括号里的那个东西啦。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">ll dp[<span class="number">2</span>][N], n, m, C, a[N], ans;  <span class="comment">// 滚动</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"time.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"time.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; C;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edges.push_back(make_pair(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    ans = <span class="number">-1e18</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(t, <span class="number">1</span>, <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = t % <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp[p], <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp[p]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line">            <span class="keyword">if</span> (dp[p ^ <span class="number">1</span>][x] != <span class="number">-1</span>)</span><br><span class="line">                dp[p][y] = max(dp[p][y], dp[p ^ <span class="number">1</span>][x] + a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[p][<span class="number">1</span>] - C * t * t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Farmer-John-Solves-3SUM"><a href="#B-Farmer-John-Solves-3SUM" class="headerlink" title="B. Farmer John Solves 3SUM"></a>B. Farmer John Solves 3SUM</h3><hr><p>n = 5000，妥妥 n^2。如果能做到 n^2 预处理就好啦！</p><p>滴—！用 pbds 库里的 hash，O(1) 超快，用 set 或 map 会超时der。。。</p><p>具体用法下面有👇</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map, set, multimap, and multiset: log(n)</span></span><br><span class="line"><span class="comment">// hash_map, hash_set, hash_multimap, and hash_multiset: best O(1), worst O(n)</span></span><br><span class="line"><span class="comment">// pb_ds库里的hash: 1. 需要头文件(line 5,6,8) 2. 函数声明(line 23) 3. 使用方式(line 25~28)</span></span><br><span class="line"><span class="comment">// C++11!</span></span><br><span class="line"><span class="comment">// C++11!!</span></span><br><span class="line"><span class="comment">// C++11!!!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, Q, a[N];</span><br><span class="line">ll ans[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"threesum.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"threesum.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        gp_hash_table&lt;int, int&gt; g(&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;1 &lt;&lt; 13&#125;);</span><br><span class="line">        rep(j, i + <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = g.find(-a[i] - a[j]);</span><br><span class="line">            <span class="keyword">if</span> (it != end(g)) ans[i][j] = it-&gt;second;</span><br><span class="line">            g[a[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        rep(j, i, n)</span><br><span class="line">            ans[i][j] += ans[i + <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>] - ans[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Springboards"><a href="#C-Springboards" class="headerlink" title="C. Springboards"></a>C. Springboards</h3><hr><p>将特殊点按 x、y 坐标排序。设 ans[i] 表示到第 i 个落地点的最短距离。</p><p>第 i 个点之前的点是第 j 个的话，ans[i] = xi + yi - xj - yj + ans[j]</p><p>所以我们碰到落地点就计算 ans[i], 碰到起跳点就将 ans[i] - xi - yi 加入 map，map 维护之前经过的所有点的答案。map 第一维是 y 坐标，第二维是 val。</p><p>显然，对于两个入 map 顺序 i &lt; j 的点，若 yi &lt; yj 且 vali &lt; valj，那么 j 显然没有必要入 map。本着这个原则。显然 map 最后是 y 越大，val 越小的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, p, ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = prev(mp.upper_bound(y));</span><br><span class="line">    <span class="keyword">if</span> ((*it).se &lt;= v) <span class="keyword">return</span>;  <span class="comment">// (*it).se = it-&gt;se</span></span><br><span class="line">    it++;</span><br><span class="line">    <span class="keyword">while</span> (it != mp.end() &amp;&amp; it-&gt;se &gt; v) mp.erase(it++);</span><br><span class="line">    mp[y] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"boards.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"boards.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;pii, pii&gt;&gt; v;</span><br><span class="line">    rep(i, <span class="number">1</span>, p) &#123;</span><br><span class="line">        pii a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a.fi &gt;&gt; a.se &gt;&gt; b.fi &gt;&gt; b.se;</span><br><span class="line">        v.push_back(&#123;a, &#123;i, <span class="number">-1</span>&#125;&#125;);</span><br><span class="line">        v.push_back(&#123;b, &#123;i, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].se.se == <span class="number">-1</span>) &#123;</span><br><span class="line">            ans[v[i].se.fi] = v[i].fi.fi + v[i].fi.se + prev(mp.upper_bound(v[i].fi.se))-&gt;se;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(v[i].fi.se, ans[v[i].se.fi] - v[i].fi.fi - v[i].fi.se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mp.rbegin()-&gt;se + <span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】虚树</title>
      <link href="2020/02/01/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%99%9A%E6%A0%91/"/>
      <url>2020/02/01/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E8%99%9A%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>虚树，没那么玄乎，针对的是“多次树上询问一些点”的题目。比如下面这道题，题面中就有这样的表述：sigma(ki)&lt;=500000 那么我们的算法一定不和 n 有关，而是和 k 有关啦！</p><p>虚树的时间复杂度就是 O(sigma(ki))！下面是练习时间~</p><h3 id="SDOI2011-消耗战"><a href="#SDOI2011-消耗战" class="headerlink" title="[SDOI2011]-消耗战"></a>[SDOI2011]-消耗战</h3><hr><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2286" target="_blank" rel="noopener">传送门</a></p><p>很容易想到树形DP，但那样就是 O(nm)，太大了！肿么办 ಠ_ಠ 上虚树！</p><p>每次把询问点及它们的 LCA 摘出来重新建一棵树，也就是虚树，虚树上树形 DP，单次 O(ki)。</p><p>注意，本题特殊性在于，一条链若是 根-&gt;a-&gt;b-&gt;c，那么只要保留 根-&gt;a 这段路径就可以了！这个很明显吧</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], idx;</span><br><span class="line"><span class="keyword">int</span> dep[N], son[N], fa[N], tp[N], sz[N], dfn[N];</span><br><span class="line"><span class="keyword">int</span> lnk[N], nxt[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line">ll mn[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; v[x].push_back(y); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    fa[x] = father;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    dep[x] = dep[father] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == father) <span class="keyword">continue</span>;</span><br><span class="line">        mn[y] = min(mn[x], (ll)val[i]);</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; sz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    tp[x] = top;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tp[x] != tp[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[tp[x]] &lt; dep[tp[y]]) swap(x, y);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">1</span>) &#123; stk[++top] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (lca == stk[top]) <span class="keyword">return</span>;  <span class="comment">// 直接 return 的原因是 一条链上只要存除根结点以外最上面的那个点！！！</span></span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top - <span class="number">1</span>]] &gt;= dfn[lca])</span><br><span class="line">        addedge(stk[top - <span class="number">1</span>], stk[top]), --top;</span><br><span class="line">    <span class="keyword">if</span> (lca != stk[top])</span><br><span class="line">        addedge(lca, stk[top]), stk[top] = lca;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[x].size() == <span class="number">0</span>) <span class="keyword">return</span> mn[x];</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        sum += DP(v[x][i]);</span><br><span class="line">    v[x].clear();</span><br><span class="line">    <span class="keyword">return</span> min(mn[x], sum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    mn[<span class="number">1</span>] = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">        stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) insert(a[i]);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            addedge(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, DP(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HEOI2014-大工程"><a href="#HEOI2014-大工程" class="headerlink" title="[HEOI2014]-大工程"></a>[HEOI2014]-大工程</h3><hr><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3611" target="_blank" rel="noopener">传送门</a></p><p>树形DP。一开始的思路是 求代价 sigma(边ab的val ✖️ a子树中选中节点数 ✖️ b子树中选中节点数)，这样应该也可以？。看 hzwer 求代价和的方法是不断合并，设 f[x] 表示在遍历 y 子树前遍历的选中节点到 x 的距离和，反正搞一搞就出来了。最大最小代价也挺好求的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bzoj_3611</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, Q, idx, top;</span><br><span class="line">ll sz[N], son[N], fa[N], tp[N], id[N], dep[N];</span><br><span class="line">ll h[N], v[N], stk[N], siz[N], f[N], mn[N], mx[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], val[N];</span><br><span class="line">ll tot, ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    fa[x] = fat;</span><br><span class="line">    dep[x] = dep[fat] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fat) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; sz[y])</span><br><span class="line">            mx = sz[y], son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    id[x] = ++idx;</span><br><span class="line">    tp[x] = rt;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x], rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> id[a] &lt; id[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    val[x].push_back(dep[y] - dep[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tp[x] != tp[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[tp[x]] &lt; dep[tp[y]]) swap(x, y);</span><br><span class="line">        x = fa[tp[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, stk[top]);</span><br><span class="line">    <span class="keyword">if</span> (lca == stk[top]) &#123; stk[++top] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; id[stk[top - <span class="number">1</span>]] &gt;= id[lca])</span><br><span class="line">        addedge(stk[top - <span class="number">1</span>], stk[top]), --top;</span><br><span class="line">    <span class="keyword">if</span> (lca != stk[top])</span><br><span class="line">        addedge(lca, stk[top]), stk[top] = lca;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    siz[x] = v[x];</span><br><span class="line">    mn[x] = v[x] ? <span class="number">0</span> : inf;</span><br><span class="line">    mx[x] = v[x] ? <span class="number">0</span> : -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[x][i], z = val[x][i];</span><br><span class="line">        dfs(y);</span><br><span class="line">        tot += (f[x] + siz[x] * z) * siz[y] + f[y] * siz[x];</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[x] += f[y] + siz[y] * z;</span><br><span class="line">        ans1 = min(ans1, mn[x] + mn[y] + z);</span><br><span class="line">        ans2 = max(ans2, mx[x] + mx[y] + z);</span><br><span class="line">        mn[x] = min(mn[x], mn[y] + z);</span><br><span class="line">        mx[x] = max(mx[x], mx[y] + z);</span><br><span class="line">    &#125;</span><br><span class="line">    g[x].clear(), val[x].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">cin</span> &gt;&gt; h[i], v[h[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"0 0 0"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        sort(h + <span class="number">1</span>, h + k + <span class="number">1</span>, cmp);</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!v[<span class="number">1</span>]) stk[++top] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) insert(h[i]);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            addedge(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">0</span>, ans1 = inf, ans2 = -inf;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld\n"</span>, tot, ans1, ans2);</span><br><span class="line">        rep(i, <span class="number">1</span>, k) v[h[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HNOI2014-世界树"><a href="#HNOI2014-世界树" class="headerlink" title="[HNOI2014]-世界树"></a>[HNOI2014]-世界树</h3><hr><p><a href="https://www.luogu.com.cn/problem/P3233" target="_blank" rel="noopener">传送门</a></p><p><a href="http://hzwer.com/6804.html" target="_blank" rel="noopener">hzwer大神写得好</a></p><p>真的，太难调了orz。。。两遍 dfs 求出每个虚树上的点对应的管理点，虚树上每条边 ab 对应在树上的区域涵盖的点，它们的管理点不是 a 的管理点就是 b 的管理点。确定范围，其实可以倍增跳到 ab 的中点。size 的加加减减要注意，很容易出错 ಥ_ಥ</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], Q, k, m[N], b[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">22</span>], dfn[N], idx, dep[N], sz[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, q[N], id, ans[N], bel[N], siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++idx;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">        f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[y][<span class="number">0</span>] = x;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[LCA(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = b, mid = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]] &gt; dep[a]) x = f[x][i];</span><br><span class="line">    siz[a] -= sz[x];</span><br><span class="line">    <span class="keyword">if</span> (bel[a] == bel[b]) &#123; ans[bel[a]] += sz[x] - sz[b]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = f[mid][i];</span><br><span class="line">        <span class="keyword">if</span> (dep[tmp] &lt;= dep[a]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[a], tmp), t2 = dis(bel[b], tmp);</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt; t2 || (t1 == t2 &amp;&amp; bel[b] &lt; bel[a])) mid = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[bel[a]] += sz[x] - sz[mid];</span><br><span class="line">    ans[bel[b]] += sz[mid] - sz[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++id] = x;</span><br><span class="line">    siz[x] = sz[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        dfs1(y);</span><br><span class="line">        <span class="keyword">if</span> (!bel[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[y], x), t2 = dis(bel[x], x);</span><br><span class="line">        <span class="keyword">if</span> ((t1 == t2 &amp;&amp; bel[y] &lt; bel[x]) || t1 &lt; t2 || !bel[x])</span><br><span class="line">            bel[x] = bel[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">int</span> t1 = dis(bel[x], y), t2 = dis(bel[y], y);</span><br><span class="line">        <span class="keyword">if</span> ((t1 == t2 &amp;&amp; bel[y] &gt; bel[x]) || t1 &lt; t2 || !bel[y])</span><br><span class="line">            bel[y] = bel[x];</span><br><span class="line">        dfs2(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(m + <span class="number">1</span>, m + k + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">if</span> (bel[<span class="number">1</span>] != <span class="number">1</span>) stk[++top] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = m[i], lca = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!top) &#123; stk[++top] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        lca = LCA(stk[top], x);</span><br><span class="line">        <span class="keyword">if</span> (lca == stk[top]) &#123; stk[++top] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top - <span class="number">1</span>]] &gt;= dfn[lca]) &#123;</span><br><span class="line">            add(stk[top - <span class="number">1</span>], stk[top]); top--;  <span class="comment">// 不能写 stk[top--], 不然会 WA。。。不知道为啥</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lca != stk[top]) &#123;</span><br><span class="line">            add(lca, stk[top]); stk[top] = lca;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span>) add(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        top = id = cnt = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m[i]), b[i] = m[i], bel[m[i]] = m[i];</span><br><span class="line">        build();</span><br><span class="line"></span><br><span class="line">        dfs1(<span class="number">1</span>), dfs2(<span class="number">1</span>);</span><br><span class="line">        rep(o, <span class="number">1</span>, id)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[q[o]]; i; i = nxt[i])</span><br><span class="line">                solve(q[o], to[i]);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, id)</span><br><span class="line">            ans[bel[q[i]]] += siz[q[i]];</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, k) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[b[i]]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, id)</span><br><span class="line">            ans[q[i]] = bel[q[i]] = siz[q[i]] = lnk[q[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AT2149]-Snuke&#39;s Coloring 2</title>
      <link href="2020/01/13/%5BAT2149%5D-Snuke&#39;s%20Coloring%202/"/>
      <url>2020/01/13/%5BAT2149%5D-Snuke&#39;s%20Coloring%202/</url>
      
        <content type="html"><![CDATA[<p>ARC 的 D 啊这是！！！毒瘤 qwq。。不过挺有意思的</p><p><a href="https://vjudge.net/problem/AtCoder-2149" target="_blank" rel="noopener">传送门！飞</a></p><p><a href="https://www.cnblogs.com/coco-night/p/9677691.html" target="_blank" rel="noopener">这位dalao说得好，我若讲不清楚可看ta的！</a></p><p>首先，一切的一切之前！要先公布一个性质。。（什么时候才能自己找啊qwq），就是这个矩形周长一定大于等于 $2 <em> max(w, h) + 2$, 那么这个矩形<em>*一定</em></em>过 $x = \frac{w}{2}$ 或 $y = \frac{h}{2}$ 中的一条，接下来以后者为例。（别忘记做完后将图翻转再做一次前者）</p><p>有了<strong>过中线</strong>的保证，我们就可以把点分成中线上下两部分处理。</p><p>找！定！量！这个定量就是一条竖着的扫描线，身份是矩形的右边界。。$O(n ^ 2)$的朴素算法就是从右边界往左扫，单调栈维护<strong>最</strong>值。考虑如何优化。</p><p>用线段树<strong>帮助</strong>维护扫描线左边（即扫过区域）每个点所在直线为左边界时的最大矩形周长，加加减减具体可看 dalao 博客链接，其核心就是线段的和差。。显然是可以维护的！！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (long long i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> w, h, n, ans;</span><br><span class="line"><span class="keyword">int</span> tag[N &lt;&lt; <span class="number">2</span>], mx[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">pii p[N], a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span>] += tag[x];</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x];</span><br><span class="line">        mx[x &lt;&lt; <span class="number">1</span>] += tag[x];</span><br><span class="line">        mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x];</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rx &lt; l || r &lt; lx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        tag[x] += val, mx[x] += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    update(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    update(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    mx[x] = max(mx[x &lt;&lt; <span class="number">1</span>], mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx, <span class="number">0</span>, <span class="keyword">sizeof</span>(mx));</span><br><span class="line">    <span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="keyword">sizeof</span>(tag));</span><br><span class="line"></span><br><span class="line">    sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].y &lt;= h / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &amp;&amp; p[i].y &gt; a[l].y) &#123;</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, a[l].x, nxt, a[l].y - p[i].y);</span><br><span class="line">                nxt = a[l].x - <span class="number">1</span>;</span><br><span class="line">                --l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt != i - <span class="number">1</span>) a[++l] = make_pair(nxt + <span class="number">1</span>, p[i].y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (r &amp;&amp; p[i].y &lt; b[r].y) &#123;</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, b[r].x, nxt, p[i].y - b[r].y);</span><br><span class="line">                nxt = b[r].x - <span class="number">1</span>;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nxt != i - <span class="number">1</span>) b[++r] = make_pair(nxt + <span class="number">1</span>, p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        a[++l] = make_pair(i, <span class="number">0</span>);</span><br><span class="line">        b[++r] = make_pair(i, h);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, i, i, h - p[i].x);</span><br><span class="line">        ans = max(ans, p[i + <span class="number">1</span>].x + mx[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; h &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    p[++n] = make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    p[++n] = make_pair(w, h);</span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) swap(p[i].x, p[i].y);  <span class="comment">// 翻转</span></span><br><span class="line">    swap(w, h);</span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我发现做题找定量是非常重要的！本题的精髓就在于找定量。上次 usaco 12月月赛 T1 也是找定量，这个真的很有用哇！</p><p>（一上来看到矩形肯定头都大啦，哪知道定量是啥啊。。</p><p>反正这题 <strong>性质</strong> 和 <strong>定量思想</strong> 缺一不可啊。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Usaco19Dec (Gold)</title>
      <link href="2019/12/21/Usaco19Dec%20(Gold)/"/>
      <url>2019/12/21/Usaco19Dec%20(Gold)/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.usaco.org/index.php?page=dec19results" target="_blank" rel="noopener">传送门</a></p><p>Usaco Gold round 第一次！！做出了 T1，个人感觉 usaco 题目质量十分的高啊~ 都不是毒瘤题，但本人过于菜鸡了 qaq</p><h3 id="A-Milk-Pumping"><a href="#A-Milk-Pumping" class="headerlink" title="A. Milk Pumping"></a>A. Milk Pumping</h3><hr><p>一句话题解：最短路变形。</p><p>以前好像做过类似的。只要按照边的流量从大到小排序，一一加边，每加一次跑一遍最短路即可！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dis[N], inq[N], ansx, ansy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> x, y, c, f; &#125;e[N];</span><br><span class="line">ll cur;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; nxt[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123; <span class="keyword">return</span> a.f &gt; b.f; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); inq[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">            edge now = nxt[x][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[now.y] &gt; dis[x] + now.c) &#123;</span><br><span class="line">                dis[now.y] = dis[x] + now.c;</span><br><span class="line">                <span class="keyword">if</span> (!inq[now.y]) inq[now.y] = <span class="number">1</span>, q.push(now.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"pump.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pump.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].c, &amp;e[i].f);</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    cur = <span class="number">-1e18</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        nxt[e[i].x].push_back(e[i]);</span><br><span class="line">        swap(e[i].x, e[i].y);</span><br><span class="line">        nxt[e[i].x].push_back(e[i]);</span><br><span class="line">        spfa();</span><br><span class="line">        <span class="keyword">if</span> (dis[n] != inf)</span><br><span class="line">            cur = max(cur, (<span class="number">1l</span>l * <span class="number">1000000</span> * e[i].f / dis[n]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Milk-Visits"><a href="#B-Milk-Visits" class="headerlink" title="B. Milk Visits"></a>B. Milk Visits</h3><hr><p>很妙的题！首先把询问离线。对于 (x, y, c) 这组询问（设 lca(x, y) = L）显然可以分解为 x ~ L 这段和 y ~ L 这段。</p><p>dfs。用栈 (实际操作可用vector) 储存经过的点的颜色和点的位置（实际操作储存深度），到达点 x 时看看栈中是否有 c 颜色的，以及离 x 最近的（深度最大的）点是不是 L 的祖先，如果不是，(x, y, c) 这个询问的答案就是 1.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, col[N], id[N][<span class="number">2</span>], c[N], cur, ok[N];</span><br><span class="line">pii range[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; stor[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; todo[N], v[N], ord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    range[x].fi = ++cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (v[x][i] != fa) pre(v[x][i], x);</span><br><span class="line">    range[x].se = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">anc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// is_ancestor ?</span></span><br><span class="line">    <span class="keyword">return</span> (range[x].fi &lt;= range[y].fi &amp;&amp; range[y].se &lt;= range[x].se);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    stor[col[x]].push_back(make_pair(x, ord.size()));</span><br><span class="line">    ord.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt; todo[x].size(); o++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = todo[x][o];</span><br><span class="line">        <span class="keyword">if</span> (stor[c[i]].size()) &#123;</span><br><span class="line">            pii y = stor[c[i]].back();</span><br><span class="line">            <span class="keyword">if</span> (y.fi == x) ok[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> son = ord[y.se + <span class="number">1</span>];  <span class="comment">// 下一个 (想想为什么)</span></span><br><span class="line">    <span class="comment">// x is one of endpoints for query t</span></span><br><span class="line">                <span class="keyword">if</span> (!anc(son, id[i][<span class="number">0</span>] + id[i][<span class="number">1</span>] - x)) ok[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (v[x][i] != fa) dfs(v[x][i], x);</span><br><span class="line">    stor[col[x]].pop_back();</span><br><span class="line">    ord.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"milkvisits.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"milkvisits.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        v[x].push_back(y), v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pre(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;id[i][<span class="number">0</span>], &amp;id[i][<span class="number">1</span>], &amp;c[i]);</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">1</span>) todo[id[i][j]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ok[i] ? <span class="number">1</span> : <span class="number">0</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Moortal-Cowmbat"><a href="#C-Moortal-Cowmbat" class="headerlink" title="C. Moortal Cowmbat"></a>C. Moortal Cowmbat</h3><hr><p>DP 大法好….</p><p>DP 还是弱啊。。其实不是很难</p><p>首先跑一遍 Floyd！。设 f[i] 表示前 i 个合法的最小值。</p><p>f[i] = min(f[j] + calc(j + 1, i, c)) (j &lt;= i - k)，其中 calc(l, r, c) 表示区间 [l, r] 全变为 c 的价值和。</p><p>发现每次只加进去 i - k 的贡献。用 mn[j] 数组维护当前取 j 颜色且合法的最小值，O(1)。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>][<span class="number">30</span>], cost[N][<span class="number">30</span>], mn[N], f[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> cost[r][c] - cost[l - <span class="number">1</span>][c]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cowmbat.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"cowmbat.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    --m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, m)</span><br><span class="line">        rep(j, <span class="number">0</span>, m)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line">    rep(k, <span class="number">0</span>, m)</span><br><span class="line">        rep(i, <span class="number">0</span>, m)</span><br><span class="line">            rep(j, <span class="number">0</span>, m)</span><br><span class="line">                c[i][j] = min(c[i][j], c[i][k] + c[k][j]);</span><br><span class="line">    rep(i, <span class="number">0</span>, m)</span><br><span class="line">        rep(j, <span class="number">1</span>, n)</span><br><span class="line">            cost[j][i] = cost[j - <span class="number">1</span>][i] + c[s[j] - <span class="string">'a'</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rep(i, K, n)</span><br><span class="line">        rep(j, <span class="number">0</span>, m) &#123;</span><br><span class="line">            mn[j] = min(mn[j] + c[s[i] - <span class="string">'a'</span>][j], f[i - K] + calc(i - K + <span class="number">1</span>, i, j));  <span class="comment">// mn[j] 表示当前 i 位置为 j 时的最小花费</span></span><br><span class="line">            f[i] = min(f[i], mn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要多打比赛！等考完 看我不屠它个百来道题 (♯｀∧´) 哼</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019前的做题记录 &amp; 每日小结</title>
      <link href="2019/11/16/CSP2019%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95&amp;%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
      <url>2019/11/16/CSP2019%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95&amp;%E6%AF%8F%E6%97%A5%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这里是 CSP2019 前的做题记录 &amp; 每日小结！</p><p>每天计划如下：</p><ol><li>订正monisai！</li><li>ATC一套（2 ~ 3道）</li><li>随即开题 &gt;= 3 道</li><li>算法针对 &gt;= 3 道</li><li>博客总结</li><li>博客回顾 &gt;= 10 篇</li><li>后期安排 NOIp 真题体验</li></ol><p>日拱一卒无有尽，功不唐捐终入海！加油加油~</p><h2 id="——"><a href="#——" class="headerlink" title="——-"></a>——-</h2><hr><h3 id="10-29"><a href="#10-29" class="headerlink" title="10.29"></a>10.29</h3><ul><li>⚠️monisai T2 模数有一重没加，全wa丢40+。。</li></ul><p>luogu3586, agc037C, abc144D+E+F, bzoj1016</p><h3 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h3><ul><li>⚠️monisai T1 无向边建成有向的了凉凉。。（奇怪，以前从来不犯的错误啊 o(╥﹏╥)o</li></ul><p>luogu3317, luogu1131, luogu1879</p><h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><p>abc137E, bzoj4805, bzoj2005, bzoj2671, luogu2219, luogu2569, luogu2709</p><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><ul><li>⚠️用着可以 O(n^2 + Q) 的部分分写法，写了 O(n^2 + Qn) 的。。虽然也不会太凉，但是正式比赛一定要小心啊！（别想出正解写了暴力就是了qwq</li></ul><p>luogu3172, luogu3830, luogu2613, bzoj1531</p><h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><ul><li>今日份快乐：monisai烤了10.17日的模拟赛T3，然鹅我并没订正过这道清真的斜率优化。。然后我调出来了，耶。</li><li>形如 a = b 的东西可以化成 a - b = 0, 也许可以用数据结构维护呢。</li><li>⚠️monisai T1 矩阵加速丢 30 pts，原来是 ll 类型的 n 被我用 %d 输入了。。。检查 long long 🈶️🈚️开不只是检查定义处，还有输入输出处哇。。。两个字母三十分 o(╥﹏╥)o 超贵</li></ul><p>luogu2915, luogu2150</p><h3 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h3><ul><li>今日份快乐：在家休息哦！补觉啦【快快乐乐】然后复习了dp！</li></ul><p>bzoj1037, bzoj1042, bzoj1084, bzoj2431, bzoj1190</p><h3 id="11-4"><a href="#11-4" class="headerlink" title="11.4"></a>11.4</h3><ul><li>今天早上音乐抽到我了，，于是就没有去训练，在家 vp 了 CF round 597 (Div2)</li></ul><p>bzoj1833</p><h3 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h3><ul><li>⚠️今！天！又！爆！int！了！下次用 <code>#define ing long long</code> 吧</li><li>T2 可以 AC 的。。vector 定义成 int 类型了，爆了，什么都不想说了，T2 没有了还活个什么劲啊</li><li>以下是一些牢骚：诶为什么人家 fst 都是小 f 啊，就我是大 f ？一次 f 100 的那种？水逆特别眷顾我吗 qaq… 要么脑子少一块了🧠</li></ul><p>cf997e, bzoj3209, luogu4999</p><h3 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h3><p>对于二分图：</p><ul><li>最小点覆盖 = 最大匹配</li><li>最大独立集 = 最小边覆盖 = 顶点数 - 最小点覆盖（最大匹配）</li></ul><p>对于DAG：</p><ul><li>最小不相交路径覆盖 = 原图顶点数 - 转为二分图后的最大匹配数</li><li>最小可相交路径覆盖 转化转化能变成上面那个。转化方法：用 floyd 求出原图传递闭包，如果 a 到 b 有路径，就加边 a-&gt; b, 就行了。（这样就不用经过中间点了，如果经过中间点有可能会与其它路径相交。）</li></ul><p>概念：</p><ul><li>最大匹配：二分图中边集的数目最大的那个匹配；</li><li>最小点覆盖：用最少的点，让每条边都至少和其中一个点关联；</li><li>最小边覆盖：用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点；</li><li>最大独立集：在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边的点中，m的最大值。</li></ul><p>bzoj1082, bzoj1179</p><h3 id="11-7"><a href="#11-7" class="headerlink" title="11.7"></a>11.7</h3><p>bzoj1143, bzoj3175, bzoj2783, bzoj3190</p><h3 id="11-8"><a href="#11-8" class="headerlink" title="11.8"></a>11.8</h3><ul><li>⚠️给 trick 坑了！（这算 trick 吗）：对于每个质因数 p，将所有能被它分解的 a[i] 提到 vector 里。这样处理每个 p 就只会用到 vector 里的 a[i] 了。每个 a[i] 最多被提 sqrt(a[i]) 次（其实远远达不到），复杂度就由 O(质数个数 ✖️n) 变为 O(n ✖️根号n) 了（哭倒。。。</li></ul><p>agc036A</p><h3 id="11-9"><a href="#11-9" class="headerlink" title="11.9"></a>11.9</h3><ul><li>⚠️T2 想打的部分分没写出来，提交时还没删掉那部分程序，居然 CE 了。。30 分啊。。唯一一次能比 xyr 高的机会。。。被我自己作没了。。。。 </li></ul><p>agc036B, bzoj1027, </p><h3 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h3><ul><li>打了 xj 的一场模拟赛 + ez dalao 出的一场 comet。感想：bitset 真是个好东西 + 我好菜啊qwq</li></ul><h3 id="11-11"><a href="#11-11" class="headerlink" title="11.11"></a>11.11</h3><ul><li>双十一块乐！</li></ul><p>bzoj1027, luogu2680, 然后切了一些历年真题的水题啦</p><h3 id="11-12"><a href="#11-12" class="headerlink" title="11.12"></a>11.12</h3><ul><li>⚠️每日一fst：二分要注意答案是否有机会为 0 或有可能超过 int 范围！</li><li>今日份块乐：有生之年订完了monisai（其实不是第一回qwq）220pts信心赛可 🌊🌟</li></ul><p>bzoj1295, luogu3960</p><h3 id="11-13"><a href="#11-13" class="headerlink" title="11.13"></a>11.13</h3><ul><li>调代码的时候被一些 傻【数据删除】手误给坑了一个多小时。。ㆁᴗㆁ绝了</li><li>判断一些东西的时候可以借用另一些比较有用的有特征的东西（我在说什么啊），比如 tarjan 题就离不开 dfn 和 low。</li></ul><p>luogu1600, loj114, luogu2827, </p><h3 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h3><ul><li>今日份加倍快乐：monisai登顶，有生之年系列（其实只是 1 pts 都没 fst 而已 qwq</li><li>后天的 CSP 信心瞬间加满！CSP 2019 RP += (inf) ^ {inf} !!!</li><li>CSP 时要仔细啊，别 fst 了！</li><li>读完题后一定会懵的，此时不妨写写画画，模拟一些小样例，说不定就看破出题人的意思了。</li></ul><p>luogu2679, luogu1155, bzoj1823, bzoj1718</p><h3 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h3><p>bzoj1305, bzoj2424, bzoj1923, </p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF997E]-Good Subsegments</title>
      <link href="2019/11/05/%5BCF997E%5D-Good%20Subsegments/"/>
      <url>2019/11/05/%5BCF997E%5D-Good%20Subsegments/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/997/problem/E" target="_blank" rel="noopener">传送门</a></p><p>这题太神了！！真是好题！！！</p><p>显然：区间 $[l, r]$ 是好的，当且仅当 $(Max - Min) - (r - l) = 0$.</p><p>我们可以将询问区间按右端点从小到大排序，依次作为“当前的右端点”。</p><p>于是我们维护每个位置到“当前右端点”的 $(Max - Min) - (r - l)$，维护它们的最小值和最小值个数。</p><p>重要的 trick：一个区间 $[l, r]$ 所有子区间的答案可以随着“当前右端点” $r0$ 的增加而实时统计，累加 $query(l, r0)$.</p><p>仅仅这样做，线段树操作后存储的就只是当前的答案，所以我们还需要用标记，每次 $psd$ 的时候为线段树累加上前一次的答案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120010</span>;</span><br><span class="line"><span class="keyword">int</span> n, Q, a[N], s1[N], s2[N], top1, top2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> r &lt; x.r; &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> tag[N &lt;&lt; <span class="number">2</span>], tg[N &lt;&lt; <span class="number">2</span>], mn[N &lt;&lt; <span class="number">2</span>], t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">ll sum[N &lt;&lt; <span class="number">2</span>], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    mn[x] = l;  <span class="comment">// at first: (mx - mn) - (r - l) = 0 - (0 - l) = l</span></span><br><span class="line">    t[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls, l, mid), build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[x] = min(mn[ls], mn[rs]);</span><br><span class="line">    t[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    t[x] = (mn[x] == mn[ls] ? t[x] + t[ls] : t[x]);</span><br><span class="line">    t[x] = (mn[x] == mn[rs] ? t[x] + t[rs] : t[x]);</span><br><span class="line"></span><br><span class="line">    sum[x] = sum[ls] + sum[rs];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        mn[ls] += tag[x], mn[rs] += tag[x];</span><br><span class="line">        tag[ls] += tag[x], tag[rs] += tag[x];</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tg[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mn[x] == mn[ls])</span><br><span class="line">            sum[ls] += <span class="number">1l</span>l * t[ls] * tg[x], tg[ls] += tg[x];</span><br><span class="line">        <span class="keyword">if</span> (mn[x] == mn[rs])</span><br><span class="line">            sum[rs] += <span class="number">1l</span>l * t[rs] * tg[x], tg[rs] += tg[x];</span><br><span class="line">        tg[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        mn[x] += val; tag[x] += val; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(ls, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(rs, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> sum[x];</span><br><span class="line">    psd(x);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) ret = query(ls, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) ret += query(rs, mid + <span class="number">1</span>, r, lx, rx);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    rep(tr, <span class="number">1</span>, n) &#123;</span><br><span class="line">        mn[<span class="number">1</span>]--, tag[<span class="number">1</span>]--;  <span class="comment">// 随着 r 的增加，最小值减小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top1 &amp;&amp; a[s1[top1]] &gt; a[tr])</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, s1[top1 - <span class="number">1</span>] + <span class="number">1</span>, s1[top1], a[s1[top1]] - a[tr]), --top1;</span><br><span class="line">        s1[++top1] = tr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top2 &amp;&amp; a[s2[top2]] &lt; a[tr])</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, s2[top2 - <span class="number">1</span>] + <span class="number">1</span>, s2[top2], a[tr] - a[s2[top2]]), --top2;</span><br><span class="line">        s2[++top2] = tr;</span><br><span class="line"></span><br><span class="line">        sum[<span class="number">1</span>] += t[<span class="number">1</span>], tg[<span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= Q &amp;&amp; q[pos].r == tr) &#123;</span><br><span class="line">            ans[q[pos].id] = query(<span class="number">1</span>, <span class="number">1</span>, n, q[pos].l, tr);</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 144</title>
      <link href="2019/10/30/Atcoder%20Beginner%20Contest%20144/"/>
      <url>2019/10/30/Atcoder%20Beginner%20Contest%20144/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc144" target="_blank" rel="noopener">传送门</a></p><h3 id="D-Water-Bottle"><a href="#D-Water-Bottle" class="headerlink" title="D - Water Bottle"></a>D - Water Bottle</h3><hr><p>分类讨论 + 三角函数</p><p>正切是我们平时说的直线的斜率，反正切（c++中的atan函数）的意义大概是这样的：若 A 为角，tanA = x / y, 则 A = arctan x / y. 而 c++ 中计算使用的是弧度制，所得的要转化为角度，还需乘以 180 / PI.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535897923</span>;</span><br><span class="line"><span class="keyword">double</span> a, b, x, v, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">    v = a * a * b;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= v / <span class="number">2</span>) &#123;</span><br><span class="line">        t = <span class="number">2</span> * (v - x) / (a * a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, <span class="built_in">atan</span>(t / a) * <span class="number">180</span> / PI);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = <span class="number">2</span> * x / a / b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, <span class="number">90</span> - <span class="built_in">atan</span>(t / b) * <span class="number">180</span> / PI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Gluttony"><a href="#E-Gluttony" class="headerlink" title="E - Gluttony"></a>E - Gluttony</h3><hr><p>贪心 + 二分</p><p>根据贪心策略很容易想到：将 A 从小到大排，F 从大到小排，Ai 与 Fi 配。然后本题的实质就变成了“最大值最小”，二分妥妥的！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, K, a[N], f[N], l, r, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll lim)</span> </span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        cnt += max(<span class="number">0l</span>l, a[i] - lim / f[i]);</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;f[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    sort(f + <span class="number">1</span>, f + n + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) r = max(r, a[i] * f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值最小！最大值最小！最大值最小！重要的事情汪三遍</span></span><br></pre></td></tr></table></figure></p><h3 id="F-Fork-in-the-Road"><a href="#F-Fork-in-the-Road" class="headerlink" title="F - Fork in the Road"></a>F - Fork in the Road</h3><hr><p>一开始思路是枚举断边，每次拓扑一遍计算 f[x] 表示 x 到 n 的期望步数，这样复杂度是 $O(m(n + m))$ 的，不太ok。</p><p>注意到 m 挺大，n 比较小，我们可以枚举断哪个点 x 周围的边（假设该边连接 x 和 y，必然断的是 f[y] 最大的边），复杂度是 $O(n(n+m))$ 的，可以切了此题。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// si &lt; ti !!! si &lt; ti !!! si &lt; ti !!! 条件还能漏的啊？你眼睛呢？？！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">605</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = (<span class="keyword">double</span>)<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sons;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">double</span> ans, f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> s, t; &#125;e[N * N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = n - <span class="number">1</span>; x &gt;= <span class="number">1</span>; x--) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nxt[x].size();</span><br><span class="line">        <span class="keyword">if</span> (pos == x &amp;&amp; num == <span class="number">1</span>) &#123; f[x] = inf; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1.0</span> / (num - (pos == x)), mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">            f[x] += (f[y] + <span class="number">1</span>) * t;</span><br><span class="line">            mx = max(mx, (f[y] + <span class="number">1</span>) * t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == x) f[x] -= mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;e[i].s, &amp;e[i].t);</span><br><span class="line">        nxt[e[i].s].push_back(e[i].t);</span><br><span class="line">        <span class="keyword">if</span> (e[i].s == <span class="number">1</span>) sons++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = calc(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = min(ans, calc(i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2015]-LOG</title>
      <link href="2019/10/29/%5BPOI2015%5D-LOG/"/>
      <url>2019/10/29/%5BPOI2015%5D-LOG/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P3586" target="_blank" rel="noopener">传送门</a></p><p>“每次选 $a$ 个正数并将它们都减去 $1$，判断能否进行 $s$ 次操作” 这一类题有个小技巧：</p><blockquote><p>设大于等于 $s$ 有 $x$ 个，判定就转化为 $[ x <em> s + (小于 s 的数字之和) &gt;= a </em> s ]$</p></blockquote><p>用树状数组要对 $s$ 离散化即可。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, C[N], cnt[N], a[N], h[N &lt;&lt; <span class="number">1</span>], num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">char</span> opt; ll x, y; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += lowbit(x)) C[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(ll x, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += lowbit(x)) cnt[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += cnt[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    ll x = ask1(num) - ask1(s - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> x * h[s] + ask2(s - <span class="number">1</span>) &gt;= <span class="number">1l</span>l * c * h[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].opt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        h[++num] = q[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    h[++num] = <span class="number">0</span>;</span><br><span class="line">    sort(h + <span class="number">1</span>, h + num + <span class="number">1</span>);</span><br><span class="line">    num = unique(h + <span class="number">1</span>, h + num + <span class="number">1</span>) - h - <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">        q[i].y = lower_bound(h + <span class="number">1</span>, h + num + <span class="number">1</span>, q[i].y) - h;</span><br><span class="line">    </span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch; <span class="keyword">int</span> x, y;</span><br><span class="line">        ch = q[i].opt, x = q[i].x, y = q[i].y;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x])</span><br><span class="line">                add1(a[x], <span class="number">-1</span>), add2(a[x], -h[a[x]]);</span><br><span class="line">            a[x] = y;</span><br><span class="line">            add1(a[x], <span class="number">1</span>);</span><br><span class="line">            add2(a[x], h[a[x]]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(calc(x, y) ? <span class="string">"TAK"</span> : <span class="string">"NIE"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的题目还有 <a href="https://atcoder.jp/contests/abc143/tasks/abc143_f" target="_blank" rel="noopener">ATC143F - Distinct Numbers</a>, 只是将 $s$ 替换为二分值 $mid$ 了。二分做法复杂度是 $O(nlog^2n)$, 但这里是利用答案单调性的 $O(n)$ 做法（容易发现，随着 $K$ 的减小，答案只会增加不会减少），然后前缀的预处理还是非常神仙的（从网上贺来的qwq），实在不懂可以模拟输出中间过程（其实也不难理解）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, x, a[N], K, cnt[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll k, ll x)</span> </span>&#123; <span class="keyword">return</span> sum[x] &gt;= k * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; x, ++sum[++cnt[x]];</span><br><span class="line">    rep(i, <span class="number">1</span>, n) sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (now &lt; n &amp;&amp; chk(k, now + <span class="number">1</span>)) ++now;</span><br><span class="line">        ans[k] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[LG4551]-最长异或路径</title>
      <link href="2019/10/12/%5Bluogu4551%5D-%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/"/>
      <url>2019/10/12/%5Bluogu4551%5D-%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P4551" target="_blank" rel="noopener">传送门</a></p><p>【 新技能get√￣ 】</p><p>首先有个很重要的常识：$x$ 到 $y$ 的异或值为 $x$ 到根的异或值异或上 $y$ 到根的异或值。其正确性显然。</p><p>那么题目就变为：选两个点，使得它们的异或值异或起来最大。</p><p>（我居然还想到线性基了。。智商不行呀，不是什么异或都是线性基的，线性基是多个异或，不是两个异或。。</p><p>重点来了：$01$ 字典树是处理异或问题的利器，对于一个值 $x$，为了使它与另一个值 $y$ 异或后最大，根据贪心的思想，显然尽量使它们的二进制最高位不同，然后次高位不同…blabla</p><p>那么把所有节点到根结点的异或值建成一棵 $01$ 字典树就行啦。复杂度 $O(NlogV)$</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, dis[N], ch[<span class="number">31</span> * N][<span class="number">2</span>], idx, mark[<span class="number">31</span> * N], ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    nxt[x].push_back(y), val[x].push_back(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = nxt[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[y] = dis[x] ^ val[x][i];</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ch[u][c]) ch[u][c] = ++idx;</span><br><span class="line">        u = ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    mark[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (((x &gt;&gt; i) &amp; <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch[u][c]) u = ch[u][c], ret += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="keyword">else</span> u = ch[u][c ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) insert(dis[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) ans = max(ans, query(dis[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Grand Contest 038</title>
      <link href="2019/10/09/Atcoder%20Grand%20Contest%20038/"/>
      <url>2019/10/09/Atcoder%20Grand%20Contest%20038/</url>
      
        <content type="html"><![CDATA[<h3 id="A-01-Matrix"><a href="#A-01-Matrix" class="headerlink" title="A - 01 Matrix"></a>A - 01 Matrix</h3><hr><p>想了一会儿。。qwq</p><p>显然，令 mp[1 ~ b, 1 ~ a] = 1, mp[b + 1 ~ n, a + 1 ~ m] = 1 即可。</p><h3 id="B-Sorting-a-Segment"><a href="#B-Sorting-a-Segment" class="headerlink" title="B - Sorting a Segment"></a>B - Sorting a Segment</h3><hr><p>我们发现，若排序 (l1, r1) 得到的序列与排序 (l2, r2) 得到的序列相同(r1 &lt; l2)，那么排序 (l1, r1), (l1 + 1, r1 + 1), (l1 + 2, r1 + 2) … (l2 - 1, r2 - 1), (l2, r2) 得到的序列也是相同的。</p><p>排序 (l, r) 与 (l + 1, r + 1) 得到的序列相同当且仅当在 [l, r + 1] 中，a[l] 是最小值，a[r + 1] 是最大值。这个用单调队列判断即可，最后用方案总数减去相同的方案数得出答案！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], q[N], ans, mark[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ans = n - K + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>]) b[i] = b[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= K) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &lt; i - K) ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] == i - K) mark[i]++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r]] &gt; a[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n - K + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] &gt; i + K) ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] == i + K) mark[i + K]++;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r]] &lt; a[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    rep(i, K, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= K) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ff) ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tot++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark[i] == <span class="number">2</span>) tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-LCMs"><a href="#C-LCMs" class="headerlink" title="C - LCMs"></a>C - LCMs</h3><hr><p>数论题！Atcoder真全</p><p>$\sum\limits_{i=1}^{n}\sum\limits_{j=i + 1}^n\frac{A_iA_j}{gcd(A_i,A_j)}$</p><p>= $\sum\limits_{d=1}^N\frac{1}{d}\sum\limits_{i=1}^n\sum\limits_{j=i+1}^nA_iA_j\sum\limits_{kd|A_i,kd|A_j}\mu(k)$</p><p>= $\sum\limits_{d=1}^N\frac{1}{d}\sum\limits_{k=1}^{N/d}\mu(k)(\sum\limits_{kd|A_i}\sum\limits_{kd|A_j}A_iA_j)$</p><p>右边这个 “()” 里的部分可以调和级数复杂度预处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (long long i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>, mod = <span class="number">998244353</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[M], inv[N + <span class="number">5</span>], bin[N + <span class="number">5</span>], ans, f[N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> mu[N + <span class="number">5</span>], prime[N + <span class="number">5</span>], tot, mark[N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            mark[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, N) inv[i] = inv[mod % i] * (mod - mod / i) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prework();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i], bin[a[i]]++;  <span class="comment">// 小技巧</span></span><br><span class="line">    rep(i, <span class="number">1</span>, N) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = i; j &lt;= N; j += i) &#123;</span><br><span class="line">            sum = (sum + bin[j] * j % mod) % mod;</span><br><span class="line">            f[i] = (f[i] + j * j * bin[j] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = (sum * sum % mod - f[i] + mod) * inv[<span class="number">2</span>] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(k, <span class="number">1</span>, N)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= N; i += k) <span class="comment">// i = k * d</span></span><br><span class="line">            ans = (ans + inv[k] * mu[i / k] % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2007]-上升序列</title>
      <link href="2019/10/08/%5BHAOI2007%5D-%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97/"/>
      <url>2019/10/08/%5BHAOI2007%5D-%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2215" target="_blank" rel="noopener">传送门</a></p><p>aaaaaaaa我居然不会二分求最长上升/下降子序列！！！</p><p>所以今天涨姿势了 qaq</p><ul><li>题意划重点：字典序最小指 $x_i$ 最小。</li></ul><p>先判断下最长上升子序列长度是否 $\geq$ 询问的 $L$。</p><p>$O(nm)$ 的复杂度完全可以过，所以我们枚举 $x_i$ 看是否符合条件，若符合则立刻输出 $a_{x_i}$，保证字典序最小。</p><p>符合条件是什么意思呢？假设还剩下 $x$ 的长度没有分配，若 $x_i$ 符合要求，则 $x_i$ ~ $n$ 这段中有 $\geq x$ 个后续位置。由于是 $x_i$ ~ $n$ ，我们预处理的是下降而不是上升子序列。</p><p>大概是这样：维护最长下降子序列 $b$ 数组，对于每个 $a_i$ 二分求出 $b$ 中第一个 &gt; $a_i$ 的 $b_j$，令 $i$ 位置的后续长度为 $j + 1$.<br>同时，若 $b[j + 1] &lt; a[i]$, 则令 $b[j + 1] = a[i]$（并不会使子序列更劣，反而有可能更优，因为下降的幅度减小了嘛）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], x, b[N], f[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = tot, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &gt; x) ret = max(ret, mid), l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(a[i]);</span><br><span class="line">        f[i] = tmp + <span class="number">1</span>;</span><br><span class="line">        tot = max(tot, tmp + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (b[tmp + <span class="number">1</span>] &lt; a[i]) b[tmp + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; tot) <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; lst &amp;&amp; f[i] &gt;= x) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">                    x--;</span><br><span class="line">                    lst = a[i];</span><br><span class="line">                    <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO2009open]-干草堆tower</title>
      <link href="2019/09/25/%5BUSACO2009open%5D-%E5%B9%B2%E8%8D%89%E5%A0%86tower/"/>
      <url>2019/09/25/%5BUSACO2009open%5D-%E5%B9%B2%E8%8D%89%E5%A0%86tower/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1233" target="_blank" rel="noopener">传送门</a></p><p>是一道非常神奇的单调队列优化 DP！</p><p>首先，我们发现这题非常不好做（没有入手点，但发现可以用二维 $n^3$ DP：$f[i, j]$ 表示 $i$ ~ $j - 1$ 是 $j$ 左边的一段的最大高度。我们想想怎么优化。</p><p>zkw 大神证出，最优的方案必定底层宽度最小。大概是这样证的：有 $A$ 和 $B$ 两个塔，$A$ 的高度最大，$B$ 按从低到高的顺序的每层宽度最小。那么 $A$ 的底层宽度必然大于等于 $B$，$B$ 的高度必然小于等于 $A$。必定存在一个位置 $pos$，该位置 $A$ 的宽度小于 $B$（因为 $A$ 不可能层层都比 $B$ 宽），那么对于 $B$ 来说，只要把 $pos$ 以上的部分换成 $A$ 塔中 $pos$ 以上的部分，就能变成更优的方案。</p><p>如果从底层到顶层 DP，会发现状态不好设计（反正我没想出来qvq），而且没有单调性（比如 $n = 3$，$w = \{2, 1, 4\}$，前两个最大高度是 $2$，加入第三个就变成 $1$ 了。。），而从顶层到底层 DP 是有单调性的（自己想一想）。</p><p>设 $f[i]$ 表示该层编号最小为 $i$ 时的宽度。 $f[i] = \min\limits_{sum[j - 1] - sum[i - 1] &gt;= f[j]}\{sum[j - 1] - sum[i - 1]\}$</p><p>即 $sum[j - 1] - f[j] &gt;= sum[i - 1]$</p><p>显然只有 $sum[j - 1] - f[j] &gt;= sum[i - 1]$ 且离 $i$ 最近的 $j$ 才能转移给 $i$。维护一个 $sum[j - 1] - f[j]$ 单调递减（因为 $i$ 从 $n$ 到 $1$，$sum[i - 1]$ 是递减的）的单调队列就可以了。</p><p>山路十八弯 ~ 思维难度还是很大的！【单调队列难.jpg】</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], q[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    a[n + <span class="number">1</span>] = a[n];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    q[l] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l + <span class="number">1</span>] - <span class="number">1</span>] - f[q[l + <span class="number">1</span>]] &gt;= a[i - <span class="number">1</span>]) ++l;</span><br><span class="line">        f[i] = a[q[l] - <span class="number">1</span>] - a[i - <span class="number">1</span>];</span><br><span class="line">        g[i] = g[q[l]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[q[r] - <span class="number">1</span>] - f[q[r]] &lt;= a[i - <span class="number">1</span>] - f[i]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, g[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 141</title>
      <link href="2019/09/17/Atcoder%20Beginner%20Contest%20141/"/>
      <url>2019/09/17/Atcoder%20Beginner%20Contest%20141/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc141/tasks" target="_blank" rel="noopener">传送门</a></p><p>ABC皆为水题。。。略过</p><h3 id="D-Powerful-Discount-Tickets"><a href="#D-Powerful-Discount-Tickets" class="headerlink" title="D - Powerful Discount Tickets"></a>D - Powerful Discount Tickets</h3><hr><p>a/b/c(下取整) 竟然等于 a/(bc)(下取整)。。。比赛时想到正解做法，但由于无法证明前面那句也举不出反例而不了了之了。。。</p><p>正解就是堆优化啦</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], f[N][<span class="number">2</span>];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        q.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        ans += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Who-Says-a-Pun"><a href="#E-Who-Says-a-Pun" class="headerlink" title="E - Who Says a Pun?"></a>E - Who Says a Pun?</h3><hr><p>后缀数组 + 二分经典好题（套路题），可见 POJ1743</p><h3 id="F-Xor-Sum-3"><a href="#F-Xor-Sum-3" class="headerlink" title="F - Xor Sum 3"></a>F - Xor Sum 3</h3><hr><p>一句话题意：设序列的异或值为 sum，求分两堆，一堆异或值为 res，使得 res + (sum ^ res) 最大。</p><p>一看到就觉得是线性基。。。然鹅并不会做，果然还是太弱了。。。</p><p>位运算的题十有八九要按位讨论！来一起想想，若 sum 的第 i 位为 1，那么分的两堆中必一堆为 1 一堆为 0，也就是说应忽略 i 位为 1 的位；若 i 位为 0，那么两堆中这一位的贡献是相同的，也就是说我们只要找 i 位为 0 的数的最大异或值就好啦。线性基可以胜任。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, q[<span class="number">65</span>];</span><br><span class="line">ll a[N], sum, tot, p[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; (<span class="number">1l</span>l &lt;&lt; q[i]))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p[i]) &#123; p[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">        x ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]), sum ^= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!((<span class="number">1l</span>l &lt;&lt; i) &amp; sum)) q[++tot] = i;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) insert(a[i]);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, tot)</span><br><span class="line">        <span class="keyword">if</span> (!(res &amp; (<span class="number">1l</span>l &lt;&lt; q[i]))) res ^= p[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res + (sum ^ res));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[WC2011]-最大XOR和路径</title>
      <link href="2019/08/18/%5BWC2011%5D-%E6%9C%80%E5%A4%A7XOR%E5%92%8C%E8%B7%AF%E5%BE%84/"/>
      <url>2019/08/18/%5BWC2011%5D-%E6%9C%80%E5%A4%A7XOR%E5%92%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P4151" target="_blank" rel="noopener">传送门</a></p><p>学了线性基、、挺友好的、、、</p><p>首先很容易得出，一个环走两遍没有意义，走过一个子树也没有意义（因为任意一条边都会走过去再走回来），所以路径可以表示为一条链 + 一些环。</p><p>我们把每一个环的 XOR 和丢进一个线性基里，答案就是链与线性基的最大异或和。</p><p>ps：链不一定要是最长链。假设有链 A 和链 B，两者构成了 1 ~ n ~ 1 的一个环，也就是这个环异或链 A 就能得到链 B。</p><p>最近有进步呀！自己都能想想了（。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, vis[N], mark[N];</span><br><span class="line">ll to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line">ll val[N &lt;&lt; <span class="number">1</span>], p[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt, val[cnt] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(x &amp; (<span class="number">1l</span>l &lt;&lt; i))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!p[i]) &#123; p[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">x ^= p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> ((ret ^ p[i]) &gt; ret) ret ^= p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll res)</span> </span>&#123;</span><br><span class="line">mark[x] = res, vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = to[i];</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) dfs(y, res ^ val[i]);</span><br><span class="line"><span class="keyword">else</span> insert(res ^ mark[y] ^ val[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y; ll z; <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">addedge(x, y, z), addedge(y, x, z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(mark[n]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ARC087]-E. Prefix-free game</title>
      <link href="2019/08/10/%5BARC087%5D-E.%20Prefix-free%20game/"/>
      <url>2019/08/10/%5BARC087%5D-E.%20Prefix-free%20game/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/arc087/tasks/arc087_c" target="_blank" rel="noopener">传送门</a></p><p>很妙啊！早知道 ARC 这么启发思维的话就去做了啊 qaqaq</p><p>对字符串玩博弈好像的确不太可能，但移到字典树上就不一样了。我们发现，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 65</title>
      <link href="2019/07/30/Educational%20Codeforces%20Round%2065/"/>
      <url>2019/07/30/Educational%20Codeforces%20Round%2065/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1167" target="_blank" rel="noopener">传送门</a></p><h3 id="A-Telephone-Number"><a href="#A-Telephone-Number" class="headerlink" title="A. Telephone Number"></a>A. Telephone Number</h3><hr><p>签到题</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'8'</span>) &#123; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (n - (pos - <span class="number">1</span>) &lt; <span class="number">11</span> || !pos) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] != <span class="string">'8'</span>) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Lost-Numbers"><a href="#B-Lost-Numbers" class="headerlink" title="B. Lost Numbers"></a>B. Lost Numbers</h3><hr><p>第一次 B 题是交互诶。。</p><p>很暴力</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y, z, w, ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) <span class="keyword">if</span> (a[i] == x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 2\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 3 4\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 3\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? 1 5\n"</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) tot *= a[i];</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % a[i] == <span class="number">0</span> &amp;&amp; z % a[i] == <span class="number">0</span> &amp;&amp; w % a[i] == <span class="number">0</span> &amp;&amp; find(x / a[i]) &amp;&amp; find(z / a[i]) &amp;&amp; find(w / a[i])) &#123;</span><br><span class="line">            ans[<span class="number">1</span>] = a[i];</span><br><span class="line">            ans[<span class="number">2</span>] = x / a[i];</span><br><span class="line">            ans[<span class="number">3</span>] = z / a[i];</span><br><span class="line">            ans[<span class="number">4</span>] = y / ans[<span class="number">3</span>];</span><br><span class="line">            ans[<span class="number">5</span>] = w / a[i];</span><br><span class="line">            ans[<span class="number">6</span>] = tot / x / y / ans[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d %d %d\n"</span>, ans[<span class="number">1</span>], ans[<span class="number">2</span>], ans[<span class="number">3</span>], ans[<span class="number">4</span>], ans[<span class="number">5</span>], ans[<span class="number">6</span>]);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-News-Distribution"><a href="#C-News-Distribution" class="headerlink" title="C. News Distribution"></a>C. News Distribution</h3><hr><p>题目看到一半。。嗯？？冰茶姬？？？</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], fa[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = getfa(x), y = getfa(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y)</span><br><span class="line">        fa[x] = y, sum[y] += sum[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) fa[i] = i, sum[i] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (lst) merge(x, lst);</span><br><span class="line">            lst = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, sum[getfa(i)]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Bicolored-RBS"><a href="#D-Bicolored-RBS" class="headerlink" title="D. Bicolored RBS"></a>D. Bicolored RBS</h3><hr><p>比较暴力的思想：维护红色和蓝色括号序列的前缀和，然后 ‘(‘ 优先给前缀和小的，’)’ 优先给前缀和大的</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) x++, ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> y++, ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) x--, ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> y--, ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Range-Deleting"><a href="#E-Range-Deleting" class="headerlink" title="E. Range Deleting"></a>E. Range Deleting</h3><hr><p>赛后补题！挺妙滴</p><p>发现，删除的区间若左区间固定，右区间呈单调性。设对于不同的左区间 l_i, 都有右区间 r_i, 则 r_1 &lt;= r_2 &lt;= … &lt;= r_n, 所以可以用二分或 two-pointers 找 r_i.</p><p>可以预处理每个 a_i 最左和最右的位置，预处理 1 ~ i 最右的位置 和 i ~ x 最左的位置，用于在查找 r_i 时判断某部分数是否呈非递减。</p><p>若区间 [l, r] 都可以删除，那么 [l, r + 1] 也可以删除，所以此时对答案产生贡献 (n - r + 1).</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, x, a[N], l[N], r[N], L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(L, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(L));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        l[a[i]] = min(l[a[i]], i);</span><br><span class="line">        r[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        L[i] = min(L[i + <span class="number">1</span>], l[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, x)</span><br><span class="line">        R[i] = max(R[i - <span class="number">1</span>], r[i]);</span><br><span class="line">    <span class="keyword">int</span> k = x;</span><br><span class="line">    <span class="keyword">for</span> (; k &gt; <span class="number">1</span> &amp;&amp; r[k] &lt;= L[k + <span class="number">1</span>]; --k);  <span class="comment">// 要删除的区间是 [1, k]</span></span><br><span class="line">    ll ans = x - k + <span class="number">1</span>;  <span class="comment">// 产生贡献</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x &amp;&amp; R[i - <span class="number">2</span>] &lt;= l[i - <span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; i || R[i - <span class="number">1</span>] &gt; L[k + <span class="number">1</span>]; ++k);  <span class="comment">// 要删除的区间是 [i, k]</span></span><br><span class="line">        ans += x - k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Scalar-Queries"><a href="#F-Scalar-Queries" class="headerlink" title="F. Scalar Queries"></a>F. Scalar Queries</h3><hr><p>因为是 vp 的，，到点儿了就要吃饭去，，抵不住十三香大虾🍤的诱惑 [捂脸] F 题只是有了初步思路，，，，，</p><p>后来是看题解的。。好题。。。</p><p>变相理解题意就是：如果 a 和 b 在一个区间 [l, r] 里且 a &lt; b, 那么就会对 f(l, r) 产生 b 的贡献（a 和 b 对 f(l, r) 的初始贡献分别是 a 和 b</p><ul><li>a[i] 和 a[j] 在一个区间的情况数 共有 $i * (n - j + 1)$ 种</li></ul><p>如果在 a[i] 的前面有个比 a[i] 小的数 a[j]，那么 a[j] 对 a[i] 系数的贡献应该等于包含 a[i] 和 a[j] 的区间数量，即 $j*(n-i+1)$</p><p>如果在 a[i] 的前面有个比 a[i] 小的数 a[j]，同上，贡献等于 $i*(n-j+1)$</p><p>所以我们现在需要维护比 a[i] 小的数的信息，那么对 a[i] 权值排序，可以用两个树状数组实现，分别维护上述两种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一点儿收获：对于这样的题，肯定要 O(n) 或 O(n <span class="built_in">log</span> n) 解决，只能数据结构出场，比如树状数组。为了保持 “值小的优先处理” 的顺序，我们需要按照值的大小排序。</span><br></pre></td></tr></table></figure><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll w, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> C[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) &#123;</span><br><span class="line">            C[x] += val;</span><br><span class="line">            <span class="keyword">if</span> (C[x] &gt;= mod) C[x] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= lowbit(x)) &#123;</span><br><span class="line">            ret += C[x];</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= mod) ret -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].w);</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll sum = a[i].id * (n - a[i].id + <span class="number">1</span>) % mod;</span><br><span class="line">        sum = (sum + l.query(a[i].id) * (n - a[i].id + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        sum = (sum + (r.query(n) - r.query(a[i].id) + mod) % mod * a[i].id % mod) % mod;</span><br><span class="line">        l.add(a[i].id, a[i].id);</span><br><span class="line">        r.add(a[i].id, n - a[i].id + <span class="number">1</span>);</span><br><span class="line">        ans = (ans + a[i].w * sum % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 561 Div2</title>
      <link href="2019/07/28/Codeforces%20Round%20561%20Div2/"/>
      <url>2019/07/28/Codeforces%20Round%20561%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1166" target="_blank" rel="noopener">传送门</a></p><h3 id="A-Silent-Classroom"><a href="#A-Silent-Classroom" class="headerlink" title="A. Silent Classroom"></a>A. Silent Classroom</h3><hr><p>签到题</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">30</span>], ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), num[s[<span class="number">1</span>] - <span class="string">'a'</span>]++;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = num[i] / <span class="number">2</span>, y = num[i] - x;</span><br><span class="line">        ans += (x * (x - <span class="number">1</span>) / <span class="number">2</span>) + (y * (y - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-All-the-Vowels-Please"><a href="#B-All-the-Vowels-Please" class="headerlink" title="B. All the Vowels Please"></a>B. All the Vowels Please</h3><hr><p>题意：每行每列都得有 a e i o u</p><p>稍微构造下就好啦</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) x = i, y = n / i;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span> || y &lt; <span class="number">5</span>) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"aeiou"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"eioua"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"e"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"iouae"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"i"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ouaei"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"o"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"uaeio"</span>);</span><br><span class="line">            rep(j, <span class="number">1</span>, y - <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"u"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-A-Tale-of-Two-Lands"><a href="#C-A-Tale-of-Two-Lands" class="headerlink" title="C. A Tale of Two Lands"></a>C. A Tale of Two Lands</h3><hr><p>推不等式</p><p>(x2 = x^2)</p><p>min(|x - y|, |x + y|) &lt;= |x|, |y| &lt;= max(|x - y|, |x + y|)</p><p>|x|2 + |y|2 - 2|x||y| &lt;= |x|2, |y|2 &lt;= |x|2 + |y|2 + 2|x||y|</p><p>2|x| &gt;= |y|, |x| &gt;= -2|y|</p><p>总而言之就是 2|x| &gt;= |y|, upper_bound() 搞一搞就 AC，，</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), a[i] = <span class="built_in">fabs</span>(a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = upper_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">2</span> * a[i]) - a;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; n) tmp = n;</span><br><span class="line">        <span class="keyword">if</span> (a[tmp] &gt; <span class="number">2</span> * a[i]) tmp--;</span><br><span class="line">        ans += tmp - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Cute-Sequences"><a href="#D-Cute-Sequences" class="headerlink" title="D. Cute Sequences"></a>D. Cute Sequences</h3><hr><p>有趣又恶心的构造！是赛后补的</p><p>主要看 <a href="https://www.cnblogs.com/megalovania/p/10888493.html" target="_blank" rel="noopener">这位大佬</a> 的，这边补充说明下：</p><ul><li><p>r_i 对 x_j (j &gt;= i) 的贡献我们发现是 1，2，4，8，… 这样的</p></li><li><p>此处的贡献可以理解为：在位置 i 加一，位置 j (j &gt;= i) 会加上多少？</p></li><li><p>在 “减回来” 的时候，我们从数列中靠前的位置开始，因为越靠前，对后面的影响力越大</p></li></ul><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">ll l[N], r[N], prel[N], prer[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">50</span>) rep(j, <span class="number">0</span>, i - <span class="number">1</span>) pre[i] += pre[j];  <span class="comment">// 预处理影响</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a, b, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line">        prel[<span class="number">1</span>] = l[<span class="number">1</span>] = prer[<span class="number">1</span>] = r[<span class="number">1</span>] = a;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1 %lld\n"</span>, a); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; ; i++) &#123;</span><br><span class="line">            l[i] = prel[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            r[i] = prer[i - <span class="number">1</span>] + m;</span><br><span class="line">            prel[i] = prel[i - <span class="number">1</span>] + l[i];</span><br><span class="line">            prer[i] = prer[i - <span class="number">1</span>] + r[i];</span><br><span class="line">            <span class="keyword">if</span> (r[i] &gt;= b) &#123; n = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l[n] &gt; b) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, n);</span><br><span class="line">        rep(i, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> (r[n] &gt; b) &#123;</span><br><span class="line">                ll d = min(m - <span class="number">1</span>, (r[n] - b) / pre[n - i]);</span><br><span class="line">                rep(j, i, n) r[j] -= d * pre[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, r[i]); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-The-LCMs-Must-be-Large"><a href="#E-The-LCMs-Must-be-Large" class="headerlink" title="E. The LCMs Must be Large"></a>E. The LCMs Must be Large</h3><hr><p>结论题好哇！</p><p>很容易证明，如果有两天的购买物品的集合完全不同，答案不存在：lcm(Si) &gt; lcm(U - Si) &gt;= lcm(Sj) &gt; lcm(U - Sj) &gt;= lcm(Si) （其中 Sx 表示一个集合） 这是不可能滴！</p><p>如何证明若任意两天购买集合都有交集，则必然存在答案呢？可以这样：先把数组 a 置为 1，把 a 中第一天购买集合乘以质数 p1，把 a 中第二天购买集合乘以质数 p2，就是一组符合要求的数字。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s[<span class="number">55</span>], mark[<span class="number">55</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        rep(j, <span class="number">1</span>, s[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            mark[i][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j, <span class="number">1</span>, i - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            rep(k, <span class="number">1</span>, m) <span class="keyword">if</span> (mark[i][k] &amp;&amp; mark[j][k]) cnt++;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) &#123; <span class="built_in">puts</span>(<span class="string">"impossible"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"possible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 574 Div2</title>
      <link href="2019/07/25/Codeforces%20Round%20574%20Div2/"/>
      <url>2019/07/25/Codeforces%20Round%20574%20Div2/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Drinks-Choosing"><a href="#A-Drinks-Choosing" class="headerlink" title="A. Drinks Choosing"></a>A. Drinks Choosing</h3><hr><p>就是本着尽量别浪费的原则。。</p><p>签到题硬是读了 N 遍题意。。英语不行啊</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        num[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = (n + <span class="number">1</span>) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">        ans += num[i] / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">        tot -= num[i] / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += tot;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Sport-Mafia"><a href="#B-Sport-Mafia" class="headerlink" title="B. Sport Mafia"></a>B. Sport Mafia</h3><hr><p>解了个二元一次方程（噗</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll a = <span class="number">1</span>, b = -(n + <span class="number">1</span> + n) - <span class="number">2</span>, c = (n + <span class="number">1</span>) * n - <span class="number">2</span> * k;</span><br><span class="line">    ll tmp = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">    tmp = (ll)<span class="built_in">sqrt</span>(tmp);</span><br><span class="line">    ll ans1 = (-b + tmp) / (<span class="number">2</span> * a), ans2 = (-b - tmp) / (<span class="number">2</span> * a);</span><br><span class="line">    <span class="keyword">if</span> (ans2 &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans2);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Basketball-Exercise"><a href="#C-Basketball-Exercise" class="headerlink" title="C. Basketball Exercise"></a>C. Basketball Exercise</h3><hr><p>DP? 很简单</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], b[N], dp[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">        dp[i][<span class="number">2</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(dp[n][<span class="number">0</span>], max(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D1-Submarine-in-the-Rybinsk-Sea-easy-edition"><a href="#D1-Submarine-in-the-Rybinsk-Sea-easy-edition" class="headerlink" title="D1. Submarine in the Rybinsk Sea (easy edition)"></a>D1. Submarine in the Rybinsk Sea (easy edition)</h3><hr><p>考虑按位处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], num[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            num[pos * <span class="number">2</span> - <span class="number">1</span>] = (num[pos * <span class="number">2</span> - <span class="number">1</span>] + (x % <span class="number">10</span>) * n) % mod;</span><br><span class="line">            num[pos * <span class="number">2</span>] = (num[pos * <span class="number">2</span>] + (x % <span class="number">10</span>) * n) % mod;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]) len = i;</span><br><span class="line">        num[i + <span class="number">1</span>] += num[i] / <span class="number">10</span>;</span><br><span class="line">        num[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num[len + <span class="number">1</span>]) ++len;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        ans = (ans * <span class="number">10</span> + num[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D2-Submarine-in-the-Rybinsk-Sea-hard-edition"><a href="#D2-Submarine-in-the-Rybinsk-Sea-hard-edition" class="headerlink" title="D2. Submarine in the Rybinsk Sea (hard edition)"></a>D2. Submarine in the Rybinsk Sea (hard edition)</h3><hr><p>预处理第 i 个数和长度为 j 的串在一起的贡献，还是按位处理</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, a[N], num[<span class="number">30</span>], len[<span class="number">15</span>], pw[<span class="number">35</span>], f[N][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % mod;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ll x = a[i];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            x /= <span class="number">10</span>; pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        len[pos]++;</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= j) &#123;</span><br><span class="line">                ll tmp = a[i];</span><br><span class="line">                rep(k, <span class="number">0</span>, j - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (((f[i][j] + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span>] % mod) % mod) + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span> + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> p = <span class="number">2</span> * j;</span><br><span class="line">                rep(k, j, pos - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (f[i][j] + <span class="number">2l</span>l * x * pw[p] % mod) % mod;</span><br><span class="line">                    ++p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">                rep(k, <span class="number">0</span>, pos - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = tmp % <span class="number">10</span>; tmp /= <span class="number">10</span>;</span><br><span class="line">                    f[i][j] = (((f[i][j] + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span>] % mod) % mod) + <span class="number">1l</span>l * x * pw[k * <span class="number">2</span> + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            ans = (ans + <span class="number">1l</span>l * f[i][j] * len[j] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-OpenStreetMap"><a href="#E-OpenStreetMap" class="headerlink" title="E. OpenStreetMap"></a>E. OpenStreetMap</h3><hr><p>基础套路题！单调队列就可以</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line">ll g, x, y, z, mp[N][N], f[N][N];</span><br><span class="line"><span class="built_in">deque</span>&lt;pii&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; g &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        mp[i][j] = g; g = (<span class="number">1l</span>l * g * x % z + y) % z;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) q.pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; mp[i][j] &lt; q.front().first) q.pop_front();</span><br><span class="line">            q.push_front(make_pair(mp[i][j], j));</span><br><span class="line">            f[i][j] = q.back().first;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; q.back().second &gt;= j + b - <span class="number">1</span>) q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) mp[i][j] = f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) q.pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; mp[i][j] &lt; q.front().first) q.pop_front();</span><br><span class="line">            q.push_front(make_pair(mp[i][j], i));</span><br><span class="line">            f[i][j] = q.back().first;</span><br><span class="line">            <span class="keyword">while</span> (q.size() &amp;&amp; q.back().second &gt;= i + a - <span class="number">1</span>) q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n - a + <span class="number">1</span>) rep(j, <span class="number">1</span>, m - b + <span class="number">1</span>) ans += f[i][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Geometers-Anonymous-Club"><a href="#F-Geometers-Anonymous-Club" class="headerlink" title="F. Geometers Anonymous Club"></a>F. Geometers Anonymous Club</h3><hr><p>补了 F！</p><p>题意就是让你对一个区间内的凸包进行闵可夫斯基求和。</p><p>有一个闵可夫斯基求和的定理，就是 n 个方向不同的向量形成的凸包有 n 个顶点。</p><p>离线处理，用树状数组维护。注意，多点一线这种情况要处理！见代码。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, q, l[N], r[N], C[N], ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;pii, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; ve, tmp, query;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">get_dir</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 处理多点一线的情况</span></span><br><span class="line">    <span class="keyword">int</span> gcd = __gcd(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">    <span class="keyword">if</span> (gcd) x /= gcd, y /= gcd;</span><br><span class="line">    <span class="keyword">return</span> make_pair(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= N; x += lowbit(x)) C[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ve.push_back(make_pair(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        rep(j, <span class="number">1</span>, x) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            tmp.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">        l[i] = ve.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp.size(); j++)</span><br><span class="line">            ve.push_back(get_dir(tmp[j].first - tmp[(j + <span class="number">1</span>) % tmp.size()].first, tmp[j].second - tmp[(j + <span class="number">1</span>) % tmp.size()].second));</span><br><span class="line">        tmp.clear();</span><br><span class="line">        r[i] = ve.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    rep(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        pii temp = make_pair(l[a], r[b]);</span><br><span class="line">        query.push_back(temp);</span><br><span class="line">        t[temp.second].push_back(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ve.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.count(ve[i])) add(mp[ve[i]], <span class="number">-1</span>);</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">        mp[ve[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t[i].size(); j++)</span><br><span class="line">            ans[t[i][j]] = get_sum(query[t[i][j]].second) - get_sum(query[t[i][j]].first - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, q - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2019同步赛体验&amp;感想</title>
      <link href="2019/07/24/NOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C&amp;%E6%84%9F%E6%83%B3/"/>
      <url>2019/07/24/NOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E4%BD%93%E9%AA%8C&amp;%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>(&gt;﹏&lt;) 今年暴力分比去年足诶！！（暴力选手真心话</p><hr><p>来补题解啦，由于咕咕了很久所以已经忘记题目顺序啦</p><h2 id="回家路线"><a href="#回家路线" class="headerlink" title="$回家路线$"></a>$回家路线$</h2><p>同步赛时写了以边为点的 $O(m^2)$ 最短路。听说数据很水，emm</p><p>$p &lt; q$，显然不会构成环，dp 就行了</p><p>正解是斜率优化 dp，$f[i]$ 表示走了第 $i$ 条边的最小烦躁值。$f[i] = min(f[j] + calc(p_i - q_j)(y_j = x_i, q_j \leq p_i))$</p><p>对于最优解 $j$, $f[j] + Ap_j^2 - Bq_j = 2Ap_iq_j + f[i] - Ap_i^2 - Bp_i - C$</p><p>其中 $y = f[j] + Ap_j^2 - Bq_j$, </p><p>$k = 2Ap_i$, </p><p>$x = q_j$, </p><p>$b = f_i - Ap_i^2 - Bp_i - C$</p><p>要 $f_i$ 小就是要截距小，因此维护一个下凸包</p><p>以时间为阶段，维护 $t$ 时间内的凸包集合，即集合内决策点满足 $q_i \leq t$. 桶排，将决策点 $j$ 在时刻 $q_j$ 加入凸包 $y_j$ 中。每个凸包满足 $q$ 递增。</p><p>RE 调半天，发现数组没开足。。。</p><h2 id="序列"><a href="#序列" class="headerlink" title="$序列$"></a>$序列$</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【习题选讲】一些「有趣」的计数题</title>
      <link href="2019/07/12/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E4%B8%80%E4%BA%9B%E3%80%8C%E6%9C%89%E8%B6%A3%E3%80%8D%E7%9A%84%E8%AE%A1%E6%95%B0%E9%A2%98/"/>
      <url>2019/07/12/%E3%80%90%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B2%E3%80%91%E4%B8%80%E4%BA%9B%E3%80%8C%E6%9C%89%E8%B6%A3%E3%80%8D%E7%9A%84%E8%AE%A1%E6%95%B0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>都是 2019 暑期训练题～</p><h2 id="燕归巢-swalllow"><a href="#燕归巢-swalllow" class="headerlink" title="燕归巢(swalllow)"></a>燕归巢(swalllow)</h2><hr><p>枚举不同形态的树显然不可能，所以我们可以考虑一条边的贡献（这在之后的计数题是很常用的技巧，可以说是套路了，一定要掌握！</p><p>先将结点分为左右两个集合，枚举左边集合点数 i，那么右边集合点数则为 n - i；</p><p>选择左边点集共有 C(n - 1, i - 1) 种方法（注意要减一！因为连接两个集合的边，也就是被考虑贡献的边，它的一端是不被计入的）；</p><p>左边形成的树有 i ^ {i - 2} 种形态，右边形成的树有 (n - i) ^ {n - i - 2} 种形态；</p><p>选择连接左集合和右集合的边 共有 i(n - i) 种方法；</p><p>选择包含这条边的路径 共有 i(n - i) 种方法。</p><p>所以就是: </p><h2 id="sum-limits-i-1-nC-n-1-i-1-i-i-2-n-i-n-i-2-i-n-i-i-n-i"><a href="#sum-limits-i-1-nC-n-1-i-1-i-i-2-n-i-n-i-2-i-n-i-i-n-i" class="headerlink" title="$\sum\limits_{i = 1}^nC(n - 1, i - 1)  i^{i - 2}  (n - i)^{n - i - 2}  i  (n - i)  i  (n - i)$"></a>$\sum\limits_{i = 1}^nC(n - 1, i - 1) <em> i^{i - 2} </em> (n - i)^{n - i - 2} <em> i </em> (n - i) <em> i </em> (n - i)$</h2><h2 id="头皮屑-Venus"><a href="#头皮屑-Venus" class="headerlink" title="头皮屑(Venus)"></a>头皮屑(Venus)</h2><hr><p>（有趣的标题</p><p>实质是数论题。考试时找到了性质：</p><ol><li>至少一个是质数且至少一个数 &gt; n / 2，无边相连，为 0</li><li>gcd &gt; 1，有直接边，为 1</li><li>互质，最小质因数之和 &lt;= n，为 2</li><li>互质，两个数都 &lt;= n / 2，为 3</li></ol><p>我们在讨论中忽略数字 1。</p><p>4）直接用总边数减去 0）1）2）就好了。</p><p>建议看 CF 原题解：<a href="http://codeforces.com/blog/entry/55200" target="_blank" rel="noopener">传送门</a></p><h2 id="坐等memset0-memset"><a href="#坐等memset0-memset" class="headerlink" title="坐等memset0(memset)"></a>坐等memset0(memset)</h2><hr><p>非常妙的 CF 题！</p><p>我们发现，f(l, r) = l ~ r 的点数 - l ~ r 的边数。</p><p>那么我们可以拆开 sigma，计算每一个点的贡献和每一条边的贡献，就可以 AC。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2014]-序列分割</title>
      <link href="2019/07/06/%5BAPIO2014%5D-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/"/>
      <url>2019/07/06/%5BAPIO2014%5D-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3675" target="_blank" rel="noopener">题目链接</a></p><p>啊。。。好恶心。。最后逼着我去对拍【面孔扭曲】也算很有意义了！趁机复习一波斜率优化。。</p><p>可以发现，答案和分割顺序好像并没有关系，所以我们可以默认为从左向右分割（这样最方便</p><p>设 f[i, j] 表示前 j 个分割了 i 次。那么方程就是：f[i, j] = max{f[i - 1][k] + s[k]·(s[j]·s[k])}<br>(其中 s[i] 表示 a[1] ~ a[i] 的和)</p><p>如果决策 k1 &lt; k2（k2更优：</p><script type="math/tex; mode=display">f[i, k1] + s[k1]*(s[j]*s[k1]) < f[i, k2] + s[k2]*(s[j]*s[k2])</script><p>=&gt;</p><script type="math/tex; mode=display">s[j] > \frac{f[i, k1] - f[i, k2] + (s[k1] ^ 2) - (s[k2] ^ 2)}{s[k2] - s[k1]}</script><p>这是一个斜率优化的式子，然后就是套路了。祝玩耍愉快。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, K, a[N], q[N], r;</span><br><span class="line">ll sum[N], f[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[j] == sum[k]) <span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(sum[k] * sum[k] - sum[j] * sum[j] + f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j] - f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][k]) / (<span class="keyword">double</span>)(sum[k] - sum[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt;= K; r++) &#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[head], q[head + <span class="number">1</span>]) &lt; sum[i]) head++;</span><br><span class="line">            <span class="keyword">int</span> t = q[head];</span><br><span class="line">            f[r &amp; <span class="number">1</span>][i] = f[(r &amp; <span class="number">1</span>) ^ <span class="number">1</span>][t] + (sum[i] - sum[t]) * sum[t];</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; slope(q[tail - <span class="number">1</span>], q[tail]) &gt; slope(q[tail], i)) tail--;</span><br><span class="line">            q[++tail] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[K &amp; <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 572 Div2</title>
      <link href="2019/07/05/Codeforces%20Round%20572%20Div2/"/>
      <url>2019/07/05/Codeforces%20Round%20572%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1189" target="_blank" rel="noopener">比赛链接</a></p><p>VP 的～</p><h3 id="A-Keanu-Reeves"><a href="#A-Keanu-Reeves" class="headerlink" title="A. Keanu Reeves"></a>A. Keanu Reeves</h3><hr><p>H2O 签到题～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        c[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>], b[i] = b[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (c[i]) a[i]++; <span class="keyword">else</span> b[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[n] != b[n]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                rep(j, <span class="number">1</span>, i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                rep(j, i + <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">"%d"</span>, c[j]);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Number-Circle"><a href="#B-Number-Circle" class="headerlink" title="B. Number Circle"></a>B. Number Circle</h3><hr><p>尽量保持 大-&gt;小-&gt;大 的顺序～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = n + <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) b[++r] = a[i];</span><br><span class="line">        <span class="keyword">else</span> b[--l] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l) l = n;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; n) r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[l] + b[r] &lt;= b[i]) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Candies"><a href="#C-Candies" class="headerlink" title="C. Candies!"></a>C. Candies!</h3><hr><p>当时暴力模拟是 T 了一发，然后才想到 ST 表。。（这种题应该首选 ST 啊！</p><p>不是很难，复习一波！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, q, l, r, pre[N], ans, f[N][<span class="number">20</span>], g[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">log</span>(n + eps) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tmp; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> k = n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            f[i][j] = (f[i][j - <span class="number">1</span>] + f[i + len][j - <span class="number">1</span>]) % <span class="number">10</span>;</span><br><span class="line">            g[i][j] = (g[i][j - <span class="number">1</span>] + g[i + len][j - <span class="number">1</span>]) + (f[i][j - <span class="number">1</span>] + f[i + len][j - <span class="number">1</span>] &gt;= <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        tmp = <span class="built_in">log</span>(r - l + <span class="number">1</span> + eps) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g[l][tmp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D1-Add-on-a-Tree"><a href="#D1-Add-on-a-Tree" class="headerlink" title="D1. Add on a Tree"></a>D1. Add on a Tree</h3><hr><p>发现，有 3 个以上分支的点，它连接的边可以任意+。</p><p>所以如果有 2 个分支的点就不可以！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        d[x]++, d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (d[i] == <span class="number">2</span>) &#123; ff = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="built_in">puts</span>(<span class="string">"no"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"yes"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Count-Pairs"><a href="#E-Count-Pairs" class="headerlink" title="E. Count Pairs"></a>E. Count Pairs</h3><hr><p>这种题肯定得 i 归一边，j 归另一边，各管各的才好～</p><p>因式分解党表示强迫症发作～</p><p>两边同乘 (ai - aj)，就是 ai^4 - aj^4 恒等于 (ai - aj)k (mod p)</p><p>整理得 ai^4 - aiK 恒等于 aj^4 - ajK (mod p)</p><p>那么就很 easy 惹～ E题 AC～</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mod, K, a[N], ans;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a - b;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += mod;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1l</span>l * a * b) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mul(mul(x, x), mul(x, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        a[i] = sub(p(a[i]), mul(K, a[i]));</span><br><span class="line">        ans += mp[a[i]];</span><br><span class="line">        mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>有进步！暑假拼了 (ง •̀灬•́)ง</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态DP</title>
      <link href="2019/06/27/%E5%8A%A8%E6%80%81DP/"/>
      <url>2019/06/27/%E5%8A%A8%E6%80%81DP/</url>
      
        <content type="html"><![CDATA[<p>神仙芝士= =</p><p>恐怕讲不好，还是挂别人 dalao 的 blog 吧！</p><p><a href="https://www.cnblogs.com/RabbitHu/p/9112811.html" target="_blank" rel="noopener">这个超好</a></p><p>再挂个板子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu4719</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dfn;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>], g[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[N], w2[N], sz[N], top[N], ed[N], bel[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], son[N], id[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) m[i][j] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ans[N &lt;&lt; <span class="number">2</span>], val[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    <span class="keyword">int</span> Mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; Mx) Mx = sz[y], son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    top[x] = f;</span><br><span class="line">    id[x] = ++dfn;</span><br><span class="line">    bel[dfn] = x, ed[f] = x;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x], f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[x] = ed[f]; <span class="comment">// !!!!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    g[x][<span class="number">1</span>] = w[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == son[x] || y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs3(y);</span><br><span class="line">        g[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        g[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>] += g[x][<span class="number">0</span>], f[x][<span class="number">1</span>] += g[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        dfs3(son[x]);</span><br><span class="line">        f[x][<span class="number">0</span>] += max(f[son[x]][<span class="number">1</span>], f[son[x]][<span class="number">0</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += f[son[x]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mul</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">    node res;</span><br><span class="line">    res.cl();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; k++)</span><br><span class="line">                res.m[i][j] = max(res.m[i][j], x.m[i][k] + y.m[k][j]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[x].l = l, tr[x].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[bel[l]].m[<span class="number">0</span>][<span class="number">0</span>] = g[bel[l]][<span class="number">0</span>], val[bel[l]].m[<span class="number">0</span>][<span class="number">1</span>] = g[bel[l]][<span class="number">0</span>];</span><br><span class="line">        val[bel[l]].m[<span class="number">1</span>][<span class="number">0</span>] = g[bel[l]][<span class="number">1</span>], val[bel[l]].m[<span class="number">1</span>][<span class="number">1</span>] = -inf;</span><br><span class="line">        ans[x] = val[bel[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, l, mid), build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    ans[x] = mul(ans[x &lt;&lt; <span class="number">1</span>], ans[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[x].l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> ans[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= r) <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; l) <span class="keyword">return</span> query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> mul(query(x &lt;&lt; <span class="number">1</span>, l, r), query(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l == tr[x].r &amp;&amp; tr[x].l == pos) &#123;</span><br><span class="line">        ans[x] = val[bel[pos]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) upd(x &lt;&lt; <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">else</span> upd(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos);</span><br><span class="line">    ans[x] = mul(ans[x &lt;&lt; <span class="number">1</span>], ans[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    val[x].m[<span class="number">1</span>][<span class="number">0</span>] += f - w[x];</span><br><span class="line">    w[x] = f;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = top[x];</span><br><span class="line">        node lst = query(<span class="number">1</span>, id[y], id[ed[y]]);</span><br><span class="line">        upd(<span class="number">1</span>, id[x]);</span><br><span class="line">        node now = query(<span class="number">1</span>, id[y], id[ed[y]]);</span><br><span class="line">        x = fa[y];</span><br><span class="line">        val[x].m[<span class="number">0</span>][<span class="number">0</span>] += max(now.m[<span class="number">0</span>][<span class="number">0</span>], now.m[<span class="number">1</span>][<span class="number">0</span>]) - max(lst.m[<span class="number">0</span>][<span class="number">0</span>], lst.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        val[x].m[<span class="number">0</span>][<span class="number">1</span>] = val[x].m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[x].m[<span class="number">1</span>][<span class="number">0</span>] += now.m[<span class="number">0</span>][<span class="number">0</span>] - lst.m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs3(<span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        modify(x, y);</span><br><span class="line">        node res = query(<span class="number">1</span>, id[<span class="number">1</span>], id[ed[<span class="number">1</span>]]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(res.m[<span class="number">0</span>][<span class="number">0</span>], res.m[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRT&amp;EXCRT中国剩余定理与扩展中国剩余定理</title>
      <link href="2019/06/02/CRT&amp;EXCRT%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>2019/06/02/CRT&amp;EXCRT%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这真的超容易忘。。。所以特此记录一篇博客！</p><h2 id="CRT（中国剩余定理）"><a href="#CRT（中国剩余定理）" class="headerlink" title="CRT（中国剩余定理）"></a>CRT（中国剩余定理）</h2><hr><ul><li>前言：必须是模数两两互质的情况哦！</li></ul><p>中国剩余定理，又称孙子定理（古人好厉害哇</p><p>是用来解决下面这种同余方程组的：</p><script type="math/tex; mode=display">\begin{cases}x\equiv a_1(mod\ m_1)\\x\equiv a_2(mod\ m_2)\\\ \vdots\\x\equiv a_k(mod\ m_k)\end{cases}</script><p>可以假设 $n_1 \equiv a_1(mod m_1)$, $n_2 \equiv a_2(mod m_2)$, $\cdots$, $n_k \equiv a_k(mod m_k)$</p><p>设 $M = m_1 <em> m_2 </em> … * m_k$. $M_i = M / m_i$.</p><p>为了使得 $n_1 + n_2 \equiv a_1(mod m_1)$, n2 必须是 m1 的倍数。同理可得：</p><ul><li>n1 是 m2 和 m3 的倍数（是 M1 的倍数</li><li>n2 是 m1 和 m3 的倍数（是 M2 的倍数</li><li>n3 是 m1 和 m2 的倍数（是 M3 的倍数</li></ul><p>这样的话，为 n1 + n2 + n3 的解就满足上述方程啦！</p><p>设 $M_1t_1 \equiv 1(mod m_1)$，则 $a_1M_1t_1 \equiv a_1(mod m_1)$，我们可以用扩欧求出 t1. 所以 $n_1 = a_1M_1t_1$.</p><p>$x = \sum_{i = 1}^k n_i = \sum_{i = 1}^ka_iM_it_i$. 求完啦！就这样~</p><h2 id="EXCRT（扩展中国剩余定理）"><a href="#EXCRT（扩展中国剩余定理）" class="headerlink" title="EXCRT（扩展中国剩余定理）"></a>EXCRT（扩展中国剩余定理）</h2><hr><p>说是扩展，其实这俩玩意儿半分钱关系也木有。。</p><p>两个问题唯一的区别就是：EXCRT 模数不互质</p><p>怎么做捏？假设有 n 个方程。$x \equiv a_1(mod m_1)$，即 $x = m_1 <em> k_1 + a_1$; $x \equiv a_2(mod m_2)$, 即 $x = m_2 </em> k_2 + a_2$.</p><p>联立：$m_2 <em> k_2 - m_1 </em> k_1 = r_1 - r_2$. 其中只有 k1 和 k2 是未知的，我们可以用扩欧判断有无解，求出 k1, 求出 x。</p><p>我们把这个 x 叫做 x0. x 的通解就是 $x_0 + k * lcm(m_1, m_2)$, 即 $x \equiv x_0(mod lcm(m_1, m_2))$</p><p>就这样，我们把前两个方程变为一个方程了。</p><p>用这样的方法做 n - 1 次扩欧，就可以求出最终的 x 了。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exGCD</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exGCD(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exCRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll M = m[<span class="number">1</span>], R = r[<span class="number">1</span>], x, y, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        d = exGCD(m[i], M, y, x);</span><br><span class="line">        <span class="keyword">if</span> ((R - r[i]) % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = (R - r[i]) / d * x % m[i];</span><br><span class="line">        R -= M * x;</span><br><span class="line">        M = M / d * m[i];</span><br><span class="line">        R %= M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (R % M + M) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;m[i], &amp;r[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, exCRT());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 同余方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2011]-观光公交</title>
      <link href="2019/05/18/%5BNOIP2011%5D-%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/"/>
      <url>2019/05/18/%5BNOIP2011%5D-%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1315" target="_blank" rel="noopener">题目链接</a></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><hr><p>就是每次找一条 “如果使用加速器，能影响的人最多” 的边！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, d[N], pre[N], on[N], off[N], arri[N], use[N], ans;</span><br><span class="line"><span class="comment">// use[i] ��ʾ d[i]-- ���ж����������� </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("bus.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("bus.out", "w", stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;a, &amp;b);</span><br><span class="line">        ans -= t;</span><br><span class="line">        on[a] = max(on[a], t);</span><br><span class="line">        off[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            arri[i] = max(arri[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + d[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// if (!d[i - 1]) use[i - 1] = 0;</span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">                use[i - <span class="number">1</span>] = off[i];</span><br><span class="line">                <span class="keyword">if</span> (arri[i] &gt; on[i]) use[i - <span class="number">1</span>] += use[i];</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (use[i] &gt; use[id] &amp;&amp; d[i] &gt; <span class="number">0</span>) id = i;</span><br><span class="line">        d[id]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        arri[i] = max(arri[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += arri[i] * off[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><hr><p>网上只有一个费用流题解 T^T 那位大神也是超级厉害！</p><p>首先由 $S$ 向 $S’$ 连一条流量为 $K$，费用为 $0$ 的边（限制总流量为 $K$）</p><p>把每个点 $i$ 拆为 $i’$ 和 $i’’$。</p><ol><li><p>$(i’, i’’, max(tim[i] - on[i], 0), 0)$，其中 $tim[i]$ 表示不加任何加速器时车到达 $i$ 点的时间，$on[i]$ 表示 $i$ 点最晚上车的时间。一旦加速器使用超过 $tim[i] - on[i]$ 了，多余的部分就会没用，所以就别浪费了</p></li><li><p>$(i’’, (i + 1)’, \infty, -off[i])$，其中 $off[i]$ 表示 $i$ 点下车的人</p></li><li><p>$(S’, i’’, D[i]（这应该也是在限制该边总流量不超过 D[i]）, 0)$</p></li><li><p>$(i’, T, \infty, 0)$</p></li></ol><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">1e4</span> + <span class="number">10</span>, T = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, ans, s, t;</span><br><span class="line"><span class="keyword">int</span> D[N], on[T], off[T], tim[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> t, a, b; &#125;p[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> u, v, c, cost; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dis[N &lt;&lt; <span class="number">1</span>], inq[N &lt;&lt; <span class="number">1</span>], pre[N &lt;&lt; <span class="number">1</span>], fl[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> c, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edges.push_back((edge)&#123;s, t, c, v&#125;);</span><br><span class="line">    edges.push_back((edge)&#123;t, s, <span class="number">0</span>, -v&#125;);</span><br><span class="line">    <span class="keyword">int</span> tot = edges.size();</span><br><span class="line">    G[s].push_back(tot - <span class="number">2</span>);</span><br><span class="line">    G[t].push_back(tot - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    q.push(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>, inq[s] = <span class="number">1</span>, fl[s] = inf, pre[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            edge e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.c &amp;&amp; dis[e.v] &gt; dis[e.u] + e.cost) &#123;</span><br><span class="line">                dis[e.v] = dis[e.u] + e.cost;</span><br><span class="line">                pre[e.v] = G[u][i];</span><br><span class="line">                fl[e.v] = min(fl[e.u], e.c);</span><br><span class="line">                <span class="keyword">if</span> (!inq[e.v]) &#123;</span><br><span class="line">                    inq[e.v] = <span class="number">1</span>; q.push(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[t] == inf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    flow += fl[t];</span><br><span class="line">    cost += fl[t] * dis[t];</span><br><span class="line">    <span class="keyword">int</span> pos = t;</span><br><span class="line">    <span class="keyword">while</span> (pos != s) &#123;</span><br><span class="line">        edges[pre[pos]].c -= fl[t];</span><br><span class="line">        edges[pre[pos] ^ <span class="number">1</span>].c += fl[t];</span><br><span class="line">        pos = edges[pre[pos]].u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mincost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s, t, flow, cost));</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;D[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p[i].t, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">        on[p[i].a] = max(on[p[i].a], p[i].t);</span><br><span class="line">        off[p[i].b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tim[i] = max(tim[i - <span class="number">1</span>], on[i - <span class="number">1</span>]) + D[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans += tim[p[i].b] - p[i].t;</span><br><span class="line"></span><br><span class="line">    s = n * <span class="number">2</span> + <span class="number">1</span>, t = n * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> s1 = n * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    add(s, s1, K, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        add(i, i + n, max(tim[i] - on[i], <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">        add(i + n, i + <span class="number">1</span>, inf, -off[i + <span class="number">1</span>]);</span><br><span class="line">        add(s1, i + n, D[i], <span class="number">0</span>);</span><br><span class="line">        add(i + <span class="number">1</span>, t, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + Mincost());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好鬼畜啊。。。是目前做过最奇技淫巧的网络流。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1030]-文本生成器</title>
      <link href="2019/05/05/%5BBZOJ1030%5D-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2019/05/05/%5BBZOJ1030%5D-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1030" target="_blank" rel="noopener">题目链接</a></p><p>如果要计算可读文本的数量，那就要用到容斥（没尝试过。。应该不好算，或者不能算）</p><p>不如计算不可读文本数量，再用总数减去它！（这叫逆向思维还是啥</p><p>这样就比较美滋滋了，只要不让 AC 自动机上走到单词节点就好了。DP 的话，设 $f[i, j]$ 表示文本长度为 $i$，匹配到自动机上第 $j$ 个节点时的情况数。同时要记得排除一个模式串包含另一个模式串，第一个没走到单词节点，第二个却走到了的情况。代码中也有注释。</p><p>Hint！$f[0, 0]$ 也是一种不可读的情况哦，不能舍。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>, M = <span class="number">110</span>, mod = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sz, ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], f[M][N], fail[N];</span><br><span class="line"><span class="keyword">bool</span> val[N];</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> ch - <span class="string">'A'</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (!trie[u][c]) trie[u][c] = ++sz;</span><br><span class="line">        u = trie[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = trie[r][c];</span><br><span class="line">            <span class="keyword">if</span> (u) &#123;</span><br><span class="line">                fail[u] = trie[fail[r]][c];</span><br><span class="line">                q.push(u);</span><br><span class="line">            &#125; <span class="keyword">else</span> trie[r][c] = trie[fail[r]][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val[fail[r]]) val[r] = <span class="number">1</span>;  <span class="comment">// 这边跟传统的自动机有些不同，是为了不让 “一个模式串包含另一个模式串，一个没走到单词节点但另一个走到了” 的情况出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    getfail();</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz; j++) &#123;  <span class="comment">// j 从 0 号节点开始！</span></span><br><span class="line">            <span class="keyword">if</span> (val[j] || !f[i][j]) <span class="keyword">continue</span>;  <span class="comment">// 只要碰到任意单词节点就不走</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trie[j][k];</span><br><span class="line">                <span class="comment">// 这里 u 即使 == 0 也没有关系！可以理解为文本第 i + 1 个位置与自动机的根结点（0 号节点）匹配</span></span><br><span class="line">                f[i + <span class="number">1</span>][u] = (f[i + <span class="number">1</span>][u] + f[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) ans = ans * <span class="number">26</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz; i++)  <span class="comment">// 不要忘记算上 f[0, 0]</span></span><br><span class="line">        <span class="keyword">if</span> (!val[i]) <span class="comment">// !!!</span></span><br><span class="line">            ans = (ans + mod - f[m][i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1009]-GT考试</title>
      <link href="2019/05/05/%5BBZOJ1009%5D-GT%E8%80%83%E8%AF%95/"/>
      <url>2019/05/05/%5BBZOJ1009%5D-GT%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1009" target="_blank" rel="noopener">题目链接</a></p><p>一直在想组合数学，容斥怎么做。。。看了题解发现是矩阵乘法 + 字符串。。。</p><p>一般矩阵乘法的题都得先找递推式。这题的转移方程是:</p><script type="math/tex; mode=display">f[i, j] = \sum\limits_{k = 0}^{m - 1} f[i - 1, k] * g[k][j]\ (0 \leq j < m)</script><p>（$0 \leq j &lt; m$ 是因为题目要求准考证号不完全出现 A 的方案数）</p><p>其中, $f[i, j]$ 表示准考证号前 $i$ 位中的后 $j$ 位与 $A$ 的前 $j$ 位相同的方案数, $g[k, j]$ 表示准考证号匹配 $A$ 的前 $k$ 位时，准考证号增加一个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$ 的方案数（计算 $g$ 时要从 $0$ 到 $9$ 枚举增加的那个字符是啥）。</p><p>我们发现，$f[i, ]$ 每次都是由 $f[i - 1, ]$ 转移来的，所以对 $g$ 矩阵做快速幂就行，$O(m^3 log n)$。</p><p>最后的答案就是 $\sum\limits_{i = 0}^{m - 1}g[0, i]$ 。为啥呢？</p><p>根据矩阵乘法，我们可知：转移 $k$ 次，$g[k, j]$ 就表示一开始准考证号匹配 $A$ 的前 $k$ 位时，准考证号增加 $k$ 个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$（算上新匹配的 $k$ 位）的方案数。</p><p>同理，转移 $n$ 次，$g[i, j]$ 就表示一开始准考证号匹配 $A$ 的前 $i$ 位时，准考证号增加 $n$ 个字符，使 $A$ 沿着失配指针找到的最大匹配位数 $j$（算上新匹配的 $n$ 位）的方案数。</p><p>我们又知道，一开始准考证号匹配 $A$ 的 $0$ 位，所以最后的答案就是 $\sum\limits_{i = 0}^{m - 1}g[0, i]$ 。</p><p>有一定的思维难度，重要的还是转移方程式吧。。额，对于我这个 DP 渣渣来说，DP 题还要切很多。。。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mod;</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">30</span>], b[<span class="number">30</span>][<span class="number">30</span>], a[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[<span class="number">30</span>][<span class="number">30</span>], <span class="keyword">int</span> b[<span class="number">30</span>][<span class="number">30</span>], <span class="keyword">int</span> ans[<span class="number">30</span>][<span class="number">30</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            tmp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">                tmp[i][j] = (tmp[i][j] + a[i][k] * b[k][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            ans[i][j] = tmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = nxt[j];</span><br><span class="line">        nxt[i] = (s[j + <span class="number">1</span>] == s[i] ? ++j : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">while</span> (t &amp;&amp; s[t + <span class="number">1</span>] - <span class="string">'0'</span> != j) t = nxt[t];</span><br><span class="line">            <span class="keyword">if</span> (s[t + <span class="number">1</span>] - <span class="string">'0'</span> == j) ++t;</span><br><span class="line">            <span class="keyword">if</span> (t != m)</span><br><span class="line">                b[i][t] = (b[i][t] + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) a[i][i] = <span class="number">1</span>;  <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (; n ; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(a, b, a);</span><br><span class="line">        mul(b, b, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) res = (res + a[<span class="number">0</span>][i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯函数求法</title>
      <link href="2019/05/04/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E6%B1%82%E6%B3%95/"/>
      <url>2019/05/04/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E6%B1%82%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="O-n-线性求法"><a href="#O-n-线性求法" class="headerlink" title="O(n) 线性求法"></a>O(n) 线性求法</h3><hr><p>不难理解，就是在欧拉线性筛的时候顺便求的。不过有个酷炫的名字，叫“O(n) 递推求解”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N], prime[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobius</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++m] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sqrt-n-单独求解"><a href="#sqrt-n-单独求解" class="headerlink" title="sqrt(n) 单独求解"></a>sqrt(n) 单独求解</h3><hr><p>这个基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">get_mu</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            mu = -mu;</span><br><span class="line">            n /= i;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) mu = -mu;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogn-调和级数复杂度求法"><a href="#O-nlogn-调和级数复杂度求法" class="headerlink" title="O(nlogn) 调和级数复杂度求法"></a>O(nlogn) 调和级数复杂度求法</h3><hr><p>这个有点妙！<br>（目前不知道原理，留坑待填）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) mu[j] -= mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于交互的一些解题姿势</title>
      <link href="2019/05/04/%E5%85%B3%E4%BA%8E%E4%BA%A4%E4%BA%92%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/"/>
      <url>2019/05/04/%E5%85%B3%E4%BA%8E%E4%BA%A4%E4%BA%92%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>· 把交互操作包成函数（如果忘写 fflush(stdout) 就不至于绝望透顶。。）</p><p>· 交互中，scanf 和 printf 是和交互库的 stdout 和 stdin 接上的，所以你并不能看到输出的信息</p><p>· 交互操作中，只有输出后才需要 fflush(stdout)</p><p>· 如果你想看到输出信息，那么用 fprintf(stderr, “blabla\n”) 吧</p><p>· 交互题让人感到 “踏空而行”。如果不想这样，就写一个 interactor.cpp，自己造数据和进行交互！</p><p>打了一场 CodeJam，收获了一个优质的 interactive_runner.py! （在我的电脑中的 Workspace - Programs - Template 文件夹中）</p><p>终端中怎么运行呢？python interactive_runner.py ./interactor — ./main</p><p>⬆️其中，interactive_runner.py 是运行程序，interactive.cpp 是你自己写的交互程序，main.cpp 是你自己写的主程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeJam2019-R1c</title>
      <link href="2019/05/04/CodeJam2019-R1c/"/>
      <url>2019/05/04/CodeJam2019-R1c/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Robot-Programming-Strategy"><a href="#A-Robot-Programming-Strategy" class="headerlink" title="A. Robot Programming Strategy"></a>A. Robot Programming Strategy</h3><hr><p>分类讨论每一位 pos：</p><p>如果 pos 这位，只有一种字符，那么显然有解；</p><p>如果有三种字符，不管答案串当前位为什么，都会被某种字符克制，显然无解；</p><p>如果有两种字符，那么当前只有一种选择，即：打平一种字符，赢过另一种字符。</p><p>dfs！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, len[N], S[<span class="number">505</span>], a[<span class="number">505</span>], L;</span><br><span class="line"><span class="built_in">string</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> pos)</span> </span>&#123; <span class="keyword">return</span> c[i][pos % len[i]]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">500</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 莫忘</span></span><br><span class="line">    L++;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (S[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'R'</span>) cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'S'</span>) cnt[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (calc(i, pos) == <span class="string">'P'</span>) cnt[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">if</span> (cnt[i]) num++;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">            a[pos] = (i + <span class="number">2</span>) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] &amp;&amp; cnt[(i + <span class="number">1</span>) % <span class="number">3</span>]) &#123;</span><br><span class="line">            a[pos] = i;</span><br><span class="line">            <span class="keyword">int</span> k = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'R'</span> &amp;&amp; !k) S[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'S'</span> &amp;&amp; k == <span class="number">1</span>) S[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (calc(j, pos) == <span class="string">'P'</span> &amp;&amp; k == <span class="number">2</span>) S[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dfs(pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        L = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) S[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">            len[i] = c[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, cas);</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i] == <span class="number">0</span> ? <span class="string">'R'</span> : (a[i] == <span class="number">1</span> ? <span class="string">'S'</span> : <span class="string">'P'</span>));</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Power-Arrangers"><a href="#B-Power-Arrangers" class="headerlink" title="B. Power Arrangers"></a>B. Power Arrangers</h3><hr><p>是交互题！</p><p>总共 595 个数字。分三轮。</p><ol><li><p>询问 119 个序列的首位，我们发现 A B C D E 的数量必定有一个是比别人少一的，那么答案序列的首位就是它。</p></li><li><p>询问 23（23 = (119 + 1) / 5 - 1）个序列的次位，bla…bla…bla</p></li><li><p>询问 5（5 = (23 + 1) / 4 - 1）个序列的第三位，bla…bla…bla</p></li><li><p>询问 1 (1 = (5 + 1) / 3 - 1) 个。。。诶？只有一个了？那么直接询问它的第四位，顺便也能得出第五位了！</p></li></ol><p>这边有个易错点：假设询问的第四位是 C，第五位是 D，这个 <em> </em> <em> C D 序列是还存在的，没有被删除的！所以答案序列是 </em> <em> </em> D C! 这个一定要注意</p><p>然后我们算一发… 119 + 23 + 5 + 1 + 1 = 149 ！离 150 次只有一步之遥… 卡的好紧…</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, F;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">700</span>], ans[<span class="number">10</span>], cnt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getn</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    _count ++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>] - <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;F);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        _count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">119</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[(j - <span class="number">1</span>) * <span class="number">5</span> + k] != ans[k]) &#123;</span><br><span class="line">                        ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ff) &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = (j - <span class="number">1</span>) * <span class="number">5</span> + i;</span><br><span class="line">                    a[p] = getn(p);</span><br><span class="line">                    cnt[a[p]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (!cnt[id]) id = j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cnt[id] &gt; cnt[j] &amp;&amp; cnt[j]) id = j;</span><br><span class="line">            <span class="comment">// fprintf(stderr, "%d\n", cnt[id]);</span></span><br><span class="line">            ans[i] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">119</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (i - <span class="number">1</span>) * <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[p + j] != ans[j]) &#123;</span><br><span class="line">                    ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ff == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[<span class="number">5</span>] = getn(p + <span class="number">4</span>);</span><br><span class="line">                ans[<span class="number">4</span>] = getn(p + <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, ans[i] + <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="number">0</span>] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// fprintf(stderr, "%d\n", _count);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Bacterial-Tactics"><a href="#C-Bacterial-Tactics" class="headerlink" title="C. Bacterial Tactics"></a>C. Bacterial Tactics</h3><hr><p>是博弈！</p><p>我们发现 R 和 C 都非常小！可以用 SG 函数 + 记忆化搜索。</p><p>可以把横向或纵向放细菌，形象看成 横着或竖着 pia 刀。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">---------------</span><br><span class="line">图 <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如图 1，我们在中间竖着 pia 了一刀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">|------|      |</span><br><span class="line">|      |      |</span><br><span class="line">|      |      |</span><br><span class="line">---------------</span><br><span class="line">图 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如图 2，我们在左边那块横着 pia 了一刀。我们发现，刀痕有可能会被之前的刀痕半路拦截。所以左边的操作对右边半块毫无影响。</p><p>这样好办了：左右半块分别可视为两个子问题。我们用 SG[x1, y1, x2, y2] 表示左上角为 (x1, y1)，右下角为 (x2, y2) 的矩阵的 SG 函数值。枚举竖着 pia 哪一列，横着 pia 哪一行，加上神奇的 mex 函数，就是一个像模像样的博弈解法。别忘判当前操作合法性！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, SG[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x0 &gt; x2 || y0 &gt; y2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (SG[x0][y0][x2][y2] != <span class="number">-1</span>) <span class="keyword">return</span> SG[x0][y0][x2][y2];  <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">bool</span> c[<span class="number">60</span>];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x0; i &lt;= x2; i++) &#123;</span><br><span class="line">        <span class="comment">// 判合法性</span></span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y0; j &lt;= y2; j++) <span class="keyword">if</span> (s[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        c[dfs(x0, y0, i - <span class="number">1</span>, y2) ^ dfs(i + <span class="number">1</span>, y0, x2, y2)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y0; i &lt;= y2; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = x0; j &lt;= x2; j++) <span class="keyword">if</span> (s[j][i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        c[dfs(x0, y0, x2, i - <span class="number">1</span>) ^ dfs(x0, i + <span class="number">1</span>, x2, y2)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) <span class="keyword">if</span> (!c[i]) &#123;</span><br><span class="line">        SG[x0][y0][x2][y2] = i; <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(SG, <span class="number">-1</span>, <span class="keyword">sizeof</span>(SG));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, n, m);</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (s[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((dfs(<span class="number">1</span>, <span class="number">1</span>, i - <span class="number">1</span>, m) ^ dfs(i + <span class="number">1</span>, <span class="number">1</span>, n, m)) == <span class="number">0</span>) ans += m;  <span class="comment">// 对于对手是必败态，则对于我是必胜态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> ff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (s[j][i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                ff = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">if</span> (!ff) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((dfs(<span class="number">1</span>, <span class="number">1</span>, n, i - <span class="number">1</span>) ^ dfs(<span class="number">1</span>, i + <span class="number">1</span>, n, m)) == <span class="number">0</span>) ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF600E]-Lomsat gelral</title>
      <link href="2019/04/02/%5BCF600E%5D-Lomsat%20gelral/"/>
      <url>2019/04/02/%5BCF600E%5D-Lomsat%20gelral/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">题目链接</a></p><p>大概意思就是让你求每个子树内颜色数最多的颜色总和（有点绕。。</p><p>其实是个模版题！我先用树上启发式合并 (dsu on tree) 过的。</p><p>树上启发式合并其实就是暴力的优化版！大概步骤为：</p><p>处理轻儿子(清除轻儿子信息) -&gt; 处理重儿子(不清除重儿子信息) -&gt; 再加入轻儿子信息，计算父亲信息 -&gt; 如果当前父亲为祖父的轻儿子，清除父亲及其子树信息.</p><p>其实就是将 $size$ 较小的（此处体现为轻儿子）合并到 $size$ 较大的（此处体现为重儿子）上，从而达到降低复杂度的效果。如何分析复杂度呢？一个轻儿子子树里的点至多会被消除 $logN$ 次（因为这点上面最多有 $logN$ 条边），利用轻重链剖分的思想，就能 $O(nlogn)$ 解决问题。（此处假设合并信息是 $O(1)$ 的）</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dsu on tree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mx;</span><br><span class="line"><span class="keyword">int</span> a[N], f[N], sz[N], son[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], lnk[N], tot;</span><br><span class="line">ll sum, ans[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x] = fa;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; sz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]] += val;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == mx) sum += a[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt[a[x]] &gt; mx) sum = a[x], mx = cnt[a[x]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i])</span><br><span class="line">        <span class="keyword">if</span> (to[i] != f[x] &amp;&amp; !vis[to[i]])</span><br><span class="line">            calc(to[i], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != f[x] &amp;&amp; y != son[x]) dfs2(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x]), vis[son[x]] = <span class="number">1</span>;</span><br><span class="line">    calc(x, <span class="number">1</span>);</span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="comment">// = if (son[x] &amp;&amp; son[f[x]] != x)</span></span><br><span class="line">        vis[son[x]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (son[f[x]] != x) calc(x, <span class="number">-1</span>), sum = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一种方法：线段树合并。顾名思义，也是一种合并。这是在每个节点上开一棵线段树，每次将儿子的线段树合并到父亲的线段树里。假设合并操作是 logN 的。线段树合并复杂度取决于重合节点个数，而现实中一般重合较少，可以视为 logN，因此复杂度嘛，，O(nlogn)?</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> * <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, c[N], id;</span><br><span class="line"><span class="keyword">int</span> to[N], nxt[N], lnk[N], tot;</span><br><span class="line"><span class="keyword">int</span> ls[N], rs[N], mx[N], rt[N];</span><br><span class="line">ll sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    x = ++id;</span><br><span class="line">    sum[x] = val, mx[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= mid) insert(ls[x], l, mid, val);</span><br><span class="line">    <span class="keyword">else</span> insert(rs[x], mid + <span class="number">1</span>, r, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = ls[x], r = rs[x];</span><br><span class="line">    mx[x] = mx[l], sum[x] = sum[l];</span><br><span class="line">    <span class="keyword">if</span> (mx[r] == mx[x]) sum[x] += sum[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mx[r] &gt; mx[x]) sum[x] = sum[r], mx[x] = mx[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; mx[x] += mx[y]; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ls[x] = merge(ls[x], ls[y], l, mid);</span><br><span class="line">    rs[x] = merge(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    upd(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    insert(rt[x], <span class="number">1</span>, n, c[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        rt[x] = merge(rt[x], rt[y], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = sum[rt[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这题两种都很好写啊！(x</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
            <tag> 树上启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF1C]-Ancient Berland Circus</title>
      <link href="2019/03/03/%5BCF1C%5D-Ancient%20Berland%20Circus/"/>
      <url>2019/03/03/%5BCF1C%5D-Ancient%20Berland%20Circus/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1/C" target="_blank" rel="noopener">题目链接</a></p><p>平生第一道计算几何 ( *｀ω´) 有点被吓到了，创世纪初的 CF T3 都是这种风格的嘛 ∑(ﾟДﾟ)</p><p>其实题目还挺友好。这个多边形中心到给定的三个点距离相等，设这个距离为 dis、多边形中心为 O，我们以 O 为圆心，以 dis 为半径作圆，这就是俗称的“外接圆”啦。三个点也都在这个外接圆上。</p><p>我们发现，多边形边数越少，其面积越小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1123]-BLO</title>
      <link href="2019/03/03/%5BBZOJ1123%5D-BLO/"/>
      <url>2019/03/03/%5BBZOJ1123%5D-BLO/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1123" target="_blank" rel="noopener">题目链接</a></p><p>根据割点的定义，若节点 $i$ 不是割点，则把与 $i$ 相连的边删除后，只有 $i$ 与其他 $n - 1$ 个点不连通，而其他 $n - 1$ 个点之间还都是连通的，（注意是有序点对！）则此时答案为 $2(n - 1)$.</p><p>否则，去掉 $i$ 后，会分成若干个连通块，我们应求出每个连通块的大小，两两相乘再相加。</p><p>我们可以在 Tarjan 算法执行深度优先遍历的过程中，顺便求出搜索树每棵子树的大小，这样，如果 $y \in Son(x)$, $low[y] \geq dfn[x]$, 关于 $x$ 的边全部断了后 $y$ 及 $y$ 的子树就是一个连通分量，它的大小应该很好求吧？</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> lnk[N], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], size[N], cut[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, tot, num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt;= dfn[x]) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                ans[x] += (ll)size[y] * (n - size[y]);</span><br><span class="line">                sum += size[y];</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">1</span> || flag &gt; <span class="number">1</span>) cut[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cut[x])</span><br><span class="line">        ans[x] += (ll)(n - sum - <span class="number">1</span>) * (sum + <span class="number">1</span>) + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ans[x] = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        add(x, y), add(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图的连通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 541 Div2</title>
      <link href="2019/02/24/Codeforces%20Round%20541%20Div2/"/>
      <url>2019/02/24/Codeforces%20Round%20541%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1131" target="_blank" rel="noopener">题目链接</a></p><p>唉，还是有很大的进步空间啊。做了 A 和 C，B 和 D 都调不出来。。</p><h3 id="A-Sea-Battle"><a href="#A-Sea-Battle" class="headerlink" title="A. Sea Battle"></a>A. Sea Battle</h3><hr><p>签到题。</p><h3 id="B-Draw"><a href="#B-Draw" class="headerlink" title="B. Draw!"></a>B. Draw!</h3><hr><p>是 min(a[i], b[i]) - max(a[i - 1], b[i - 1]) + 1 没错了。。但是要考虑 a[i - 1] = b[i - 1] 的情况！</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll aa, bb; <span class="built_in">cin</span> &gt;&gt; aa &gt;&gt; bb;</span><br><span class="line">        <span class="keyword">if</span> (aa == a &amp;&amp; bb == b) <span class="keyword">continue</span>;</span><br><span class="line">        ans += max(<span class="number">0L</span>L, min(aa, bb) - max(a, b) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) ans--;</span><br><span class="line">        swap(a, aa), swap(b, bb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Birthday"><a href="#C-Birthday" class="headerlink" title="C. Birthday"></a>C. Birthday</h3><hr><p>说实话没想到居然一下就 A 了(<em>ˉ︶ˉ</em>)</p><p>记得以前 CF 上见到过 C 题出这种构造方式的，觉得很新奇🤔</p><p>给 a[] 排序，然后 i 从 1 开始枚举，每次 += 2。i 和 i + 1 一个放在 ans[] 中 i 位置，一个放在 n - i + 1 的位置，具体放哪要看哪种最优（即使最大差值增加得最慢）。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">105</span>], ans[<span class="number">105</span>], maxn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[l] = a[n]; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        ans[l] = a[i], ans[r] = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp = max(x - ans[l - <span class="number">1</span>], y - ans[r + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; maxn) &#123;</span><br><span class="line">            l++, r--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - ans[l - <span class="number">1</span>] &lt; tmp &amp;&amp; x - ans[r + <span class="number">1</span>] &lt; tmp)</span><br><span class="line">            swap(ans[l], ans[r]);</span><br><span class="line">        maxn = max(maxn, max(ans[l] - ans[l - <span class="number">1</span>], ans[r] - ans[r + <span class="number">1</span>]));</span><br><span class="line">        l++, r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Gourmet-choice"><a href="#D-Gourmet-choice" class="headerlink" title="D. Gourmet choice"></a>D. Gourmet choice</h3><hr><p>一开始是想到了拓扑，但没想到缩点来着，后来越敲越乱，弃疗了。。</p><p>没错，正解就是暴力拓扑 + 缩点。缩点其实不可怕，就是并查集啦（此题不用 Tarjan）。aij = ‘=’ 时，将 i 和 j 并一下；aij = ‘&gt;’ 时，建立一条 i 指向 j 的边；’&lt;’ 时，建立 j 指向 i 的边。</p><p>检查有没有自环（即自己大于自己）和环（a1 &gt; a2 &gt; … &gt; ak &gt; a1），如果有，输出 No，否则根据拓扑结果输出答案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> fa[N], deg[N], vis[N], len[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; len[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span> (v == u) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) &#123;  <span class="comment">// 有环</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v] == <span class="number">2</span>) &#123;</span><br><span class="line">            len[u] = max(len[u], len[v] + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            len[u] = max(len[u], len[v] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span> (s[i][j] == <span class="string">'='</span>) fa[getfa(i)] = getfa(j + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i][j] == <span class="string">'&gt;'</span>) g[getfa(i)].push_back(getfa(j + n)), deg[getfa(j + n)]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">'&lt;'</span>) g[getfa(j + n)].push_back(getfa(i)), deg[getfa(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="keyword">if</span> (!deg[i]) dfs(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="keyword">if</span> (vis[i] != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, len[getfa(i)]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, len[getfa(i + n)]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-String-Multiplication"><a href="#E-String-Multiplication" class="headerlink" title="E. String Multiplication"></a>E. String Multiplication</h3><hr><p>首先应该想到 DP：f[i, j] 表示 $p_1 <em> p_2 </em> … * p_i$ 的结果中 j 字母的最长串的长度。</p><p>设 $S_i = p_1 <em> … </em> p_i$，最后一定是 $S_{n - 1} * p_n$。按照 pn 分类讨论，一共有三种情况：</p><p>设 pn 的开头字符是 c0, 结尾字符是 c1，包含开头的连续段的长度是 pre，包含结尾的连续段的长度是 suf。</p><ol><li><p>$c0 \neq c1$，答案可以是三个：(1). 可以是 pn 中最长的连续子段；(2). 如果 $S_{n - 1}$ 中存在 c0，pre + 1；(3). 如果 $S_{n - 1}$ 中存在 c1，suf + 1。</p></li><li><p>c0 = c1, 并且整个串不只有一种字符：如果 $S_{n - 1}$ 中存在 c0，那么答案可以是 pre + suf + 1.</p></li><li><p>如果 pn 只由一种字符构成，那么求 $S_{n - 1}$ 中最长的字符是 c0 连续段的，设为 t，答案就是 $pre * (t + 1) + t$.</p></li></ol><p>注意记录输出方案。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">30</span>], pre[<span class="number">30</span>], suf[N];  <span class="comment">// pre:前缀 suf:后缀</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;  <span class="comment">// p[1] 的最长相同子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= l; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) mx = max(mx, ++cnt);</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">        f[j] = mx, pre[j] = suf[j] = <span class="number">0</span>;  <span class="comment">// 不要忘记置 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) ++pre[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i; i--)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == j + <span class="string">'a'</span>) ++suf[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    solve(f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        solve(f[i]);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">if</span> (pre[j] != l) <span class="comment">// 判断 pi 是否全由 j 组成</span></span><br><span class="line">                    f[i][j] = max(f[i][j], pre[j] + suf[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = max(f[i][j], l * (f[i - <span class="number">1</span>][j] + <span class="number">1</span>) + f[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) ans = max(ans, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="F-Asya-And-Kittens"><a href="#F-Asya-And-Kittens" class="headerlink" title="F. Asya And Kittens"></a>F. Asya And Kittens</h3><hr><p>这道看很多人一开始就去 A 了呀，果然比 E 题简单 🤔 并查集模拟就好啦。</p><p>对于每次的 (x, y), “并” 其实是并 x 所在的块的最右边一个和 y 所在的块的最左边一个，就像真的合并一样。记录某个块的最右端和最左端就可以了。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"><span class="keyword">int</span> n, d[N], pre[N], nxt[N], fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    g[u].push_back(v), g[v].push_back(u);</span><br><span class="line">    d[u]++, d[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (g[x][i] != fa) print(g[x][i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = nxt[i] = fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        x = getfa(x), y = getfa(y);</span><br><span class="line">        add(nxt[x], pre[y]);</span><br><span class="line">        nxt[x] = nxt[y];</span><br><span class="line">        fa[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (d[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        root = i; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要加油！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG4314]-CPU监控</title>
      <link href="2019/02/22/%5Bluogu4314%5D-CPU%E7%9B%91%E6%8E%A7/"/>
      <url>2019/02/22/%5Bluogu4314%5D-CPU%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4314" target="_blank" rel="noopener">题目链接</a></p><p>AC之旅真是坎坷啊。。一上来，咦，这不是模版题嘛，深蓝题是群众误评嘛 qwq</p><p>然后敲完一交，哎哟啧，爆零哇。。。去翻了翻题解，发现这个问题还真是隐蔽。</p><p>题解里是这样说的：</p><p>“按原来的方法会有一点 bug  ，就是很有可能会出现这样的情况：对于某个结点 i ，在它的标记还没有下放的时候，它的父亲又下放了新的标记给它，于是就将原来的标记覆盖了，丢失了原来的那一次修改的值，这样在查询历史最大值的时候就有可能出现错误的答案。</p><p>“如果只记录区间历史最大值显然不能下放，如果单纯更新区间加，区间赋值最大值，可能会出现历史最大值更新不及时的情况。如先赋值很大值，未来得及下放，又赋值很小，导致子区间历史最大值不能更新。又如如果区间加只取最大值，可能会只取最大值，导致实际上忽视了一些使区间加变小的操作。”</p><p>如果次次下放标记，那显然复杂度太高了。</p><p>为了不错过每一次操作产生的贡献，我们对于每一个区间 $x$ 存储它从上一次 pushdown 到现在的最大加法操作和最大赋值操作，这样显然是正确的。</p><p>总之还是很棒的啊，至少比之前的所以模版题好！！！就是要做这样的（虐）题 ( ´▽｀)</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll add, c;</span><br><span class="line">    ll mx, hx;</span><br><span class="line">    ll ha, hc;  <span class="comment">// h = history</span></span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].mx = max(t[x &lt;&lt; <span class="number">1</span>].mx, t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    t[x].hx = max(t[x &lt;&lt; <span class="number">1</span>].hx, t[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].hx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = x &lt;&lt; <span class="number">1</span> | i;  <span class="comment">// s = son</span></span><br><span class="line">        t[s].hx = max(t[s].hx, max(t[s].mx + t[x].ha, t[x].hc));</span><br><span class="line">        <span class="keyword">if</span> (t[s].c != -inf)</span><br><span class="line">            t[s].hc = max(t[s].hc, t[s].c + t[x].ha);</span><br><span class="line">        <span class="keyword">else</span> t[s].ha = max(t[s].ha, t[s].add + t[x].ha);</span><br><span class="line">        <span class="keyword">if</span> (t[x].add) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[s].c != -inf) t[s].c += t[x].add;</span><br><span class="line">            <span class="keyword">else</span> t[s].add += t[x].add;</span><br><span class="line">            t[s].mx += t[x].add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[x].c != -inf) &#123;</span><br><span class="line">            t[s].mx = t[s].c = t[x].c;</span><br><span class="line">            t[s].add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t[s].hc = max(t[s].hc, max(t[s].c, t[x].hc));</span><br><span class="line">        t[s].ha = max(t[s].ha, t[s].add);</span><br><span class="line">    &#125;</span><br><span class="line">    t[x].hc = t[x].c = -inf;</span><br><span class="line">    t[x].add = t[x].ha = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[x].add = t[x].ha = <span class="number">0</span>;</span><br><span class="line">    t[x].c = t[x].hc = -inf;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ll tmp; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;tmp);</span><br><span class="line">        t[x].mx = t[x].hx = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        t[x].mx += val;</span><br><span class="line">        t[x].add += val;</span><br><span class="line">        t[x].ha += val;</span><br><span class="line">        t[x].hx = max(t[x].hx, t[x].mx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l != r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;</span><br><span class="line">        t[x].c = val;</span><br><span class="line">        t[x].mx = val;</span><br><span class="line">        t[x].hc = val;</span><br><span class="line">        t[x].hx = max(t[x].hx, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) change(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx, val);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) change(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx, val);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">queryhis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> t[x].hx;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) sum = queryhis(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) sum = max(sum, queryhis(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">querynow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) psd(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) <span class="keyword">return</span> t[x].mx;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) sum = querynow(x &lt;&lt; <span class="number">1</span>, l, mid, lx, rx);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) sum = max(sum, querynow(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, lx, rx));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, queryhis(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, querynow(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'P'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">            modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">            change(<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 538 Div2</title>
      <link href="2019/02/11/Codeforces%20Round%20538%20Div2/"/>
      <url>2019/02/11/Codeforces%20Round%20538%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1114" target="_blank" rel="noopener">比赛链接</a></p><p>Div2怎么这么难呀，趋于数学化了 🤔️</p><h3 id="A-Got-Any-Grapes"><a href="#A-Got-Any-Grapes" class="headerlink" title="A. Got Any Grapes?"></a>A. Got Any Grapes?</h3><hr><p>签到题，然而第一次提交把紫葡萄和黑葡萄的顺序看错了。。。成功 -50。。。</p><h3 id="B-Yet-Another-Array-Partitioning-Task"><a href="#B-Yet-Another-Array-Partitioning-Task" class="headerlink" title="B. Yet Another Array Partitioning Task"></a>B. Yet Another Array Partitioning Task</h3><hr><p>这题看着有点眼熟，好像 Global Round 1 的 B 题呀 🤔</p><p>一开始想各种贪心，好像都不大可行。其实注意到了 Input 数据范围里有个 $m <em> k \leq n$, 但不知道有啥用。后来才知道，是因为首先你得选前 $m </em> k$ 大的吧！这样，你将前 $m * k$ 大的记录下来，每隔 k 个分一组，既满足了每组数量 &gt;= m, 又是最优解。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N], mark[N], ret[N], cnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, num;</span><br><span class="line">&#125;b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> a.num &gt; b.num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[i].num = a[i], b[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * k; i++) &#123;</span><br><span class="line">        mark[b[i].id] = <span class="number">1</span>; tot += b[i].num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[i]) sum++;</span><br><span class="line">        <span class="keyword">if</span> (sum == m) ret[++cnt] = i, sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ret[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Trailing-Loves-or-L’oeufs"><a href="#C-Trailing-Loves-or-L’oeufs" class="headerlink" title="C. Trailing Loves (or L’oeufs?)"></a>C. Trailing Loves (or L’oeufs?)</h3><hr><p>啊！这是个玄学题！</p><p>首先我们来看看 10 进制：10 进制下求 n! 末尾 0 的个数很容易吧，找出 1 ～ n 中 2 和 5 作为因子的个数 a 和 b，答案就是 min(a, b).</p><p>由此我们可以大胆猜想，b 进制下求 n! 末尾 0 的个数是同样做法。我们把 b 写成 $b = p_1^{a_1} <em> p_2^{a_2} </em> … * p_k^{a_k}$ 的形式.</p><p>众所周知，1 ～ n 中 p 的倍数的个数为 n / p 下取整。这里我们要找出对于每一个 p，它作为因子的个数，即 f(n, p). f(n, p) = n / p + n / (p ^ 2) + n / (p ^ 3). 注意求 f(n, p) 的时候不能先算 (p ^ k), 而应该用不断除的形式，避免精度误差，这一段下面代码中有具体方法。</p><p>f(n, pi) 记入答案时要除以 ai, 这个自己理解一下就可以。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, b, ans;</span><br><span class="line">ll ok[<span class="number">1000010</span>], prime[<span class="number">1000010</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Is</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok[i]) prime[++cnt] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= <span class="number">1000000</span>; j++) ok[i * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll tmpN = x, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmpN) tmpN /= y, res += tmpN;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;b);</span><br><span class="line">    Is();</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    ll tmp = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        ll p = prime[i];</span><br><span class="line">        <span class="keyword">if</span> (p &gt; b) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (b % p) <span class="keyword">continue</span>;</span><br><span class="line">        ll tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, tot++;</span><br><span class="line">        ll now = f(n, p) / tot;</span><br><span class="line">        ans = min(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = min(ans, f(n, tmp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Flood-Fill"><a href="#D-Flood-Fill" class="headerlink" title="D. Flood Fill"></a>D. Flood Fill</h3><hr><p>这个题是区间的问题，肯定不是线性的，这时候应该考虑一下区间DP啦。一想到区间DP就会有想法了！是不是很像烤乐滋打虎  🤔</p><p>设 f[i, j, k] 表示区间[i, j]已经是同一个颜色 p 了，其中如果 k = 0，p = c[i], 否则 p = c[j]. 因为一段区间的改变颜色的操作肯定是为了像滚雪球一样扩大同一颜色的区间嘛，所以颜色不是左端点的就是右端点的。</p><p>转移看代码。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, c[N], f[N][N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[l][r][sta] != <span class="number">-1</span>) <span class="keyword">return</span> f[l][r][sta];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (sta == <span class="number">0</span>) &#123;</span><br><span class="line">        res = min(res, dp(l + <span class="number">1</span>, r, <span class="number">0</span>) + (c[l] != c[l + <span class="number">1</span>]));</span><br><span class="line">        res = min(res, dp(l + <span class="number">1</span>, r, <span class="number">1</span>) + (c[l] != c[r]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = min(res, dp(l, r - <span class="number">1</span>, <span class="number">0</span>) + (c[r] != c[l]));</span><br><span class="line">        res = min(res, dp(l, r - <span class="number">1</span>, <span class="number">1</span>) + (c[r] != c[r - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[l][r][sta] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(dp(<span class="number">1</span>, n, <span class="number">0</span>), dp(<span class="number">1</span>, n, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 1</title>
      <link href="2019/02/08/Codeforces%20Global%20Round%201/"/>
      <url>2019/02/08/Codeforces%20Global%20Round%201/</url>
      
        <content type="html"><![CDATA[<p>做了 A 和 B，也算不错啦</p><p><a href="http://codeforces.com/contest/1110" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Parity"><a href="#A-Parity" class="headerlink" title="A. Parity"></a>A. Parity</h3><hr><p>奇偶性判断，注意 $a_k$ 的情况就好啦。（即 $b^0$ ）.</p><h3 id="B-Tape"><a href="#B-Tape" class="headerlink" title="B. Tape"></a>B. Tape</h3><hr><p>老了，脑子不好使啦… 想了半天，最开始想到的是隔板法，放 k - 1 个板，但是后来发现只要稍加转换就能变为，b[n] - b[1] + 1 - sum, 其中 sum 为最大的 k - 1 个间隔长度之和。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> b[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> tot = b[n] - b[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) c[i] = b[i + <span class="number">1</span>] - b[i] - <span class="number">1</span>;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) tot -= c[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Meaningless-Operations"><a href="#C-Meaningless-Operations" class="headerlink" title="C. Meaningless Operations"></a>C. Meaningless Operations</h3><hr><p>设 a 的最高位是第 x 位，则 $2^x \leq a$, $a_{max} = 2^x - 1$. 设 $b = 2^x - 1\oplus a$, 则 $f(a) = max\{gcd(2^x - 1, 0)\}$ , 即 $2^x - 1$，为最大值。</p><p>若 $a = 2^x - 1$，因为 b &lt; a = $2 ^ x - 1$, 所以 $f(a) = max\{gcd(2^x - 1 - b, b)\}$, 因为 $gcd(x, y) = gcd(x, x + y)$, 所以 $f(a) = max\{gcd(2^x - 1, b)\}$，这时找到 $2^x - 1$ 的最小质因子 t，答案就是 $\frac{2^x - 1}{t}$.</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> q, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxn &lt;= x) maxn &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        maxn--;</span><br><span class="line">        <span class="keyword">if</span> (x == maxn) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= maxn; i++) <span class="keyword">if</span> (maxn % i == <span class="number">0</span>) &#123; flag = maxn / i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Jongmah"><a href="#D-Jongmah" class="headerlink" title="D. Jongmah"></a>D. Jongmah</h3><hr><p>一个挺暴力的题，但官方正解是 DP。</p><p>首先！因为 [x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2] 总能被三组 [x, x + 1, x + 2] 所代替，我们设这时就尽量用 [x, x + 1, x + 2].</p><p>这时可以这样：设 dp[i, t1, t2] 表示前 i 种数字，有 t1 组 [i - 1, i, i + 1], t2 组 [i, i + 1, i + 2], 我们枚举 t3 表示有 t3 组 [i + 1, i + 2, i + 3], 然后转移到 dp[i + 1, t2, t3].</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, x, a[N], dp[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j + k + l &gt; a[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i][k][l] = max(dp[i][k][l], dp[i - <span class="number">1</span>][j][k] + l + (a[i] - j - k - l) / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Magic-Stones"><a href="#E-Magic-Stones" class="headerlink" title="E. Magic Stones"></a>E. Magic Stones</h3><hr><p>可以这样看：设 $d_i = c_{i + 1} - c_i$, $c_i^, = c_{i + 1} + c_{i - 1} - c_{i}$.</p><p>当将 $c_i$ 变为 $c_i^,$ 时：</p><p>· $d_{i - 1} = c_i - c_{i - 1} = c_{i + 1} - c_i = d_i$</p><p>· $d_i = c_{i + 1} - c_i = c_i - c_{i - 1} = d_{i - 1}$</p><p>发现了吗？$d_i$ 与 $d_{i - 1}$ 交换了！</p><p>所以不管序列 c 怎么变，序列 d 总是不变的。所以只要判断两个序列的序列 d 是否相同就可以了。</p><p>注意！需要判断 s[1] 是否等于 t[1]。因为第一个位置是变不了的。</p><p>code :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, x, y) for (int i = x; i &gt;= y; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, c[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">1</span>] != t[<span class="number">1</span>]) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    per(i, n, <span class="number">1</span>) c[i] -= c[i - <span class="number">1</span>];</span><br><span class="line">    per(i, n, <span class="number">1</span>) t[i] -= t[i - <span class="number">1</span>];</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (c[i] != t[i]) &#123; ok = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="built_in">puts</span>(<span class="string">"Yes"</span>); <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ4542]-大数</title>
      <link href="2019/02/07/%5BBZOJ4542%5D-%E5%A4%A7%E6%95%B0/"/>
      <url>2019/02/07/%5BBZOJ4542%5D-%E5%A4%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4542" target="_blank" rel="noopener">题目链接</a></p><p>首先！我们要提到一个模运算的性质：</p><script type="math/tex; mode=display">(a + b)\ mod\ p = (a\ mod\ p + b\ mod\ p)\ mod\ p</script><p>然后就可以开始了。</p><h2 id="P-neq-2-5-的情况："><a href="#P-neq-2-5-的情况：" class="headerlink" title="$P \neq 2, 5$ 的情况："></a>$P \neq 2, 5$ 的情况：</h2><p>要计算一个区间能否整除 P，是不可能的，我们可以这么转化：</p><p>首先，可以 $O(n)$ 预处理出 $S[i … n] % P$, 这要用到上面的性质。</p><p>如果 $S[l … n] - S[r + 1 … n] \equiv 0 (mod P)$, 那么 $S[l … r] \equiv 0 (mod P)$.</p><p>这样，问题就转化成了：求在 [L, R] 这个区间内，有多少个 S[i … n] % P 是相同的，其中 L &lt;= i &lt;= R. 莫队套路，是吧？</p><h2 id="P-2-5-的情况："><a href="#P-2-5-的情况：" class="headerlink" title="$P = 2, 5$ 的情况："></a>$P = 2, 5$ 的情况：</h2><p>特判。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll P, a = <span class="number">0</span>, b[N], c[N], sum, cnt[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, unit;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l / unit == b.l / unit ? a.r &lt; b.r : a.l / unit &lt; b.l / unit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    sum -= cnt[b[x]] * (cnt[b[x]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) cnt[b[x]]++;</span><br><span class="line">    <span class="keyword">else</span> cnt[b[x]]--;</span><br><span class="line">    sum += cnt[b[x]] * (cnt[b[x]] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>];</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>];  <span class="comment">// 此处的 cnt[i] 表示 1 ～ i 中有多少个 s[i] 是 P 的倍数</span></span><br><span class="line">        <span class="keyword">if</span> ((s[i] - <span class="string">'0'</span>) % p == <span class="number">0</span>) ans[i] += i, cnt[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[r] - ans[l - <span class="number">1</span>] - (cnt[r] - cnt[l - <span class="number">1</span>]) * (l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;P);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="number">2</span> || P == <span class="number">5</span>) &#123;</span><br><span class="line">        solve(P); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll Fac = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        b[i] = c[i] = a = (a + Fac * (s[i] - <span class="string">'0'</span>)) % P;</span><br><span class="line">        Fac = Fac * <span class="number">10</span> % P;</span><br><span class="line">    &#125;</span><br><span class="line">    b[++n] = c[n] = <span class="number">0</span>;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(c + <span class="number">1</span>, c + n + <span class="number">1</span>) - c - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = lower_bound(c + <span class="number">1</span>, c + tot + <span class="number">1</span>, b[i]) - c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    unit = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        ++q[i].r;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; q[i].r) update(++R, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (R &gt; q[i].r) update(R--, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (L &gt; q[i].l) update(--L, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; q[i].l) update(L++, <span class="number">0</span>);</span><br><span class="line">        ans[q[i].id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ4160]-Exclusive Access 2</title>
      <link href="2019/02/05/%5BBZOJ4160%5D-Exclusive%20Access%202/"/>
      <url>2019/02/05/%5BBZOJ4160%5D-Exclusive%20Access%202/</url>
      
        <content type="html"><![CDATA[<p>题意：给出 $N$ 个点 $M$ 条边的无向图，定向得到有向无环图，使得最长路最短。$N \leq 15$, $M \leq 100$.</p><p>这题真好啊！</p><p>是比赛 $T2$。一开始觉得没想法，然后码了个暴力，结果一个子任务中有一个点T了，一分都没有……</p><p>现在要正经地讲正解了！首先，有向无环图是一个切入点。我们对于第 i 个点，设它的深度为 $di$. 因为“无环”，所以对于每一条边 $&lt; v1, v2 &gt;$, $d1$ 永远小于 $d2$。</p><p>假设，这样的图存在环，那么 $d1 &lt; d2 &lt; d3 &lt; … &lt; dk &lt; d1$, 这不成立，所以该图不存在环。</p><p>在这样的图中，最长链为 $dmax - dmin$. Hint！要输出 $ans - 1$ 哦。</p><p>为了使 $dmax - dmin$ 最小，我们要使图的深度最小。怎么办呢？二进制DP。</p><p>我们设 $f(node)$ 为选择了一些点时的最小深度，其中 $node$ 为 $N$ 位二进制数表示每个点是否取。设 $leaves$ 为该图的叶子结点，那么，$f(node) = min{f(node - leaves) + 1}$.</p><p>叶子结点彼此之间是不连边的，所以可以预处理出 $ok(node)$ 表示当 $node$ 这些点能否为 $leaves$。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, mp[<span class="number">30</span>], cnt, G[<span class="number">30</span>][<span class="number">30</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">15</span>], ok[<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>], s2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">if</span> (mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>] == <span class="number">-1</span>) mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>] = cnt++;</span><br><span class="line">        <span class="keyword">if</span> (mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>] == <span class="number">-1</span>) mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>] = cnt++;</span><br><span class="line">        G[mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>]][mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>]] = G[mp[s2[<span class="number">0</span>] - <span class="string">'A'</span>]][mp[s1[<span class="number">0</span>] - <span class="string">'A'</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++) &#123;</span><br><span class="line">        ok[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cnt; k++)</span><br><span class="line">                <span class="keyword">if</span> (j != k &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; j)) &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; k)) &amp;&amp; G[j][k]) &#123;</span><br><span class="line">                    ok[i] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = i; t; t = (t - <span class="number">1</span>) &amp; i)</span><br><span class="line">            <span class="keyword">if</span> (ok[t])</span><br><span class="line">                f[i] = min(f[i], f[i - t] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算(bits)</title>
      <link href="2019/01/31/%E4%BD%8D%E8%BF%90%E7%AE%97(bits)/"/>
      <url>2019/01/31/%E4%BD%8D%E8%BF%90%E7%AE%97(bits)/</url>
      
        <content type="html"><![CDATA[<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>定义 G(x) 为 x 的二进制表示中 1 的个数。</p><p>小C有一个奇妙的方程</p><script type="math/tex; mode=display">x_1\ opt_1\ x_2\ opt_2\ x_3\ ...\ x_{n - 1}\ opt_{n - 1}\ x_n\ =\ c</script><p>其中 $opt_i$ 为 AND, OR, XOR 三种位运算中的一种。我们定义优先级是相同的，即计算顺序为从左到右。</p><p>此外，对于 $x_i$, 须满足 $0 \leq x_i &lt; 2^m$ 且 $G(x_i) = a_i$, 保证 $0 \leq c &lt; 2^m$.</p><p>求一组 $x_i$ 的取值满足上述所有约束。若不存在，输出 OvO。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>A掉了这道巨题，窝很开心啊( ´▽｀)</p><p>这道题嘛，首先要熟悉三种位运算的性质啦。</p><p>虽然要给出一组 x 的解，但只要知道了 $G(x_i)$, 就能造出 $x_i$. 所以我们先搞出 $G(x_i)$! 选择DP啦～</p><p>设 $f[i, j]$ 表示前 i 个 x 位运算后的结果中的为 1 的二进制位为 j 个。为了方便计算答案，设 $g[i, j]$ 存储前 i 个 x 位运算后的结果中的为 1 的二进制位为 j 个时，设前 i - 1 位个 x 位运算后的结果为 t，G(t) = p ，和 t 与 a[i] 共同有 q 位是同为 1 的。我们可以用 pair 型的来存 (p, q).</p><p>转移的时候枚举 $x_i$ 和 $x_{i + 1}$ 共有 k 位同为 1 的，那么分开来讨论就好啦，即从 $f[i, j]$ 转移到 $f[i + 1, ?]$.</p><p>统计答案。可以通过结果和第一个加数将第二个加数二进制位上的 1 补齐，即根据结果分三种情况讨论。</p><p>挺好的一道题呀，不适合普及组的难度qwq</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c, c_num;</span><br><span class="line"><span class="keyword">int</span> a[N], ans[N], f[N][<span class="number">60</span>], tmp[N];</span><br><span class="line">pii g[N][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;c);</span><br><span class="line">    c_num = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'X'</span>) tmp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'A'</span>) tmp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'O'</span>) tmp[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c_num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_num &amp; <span class="number">1</span>) cnt++; c_num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j, a[i + <span class="number">1</span>]); k++) &#123;  <span class="comment">// 枚举 j 和 a[i + 1] 共同为 1 的位数（k）</span></span><br><span class="line">                    <span class="keyword">if</span> (j + a[i + <span class="number">1</span>] - k &lt;= m) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tmp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - <span class="number">2</span> * k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - <span class="number">2</span> * k] = make_pair(j, k);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][k] = make_pair(j, k);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - k] = <span class="number">1</span>;</span><br><span class="line">                            g[i + <span class="number">1</span>][j + a[i + <span class="number">1</span>] - k] = make_pair(j, k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!f[n][cnt]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"OvO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = cnt, result = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        pii u = g[i][now];</span><br><span class="line">        <span class="keyword">int</span> numlst = <span class="number">0</span>, numnow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntlst = u.first, cntnow = a[i], both = u.second;</span><br><span class="line">        cntlst -= both, cntnow -= both;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (both) --both, numlst |= (<span class="number">1</span> &lt;&lt; j), numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntlst) --cntlst, numlst |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cntnow) --cntnow, numnow |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = numnow;</span><br><span class="line">        result = numlst;</span><br><span class="line">        now = u.first;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018普及组题解</title>
      <link href="2018/11/26/NOIP2018%E6%99%AE%E5%8F%8A%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
      <url>2018/11/26/NOIP2018%E6%99%AE%E5%8F%8A%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="A-标题统计"><a href="#A-标题统计" class="headerlink" title="A. 标题统计"></a>A. 标题统计</h3><hr><p>用gets<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>], ch;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">        ch = s[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-龙虎斗"><a href="#B-龙虎斗" class="headerlink" title="B. 龙虎斗"></a>B. 龙虎斗</h3><hr><p>全开longlong！！全！！！开！！！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, c[<span class="number">100005</span>], m, p1, s1, s2, l, r;</span><br><span class="line">ll ans, minn = <span class="number">1e9</span>, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; p1 &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    c[p1] += s1;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; m; i++) l += c[i] * (m - i);</span><br><span class="line">    <span class="keyword">for</span> (ll i = m + <span class="number">1</span>; i &lt;= n; i++) r += c[i] * (i - m);</span><br><span class="line">    ll s = <span class="built_in">abs</span>(l - r);</span><br><span class="line">    minn = s, ans = m;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = m + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(s - s2 * (i - m)) &lt; minn) &#123;</span><br><span class="line">                minn = <span class="built_in">abs</span>(s - s2 * (i - m)), ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(s - s2 * (m - i)) &lt;= minn) &#123;</span><br><span class="line">                minn = <span class="built_in">abs</span>(s - s2 * (m - i)), ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-摆渡车"><a href="#C-摆渡车" class="headerlink" title="C. 摆渡车"></a>C. 摆渡车</h3><hr><p>第一次是70分——大概就是DP方程对叻但没有优化那种。</p><p>说实话这个DP真的有点晕啊！下标琢磨了半天，导致T4时间严重不够。【以后拿到题目先全部看一遍喔</p><p>记 f[i] 表示第 i 分钟刚好从一趟回来的最小等待时间，转移也可以表示成 $f[i] = \min_{i - 2m &lt; j \leq i - m}\{f[j] + k\}$, 其中 k 是 j 在路上时等待的时间之和加上 j 回来后的等待时间之和。注意是完全背包！！所以从小往大枚举 i。还有最后答案不是 f[t[n]] 而是 f[t[n] + m - 1]!! </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t[<span class="number">505</span>], f[<span class="number">4000005</span>], T[<span class="number">4000005</span>];</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) sum += (r - i) * T[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; t[i], T[t[i]]++;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t[n] + m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = max(<span class="number">0</span>, i - <span class="number">2</span> * m + <span class="number">1</span>), r = max(<span class="number">0</span>, i - m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt;= f[j] + calc(max(<span class="number">0</span>, j - m + <span class="number">2</span>), max(<span class="number">0</span>, i - m + <span class="number">1</span>))) &#123;</span><br><span class="line">                f[i] = f[j] + calc(max(j - m + <span class="number">2</span>, <span class="number">0</span>), max(<span class="number">0</span>, i - m + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[t[n] + m - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>100分明天补。</p><h3 id="D-对称二叉树"><a href="#D-对称二叉树" class="headerlink" title="D. 对称二叉树"></a>D. 对称二叉树</h3><hr><p>然而，，，暴力就好了！</p><p>为什么呢？</p><p>每一次 chk 操作，当二叉树为完全二叉树时，时间复杂度最大，为树高，即为 $log_2 n$；进行 n 次，时间复杂度为 $n log_2 n$。</p><p>非完全二叉树时就更快了，因为很容易不满足对称要求，就被剪枝剪掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa, l, r, w, num;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> n, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p[x].num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[x].l &gt; <span class="number">0</span>) upd(p[x].l), p[x].num += p[p[x].l].num;</span><br><span class="line">    <span class="keyword">if</span> (p[x].r &gt; <span class="number">0</span>) upd(p[x].r), p[x].num += p[p[x].r].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">0</span> &amp;&amp; v &gt; <span class="number">0</span> &amp;&amp; p[u].w == p[v].w &amp;&amp; chk(p[u].l, p[v].r) &amp;&amp; chk(p[u].r, p[v].l))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[i].l = x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) p[x].fa = i;</span><br><span class="line">        p[i].r = y;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) p[y].fa = i;</span><br><span class="line">    &#125;</span><br><span class="line">    upd(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (chk(p[i].l, p[i].r)) ans = max(ans, p[i].num);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LG1365]-WJMZBMR打osu!</title>
      <link href="2018/11/01/%5Bluogu1365%5D-WJMZBMR%E6%89%93osu%EF%BC%81/"/>
      <url>2018/11/01/%5Bluogu1365%5D-WJMZBMR%E6%89%93osu%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1365" target="_blank" rel="noopener">题目链接</a></p><p>期望DP！</p><p>设 f[i] 表示到了第 i 位的总期望，g[i] 表示到了第 i 位结尾的连续 o 的期望长度，那么：</p><ol><li>当 s[i] = x, 则 f[i] = f[i - 1], g[i] = 0.</li><li>当 s[i] = o, 则 f[i] = f[i - 1] + 2g[i - 1] + 1, g[i] = g[i - 1] + 1(这一步可以根据完全平方公式推出)</li><li>当 s[i] = ?, 则 f[i] = f[i - 1] + g[i - 1] + 0.5, g[i] = (g[i - 1] + 1) / 2.</li></ol><p>我们发现转移时的状态只与上一轮的状态有关，所以可以使用滚动数组节省空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, now;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">2</span>], g[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'x'</span>) f[now ^ <span class="number">1</span>] = f[now], g[now ^ <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'o'</span>) f[now ^ <span class="number">1</span>] = f[now] + <span class="number">2</span> * g[now] + <span class="number">1</span>, g[now ^ <span class="number">1</span>] = g[now] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[now ^ <span class="number">1</span>] = f[now] + g[now] + <span class="number">0.5</span>, g[now ^ <span class="number">1</span>] = g[now] / <span class="number">2</span> + <span class="number">0.5</span>;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, f[now]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率与期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 518 Div2</title>
      <link href="2018/10/28/Codeforces%20Round%20518%20Div2/"/>
      <url>2018/10/28/Codeforces%20Round%20518%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1068" target="_blank" rel="noopener">比赛链接</a></p><p>是vp的</p><h3 id="A-Birthday"><a href="#A-Birthday" class="headerlink" title="A. Birthday"></a>A. Birthday</h3><hr><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k, l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k + l &gt; n || m &gt; n) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tmp;</span><br><span class="line">        <span class="keyword">if</span> ((l + k) % m == <span class="number">0</span>) tmp = (l + k) / m;</span><br><span class="line">        <span class="keyword">else</span> tmp = (l + k) / m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp * m &gt; n) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-LCM"><a href="#B-LCM" class="headerlink" title="B. LCM"></a>B. LCM</h3><hr><p>数学妙题，$\frac{[a, b]}{a}=\frac{b}{gcd(a, b)}$, 所以其实就是求 b 的约数个数。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll vis[N], prime[N], cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">()</span> </span>&#123;  <span class="comment">// 筛质数</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (ll j = i * i; j &lt;= <span class="number">100000</span>; j += i) vis[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 计算约数个数</span></span><br><span class="line">    ll ans, sum;</span><br><span class="line">    ans = <span class="number">0</span>, sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++; n /= prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum *= (ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) sum *= (<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Prime();</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; work(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Colored-Rooks"><a href="#C-Colored-Rooks" class="headerlink" title="C. Colored Rooks"></a>C. Colored Rooks</h3><hr><p>构造题，应该要用尽量简单的方式。比如说这题，可以在 (i, i) 上放第 i 种颜色的车，这样保证每种颜色都占据一格且互不相连。接下来可以在互不相连的基础上添加相连颜色的车，即如果颜色 a 和颜色 b 是一对，那么就在 (a, j) 和 (b, j) 上放一对车。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pos[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pos[i].push_back(make_pair(i, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        pos[x].push_back(make_pair(x, n + i));</span><br><span class="line">        pos[y].push_back(make_pair(y, n + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pos[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)pos[i].size(); j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; pos[i][j].first &lt;&lt; <span class="string">' '</span> &lt;&lt; pos[i][j].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 514 Div2</title>
      <link href="2018/10/21/Codeforces%20Round%20514%20Div2/"/>
      <url>2018/10/21/Codeforces%20Round%20514%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1059" target="_blank" rel="noopener">比赛链接</a></p><p>这场因为第一题题意不懂，就卡在第一题上了，导致爆零。</p><h3 id="A-Cashier"><a href="#A-Cashier" class="headerlink" title="A. Cashier"></a>A. Cashier</h3><hr><p>这题的意思是两个时间段之间能休息多少个a。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], n, L, a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        r[i] += l[i];</span><br><span class="line">        ret += (l[i] - r[i - <span class="number">1</span>]) / a;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += (L - r[n]) / a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Forgery"><a href="#B-Forgery" class="headerlink" title="B. Forgery"></a>B. Forgery</h3><hr><p>B题需要转化一步。我们可以顺思逆想：对于 (i, j)，若它的八个方向都为 #，表示 (i, j) 这个位置有一步染色操作；否则没有。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">7</span>) <span class="keyword">if</span> (s[x + d[i][<span class="number">0</span>]][y + d[i][<span class="number">1</span>]] != <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) a[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (chk(i, j))</span><br><span class="line">                rep(k, <span class="number">0</span>, <span class="number">7</span>) a[i + d[k][<span class="number">0</span>]][j + d[k][<span class="number">1</span>]] = <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        rep(j, <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != s[i][j]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Sequence-Transformation"><a href="#C-Sequence-Transformation" class="headerlink" title="C. Sequence Transformation"></a>C. Sequence Transformation</h3><hr><p>因为两个奇数的gcd肯定是1，我们第一轮要先删掉所有奇数，然后接下来每一轮都删掉2的幂次方，这样使gcd序列变大的速度是最快的，而且增大的幅度也是最大的。</p><p>唯一一个特例就是 = 3的时候，是 1 1 3.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">4</span> &gt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> &gt; n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i * <span class="number">3</span> &gt; n) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, i * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, i, i * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += (i &lt;&lt; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 516 Div2</title>
      <link href="2018/10/15/Codeforces%20Round%20516%20Div2/"/>
      <url>2018/10/15/Codeforces%20Round%20516%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1064" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Make-a-triangle"><a href="#A-Make-a-triangle" class="headerlink" title="A. Make a triangle!"></a>A. Make a triangle!</h3><hr><p>学过三角形就行了～</p><h3 id="B-Equations-of-Mathematical-Magic"><a href="#B-Equations-of-Mathematical-Magic" class="headerlink" title="B. Equations of Mathematical Magic"></a>B. Equations of Mathematical Magic</h3><hr><p>a - (a ^ x) - x = 0 ===&gt; a ^ x = a - x, 即 x 二进制位中的 1 是 a 中的子集。这也可以通过打表发现。所以就是记 cnt 为 a 中二进制位为 1 的个数，答案就是 $2^{cnt}$.</p><h3 id="C-Oh-Those-Palindromes"><a href="#C-Oh-Those-Palindromes" class="headerlink" title="C. Oh Those Palindromes"></a>C. Oh Those Palindromes</h3><hr><p>可以发现，将相同的数字排列在一起，回文字串数目最大。</p><h3 id="D-Labyrinth"><a href="#D-Labyrinth" class="headerlink" title="D. Labyrinth"></a>D. Labyrinth</h3><hr><p>裸的BFS应该过不去，可以用双端队列优化。因为我们希望左右的步数尽量不要减少，我们把左右的走步push_back，上下的走步push_front。对deque又有了深一层的了解！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, r, c, nx, ny;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, nx, ny;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node now = q.front(); q.pop_front();</span><br><span class="line">        <span class="keyword">int</span> x = now.x, y = now.y;</span><br><span class="line">        <span class="keyword">int</span> nx = now.nx, ny = now.ny;</span><br><span class="line">        <span class="keyword">if</span> (vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[x - <span class="number">1</span>][y] != <span class="string">'*'</span>) q.push_front((node)&#123;x - <span class="number">1</span>, y, nx, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; s[x + <span class="number">1</span>][y] != <span class="string">'*'</span>) q.push_front((node)&#123;x + <span class="number">1</span>, y, nx, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[x][y - <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; nx) q.push_back((node)&#123;x, y - <span class="number">1</span>, nx - <span class="number">1</span>, ny&#125;);</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; s[x][y + <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; ny) q.push_back((node)&#123;x, y + <span class="number">1</span>, nx, ny - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c &gt;&gt; nx &gt;&gt; ny;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    q.push_front((node)&#123;r, c, nx, ny&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 513 Div2</title>
      <link href="2018/10/04/Codeforces%20Round%20513%20Div2/"/>
      <url>2018/10/04/Codeforces%20Round%20513%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1060" target="_blank" rel="noopener">比赛链接</a></p><p>这次打了两道，但T2虽然思路没错，但细节处理错误，GG了。。。不过这次题目还是很有趣的！！补了4道！！</p><h3 id="A-Phone-Numbers"><a href="#A-Phone-Numbers" class="headerlink" title="A. Phone Numbers"></a>A. Phone Numbers</h3><hr><p>H2O题。ans = min(n / 11, sum)，其中 sum 是 8 的个数。</p><h3 id="B-Maximum-Sum-of-Digits"><a href="#B-Maximum-Sum-of-Digits" class="headerlink" title="B. Maximum Sum of Digits"></a>B. Maximum Sum of Digits</h3><hr><p>暴力找一下规律，发现如果 n 有 x 位，那么 a 就是 x 位的：(n 最高位数字 - 1) + 9 + 9 + 9 … + 9. 其中有 x - 1 个 9. b = n - a.</p><p>不要忘了判断，如果 n 本身就是 k + 9 + 9 … + 9 形式的，a = k, b = 0. (啊啊啊在这里玩脱了。。。直接输出 n 了。。。应该是 S(n) 啊</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum *= <span class="number">10</span>; x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum / <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>; x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, n); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll bound = get(n);</span><br><span class="line">        ll x = n - (n % bound);</span><br><span class="line">        <span class="keyword">if</span> (n == x + bound - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S(n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll a = n - (n % bound) - <span class="number">1</span>, b = n - a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, S(a) + S(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Maximum-Subrectangle"><a href="#C-Maximum-Subrectangle" class="headerlink" title="C. Maximum Subrectangle"></a>C. Maximum Subrectangle</h3><hr><p>比赛时想到了 $c_{i, j}$ 是个摆设，要拆的，但一直在想怎么枚举 x1, x2, y1, y2, 实际不用这样的。</p><p>首先拆公式：</p><script type="math/tex; mode=display">\sum\limits_{i = x1}^{x2} \sum\limits_{j = y1}^{y2} c_{i, j} = (\sum\limits_{i = x1}^{x2}a_i) * (\sum\limits_{j = y1}^{y2}b_j)</script><p>然后我们可以 $O(n^2)$ 预处理出每一段 a 的区间 [l, r]。记 $\sum\limits_{i = l}^r a_i$ 为 S，则我们开一个 $2000 ^ 2$ 的数组 A，A[S] = max(A[S], r - l + 1). 即以区间和为下标，长度为数值。对于 b 数组一样的操作。</p><p>然后用 two pointers，i 从 $2000 ^ 2$ 开始往小扫，pos只会越来越大。应该是 O(n)。同时统计答案。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], A[N * N], B[N * N];</span><br><span class="line">ll x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            sum += a[j], A[sum] = max(A[sum], j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j++)</span><br><span class="line">            sum += b[j], B[sum] = max(B[sum], j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> MAXSUM = <span class="number">2000</span> * <span class="number">2000</span>, pos = <span class="number">1</span>, ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXSUM; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= MAXSUM &amp;&amp; <span class="number">1l</span>l * i * pos &lt;= x) now = max(now, B[pos++]);</span><br><span class="line">            ans = max(ans, A[i] * now);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Social-Circles"><a href="#D-Social-Circles" class="headerlink" title="D. Social Circles"></a>D. Social Circles</h3><hr><p>这题超好玩！！</p><p>是这样的，每个人的 $l_i$ 必定要和自己或另一个人的 $r_i$ 匹配，贡献是 $max(l_i, r_i)$. 所以我们要最小化 $max(l_i, r_i)$. 这时候就不要将第 i 个人的 l 和 r 绑定了。</p><p>分别排序 l 和 r。答案就是 $\sum_{i = 1}^n max(l_i, r_i)$.</p><p>我们可以这样考虑：若 $l_n$ 是 l 数组和 r 数组中的最大值，它的匹配值必然是尽量大的、接近它的，即 $r_n$。剩下的 $2 * (n - 1)$ 个元素又是这样一个子问题，用数学归纳法即可证明。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, l[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">    sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>);</span><br><span class="line">    sort(r + <span class="number">1</span>, r + n + <span class="number">1</span>);</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += max(l[i], r[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Sergey-and-Subway"><a href="#E-Sergey-and-Subway" class="headerlink" title="E. Sergey and Subway"></a>E. Sergey and Subway</h3><hr><p>这题的意思很好理解。是一道树形DP，还没有涉及过的。</p><p>首先来考虑一个基础问题：给定一棵树，求其中每对节点的距离只和，即 $\sum\limits_{i = 1}^n \sum\limits_{j = 1}^n dist(i, j)$.</p><p>我们先定义一些量：sum[x] 表示 x 子树中的点到 x 的距离之和，cnt[x] 表示 x 子树中的点的数量，ans即答案，v即 x 的儿子节点。</p><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(进入 x 子树)</span><br><span class="line"><span class="number">1.</span> sum[x] = <span class="number">0</span>, cnt[x] = <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> dfs(v)</span><br><span class="line"><span class="number">3.</span> sum[v] += cnt[v]  <span class="comment">// v 到 x 之间有一步之差，先统计到 sum[v] 上去</span></span><br><span class="line"><span class="number">4.</span> ans += sum[x] * cnt[v] + sum[v] * cnt[x]  <span class="comment">// sum[x] 此时是 x 一部分儿子的距离之和。这一步可以视为两个集合合并的过程</span></span><br><span class="line"><span class="number">5.</span> sum[x] += sum[v], cnt[x] += cnt[v]</span><br></pre></td></tr></table></figure><p>那么 E 题是一道进阶版的。对于点 (u, v), 现在的 dist(u, v) (表示为 Now)等于基础问题中 dist(u, v) (表示为 Bef)除以二上取整。有的 Bef = 2Now，有的 Bef = 2Now - 1.</p><p>不可能整体除以二上取整，但正因为是除以二，数据少，可以手动处理。我们新建一些量：sum[x, 0] 表示 x 子树中到 x 的距离为偶数的点到 x 的距离，sum[x, 1] 对应的就是奇数；cnt[x, 0] 表示 x 子树中到 x 的距离为偶数的点数，cnt[x, 1] 对应的就是奇数；ans[0] 表示距离为偶数的点对的距离之和，ans[1] 对应的就是奇数。</p><p>由于答案 = (ans[0] / 2) + (ans[1] + 距离为奇数的点对数量) / 2，我们再开一个数组 C[], C[1] 表示距离为奇数的点对数量，方便最后计算。</p><p>五步分别对应：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> sum[x][<span class="number">0</span>] = sum[x][<span class="number">1</span>] = cnt[x][<span class="number">1</span>] = <span class="number">0</span>, cnt[x][<span class="number">0</span>] = <span class="number">1.</span></span><br><span class="line"><span class="number">2.</span> dfs(v)</span><br><span class="line"><span class="number">3.</span> sum[v][<span class="number">0</span>] += cnt[v][<span class="number">0</span>], sum[v][<span class="number">1</span>] += cnt[v][<span class="number">1</span>].</span><br><span class="line">   swap(sum[v][<span class="number">0</span>], sum[v][<span class="number">1</span>]), swap(cnt[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>])  <span class="comment">// 因为增加了 v 到 x 的一步之差，路径奇偶改变</span></span><br><span class="line"><span class="number">4.</span> ans[(j + k) &amp; <span class="number">1</span>] += sum[x][j] * cnt[v][k] + sum[x][k] * cnt[v][j]</span><br><span class="line">   C[(j + k) &amp; <span class="number">1</span>] += cnt[x][j] * cnt[v][k]</span><br><span class="line"><span class="number">5.</span> sum[x][j] += sum[v][j], cnt[x][j] += cnt[v][j].</span><br></pre></td></tr></table></figure></p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, lnk[N], tot;</span><br><span class="line">ll sum[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>], ans[<span class="number">2</span>], C[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++tot].to = v, e[tot].nxt = lnk[u], lnk[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    cnt[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = e[i].nxt) <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        dfs(v, x);</span><br><span class="line">        sum[v][<span class="number">0</span>] += cnt[v][<span class="number">0</span>], sum[v][<span class="number">1</span>] += cnt[v][<span class="number">1</span>];</span><br><span class="line">        swap(sum[v][<span class="number">0</span>], sum[v][<span class="number">1</span>]);</span><br><span class="line">        swap(cnt[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                ans[(j + k) &amp; <span class="number">1</span>] += sum[x][j] * cnt[v][k] + cnt[x][j] * sum[v][k];</span><br><span class="line">                C[(j + k) &amp; <span class="number">1</span>] += cnt[x][j] * cnt[v][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) sum[x][j] += sum[v][j], cnt[x][j] += cnt[v][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans[<span class="number">1</span>] + C[<span class="number">1</span>]) / <span class="number">2</span> + ans[<span class="number">0</span>] / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 512 Div2</title>
      <link href="2018/10/01/Codeforces%20Round%20512%20Div2/"/>
      <url>2018/10/01/Codeforces%20Round%20512%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1058" target="_blank" rel="noopener">比赛链接</a></p><p>题目比较简单，做了四道喔哈哈哈～</p><h3 id="A-In-Search-of-an-Easy-Problem"><a href="#A-In-Search-of-an-Easy-Problem" class="headerlink" title="A. In Search of an Easy Problem"></a>A. In Search of an Easy Problem</h3><hr><p>$H_2O$ 签到题</p><h3 id="B-Vasya-and-Cornfield"><a href="#B-Vasya-and-Cornfield" class="headerlink" title="B. Vasya and Cornfield"></a>B. Vasya and Cornfield</h3><hr><p>不知道有没有优美的方法～不过我的比较容易想到，就是把 {(0, d), (d, 0), (n, n - d), (n - d, n)} 区域染色，然后 O(1) 回答询问～</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d, m, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;d, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> dx, dy;</span><br><span class="line">    dx = dy = <span class="number">1</span>;</span><br><span class="line">    x = <span class="number">-1</span>, y = d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        x++, y--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - d; j++) mark[x + j][y + j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x != d &amp;&amp; y != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - d; j++) mark[x + j + <span class="number">1</span>][y + j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (mark[x][y]) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Vasya-and-Golden-Ticket"><a href="#C-Vasya-and-Golden-Ticket" class="headerlink" title="C. Vasya and Golden Ticket"></a>C. Vasya and Golden Ticket</h3><hr><p>因为数据很小，$\sum_{i = 1}^n a_i$ 最多是 900，所以可以从 0 到 tot 枚举单块的数值和，chk函数判断。虽然不能用二分，但暴力枚举也可以过！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">110</span>], tot;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (sum == limit) sum -= limit, ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; limit) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        tot += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; tot % i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(i)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Vasya-and-Triangle"><a href="#D-Vasya-and-Triangle" class="headerlink" title="D. Vasya and Triangle"></a>D. Vasya and Triangle</h3><hr><p>因为存在多个答案，是构造题，所以挑最容易构的直角三角形就可以过。</p><p>首先—三角形向量面积公司—叉积公式了解一下：$S = \frac{1}{2} |x_1y_2 - x_2y_1|$, 其中 $(x_1, y_1)$ $(x_2, y_2)$ 分别是三角形两边所表示向量的坐标。</p><p>首先，根据叉积公式算出来的 2S 一定是整数，那么 $\frac{nm}{k}$ 一定是 0.5 的倍数，即 $\frac{2nm}{k}$ 应该是整数，反之若 $2 <em> n </em> m mod k \neq 0$, 无解.</p><p>接下来是有解的情况。</p><p>构造直角三角形，相当于构造一个 (0, 0) (X, 0) (Y, 0) 形式的直角三角形，那么 XY = 2S = 2nm / k = nm / (k / 2). 令 d = gcd(n, k), x1 = n / d, y1 = 0, x2 = 0, y2  = m / (k / d), x3 = y3 = 0.</p><p>但是因为 k % 2 不一定 = 0, 所以如果 k % 2 = 0, k /= 2; 否则，如果 x1 &lt;= n / 2, x1 = 2x1, 否则 y2 = 2y2.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> !b ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * n * m % k != <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) k /= <span class="number">2</span>, flag = <span class="literal">true</span>;</span><br><span class="line">    ll d = gcd(n, k), x, y, x2, y2, x3, y3;</span><br><span class="line">    x = n / d, y = <span class="number">0</span>, x2 = <span class="number">0</span>, y2 = m / (k / d), x3 = y3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= n / <span class="number">2</span>) x *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> y2 *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n%lld %lld\n%lld %lld\n"</span>, x, y, x2, y2, x3, y3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 511 Div2</title>
      <link href="2018/09/24/Codeforces%20Round%20511%20Div2/"/>
      <url>2018/09/24/Codeforces%20Round%20511%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1047" target="_blank" rel="noopener">比赛链接</a></p><p>emmmm，这次做了两道，但由于手速脑速不够以及 WA 了几发，成功凉凉，，，，</p><p>感觉很活！！要多打！！</p><h3 id="A-Little-C-Loves-3-I"><a href="#A-Little-C-Loves-3-I" class="headerlink" title="A. Little C Loves 3 I"></a>A. Little C Loves 3 I</h3><hr><p>啊，有个很清楚的做法：a = b = c = n / 3（下取整），如果 b % 3 == 0 或 c % 3 == 0, a++, b/c —.</p><p>这样就先保证了 b 和 c 不是 3 的倍数，然后再处理 a，判断 b 和 c % 3 = 1 还是 2 就行了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = a[<span class="number">2</span>] = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = n - (n / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">0</span>] += sum;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span>) a[<span class="number">1</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">0</span>) a[<span class="number">2</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">1</span>) a[<span class="number">1</span>]++, a[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">1</span>) a[<span class="number">2</span>]++, a[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] % <span class="number">3</span> == <span class="number">2</span>) a[<span class="number">1</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">2</span>] % <span class="number">3</span> == <span class="number">2</span>) a[<span class="number">2</span>]--, a[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Cover-Points"><a href="#B-Cover-Points" class="headerlink" title="B. Cover Points"></a>B. Cover Points</h3><hr><p>可以发现，答案就是 $max_{1 \leq i \leq n}\{x_i + y_i\}$.</p><h3 id="C-Enlarge-GCD"><a href="#C-Enlarge-GCD" class="headerlink" title="C. Enlarge GCD"></a>C. Enlarge GCD</h3><hr><p>要看清题目要求，只要比整体gcd大就行了。</p><p>设整体gcd为 G。对于每个 &gt; G 的质数 x，记 cnt 为 ai 中 % x = 0 的数的个数，ans 对 n - cnt 取 min。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], G, x;</span><br><span class="line"><span class="keyword">bool</span> pri[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        <span class="keyword">if</span> (!G) G = x;</span><br><span class="line">        <span class="keyword">else</span> G = gcd(G, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G + <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pri[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">                pri[j] = <span class="number">1</span>, cnt += a[j];</span><br><span class="line">            ans = min(ans, n - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; n) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Little-C-Loves-3-II"><a href="#D-Little-C-Loves-3-II" class="headerlink" title="D. Little C Loves 3 II"></a>D. Little C Loves 3 II</h3><hr><p>首先，$1 <em> 6$, $2 </em> 4$, $2 <em> 5$, $3 </em> 4$ 都是能被构造出来的。</p><p>如果 n = 1， 那么答案就是 $6 <em> \lfloor \frac{m}{6} \rfloor + 2 </em> max((m mod 6) - 3, 0)$.</p><p>如果 n = 2，只有 $2 <em> 2$，$2 </em> 3$ 和 $2 <em> 7$ 不能被构造，其他的都可以用 $1 </em> 6$，$2 <em> 4$ 和 $2 </em> 5$ 构造出来。</p><p>否则，$4 <em> x$ 可以用 $2 </em> 4$ 和 $3 <em> 4$ 构造，$6 </em> x$ 可以用 $1 <em> 6$ 构造。$x </em> y$ 可以用 $4 <em> x$ 和 $6 </em> y$ 构造，其中 y 是偶数且 x、y &gt; 2.</p><p>也就是说，如果 $n <em> m mod 2 = 0$, 那么答案就是 $n </em> m$. 否则，我们可以用一些 $x <em> y$ 的矩阵（其中 x 或 y 是偶数）将 $n </em> m$ 的矩阵变为如下三个之一： $3 <em> 3$, $3 </em> 5$, $5 <em> 5$。而这三个都是有一个空的。即答案为 $n </em> m - 1$.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (m / <span class="number">6</span> * <span class="number">3</span> + max(m % <span class="number">6</span> - <span class="number">3</span>, <span class="number">0</span>)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m == <span class="number">2</span> ? <span class="number">0</span> : m == <span class="number">3</span> ? <span class="number">4</span> : m == <span class="number">7</span> ? <span class="number">12</span> : m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * n * m / <span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 102</title>
      <link href="2018/09/09/Atcoder%20Regular%20Contest%20102/"/>
      <url>2018/09/09/Atcoder%20Regular%20Contest%20102/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc102.contest.atcoder.jp/assignments" target="_blank" rel="noopener">比赛链接</a></p><h3 id="C-Triangular-Relationship"><a href="#C-Triangular-Relationship" class="headerlink" title="C. Triangular Relationship"></a>C. Triangular Relationship</h3><hr><p>因为只是两个数相加，所以可以分成两种情况：</p><ol><li>a 和 b 都是 k 的倍数。即，!(a % k) &amp;&amp; !(b % k).</li><li>a 和 b 之和是 k 的倍数。即，(a + b) % k = 0, </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 502 Div2</title>
      <link href="2018/08/29/Codeforces%20Round%20502%20Div2/"/>
      <url>2018/08/29/Codeforces%20Round%20502%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1017" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-The-Rank"><a href="#A-The-Rank" class="headerlink" title="A. The Rank"></a>A. The Rank</h3><hr><p>水题，struct 排序。</p><h3 id="B-The-Bits"><a href="#B-The-Bits" class="headerlink" title="B. The Bits"></a>B. The Bits</h3><hr><p>题意：给两个01字符串 a、b，只能交换第一个字符串中的两个字母，问有多少种交换方案使得交换后 a | b 不同于交换前的 a | b.</p><p>只需要考虑运算或的性质就好了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a1, a0;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100005</span>], b[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'1'</span>) a1++;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'1'</span>) a0++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">'1'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ans += a0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">'0'</span> &amp;&amp; b[i] == <span class="string">'0'</span>) ans += a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-The-Phone-Number"><a href="#C-The-Phone-Number" class="headerlink" title="C. The Phone Number"></a>C. The Phone Number</h3><hr><p>题意：给定 n，要求构造一个长度为 n 的序列使得这个序列的 LIS + LDS 长度最小。</p><p>分块思想，分成 k 块时答案为 n / k + k, 因此 k 取 sqrt(n) 最优。</p><p>也就是说图大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">1</span></span><br><span class="line">              <span class="number">1</span></span><br><span class="line">                <span class="number">1</span></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">          <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> S = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">int</span> ps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ps &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = min(ps + S - <span class="number">1</span>, n); j &gt;= ps; --j) a[++a[<span class="number">0</span>]] = j;</span><br><span class="line">        ps += S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]); <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 101</title>
      <link href="2018/08/26/Atcoder%20Regular%20Contest%20101/"/>
      <url>2018/08/26/Atcoder%20Regular%20Contest%20101/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc101.contest.atcoder.jp/assignments" target="_blank" rel="noopener">比赛链接</a></p><h3 id="C-Candles"><a href="#C-Candles" class="headerlink" title="C. Candles"></a>C. Candles</h3><hr><p>分三种情况讨论：</p><ol><li><p>选的位置全部 &gt;= 0。</p></li><li><p>选的位置全部 &lt;= 0。</p></li><li><p>选的位置包含 &lt; 0 的和 &gt; 0 的。</p></li></ol><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, a[<span class="number">100005</span>], flag;</span><br><span class="line">ll sum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] &lt; <span class="number">0</span>) flag = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) flag = n + <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag + k - <span class="number">1</span> &lt;= n) ans = min(ans, a[flag + k - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (flag - k &gt; <span class="number">0</span>) ans = min(ans, -a[flag - k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; flag; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; flag || j &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, min(-a[i] - a[i] + a[j], a[j] * <span class="number">2</span> - a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Median-of-Medians"><a href="#D-Median-of-Medians" class="headerlink" title="D. Median of Medians"></a>D. Median of Medians</h3><hr><p>我感觉我用了一个小时的思考证明了这题不是中位数。。。。（好像中位数最低复杂度也要 $n^2$ 呢）只能在不求解 m 的情况下求出中位数了。</p><p>观摩了大神的解题思路觉得很妙！转化非常自然，但是也很难想到。。。</p><p>首先二分最后答案 x（这一步想到了！｡ì _ í｡）</p><h3 id="问题转化为：有多少个区间的中位数小于等于-x"><a href="#问题转化为：有多少个区间的中位数小于等于-x" class="headerlink" title="问题转化为：有多少个区间的中位数小于等于 x"></a><strong>问题转化为：有多少个区间的中位数小于等于 x</strong></h3><p>将区间中所有 &lt;= x 的赋为 1，&gt; x 的赋为 -1. </p><h3 id="问题转化为：有多少个区间至少有（区间长度-2-1）个-1"><a href="#问题转化为：有多少个区间至少有（区间长度-2-1）个-1" class="headerlink" title="问题转化为：有多少个区间至少有（区间长度/2 + 1）个 1"></a><strong>问题转化为：有多少个区间至少有（区间长度/2 + 1）个 1</strong></h3><h3 id="等价于：有多少个区间的和是正数"><a href="#等价于：有多少个区间的和是正数" class="headerlink" title="等价于：有多少个区间的和是正数"></a><strong>等价于：有多少个区间的和是正数</strong></h3><p>即，对于 1/-1 序列求前缀和 sum[], 若 sum[r] - sum[l - 1] &gt; 0，则这就是一个符合要求的区间。</p><p>那么对于所有的 sum[x] &gt; sum[y], 如果再满足 x &gt; y, 则 [y + 1, x] 就是一个合法区间。我们可以用树状数组求顺序对的方法解决此题。</p><p>若二分判定函数 chk(x) 的返回值为 true，仅当区间和为正数的区间数量 &gt; n <em> (n + 1) / 4. 因为区间总数共有 n </em> (n + 1) / 2 个，（位置 0 也算进去），这些区间中位数组成的序列的中位数就要再除以 2.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], sum[N * <span class="number">10</span>], C[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= <span class="number">2</span> * N; x += lowbit(x)) C[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ret += C[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N; i++) C[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + (a[i] &lt;= x ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tot += query(sum[i] + N - <span class="number">1</span>);</span><br><span class="line">        add(sum[i] + N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot &gt; <span class="number">1l</span>l * n * (n + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> l = inf, r = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        l = min(l, a[i]), r = max(r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (chk(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Ribbons-on-Tree"><a href="#E-Ribbons-on-Tree" class="headerlink" title="E. Ribbons on Tree"></a>E. Ribbons on Tree</h3><hr><p>这题还是很想弄懂。。。然而目前官方题解日文版看不懂，网上题解找不到。。。打算留坑待填了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 504 Div2</title>
      <link href="2018/08/23/Codeforces%20Round%20504%20Div2/"/>
      <url>2018/08/23/Codeforces%20Round%20504%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1023" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-Single-Wildcard-Pattern-Matching"><a href="#A-Single-Wildcard-Pattern-Matching" class="headerlink" title="A. Single Wildcard Pattern Matching"></a>A. Single Wildcard Pattern Matching</h3><hr><p>啊啊啊，这题被 hack 了很痛苦，重申题意后发现星号部分只能用小写英文字母代替。重新写了代码又交，交了两发，过不去就弃疗了。现在看来，是没有判断非星号部分是否完全相同的原因。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (s1[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        flag = i; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">-1</span> &amp;&amp; s1 == s2) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">-1</span> || m &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, j = m - <span class="number">1</span>; i &gt; flag; i--, j--) <span class="keyword">if</span> (s1[i] != s2[j]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="keyword">if</span> (s2[i] &lt; <span class="string">'a'</span> || s2[i] &gt; <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Pair-of-Toys"><a href="#B-Pair-of-Toys" class="headerlink" title="B. Pair of Toys"></a>B. Pair of Toys</h3><hr><p>首先数据非常大，必须 O(1). 若所有方案都小于 n，那么答案就是 (k - 1) / 2.</p><p>否则在此基础上再减去 min(k - n - 1, (k - 1) / 2)。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    ll tmp = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) tmp -= min(k - n - <span class="number">1</span>, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Bracket-Subsequence"><a href="#C-Bracket-Subsequence" class="headerlink" title="C.Bracket Subsequence"></a>C.Bracket Subsequence</h3><hr><p>真是道假题。。。直接删去头 k / 2 个左括号和头 k / 2 个右括号就行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash题目选讲</title>
      <link href="2018/08/20/Hash%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"/>
      <url>2018/08/20/Hash%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="POJ3349-Snowflake-Snow-Snowflakes"><a href="#POJ3349-Snowflake-Snow-Snowflakes" class="headerlink" title="[POJ3349]-Snowflake Snow Snowflakes"></a>[POJ3349]-Snowflake Snow Snowflakes</h3><hr><p>题意：给你 n 个雪花，求解其中是否存在 2 个雪花从任意位置顺时针或逆时针形状是相同的。</p><p>定义 Hash 函数 $H(a_{i, 1}, a_{i, 2}, … a_{i, 6}) = (\sum_{j = 1}^6a_{i, j} + \prod_{j = 1}^6a_{i, j} mod P$, 其中 P 是一个大质数。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">99991</span>;</span><br><span class="line"><span class="keyword">int</span> n, tot, snow[N][<span class="number">10</span>], head[N], next[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        sum = (sum + a[i]) % P;</span><br><span class="line">        mul = (ll)mul * a[i] % P;</span><br><span class="line">    &#125; <span class="keyword">return</span> (sum + mul) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> eq = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (a[(i + k) % <span class="number">6</span>] != b[(j + k) % <span class="number">6</span>]) eq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (eq) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            eq = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (a[(i + k) % <span class="number">6</span>] != b[(j - k + <span class="number">6</span>) % <span class="number">6</span>]) eq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (eq) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = Hash(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[val]; i; i = next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equal(snow[i], a)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) snow[tot][i] = a[i];</span><br><span class="line">    next[tot] = head[val];</span><br><span class="line">    head[val] = tot;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[j]);</span><br><span class="line">        <span class="keyword">if</span> (insert(a)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Twin snowflakes found."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No two snowflakes are alike."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="兔子与兔子"><a href="#兔子与兔子" class="headerlink" title="兔子与兔子"></a>兔子与兔子</h3><hr><p>题意：有 1 个DNA序列，每次询问其中的两段，求这两段是否相同。</p><p>裸的字符串Hash。需要了解的是，若字符串 S 的 Hash 值是 H(S), 字符串 S + T 的 Hash 值是 H(S + T), 那么字符串 T 的 Hash 值就是 $H(T) = (H(S + T) - H(S) * P^{length(T)}) mod M$, 其中乘 P 就相当于 P 进制下的左移运算。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000010</span>], p[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * <span class="number">131</span> + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * <span class="number">131</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span> (f[r1] - f[l1 - <span class="number">1</span>] * p[r1 - l1 + <span class="number">1</span>] == f[r2] - f[l2 - <span class="number">1</span>] * p[r2 - l2 + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="POJ3974-Palindrome"><a href="#POJ3974-Palindrome" class="headerlink" title="[POJ3974]-Palindrome"></a>[POJ3974]-Palindrome</h3><hr><p>题意：寻找一个长度为 N 的字符串 S 的最长回文字串。</p><p>最长回文字串分为长度为奇数的和长度为偶数的，我们可以分情况讨论，正着倒着分别处理一遍 Hash 前缀和。假设最长回文字串的长度为 len，二分一半长度。最后取 max。时间复杂度 $O(N log N)$. 据说有个叫 Manacher 的算法可以 $O(N)$.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>, N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ull p[N], h1[N], h2[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> len, Case;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    ull val1 = h1[r1] - h1[l1 - <span class="number">1</span>] * p[r1 - l1 + <span class="number">1</span>];</span><br><span class="line">    ull val2 = h2[r2] - h2[l2 + <span class="number">1</span>] * p[l2 - r2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> val1 == val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) &amp;&amp; s[<span class="number">1</span>] != <span class="string">'E'</span>) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        h1[<span class="number">0</span>] = h2[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) h1[i] = h1[i - <span class="number">1</span>] * P + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) h2[i] = h2[i + <span class="number">1</span>] * P + (s[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans, l, r, maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            l = <span class="number">1</span>, r = min(len - i, i - <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (chk(i - mid, i - <span class="number">1</span>, i + mid, i + <span class="number">1</span>))</span><br><span class="line">                    l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn = max(maxn, <span class="number">2</span> * ans + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            l = <span class="number">1</span>, r = min(i - <span class="number">1</span>, len - (i + <span class="number">1</span>)), ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (chk(i - mid, i - <span class="number">1</span>, i + <span class="number">1</span> + mid, i + <span class="number">2</span>))</span><br><span class="line">                    ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxn = max(maxn, <span class="number">2</span> * ans + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++Case, maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 505 Div2</title>
      <link href="2018/08/20/Codeforces%20Round%20505%20Div2/"/>
      <url>2018/08/20/Codeforces%20Round%20505%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1025" target="_blank" rel="noopener">比赛链接</a></p><p>在比赛前睡了一会，果然精神不少！据说这是场数学大赛？比较考思维！B题差一点做出来啦！specialist后的第1场比赛！</p><h3 id="A-Doggo-Recoloring"><a href="#A-Doggo-Recoloring" class="headerlink" title="A. Doggo Recoloring"></a>A. Doggo Recoloring</h3><hr><p>题意：有一个字符串，包含小写英文字母。每次你可以选择一种个数大于1的字母将它们统统变为另一种字母，求能否统一字符串。</p><p>只要有一种个数大于1的字母就行了，可以26种字母统计数量后排序判断。</p><h3 id="B-Weakened-Common-Divisor"><a href="#B-Weakened-Common-Divisor" class="headerlink" title="B. Weakened Common Divisor"></a>B. Weakened Common Divisor</h3><hr><p>题意：有 n 对数字，要求求出一个WCD，要大于1，而且每对数字里有至少一个是它的倍数。</p><p>一开始想了一个质因数分解，是将每对数字都分解一下，T掉了。后来知道如果根据第一对数字的质因数分解应该也是可以的。</p><p>第二次想了<strong>接近</strong>正解的方法。就是求出每队数字lcm的gcd，然后找出这个gcd的最小质因子。一提交就发现错了，自己都能造出数据来hack。。（后来果然被hack啦）—— gcd是 $10^{18}$ 级别的，质因子最大是 $10^9$ 的，怎么找？</p><p>后来发现自己傻了。。。gcd是 $10^{18}$ 的，但每对数字是 $10^9$ 的呀，而那个最小质因子必定是第一对数字其中之一的约数，考虑第一对数字就好了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[<span class="number">150010</span>], b[<span class="number">150010</span>], sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[<span class="number">1</span>], &amp;b[<span class="number">1</span>]);</span><br><span class="line">    sum = a[<span class="number">1</span>] / (__gcd(a[<span class="number">1</span>], b[<span class="number">1</span>])) * b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        sum = __gcd(sum, a[i] / (__gcd(a[i], b[i])) * b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans &amp;&amp; sum % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[<span class="number">1</span>] % i == <span class="number">0</span>) a[<span class="number">1</span>] /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans &amp;&amp; a[<span class="number">1</span>] &gt; <span class="number">1</span> &amp;&amp; sum % a[<span class="number">1</span>] == <span class="number">0</span>) ans = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= b[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans &amp;&amp; sum % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b[<span class="number">1</span>] % i == <span class="number">0</span>) b[<span class="number">1</span>] /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans &amp;&amp; b[<span class="number">1</span>] &gt; <span class="number">1</span> &amp;&amp; sum % b[<span class="number">1</span>] == <span class="number">0</span>) ans = b[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Plasticine-zebra"><a href="#C-Plasticine-zebra" class="headerlink" title="C. Plasticine zebra"></a>C. Plasticine zebra</h3><hr><p>题意：有一个由 ‘b’ ‘w’ 两种字母组成的字符串，每次你可以选择一个位置 x，翻转 1 ~ x 和 x + 1 ~ n, 求能达到的最长交错字串（即一个 b 一个 w）长度。</p><p>一个长度为 8 的字符串，位置分别为 12345678，可以发现如果在第 4 个位置翻转，变成了 43218765，在第 5 个位置翻转变成了 81234567，有没有发现，这是一个 12345678 的变形，即把 8 移到首位？</p><p>同样第一次翻转时我们也可以将 43218765 倒过来，看作 56781234， 又是 12345678 的变形。</p><p>这样我们可以将字符串复制一份接在末尾，然后寻找最长交错字串。不要忘记与 n 取 max。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), tmp = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i + n] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i + <span class="number">1</span>]) tmp++;</span><br><span class="line">        <span class="keyword">else</span> ans = max(ans, tmp), tmp = <span class="number">1</span>;</span><br><span class="line">    ans = max(ans, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(ans, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Recovering-BST"><a href="#D-Recovering-BST" class="headerlink" title="D. Recovering BST"></a>D. Recovering BST</h3><hr><p>题意：求用给定的数字，能否做成一棵“有边相邻的两个节点都不互质”的二叉搜索树。</p><p>可以发现，若 i 号是根，根的左子树就是 1 ~ i - 1 号，右子树就是 i + 1 ~ n 号。所以说，二叉搜索树中的子树是可以和区间划上等号的。</p><p>我们设 f[l, r, 0] 表示 l ~ r 这个区间是 l - 1 号的右子树，f[l, r, 1] 表示 l ~ r 这个区间是 r + 1 号的左子树。f[l, r, 0/1] 的取值为 0 或 1，分别表示 不存在/存在。</p><p>需要注意的是，我第一次T了，但 n &lt;= 700, $n^3$ 没问题的啊。那么就是常数大了，需要卡常。</p><p>我们知道，c++ algorithm 库中的 __gcd() 函数是 log 的，$n^3 log n$ 可能太大了，我们将每一对点的gcd先预处理出来，$n^2 log n$ 就可以过了，美滋滋！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">710</span>], f[<span class="number">710</span>][<span class="number">710</span>][<span class="number">2</span>], g[<span class="number">710</span>][<span class="number">710</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">            g[i][j] = g[j][i] = (__gcd(a[i], a[j]) &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][i][<span class="number">0</span>] = g[i][i - <span class="number">1</span>];</span><br><span class="line">        f[i][i][<span class="number">1</span>] = g[i][i + <span class="number">1</span>];</span><br><span class="line">        f[i][i - <span class="number">1</span>][<span class="number">1</span>] = f[i + <span class="number">1</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[k][l - <span class="number">1</span>] &amp;&amp; f[l][k - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[k + <span class="number">1</span>][r][<span class="number">0</span>])</span><br><span class="line">                    f[l][r][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (g[k][r + <span class="number">1</span>] &amp;&amp; f[l][k - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[k + <span class="number">1</span>][r][<span class="number">0</span>])</span><br><span class="line">                    f[l][r][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">1</span>][i - <span class="number">1</span>][<span class="number">1</span>] &amp;&amp; f[i + <span class="number">1</span>][n][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018“百度之星”程序设计大赛 - 复赛</title>
      <link href="2018/08/19/2018%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/"/>
      <url>2018/08/19/2018%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=827" target="_blank" rel="noopener">比赛链接</a></p><h3 id="A-没有兄弟的舞会"><a href="#A-没有兄弟的舞会" class="headerlink" title="A. 没有兄弟的舞会"></a>A. 没有兄弟的舞会</h3><hr><p>一看这题目就让我想到‘cv-没有上司的舞会’。。。</p><p>看完题目第一反应是树形DP吗？</p><p>好像是贪心。。。先不考虑兄弟节点，最小值是所有点的子节点中最小的 vi 的和，最大值是所有点的子节点中最大的 vi 的和。然后枚举兄弟节点，计算并输出。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line">ll T, n, a[<span class="number">100005</span>], fa[<span class="number">100005</span>], maxn, minn;</span><br><span class="line">ll Max[<span class="number">100005</span>][<span class="number">2</span>], Min[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; nxt[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;fa[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nxt[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            nxt[fa[i]].push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sort(nxt[i].begin(), nxt[i].end());</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">        maxn = -inf, minn = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>)nxt[i].size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxn &lt; nxt[i][size - <span class="number">2</span>])</span><br><span class="line">                    maxn = nxt[i][size - <span class="number">2</span>], pos1 = i;</span><br><span class="line">                <span class="keyword">if</span> (minn &gt; nxt[i][<span class="number">1</span>])</span><br><span class="line">                    minn = nxt[i][<span class="number">1</span>], pos2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>)nxt[i].size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans1 = max(ans1, ans1 + nxt[i][size - <span class="number">1</span>]);</span><br><span class="line">                ans2 = min(ans2, ans2 + nxt[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos1) &#123;</span><br><span class="line">            ans1 = max(ans1, ans1 + maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos2) &#123;</span><br><span class="line">            ans2 = min(ans2, ans2 + minn);</span><br><span class="line">        &#125;</span><br><span class="line">        ans1 = max(ans1, ans1 + a[<span class="number">1</span>]);</span><br><span class="line">        ans2 = min(ans2, ans2 + a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-序列期望"><a href="#B-序列期望" class="headerlink" title="B. 序列期望"></a>B. 序列期望</h3><hr><p>$(\prod_{l_i \le h \le r_i} \sum_{x_i = l_i}^{h} h - x_i) (\prod_{r_i &lt; h} \sum_{x_i = l_i}^{r_i} h - x_i)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 “百度之星”程序设计大赛 - 初赛（B）</title>
      <link href="2018/08/13/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89/"/>
      <url>2018/08/13/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=826" target="_blank" rel="noopener">比赛链接</a></p><p>因为初赛A没过，所以也来体验了B组，感觉还要难一些，也更妙一些。很有收获！</p><h3 id="A-degree"><a href="#A-degree" class="headerlink" title="A. degree"></a>A. degree</h3><hr><p>首先确定是森林，也就是多棵树。我们枚举作为答案的那个点，首先可以在原来的基础上向剩余的连通块各连一条（即 n - 1 - m，可以脑补一下，如果将剩余的原来是连接连通块的边加上，那么就是一棵 n - 1 条边的树，而每个连通块必然只有一条边连出来，故 n - 1 - m 是可连的连通块数量）。最后再加上别处被移除的边的数量。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, a, b, T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) nxt[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            nxt[a].push_back(b);</span><br><span class="line">            nxt[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nxt[i].size();</span><br><span class="line">            ans = max(ans, x + (n - <span class="number">1</span>) - m + min(k, m - x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-hex"><a href="#B-hex" class="headerlink" title="B. hex"></a>B. hex</h3><hr><p>扛了扛，样例未过，不了了之，留坑待填。</p><h3 id="C-odds"><a href="#C-odds" class="headerlink" title="C. odds"></a>C. odds</h3><hr><p>没仔细看过，留坑待填。</p><h3 id="D-p1m2"><a href="#D-p1m2" class="headerlink" title="D. p1m2"></a>D. p1m2</h3><hr><p>二分答案！！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, n, a[<span class="number">300005</span>], tmp[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll limit)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i] &lt; limit) &#123;</span><br><span class="line">            t += limit - tmp[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += (tmp[i] - limit) / <span class="number">2</span>;  <span class="comment">// attention!!不是 sum += tmp[i] - limit.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        ll l = <span class="number">0</span>, r = (<span class="keyword">int</span>)<span class="number">1e8</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (chk(mid + <span class="number">1</span>))   <span class="comment">// ATTENTION!! WA 3 times for this mistake -- "mid + 1"</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-ratio"><a href="#E-ratio" class="headerlink" title="E. ratio"></a>E. ratio</h3><hr><p>并没有做，留坑待填。</p><h3 id="F-rect"><a href="#F-rect" class="headerlink" title="F. rect"></a>F. rect</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">|\            /|</span><br><span class="line">| \     <span class="number">1</span>    / |</span><br><span class="line">|  \        /  |</span><br><span class="line">|   \      /   |</span><br><span class="line">|    \    /    |</span><br><span class="line">|     \  /     |</span><br><span class="line">|  <span class="number">2</span>   \/   <span class="number">3</span>  |</span><br><span class="line">|      /\      |</span><br><span class="line">|     /  \     |</span><br><span class="line">|    /    \    |</span><br><span class="line">|   /      \   |</span><br><span class="line">|  /    <span class="number">4</span>   \  |</span><br><span class="line">| /          \ |</span><br><span class="line">|/            \|</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure><p>如图，位于 1 区的线段答案是 x，位于 2 区的线段答案是 y，位于 3 区的线段答案是 my - y，位于 4 区的线段答案是 mx - x，可以证明，绝对不会相交。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mx, my, n, T, x, y, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;mx, &amp;my, &amp;n);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;y);</span><br><span class="line">            ans += min(x, min(y, min(mx - x, my - y)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前500可以进复赛。在还有约30分钟时我是448名左右。当时大概大脑犯抽，一直在想“啊还有12名”，直到我发现了490这个数字的存在。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 “百度之星”程序设计大赛 - 初赛（A）</title>
      <link href="2018/08/12/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89/"/>
      <url>2018/08/12/2018%20%E2%80%9C%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%20-%20%E5%88%9D%E8%B5%9B%EF%BC%88A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825" target="_blank" rel="noopener">http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=825</a></p><p>AC一道。。。rank1959。。。又参加了有趣的B场，还是很值得一记的！</p><h3 id="A-度度熊拼三角"><a href="#A-度度熊拼三角" class="headerlink" title="A. 度度熊拼三角"></a>A. 度度熊拼三角</h3><hr><p>题意略。</p><p>三角形，两边之和大于第三边，两边之差小于第三边。</p><p>那么我们把边的长度排序，枚举最小的两条边 l, r, 找到最大的一条小于两边之和的边。用 two-pointers.</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">1005</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">            r = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; n &amp;&amp; a[i] + a[j] &gt; a[r + <span class="number">1</span>]) ++r;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] &gt; a[r])</span><br><span class="line">                    ans = max(ans, a[i] + a[j] + a[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-度度熊学队列"><a href="#B-度度熊学队列" class="headerlink" title="B. 度度熊学队列"></a>B. 度度熊学队列</h3><hr><p>题意略。</p><p>可以用STL中的map模拟双向链表。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q, flag, u, v, w, val;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &gt;a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;=<span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q) &#123;</span><br><span class="line">        a.clear();</span><br><span class="line">        <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">            read(flag);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                read(u), read(w), read(val);</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span>) a[u].push_front(val);</span><br><span class="line">                <span class="keyword">else</span> a[u].push_back(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">                read(u), read(w);</span><br><span class="line">                <span class="keyword">if</span> (!a[u].empty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; a[u].front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        a[u].pop_front();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; a[u].back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        a[u].pop_back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                read(u), read(v), read(w);</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span>) &#123;</span><br><span class="line">                    a[u].insert(a[u].end(), a[v].begin(), a[v].end());</span><br><span class="line">                    a[v].clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[u].insert(a[u].end(), a[v].rbegin(), a[v].rend());</span><br><span class="line">                    a[v].clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-度度熊剪纸条"><a href="#C-度度熊剪纸条" class="headerlink" title="C. 度度熊剪纸条"></a>C. 度度熊剪纸条</h3><hr><p>题意略。</p><p>官方题解很有道理！对于每一段连续的1，如果左边右边都有数字，那就是二元组 [1, 1]，含义是左边切一刀、右边切一刀；如果只有左边有数字，那就是 [1, 0], 反之是 [0, 1]， 或者是 [0, 0]。</p><p>现在，我们要在这些集合里挑选一些段，使得中括号里代价和不超过 K，排序后从大到小选，O(N log N).</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, cnt, cnt1, ans, b[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> d, w;&#125;kk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.d == b.d ? a.w &lt; b.w : a.d &gt; b.d;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= kk[i].w) &#123;</span><br><span class="line">            tmp += kk[i].d, k -= kk[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = max(ans, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ans++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        cnt = cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> (i == n) b[++cnt1] = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> == num) b[++cnt1] = num;</span><br><span class="line">                <span class="keyword">else</span> kk[++cnt].d = num, kk[cnt].w = <span class="number">2</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        sort(kk + <span class="number">1</span>, kk + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == <span class="number">2</span>) &#123;</span><br><span class="line">            work(k, <span class="number">0</span>), work(k - <span class="number">1</span>, b[<span class="number">1</span>]), work(k - <span class="number">1</span>, b[<span class="number">2</span>]), work(k - <span class="number">2</span>, b[<span class="number">1</span>] + b[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">1</span>) &#123;</span><br><span class="line">            work(k, <span class="number">0</span>), work(k - <span class="number">1</span>, b[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> work(k, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-度度熊看球赛"><a href="#D-度度熊看球赛" class="headerlink" title="D. 度度熊看球赛"></a>D. 度度熊看球赛</h3><hr><p>题意略。</p><p>这是一个伪的概率。(2N)! 指的是情况数，每种情况对ans的贡献是 $D^K$，其中 k 表示该情况下有 K 对情侣座位相邻。</p><p>设 $F_{i, j}$ 表示共有 i 对情侣，且正好有 j 对是挨着坐的。每次考虑把第 i + 1 对放进去：</p><p>(1). 这对情侣合在一起放。</p><p>① 拆散一对情侣：$F_{i + 1, j} += F_{i, j} * j$</p><p>② 放在情侣之间的空隙间：$F_{i + 1, j + 1} += F_{i, j} <em> (2 </em> i + 1 - j)$</p><p>(2). 这对情侣分开放。</p><p>① 他们各自拆散了一对情侣：$F_{i + 1, j - 2} += F_{i, j} <em> (j </em> \frac{(j - 1)}{2})$</p><p>② 只有一个人拆散了一对情侣：$F_{i + 1, j - 1} += F_{i, j} <em> (2 </em> i + 1 - j)$</p><p>③ 没有情侣被拆散：$F_{i + 1, j} += F_{i, j} <em> ((2 </em> i + 1 - j) <em> \frac{2 </em> i - j}{2})$</p><p>$O(N^2)$ 预处理。对于每一组询问，我们只要 O(N) 扫一遍计算一下答案即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[N][N], n, d;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(ll a, ll b = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * (a - <span class="number">1</span>) % mod * quick_pow(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ycl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span> * f[i][<span class="number">0</span>] % mod * C(<span class="number">2</span> * i + <span class="number">1</span>, <span class="number">2</span>) % mod +</span><br><span class="line">                      <span class="number">2</span> * f[i][<span class="number">1</span>] % mod * <span class="number">2</span> * i % mod + </span><br><span class="line">                      <span class="number">2</span> * f[i][<span class="number">2</span>] % mod;</span><br><span class="line">        f[i + <span class="number">1</span>][<span class="number">0</span>] %= mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][j] = <span class="number">2</span> * f[i][j - <span class="number">1</span>] % mod * (<span class="number">2</span> * i + <span class="number">1</span> - (j - <span class="number">1</span>)) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j] % mod * (j + C(<span class="number">2</span> * i + <span class="number">1</span> - j, <span class="number">2</span>)) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j + <span class="number">1</span>] % mod * ((j + <span class="number">1</span>) * (<span class="number">2</span> * i + <span class="number">1</span> - (j + <span class="number">1</span>)) % mod) % mod +</span><br><span class="line">                          <span class="number">2</span> * f[i][j + <span class="number">2</span>] % mod * C(j + <span class="number">2</span>, <span class="number">2</span>) % mod;</span><br><span class="line">            f[i + <span class="number">1</span>][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ycl();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;d)) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">2</span> * d % mod);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + f[n][i] * quick_pow(d, i) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 503 Div2</title>
      <link href="2018/08/12/Codeforces%20Round%20503%20Div2/"/>
      <url>2018/08/12/Codeforces%20Round%20503%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1020" target="_blank" rel="noopener">http://codeforces.com/contest/1020</a></p><h3 id="A-New-Building-for-SIS"><a href="#A-New-Building-for-SIS" class="headerlink" title="A. New Building for SIS"></a>A. New Building for SIS</h3><hr><p>题意略。</p><p>要注意同幢楼的情况！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, h, a, b, k, t1, t2, f1, f2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>, &amp;n, &amp;h, &amp;a, &amp;b, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;t1, &amp;f1, &amp;t2, &amp;f2);</span><br><span class="line">        <span class="keyword">if</span> (f1 &gt; f2) swap(f1, f2);</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt; t2) swap(t1, t2);</span><br><span class="line">        ll dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == t2) &#123;</span><br><span class="line">            dis += (f2 - f1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f1 &lt; a) dis += a - f1, f1 = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f1 &gt; b) dis += f1 - b, f1 = b;</span><br><span class="line">            <span class="keyword">if</span> (f2 &lt; a) dis += a - f2, f2 = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f2 &gt; b) dis += f2 - b, f2 = b;</span><br><span class="line">            dis += (f2 - f1) + (t2 - t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Badge"><a href="#B-Badge" class="headerlink" title="B. Badge"></a>B. Badge</h3><hr><p>题意略。</p><p>无脑 n^2 模拟（？？）</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p[<span class="number">1005</span>], mark[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        mark[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!mark[p[start]]) &#123;</span><br><span class="line">            start = p[start], mark[start] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = p[start];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Elections"><a href="#C-Elections" class="headerlink" title="C. Elections"></a>C. Elections</h3><hr><p>题意略。</p><p>此题卡了好久！后来干脆弃疗。。。</p><p>我一直在想是不是要设什么性价比，或者应该挑当前票最多的对手，拿ta一张票相等于两张之类，但由于很容易证明是错的，也就gg了。。。</p><p>正解在此：必定存在一个 x，使得 1 的票数 &gt;= x, 2 ～ m 的票数 &lt; x. 1 &lt;= x &lt;= 3000，枚举就行。n^2。</p><p>使所有 2 ～ m 的数量都降至 x 以下，最后若 1 的票数还是不 &gt;= x，就挑剩下来最小的补上。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c[<span class="number">3010</span>], b[<span class="number">3010</span>];</span><br><span class="line">ll ans, sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> p; ll c;&#125;a[<span class="number">3010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.c &gt; b.c;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;a[i].p, &amp;a[i].c);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    ans = inf;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) c[j] = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) b[j] = <span class="number">0</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j].p == <span class="number">1</span>) c[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[a[j].p] + <span class="number">1</span> &gt;= i) sum += a[j].c, c[<span class="number">1</span>]++, b[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> c[a[j].p]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (a[j].p != <span class="number">1</span> &amp;&amp; b[j] == <span class="number">0</span> &amp;&amp; c[<span class="number">1</span>] &lt; i) b[j] = <span class="number">1</span>, sum += a[j].c, c[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">1</span>] &gt;= i) ans = min(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-The-hat"><a href="#D-The-hat" class="headerlink" title="D. The hat"></a>D. The hat</h3><hr><p>是个交互题？？坑先留着</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1737]-Connected Graph</title>
      <link href="2018/08/10/%5BPOJ1737%5D-Connected%20Graph/"/>
      <url>2018/08/10/%5BPOJ1737%5D-Connected%20Graph/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1737" target="_blank" rel="noopener">传送门</a></p><p>题意：求 $N$ 个节点的无向连通图有多少个，节点有标号，为 $1$ ～ $N$，$1 \leq N \leq 50$.</p><p>（诶我记得有一年的初赛问题求解 $T2$ 是这个！）</p><p>当时那道初赛，4 个点，我是先算出了 $C_6^3 + C_6^4 + C_6^5 + C_6^6$，再减去三个点之间有三条边、一个点孤立的三种情况，共是38，与题例4相同。</p><p>那么我们也可以用类似容斥的方法，来做这题。</p><p>$N$ 个点的无向图总数是 $2^{N * (N - 1) / 2}$。</p><p>接下来计算 $N$ 个点的不连通无向图的数量。一个不连通无向图必定由若干连通块组成。根据 “根据围绕基准点构造一个整体” 的思想，我们可以枚举标号为 $1$ 的节点所在的连通块包含的节点个数 $k$，从 $2$ ~ $i$ 这 $i - 1$ 个节点中选出 $k - 1$ 个节点构成任意无向图，有 $2 ^ {(i - k) * (i - k - 1) / 2}$ 种方法。</p><p>综上所述，设 $F[i]$ 表示 $i$ 个节点的无向连通图个数：</p><script type="math/tex; mode=display">F[i] = 2^{i * (i - 1) / 2} - \sum\limits_{j = 1}^{i - 1} F[j] * C_{i - 1}^{j - 1} * 2^{(i - j) * (i - j - 1) / 2}</script><p>可是，这题需要高精度，所以目前我还未AC，以上只是此题主要思路！</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll f[<span class="number">60</span>], C[<span class="number">60</span>][<span class="number">60</span>], sum[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1l</span>l &lt;&lt; (x * (x - <span class="number">1</span>) / <span class="number">2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        sum[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            sum[i] += C[i - <span class="number">1</span>][j - <span class="number">1</span>] * f[j] * calc(i - j);</span><br><span class="line">        f[i] = calc(i) - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩展题目：<a href="https://vjudge.net/problem/HDU-5729" target="_blank" rel="noopener">$HDU5729-Rigid Frameworks$</a></p><p>题意：因为矩形是不稳定的，会变成平行四边形，但是可以在矩形对角线加边，通过构成三角形使这个矩形稳定下来。给一 $n <em> m$ 的矩形，可以在单位矩形里加两种对角线（从左上到右下，从左下到右上两种），或者不加对角线，或者两条。问使这个 $n </em> m$ 的矩形稳定下来的方案数。</p><p>原问题等价于求左边有 $n$ 个点，右边有 $m$ 个点的连通的二分图的数目，可以用类似连通图计数的方法 dp 得到。</p><p>每个单位矩阵可以加两种对角线（从左上到右下，从左下到右上两种），或者不加对角线，共 $3$ 种选择，则一个 $n * m$ 矩阵的总方案数是 $3^{nm}$。</p><p>我们设 $f[i, j]$ 表示使 $i * j$ 矩阵固定下来的合法方案数。</p><p>与 POJ1737 类似，该题转移方程为：</p><script type="math/tex; mode=display">f[n, m] = 3^{n * m} - C_{n - 1}^{i - 1} * C_m^j * f[i, j] * 3^{(n - i) * (m - j)}</script><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll C[N][N], g[N * N], f[N][N], inv[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">110</span>; i++) g[i] = g[i - <span class="number">1</span>] * <span class="number">3</span> % mod;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">            f[i][j] = g[i * j];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">0</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= i; n++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= j; m++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == n &amp;&amp; j == m) <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][j] -= C[i - <span class="number">1</span>][n - <span class="number">1</span>] * C[j][m] % mod * f[n][m] % mod * g[(i - n) * (j - m)] % mod;</span><br><span class="line">                    f[i][j] = (f[i][j] % mod + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
            <tag> 计数DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SPOJ-CMPLS]-Complete the Sequence!</title>
      <link href="2018/08/08/%5BSPOJ-CMPLS%5D-Complete%20the%20Sequence!/"/>
      <url>2018/08/08/%5BSPOJ-CMPLS%5D-Complete%20the%20Sequence!/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/SPOJ-CMPLS" target="_blank" rel="noopener">https://vjudge.net/problem/SPOJ-CMPLS</a></p><p>题意：给出了一个数列的前 s 项，要求推出后面的 c 项。</p><p>很像找规律，不要被那个 P(x) 的式子唬住了哈。。。</p><p>这个办法就是，差分求多项式值。</p><p>给定 f(x) 是关于 x 的一个多项式，设 f(x) 的次数是 n。</p><p>则规定:</p><p>$a_x = f(x) - f(x - 1)$, 称为一阶差分.</p><p>$b_x = a_x - a_{x - 1}$, 称为二阶差分.</p><p>$c_x = b_x - b_{x - 1}$, 称为三阶差分.</p><p>以此类推，直至 n 阶差分。</p><p>根据以上定义，给定 n + 1 组初始的 x 和 f(x) 的映射，即可通过差分法得到往后的所有多项式值。</p><p>例：$f(x) = x^3 + x^2 + x + 1$.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">x  <span class="title">f</span><span class="params">(x)</span>   ax   bx   cx</span></span><br><span class="line"><span class="function">0    1</span></span><br><span class="line"><span class="function">1    4    3</span></span><br><span class="line"><span class="function">2    15   11   8</span></span><br><span class="line"><span class="function">3    40   25   14   6</span></span><br><span class="line"><span class="function">4    85   45   20   6</span></span><br><span class="line">5   156   71   26   5   &lt;- f(x) = f(x - 1) + a_&#123;x - 1&#125; + b_&#123;x - 1&#125; + c_&#123;x - 1&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个三次的多项式在三阶差分时相等。</p><p>如上所述，这是个模板题。我们根据前 s 项逆推回去。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> T, S, C, X[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;S, &amp;C);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S - i; j++)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] - f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) f[S - <span class="number">1</span>][i] = f[S - <span class="number">1</span>][i - <span class="number">1</span>];  <span class="comment">// 逆推至此</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = S - i; j &lt; S - i + C; j++)</span><br><span class="line">                f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &lt;= S + C - <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, f[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IPSC2016C]-Counting Swaps</title>
      <link href="2018/08/07/%5BIPSC2016C%5D-Counting%20Swaps/"/>
      <url>2018/08/07/%5BIPSC2016C%5D-Counting%20Swaps/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4778#sub" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4778#sub</a></p><p>题意：给定一个 $1$ ~ $n$ 的排列 $p_1, p_2, … p_n$，可进行若干次操作，每次选择两个整数 $x$，$y$，交换 $p_x, p_y$。设把 $p_1, p_2, … p_n$ 变成单调递增的排列 $1$, $2$, … $n$ 至少需要 $m$ 次交换，求有多少种操作方法可以只用 $m$ 次交换达到上述目标。答案对 $10^9 + 9$ 取模。</p><p>对于一个排列，如果从每个 $i$ 到 $p_i$ 连一条边，那么可以得到一张 $n$ 个点 $n$ 条边的图，且由若干个环组成。</p><p>可以证明，把一个长度为 $n$ 的环变成 $n$ 个自环，至少需要 $n - 1$ 次交换。</p><p>证明：<br>首先，把一个长度为 $2$ 的环变成 $2$ 个自环显然需要一次。假设 $\forall k \leq n - 1$，把长度不超过 $k$ 的环变成 $k$ 个自环最少需要 $k - 1$ 次操作。当 $k = n$ 时，把该环拆成长度为 $j - i$ 和 $n - (j - i)$ 的两个环($i &lt; j &lt; n$) 。把二者分别拆成自环所需的最小交换次数为 $(j - i - 1) + (n - (j - i) - 1) = n - 2$，再加上第一次的拆开，共需 $n - 1$. 通过数学归纳法可知，原命题成立。</p><p>证毕。</p><p>设 $F_n$ 表示用最少的步数把一个长度为 $n$ 的环变成 $n$ 个自环，共有多少种操作方法。由上证明可知，可以将长度为 $n$ 的环拆成长度为 $x$ 和 $y$ 的两个环，其中 $x + y = n$。设 $T(x, y)$ 表示有多少种交换方法可以把长度为 $n$ 的环变成长度为 $x$ 和 $y$ 的两个环，容易发现，$T(x, y)$ 在 $n$ 是偶数且 $x = y$ 时是 $n / 2$, 在 $n$ 是奇数或 $x \neq y$ 时等于 $n$。</p><p>两者变为自环的步数为 $x - 1$ 和 $y - 1$.</p><p>根据多重集的排列数、加法原理和乘法原理：</p><script type="math/tex; mode=display">F_n = \sum_{x + y = n} T(x, y) * F_x * F_y * \frac{(n - 2)!}{(x - 1)!(y - 1)!}</script><p>如果最初的排列 $p_1, p_2, … p_n$ 由长度为 $l_1, l_2, … l_k$ 的 k 个环构成，其中 $l_1 + l_2 + … + l_k = n$，那么最终的答案就是：</p><script type="math/tex; mode=display">F_{l_1} * F_{l_2} * ... * F_{l_k} * \frac{(n - k)!}{(l_1 - 1)!(l_2 - 1)! * ... * (l_k - 1)!}</script><p>1e9 + 9 是质数，可以用乘法逆元处理公式中的除法。$O(n^2)$。</p><p>事实上，我们通过找规律可以发现通项公式 $F_n = n^{n - 2}$，从而优化到 $O(n log n)$。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, lnk[N], cnt, to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], T, colo[N], d, F[N];</span><br><span class="line">ll Fac[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v, nxt[cnt] = lnk[u], lnk[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    colo[x] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (!colo[y]) dfs(y, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b || p &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ret = ret * b % mod;</span><br><span class="line">        b = b * b % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    Fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i ++) Fac[i] = Fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">        <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line">        <span class="built_in">memset</span>(colo, <span class="number">0</span>, <span class="keyword">sizeof</span>(colo));</span><br><span class="line">        cnt = d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u;</span><br><span class="line">            add(i, u), add(u, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!colo[i]) dfs(i, ++d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) F[colo[i]]++;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            ans = ans * quick_pow(F[i], F[i] - <span class="number">2</span>) % mod;</span><br><span class="line">        ans = ans * Fac[n - d] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            ans = ans * quick_pow(Fac[F[i] - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1013]-球形空间产生器</title>
      <link href="2018/08/07/%5BBZOJ1013%5D-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/"/>
      <url>2018/08/07/%5BBZOJ1013%5D-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1013" target="_blank" rel="noopener">传送门</a></p><p>题意略。</p><p>对于每个点，他们到球心的距离都是相等的。</p><p>根据欧几里得距离，此时只需求出一点 $(x_1, x_2, … x_n)$，使得：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n (a_{i, j} - x_j) ^ 2 = C</script><p>其中 $C$ 为常数。该方程组是由 $n + 1$ 个 $n$ 元二次方程组成的，不是线性方程组（线性方程组要求均为一次），但我们可以通过相邻两个方程作差，把它变成 $n$ 个 $n$ 元一次方程，同时消去常数 $C$：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n (a_{i, j}^2 - a_{i + 1, j}^2 - 2x_j(a_{i, j} - a_{i + 1, j})) = 0\ \ \ \ (i = 1, 2, ... , n)</script><p>把变量放在左边，常数放在右边：</p><script type="math/tex; mode=display">\sum\limits_{j = 1}^n 2(a_{i, j} - a_{i + 1, j})x_j = \sum\limits_{j = 1}^n (a_{i, j}^2 - a_{i + 1, j}^2)\ \ \ \ (i = 1, 2, ... , n)</script><p>这就是一个线性方程组了，题目保证方程组有唯一解，我们直接对下面的增广矩阵进行高斯消元，变为简化阶梯形矩阵。</p><script type="math/tex; mode=display">\begin{bmatrix}2(a_{1, 1} - a_{2, 1}) & 2(a_{1, 2} - a_{2, 2}) & \cdots & 2(a_{1, n} - a_{2, n}) & \sum_{j = 1}^n(a_{1, j}^2 - a_{2, j}^2) \\2(a_{2, 1} - a_{3, 1}) & 2(a_{2, 2} - a_{3, 2}) & \cdots & 2(a_{2, n} - a_{3, n}) & \sum_{j = 1}^n(a_{2, j}^2 - a_{3, j}^2) \\\vdots & \vdots & \ddots & \vdots & \vdots \\2(a_{n, 1} - a_{n + 1, 1}) & 2(a_{n, 2} - a_{n + 1, 2}) & \cdots & 2(a_{n, n} - a_{n + 1, n}) & \sum_{j = 1}^n(a_{n, j}^2 - a_{n + 1, j}^2) \\\end{bmatrix}</script><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>], b[<span class="number">20</span>], c[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            c[i][j] = <span class="number">2</span> * (a[i][j] - a[i + <span class="number">1</span>][j]);</span><br><span class="line">            b[i] += a[i][j] * a[i][j] - a[i + <span class="number">1</span>][j] * a[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(c[j][i]) &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) swap(c[i][k], c[j][k]);</span><br><span class="line">                swap(b[i], b[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> rate = c[j][i] / c[i][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; k++) c[j][k] -= c[i][k] * rate;</span><br><span class="line">            b[j] -= b[i] * rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%.3lf "</span>, b[i] / c[i][i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高斯消元不怎么好写，重点是怎么把题意转化为式子，还有推式子的时候要勤快！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 097</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20097/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20097/</url>
      
        <content type="html"><![CDATA[<h3 id="C-K-th-Substring"><a href="#C-K-th-Substring" class="headerlink" title="C. K-th Substring"></a>C. K-th Substring</h3><hr><p>数据很小，暴力即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="built_in">string</span> str[N * <span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; k;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, T; i &lt; n; i++) &#123;</span><br><span class="line">        str[++cnt] = s[i];</span><br><span class="line">        T = min(k, n - i);  <span class="comment">// 这里很重要！没有就会TLE！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; T; j++, cnt++) str[cnt + <span class="number">1</span>] = str[cnt] + s[i + j];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(str + <span class="number">1</span>, str + cnt + <span class="number">1</span>);</span><br><span class="line">    unique(str + <span class="number">1</span>, str + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Equals"><a href="#D-Equals" class="headerlink" title="D. Equals"></a>D. Equals</h3><hr><p>用并查集维护：$x_j$ 和 $y_j$ 是在同一连通块里的。</p><p>若 i 和 p[i] 在同一连通块里，那么 ans + 1，即同一连通块里的元素是可以随意调换位置的。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N], fa[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(x), fy = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (getfa(i) == getfa(p[i])) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 098</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20098/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20098/</url>
      
        <content type="html"><![CDATA[<h3 id="C-Attention"><a href="#C-Attention" class="headerlink" title="C. Attention"></a>C. Attention</h3><hr><p>很简单的前缀和，不讲，</p><h3 id="D-Xor-Sum-2"><a href="#D-Xor-Sum-2" class="headerlink" title="D. Xor Sum 2"></a>D. Xor Sum 2</h3><hr><p>由题意可以得到，根据xor的消去律，连续子序列，如果 $a_i$ 这个数不符合，之后的对数中将不再需要这个元素，即从 $a_{i + 1}$ 开始。根据消去律可得，异或等效于加法与减法，可据此计算区间的异或和。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, f[N], s[N], x, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + x;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; f[r] - f[l - <span class="number">1</span>] != (s[r] ^ s[l - <span class="number">1</span>]); l++);</span><br><span class="line">        ans += r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 099</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20099/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20099/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc099.contest.atcoder.jp/assignments" target="_blank" rel="noopener">https://arc099.contest.atcoder.jp/assignments</a></p><p>一如既往地简洁！</p><h3 id="C-Minimization"><a href="#C-Minimization" class="headerlink" title="C. Minimization"></a>C. Minimization</h3><hr><p>题意：给定 n 的排列，每次选择连续的 k 个元素，赋为这 k 个元素的最小值，重复此操作，直到所有元素相同。</p><p>即所有元素都是 1 咯！</p><p>显然我们每次操作的区间都会包含 1。因此 $Ans = 1 + \lceil \frac{N - K}{K - 1} \rceil$。$O(1)$</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    n -= k;</span><br><span class="line">    ans += n / (k - <span class="number">1</span>);</span><br><span class="line">    n %= (k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Regular Contest 100</title>
      <link href="2018/08/04/Atcoder%20Regular%20Contest%20100/"/>
      <url>2018/08/04/Atcoder%20Regular%20Contest%20100/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arc100.contest.atcoder.jp/assignments" target="_blank" rel="noopener">https://arc100.contest.atcoder.jp/assignments</a></p><p>话说 atcoder 的题目都超短易懂有没有！</p><h3 id="C-Linear-Approximation"><a href="#C-Linear-Approximation" class="headerlink" title="C. Linear Approximation"></a>C. Linear Approximation</h3><hr><p>题意略。</p><p>$A_i - (b + i)$ 几何意义就是 $A_i - i$ 在数轴上到 b 的距离啦。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[<span class="number">200005</span>], num, tot;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">iabs</span><span class="params">(ll a)</span> </span>&#123;<span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], a[i] -= i;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    num = a[(n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tot += iabs(a[i] - num);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Equal-Cut"><a href="#D-Equal-Cut" class="headerlink" title="D. Equal Cut"></a>D. Equal Cut</h3><hr><p>题意：给你 N 个数，存为 Ai，切三刀，分为四组，每一组的和分别为 b、c、d、e，要求这四个数的极差（最大数和最小数的差）最小，输出这个最小值。</p><p>先预处理出前缀和，暴力中间的断点，在循环中找一前一后两个断点，如果移动能使得前后两个区域之间的差变小便移动，否则不移动。用一个变量存储所有循环中间断点时出现的最小值，输出即可。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, a[N], pre[N], t[<span class="number">5</span>], ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">iabs</span><span class="params">(ll a)</span> </span>&#123;<span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : -a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i], pre[i] = pre[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; i &amp;&amp; iabs(pre[l] - pre[<span class="number">0</span>] - (pre[i] - pre[l])) &gt;= iabs(pre[l + <span class="number">1</span>] - pre[<span class="number">0</span>] - (pre[i] - pre[l + <span class="number">1</span>])))</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; iabs(pre[r] - pre[i] - (pre[n] - pre[r])) &gt;= iabs(pre[r + <span class="number">1</span>] - pre[i] - (pre[n] - pre[r + <span class="number">1</span>])))</span><br><span class="line">            r++;</span><br><span class="line">        t[<span class="number">1</span>] = pre[l] - pre[<span class="number">0</span>];</span><br><span class="line">        t[<span class="number">2</span>] = pre[i] - pre[l];</span><br><span class="line">        t[<span class="number">3</span>] = pre[r] - pre[i];</span><br><span class="line">        t[<span class="number">4</span>] = pre[n] - pre[r];</span><br><span class="line">        ans = min(ans, max(t[<span class="number">1</span>], max(t[<span class="number">2</span>], max(t[<span class="number">3</span>], t[<span class="number">4</span>]))) - min(t[<span class="number">1</span>], min(t[<span class="number">2</span>], min(t[<span class="number">3</span>], t[<span class="number">4</span>]))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1101]-Zap</title>
      <link href="2018/08/01/%5BBZOJ1101%5D-Zap/"/>
      <url>2018/08/01/%5BBZOJ1101%5D-Zap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1101" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1101</a></p><p>题意略。</p><p>求 $gcd(x, y) = d$, 相当于求 $gcd(x / d, y / d) = 1$ 的个数。相当于求 $1 \leq x \leq a / d$, $1 \leq y \leq b / d$ 中 $x$, $y$ 互质对数。</p><p>令 $n = \lfloor a / d \rfloor$, $m = \lfloor b / d \rfloor$.</p><p>即</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^a \sum\limits_{j = 1}^b [gcd(i, j) == d]</script><script type="math/tex; mode=display">= \sum\limits_{i = 1}^n \sum\limits_{j = 1}^m [gcd(i, j) == 1]</script><p>现在必须提到一个莫比乌斯函数的性质：<br>当 $n &gt; 1$ 时，<br>$\sum\limits_{d | n} \mu(d) = 0$；$n = 1$ 时，$\sum\limits_{d | n} \mu(d) = 1$。</p><p>证明：</p><p>$n = 1$ 时显然。</p><p>$n &gt; 1$ 时，设 $n = p_1^{c_1} <em> p_2^{c_2} </em> p_3^{c_3} <em> … </em> p_k^{c_k}$ ，$d$ 有其中一部分。</p><p>显然根据莫比乌斯函数的定义，$d$ 的每个质因子指数为 $1$ 才有贡献，否则 $\mu(d) = 0$。</p><p>那么设 $d$ 中有 $r$ 个质因子。</p><p>$\mu(d) = (-1)^r$ ，这样的 $d$ 有 $C_m^r$ 个。</p><p>所以</p><script type="math/tex; mode=display">\sum\limits_{d | n} \mu(d) = \sum\limits_{r = 0}^m (-1)^rC_m^r</script><p>我们根据二项式定理，逆推回去：</p><script type="math/tex; mode=display">\sum\limits_{r = 0}^m(-1)^rC_m^r = \sum\limits_{r = 0}^mC_m^r(-1)^r1^{m - r} = (-1 + 1)^m = 0</script><p>证毕。</p><p>我们用这个性质把求和的式子变成：</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n \sum\limits_{j = 1}^m \sum\limits_{d | gcd(i, j)} \mu(d)</script><p>其中 $d | gcd(i, j)$ 可以变为 $d | i  and  d | j$ ，更换求和指标，</p><script type="math/tex; mode=display">= \sum\limits_{d = 1}^n \mu(d) * \lfloor \frac{n}{d} \rfloor * \lfloor \frac{m}{d} \rfloor</script><p>容易知道 $\lfloor n / d \rfloor$ 单调不上升，根据整数分块的知识，最多有 $2\sqrt{n}$ 种不同的取值。所以按取值分成 $O(\sqrt{n})$ 个段分别处理，一个连续的段内的和可以用预处理出的莫比乌斯函数前缀和求出。</p><p>初次涉及，觉得非常妙，自己想是绝不可能想到的，只能看题解，但据说是套路题，多做做，要有信心。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, a, b, d, tot;</span><br><span class="line"><span class="keyword">int</span> miu[N], sum[N], pri[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    miu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pri[++tot] = i, miu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pri[j] &lt;= <span class="number">50000</span>; j++) &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                miu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> miu[i * pri[j]] = -miu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50000</span>; i++) sum[i] = sum[i - <span class="number">1</span>] + miu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i = pos + <span class="number">1</span>) &#123;</span><br><span class="line">        pos = min(n / (n / i), m / (m / i));</span><br><span class="line">        ans += (sum[pos] - sum[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    get_prefix();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cal(a / d, b / d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 500 Div2</title>
      <link href="2018/07/31/Codeforces%20Round%20500%20Div2/"/>
      <url>2018/07/31/Codeforces%20Round%20500%20Div2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1013" target="_blank" rel="noopener">http://codeforces.com/contest/1013</a></p><h3 id="A-Piles-With-Stones"><a href="#A-Piles-With-Stones" class="headerlink" title="A. Piles With Stones"></a>A. Piles With Stones</h3><hr><p>题意：有 n 堆石子，每次你可以移走任意一堆里的一颗石子或将一堆里的部分石子移到另一堆。给出操作前的石子堆和操作后的石子堆，判断操作是否合理。</p><p>因为操作不能增加石子的总数，所以如果操作后的石子数大于操作前的就输出”No”，否则输出”Yes”。</p><h3 id="B-And"><a href="#B-And" class="headerlink" title="B. And"></a>B. And</h3><hr><p>题意：有 n 个数，x，每个数可以 xor x，求至少需要多少次异或，才能有至少两个数相等。</p><p>只存在 4 种情况：-1，0，1，2. 对于每个数 ai，如果异或后等于异或前，那么 C[ai]++ ; 否则 C[ai]++, D[ai ^ x]++。</p><p>从 0 到 100000 枚举 i，如果 C[i] &gt;= 2, ans 最小，是 0；如果 C[i] = 1, D[i] &gt; 0, ans 可能是 1；如果 C[i] = 0, D[i] &gt;= 2, ans 可能是 2.</p><h3 id="C-Photo-of-The-Sky"><a href="#C-Photo-of-The-Sky" class="headerlink" title="C. Photo of The Sky"></a>C. Photo of The Sky</h3><hr><p>题意：有 n 个坐标系上的点，这些点都在一个矩阵里。小 A 记录了它们的 x 坐标和 y 坐标，但顺序打乱了，现在要求你根据这些记录确定矩阵可能的最小面积。</p><p>有 2n 个数据，其中必定有 n 个 x 坐标，n 个 y 坐标。先排序。两种坐标必定各自在给出数据的一个区间内，设 x 坐标的区间为 [l, r], y 坐标的区间为 [p, q]。</p><p>若 l &gt; 1, r &lt; 2n, 那么 y 坐标的距离就是 a[2n] - a[1]，x 坐标的距离就是 a[r] - a[l]。因为 y 坐标的距离已经确定了，l 和 r 必然是越近越好，即 r = l + n - 1.</p><p>若 l = 1, 肯定是 r = l + n - 1, p = r + 1, q = 2n 最优。</p><p>比赛时还剩40分钟的样子，还是想出了关于区间的道理的，但打挂了：“l 和 r 必然是越近越好”的最优性没有考虑，导致了一系列奇奇怪怪无法分析的问题。。。</p><p>code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    ll ans = (a[n] - a[<span class="number">1</span>]) * (a[<span class="number">2</span> * n] - a[n + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) ans = min(ans, (a[i + n - <span class="number">1</span>] - a[i]) * (a[<span class="number">2</span> * n] - a[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Chemical-table"><a href="#D-Chemical-table" class="headerlink" title="D. Chemical table"></a>D. Chemical table</h3><hr><p>题意：给出一个 $n * m$ 的表格，表格上有一些初始点。若有这样的三个点：(r1, c1), (r1, c2), (r2, c1)，则由这三个点能生成出点 (r2, c2)。现问在初始点的基础上最少添加多少个点，能使得初始点和添加的点及它们生成出来的点能填满整个表格。</p><p>可以将每一个点看成是将所在的行和列联系起来。如此一来，对于 (r1, c1) + (r1, c2) + (r2, c1) ⇒ (r2, c2)，我们可以理解为：因为 r1 和 c1，r1 和 c2，r2 和 c1 都相应地联系起来了，那么 r2 和 c2 也联系起来了。所以我们只要把所有的行和列都联系起来，生成出来的点就能填满整个表格。那么问题就转换成问最少建立多少联结，能将所有的行和列都联系起来。可以用并查集解决。</p><p>code：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">int</span> fr = getfa(r), fc = getfa(c + n);</span><br><span class="line">        <span class="keyword">if</span> (fr != fc) fa[fr] = fc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root = getfa(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = getfa(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp != root) ans++, fa[tmp] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Hills"><a href="#E-Hills" class="headerlink" title="E. Hills"></a>E. Hills</h3><hr><p>题意：有一座城市，城市中有 n 座山，是从左到右按一行排列的，每座山有一个已知的高度 h，一座房子能在第 i 座山上建造，当且仅当 $h_{i - 1} &lt; h_i$ 且 $h_i &gt; h_{i + 1}$，现在这座城市的市长想对这些山进行修整，他们可以花一天的时间将某一座山的高度减掉1。现在，对于所有的k($1 \leq k \leq \lceil \frac{n}{2} \rceil$)，他们想知道最少需要多少天可以建造出 k 幢房子（除了调整山的高度外，其他时间一律不计）。</p><p>DP，设 $f[i][j][k]$ 表示现在 DP 到第 i 座山，前 i 座山里有 j 座可以建房子，状态为 k。</p><p>k = 0，表示第 i 座山和第 i - 1 座山都不建房子；</p><p>k = 1，表示第 i 座不建，第 i - 1 建；</p><p>k = 2，表示第 i 座建，第 i - 1 不建或第 i 座建。</p><p>不过为了方便编写，当我们在第 i 座山建房子时，对第 i + 1 座山的影响放在第 i + 1 位进行计算。</p><p>$f_{i, j, 0} = min(f_{i - 1, j, 0}, f_{i - 1, j, 1})$ 如果这一座山和前一座山都不是山峰的转移。 </p><p>$f_{i, j, 1} = f_{i - 1, j, 2} + max(0, h_i - (h_{i - 1} - 1))$ 这里是计算第 i − 1 座建房子是对第 i 座山的影响。 </p><p>$f_{i, j, 2} = min(f_{i - 1, j - 1, 0} + max(0, h_{i - 1} - (h_i - 1)), f_{i - 1, j - 1, 1} + max(0, min(h_{i - 2} - 1, h_{i - 1}) - (h_i - 1)))$ 这里是分两种情况考虑，当第 i − 2 座山也被拿来建房子时，要考虑第 i − 2 座山对第 i − 1 座山的影响与第 i 座山拿来建房子是对第 i − 1 座山的影响。如果第 i − 2 座山不拿来建房子，那就不用考虑了。</p><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, h[N], f[N][N][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = min(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = f[i - <span class="number">1</span>][j][<span class="number">2</span>] + max(<span class="number">0</span>, h[i] - (h[i - <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                f[i][j][<span class="number">2</span>] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] + max(<span class="number">0</span>, h[i - <span class="number">1</span>] - (h[i] - <span class="number">1</span>)), f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + max(<span class="number">0</span>, min(h[i - <span class="number">2</span>] - <span class="number">1</span>, h[i - <span class="number">1</span>]) - (h[i] - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n + <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, min(f[n][i][<span class="number">0</span>], min(f[n][i][<span class="number">1</span>], f[n][i][<span class="number">2</span>])));</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1951]-古代猪文</title>
      <link href="2018/07/27/%5BBZOJ1951%5D-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"/>
      <url>2018/07/27/%5BBZOJ1951%5D-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1951" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1951</a></p><p>题意：给定整数 q, n($1 \leq q, n \leq 10^9$)，计算 $q^{\sum_{d | n} C_{n}^d} mod 999911659$ 。</p><p>数论经典题！出现了很多知识点，值得回顾！</p><p>若 q = 999911659, 则上式结果为 0. 否则，因为 999911659 是质数，所以 q, 999911659 互质。由欧拉定理的推论得：</p><script type="math/tex; mode=display">q^{\sum_{d | n} C_n^d}\ mod\ 999911659 \equiv q^{\sum_{d | n} C_n^d\ mod\ 999911658}\ (mod\ 999911659)</script><p>因此，本题的关键是计算 $q^{\sum_{d | n} C_n^d mod 999911658} (mod 999911659)$</p><p>尝试分解质因数，可以发现 $999911658 = 2 <em> 3 </em> 4679 * 35617$ 。</p><p>我们可以枚举 n 的约数 d，然后运用 Lucas 定理求组合数 $C_n^d$ ，分别计算出 $\sum_{d | n} C_n^d$ 对 2, 3, 4679, 35617 四个质数的取模结果，记为 a1, a2, a3, a4。求组合数时，可以对于质数 p，预处理 p 以内的所有阶乘以及阶乘的模 p 乘法逆元，就能快速计算。</p><p>最后用中国剩余定理求解线性同余方程组：</p><script type="math/tex; mode=display">\left\{\begin{aligned}x\ mod\ 2\ =\ a1 \\x\ mod\ 3\ =\ a2 \\x\ mod\ 4679\ =\ a3 \\x\ mod\ 35617\ =\ a4 \\\end{aligned}\right.</script><p>再用快速幂求 $q^x$ 即可。</p><p>想了想还真是用了不少定理啊公式的！快速幂，Lucas 定理，扩展欧几里得，中国剩余定理，费马小定理求乘法逆元，惊叹❗️</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">999911659</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Q, n, Fac[<span class="number">4</span>][N], r[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % c;</span><br><span class="line">        a = a * a % c;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (Fac[p][m] * quick_pow(Fac[p][n] * Fac[p][m - n], T[p] - <span class="number">2</span>, T[p])) % T[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(a % T[p], b % T[p], p) * Lucas(a / T[p], b / T[p], p) % T[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exGcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exGcd(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll M = <span class="number">999911658</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ll x, y, Mi = M / T[i];</span><br><span class="line">        exGcd(Mi, T[i], x, y);</span><br><span class="line">        ans = (ans + Mi * x * r[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (Q == mod) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        Fac[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T[i]; j++) Fac[i][j] = Fac[i][j - <span class="number">1</span>] * j % T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (n % j == <span class="number">0</span>) &#123;</span><br><span class="line">                r[i] = (r[i] + Lucas(j, n, i)) % T[i];</span><br><span class="line">                <span class="keyword">if</span> (j * j != n) r[i] = (r[i] + Lucas(n / j, n, i)) % T[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, quick_pow(Q, CRT(), mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1733]-Parity game</title>
      <link href="2018/07/17/%5BPOJ1733%5D-Parity%20game/"/>
      <url>2018/07/17/%5BPOJ1733%5D-Parity%20game/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1733" target="_blank" rel="noopener">传送门</a></p><p>如果我们用 $sum$ 数组表示序列 $S$ 的前缀和， 那么在每个回答中：</p><ol><li>$S[l ~ r]$ 有偶数个 $1$，等价于 $sum[l - 1]$ 与 $sum[r]$ 奇偶性相同。</li><li>$S[l ~ r]$ 有奇数个 $1$，等价于 $sum[l - 1]$ 与 $sum[r]$ 奇偶性不同。</li></ol><p>好了，又是“相同”和“不同”，可以联系到“程序自动分析”那题，都是给定若干个变量和关系。</p><p>序列长度 $N$ 很大，但问题数 $M$ 较小，我们可以将每句话的两个整数 $l - 1$ 和 $r$ 离散化，缩小到等价的 $1$ ～ $2M$ 以内的范围。</p><p>解决本题有两种很好的方法，第一种解决方法是使用“边带权”的并查集。<br>边权 $d[x]$ 为 $0$，表示 $x$ 与 $fa[x]$ 奇偶性相同；为 $1$，表示 $x$ 与 $fa[x]$ 奇偶性不同。在路径压缩时，对 $x$ 到树根路径上的所有边权做异或操作，即可求出 $x$ 与树根的奇偶性关系。</p><p>对于每句话，设在离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$，设 $ans$ 表示这句话的奇偶性。</p><p>先检查 $x$ 和 $y$ 是否在同一个集合内（奇偶关系是否已知）、$getfa(x)$、$getfa(y)$ 都执行完成后，$d[x]$ xor $d[y]$ 即为 $x$ 和 $y$ 的奇偶性关系。若 $d[x]$ xor $d[y]$ 不等于 $ans$，则在该问题之后即可确定是假话。</p><p>若 $x$ 和 $y$ 不在同一个集合内，那么我们要合并。设两个集合的树根为 $p$ 和 $q$，要令 $p$ 为 $q$ 的子节点。已知 $d[x]$ 与 $d[y]$ 分别表示路径 $x$ ~ $p$ 与 $y$ ~ $q$ 之间所有边权的 xor 和，$p$ ~ $q$ 之间的 $d[p]$ 是待求的值，那么我们就用 $ans$ 去异或 $d[x]$ xor $d[y]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ans;</span><br><span class="line">&#125; query[N];</span><br><span class="line"><span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], fa[N &lt;&lt; <span class="number">1</span>], d[N &lt;&lt; <span class="number">1</span>], n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == fa[w]) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> root = getfa(fa[w]);</span><br><span class="line">    d[w] ^= d[fa[w]];</span><br><span class="line">    <span class="keyword">return</span> fa[w] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;query[i].l, &amp;query[i].r, str);</span><br><span class="line">        query[i].ans = (str[<span class="number">0</span>] == <span class="string">'o'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        a[++t] = query[i].l - <span class="number">1</span>;</span><br><span class="line">        a[++t] = query[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + t + <span class="number">1</span>);</span><br><span class="line">    n = unique(a + <span class="number">1</span>, a + t + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read_discrete();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].l - <span class="number">1</span>) - a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].r) - a;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(x), fy = getfa(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((d[x] ^ d[y]) != query[i].ans) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[fx] = fy, d[fx] = d[x] ^ d[y] ^ query[i].ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法更直观，是“扩展域”的并查集。</p><p>把每个变量的信息拆成两个节点 $x_{odd}$ 和 $x_{even}$ ，其中 $x_{odd}$ 表示 sum[x] 是奇数，$x_{even}$ 表示 sum[x] 是偶数。它俩也分别称为 x 的奇数域和偶数域。</p><p>对于每句话，设在离散化后 l - 1 和 r 的值分别是 x 和 y，设 ans 表示这句话的奇偶性。</p><p>若 ans = 0，则合并 $x_{odd}$ 与 $y_{odd}$ 、$x_{even}$ 与 $y_{even}$ ，表示 “x 为偶数” 与 “y 为偶数”、“x 为奇数” 与 “y 为奇数” 可以互相推出。</p><p>若 ans = 1，则合并 $x_{odd}$ 与 $y_{even}$ 、$x_{even}$ 与 $y_{odd}$ ，表示 “x 为奇数” 与 “y 为偶数”、“x 为偶数” 与 “y 为奇数” 可以互相推出。</p><p>考虑矛盾的话，跟上面一样的咯。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ans;</span><br><span class="line">&#125; query[N];</span><br><span class="line"><span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], fa[N &lt;&lt; <span class="number">1</span>], d[N &lt;&lt; <span class="number">1</span>], n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;<span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;query[i].l, &amp;query[i].r, str);</span><br><span class="line">        query[i].ans = (str[<span class="number">0</span>] == <span class="string">'o'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        a[++t] = query[i].l - <span class="number">1</span>;</span><br><span class="line">        a[++t] = query[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + t + <span class="number">1</span>);</span><br><span class="line">    n = unique(a + <span class="number">1</span>, a + t + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read_discrete();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].l - <span class="number">1</span>) - a;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, query[i].r) - a;</span><br><span class="line">        <span class="keyword">int</span> x_odd = x, x_even = x + n;</span><br><span class="line">        <span class="keyword">int</span> y_odd = y, y_even = y + n;</span><br><span class="line">        <span class="keyword">if</span> (query[i].ans == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getfa(x_odd) == getfa(y_even)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fa[getfa(x_odd)] = getfa(y_odd);</span><br><span class="line">            fa[getfa(x_even)] = getfa(y_even);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getfa(x_odd) == getfa(y_odd)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fa[getfa(x_odd)] = getfa(y_even);</span><br><span class="line">            fa[getfa(x_even)] = getfa(y_odd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 47</title>
      <link href="2018/07/15/Educational%20Codeforces%20Round%2047/"/>
      <url>2018/07/15/Educational%20Codeforces%20Round%2047/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1009" target="_blank" rel="noopener">http://codeforces.com/contest/1009</a></p><p>总结：codeforces比赛打得挺少，这次有几个问题，一是时间分配，二是心态。T3后来在比赛结束一分钟左右敲好了，但事后想起来因为太紧张导致好几次提交错误，浪费时间。还有因为是英文题面，不能像中文题面那样很快地来回反复找信息，在预览题目时忽略了部分信息导致我对题目难度预估出错，在T2上花了大量的时间后才意识到T3是水题。</p><h3 id="A-Game-Shopping"><a href="#A-Game-Shopping" class="headerlink" title="A. Game Shopping"></a>A. Game Shopping</h3><hr><p>题意不想放。。傻题，两个指针从左到右就好了。</p><h3 id="B-Minimum-Ternary-String"><a href="#B-Minimum-Ternary-String" class="headerlink" title="B. Minimum Ternary String"></a>B. Minimum Ternary String</h3><hr><p>题意：有一个三进制的字符串由 ‘0’ ，’1’， ‘2’ 组成。我们每次可以交换相邻的两个字符的条件是这两个为 ‘0’, ‘1’ 或为 ‘1’, ‘2’。<br>求该字符串的最小字典序。例如，201 的最小字典序为 120。</p><p>被题目绕了差不多一个小时？。。。。。总时间只有2小时啊。。。。。<br>这种贪心题目容易产生很多具有误导性的错误贪心算法，一开始我想的是找到连续的一个块由 ‘0’, ‘1’ 组成或 ‘1’, ‘2’ 组成，将块里所有较小的字符归到左边，较大的字符归到右边。</p><p>这题还有一个坑点就是，如果不找到正确贪心算法，那么思考时，区间会被多次进行找块、换位的操作，这个弯绕不过去，这应该也是多数贪心具有的特点。我根据一开始的想法写，多次区间的操作这点达不到，就wa了。。。</p><p>正解非常优美，发现 1 畅通无阻，可以任意移动，0 和 2 不可能交换相对位置，例如 0 在 2 前面，那么就不可能通过移动达到 0 在 2 后面。</p><p>为了达到字典序最小，第一个 2 前的 0 们应该移到最前面，所有的 1 都要移到第一个 2 前面，第一个 2 前面的 0 们的后面，第一个 2 后面的 0 和 2 保持不变。</p><p>然后，要注意整个序列没有 2 的情况。</p><p>结果，知道算法还写挂了。。。。被 hack 的感觉就是这样的吗？（因为我判断，如果序列里有 2 ，就在输出第一个 2 前面的元素后输出一个 2。有无 2 都从第一个 2 的位置（如果没有就是 n）开始 for 到 n，输出所有不是 1 的元素，但如果序列里没有 2，n 的位置上又是 0，岂不是多输了一个 0。）</p><h3 id="C-Annoying-Present"><a href="#C-Annoying-Present" class="headerlink" title="C. Annoying Present"></a>C. Annoying Present</h3><hr><p>题意：一个长度为 n 的数组（初始全为0），进行 m 次操作。<br>操作：给你 m 个 x、d，你任意挑选一个 i (1~n)，每个数字加上 x + |i - j| * d（ j 表示对应数字的下标）<br>问 m 次操作后的最大算术平均值为多少？</p><p>水题，一看就有想法（。。。）首先每个位置的数组都应加上 $\sum_{i = 1}^n x_i$ ，然后考虑 1 ～ m 的 d，若 &lt; 0 ，那么只能对整个序列的平均值产生不好的影响，我们应该把这种影响降到最低，也就是 $d * (\sum_{j = 1}^n |pos - j|)$ 最小，那么 pos 肯定是越靠中间越好，即 n 或 1；若 d &gt; 0 ，那么肯定 pos 越靠两边越好。提前记录 n 到每个位置的距离和与 (n + 1) / 2 到每个位置的距离和即可。注意 long long。</p><h3 id="D-Relatively-Prime-Graph"><a href="#D-Relatively-Prime-Graph" class="headerlink" title="D. Relatively Prime Graph"></a>D. Relatively Prime Graph</h3><hr><p>题意：构造一个 n 个点 m 条边的图，要求：图联通，GCD(u，v) = 1， u 、 v之间才可以建边。节点分别为 1 ～ n。</p><p>由欧拉函数表 $\phi(n)$ 可得，573以内互质的对数就已经超过 1e5 了，暴力枚举即可。</p><p>首先 1 到任何点都可以连一条边，这样就能保证图连通了。接着再根据上面的结论，确定该算法不会超时。</p><p>当然这需要足够的数感和估算技巧(?)</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; ans.size() &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; ans.size() &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (__gcd(i, j) == <span class="number">1</span>)</span><br><span class="line">                ans.push_back(make_pair(i, j));</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n - <span class="number">1</span> || ans.size() &lt; m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Possible\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)ans.size(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i].first, ans[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="E-Intercity-Travelling"><a href="#E-Intercity-Travelling" class="headerlink" title="E. Intercity Travelling"></a>E. Intercity Travelling</h3><hr><p>题意：Leha从数轴的 0 到 n ，中间的整数点都有可能有休息点也可能没有休息点。当你连续坐 k 站时，每两站间的疲劳值为 a1, a2 …… ak，如果第 k 站有休息点，那么你可以在此处休息，然后接下来的站点的疲劳值又从 a1 开始，否则继续为 ak + 1。题目给你 n 和 ai，每个站点有休息点的概率都是 1/2，问你期望值 * 2 ^ (n - 1) 的值。</p><p>我们知道从 0 到 1 的疲劳值必定为 a1，从 1 到 2 的疲劳值为 a1(1 / 2) 或 a2(1 / 2) ，从 2 到 3 的疲劳值为 a1(1 / 2) , a2(1 / 4), </p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ1201]-Intervals</title>
      <link href="2018/07/11/%5BPOJ1201%5D-Intervals/"/>
      <url>2018/07/11/%5BPOJ1201%5D-Intervals/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/POJ-1201" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-1201</a></p><p>题意：从 0 ～ 50000 中选出尽量少的整数，使每个区间 $[a_i, b_i]$ 内都有至少 $c_i$ 个数被选。</p><p>分析条件：<br>设 $s[k]$ 表示 0 ～ k 之间最少选出多少个数，那么：</p><script type="math/tex; mode=display">s[b_i] - s[a_i - 1] \geq c_i</script><p>超级明显的差分约束系统？</p><p>那么，我们还要创造一些初始化的条件，可以根据题目中隐含的条件来：</p><ol><li>$s[k] - s[k - 1] \geq 0$</li><li>$s[k] - s[k - 1] \leq 1$</li></ol><p>因此，我们把 -1 ～ 50000 这 50002 个整数分别作为图中的节点，从每个 k - 1 到 k 连长度为 0 的有向边， k 到 k - 1 连长度为 -1 的有向边，从每个 $a_i - 1$ 到 $b_i$ 连长度为 $c_i$ 的有向边。</p><p>当然，我们也可以取 $a_i - 1$ 的最小值 Min，$b_i$ 的最大值 Max，然后从 Min 到 Max 连初始边。求完后，s[Max] 即为答案。</p><p>不过，既然与区间有关，应该也可以用贪心求解，并用数据结构进行优化，可以考虑一下。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, dis[N], inq[N], Min = inf, Max = -inf;</span><br><span class="line"><span class="keyword">int</span> to[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v, nxt[cnt] = lnk[u], lnk[u] = cnt, val[cnt] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Min; i &lt;= Max; i++) dis[i] = -inf;</span><br><span class="line">    dis[Min] = <span class="number">0</span>;</span><br><span class="line">    inq[Min] = <span class="number">0</span>;</span><br><span class="line">    q.push(Min);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &lt; dis[u] + val[i]) &#123;</span><br><span class="line">                dis[y] = dis[u] + val[i];</span><br><span class="line">                <span class="keyword">if</span> (!inq[y]) &#123;</span><br><span class="line">                    q.push(y);</span><br><span class="line">                    inq[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b + <span class="number">1</span>, c);</span><br><span class="line">        Min = min(Min, a);</span><br><span class="line">        Max = max(Max, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Min; i &lt; Max; i++) &#123;</span><br><span class="line">        add(i, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[Max]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2012]-疫情控制</title>
      <link href="2018/07/10/%5BNOIP2012%5D-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/"/>
      <url>2018/07/10/%5BNOIP2012%5D-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>挺妙（烦）的！</p><p>大致思路很好构建：二分答案，贪心上跳。跳不到根的就让它停在那，能跳到的就要考虑互相救助了。</p><p>但是怎么知道，如果我选择救助别的子树，情况会不会变劣？</p><p>有个很重要的结论：如果我到根后剩余的步数小于我从根走回到所在子树的距离，那我就不跳到根，留在差一步的子树顶。这个还挺容易 yy，因为会使后面更大的剩余步数浪费掉。否则那我就跳呗。</p><p>可是为什么我跳，答案不会变劣？</p><p>其实是要分类讨论的。将需要救助的子树顶到根的距离排序，将剩余步数排序。剩余步数排名和需要救助的步数排名一一对应，显然不劣；错开，发现就影响中间一段；而前者比后者好的时候显然不劣；前者比后者差的情况根本就不存在，因为大小关系不对劲。</p><p>所以就跳！</p><p>证明还挺容易，但是怎么想到啊 /kk</p><p><a href="https://www.luogu.com.cn/record/42699241" target="_blank" rel="noopener">$Code$</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ1977]-次小生成树</title>
      <link href="2018/07/10/%5BBZOJ1977%5D-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>2018/07/10/%5BBZOJ1977%5D-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1977" target="_blank" rel="noopener">传送门</a></p><p>题意：给定一张 $n$ 点 $m$ 边的无向图，求无向图的严格次小生成树的边权之和。</p><p>首先求出最小生成树的边权之和 $sum$。我们称最小生成树的 $n - 1$ 条边为树边，剩余 $m - n + 1$ 条边为非树边。</p><p>把一条非树边 $(x, y, z)$ 加入到最小生成树中，会与树上 $x$, $y$ 之间的路径形成一个环。设树上 $x$, $y$ 之间的路径上的最大边权为 $val1$，严格次大边权为 $val2$。</p><p>若 $z &gt; val1$, 则把 $val1$ 对应的那条边替换成 $(x, y, z)$ 这条边，就得到了严格次小生成树的一个候选答案，边权之和为 $sum - val1 + z$ 。</p><p>若 $z = val1$, 则把 $val2$ 对应的那条边替换成 $(x, y, z)$ 这条边，就得到了严格次小生成树的一个候选答案，边权之和为 $sum - val2 + z$ 。</p><p>如上述枚举所有非树边，计算出所有候选答案，取最小值即为本题所求。</p><p>那么现在的问题就是：如何快速求出一条路径上的最大边权与严格次大边权。</p><p>可以用树上倍增算法来进行预处理。设 $F[x, k]$ 表示 $x$ 的 $2^k$ 祖先，$G[x, k, 0]$ 与 $G[x, k, 1]$ 分别表示 $x$ 到 $F[x, k]$ 的路径上的最大边权和严格次大边权。于是 $k \in [1, log N]$ 有：</p><script type="math/tex; mode=display">F[x, k] = F[F[x, k - 1], k - 1]</script><script type="math/tex; mode=display">G[x, k, 0] = max(G[x, k - 1, 0], G[F[x, k - 1], k - 1, 0])</script><script type="math/tex; mode=display">G[x, k, 1] = max(G[x, k - 1, 1], G[F[x, k - 1], k - 1, 1])</script><p>如果 $G[x, k - 1, 0] \neq G[F[x, k - 1], k - 1, 0]$ ， 那么：</p><script type="math/tex; mode=display">G[x, k, 1] = max(G[x, k, 1], min(G[x, k - 1, 0], G[F[x, k - 1], k - 1, 0]))</script><p>当 $k = 0$ 时，有初值：</p><script type="math/tex; mode=display">F[x, 0] = father(x)</script><script type="math/tex; mode=display">G[x, 0, 0] = edge(x, father(x))</script><script type="math/tex; mode=display">G[x, 0, 1] = -\infty</script><p>接下来，我们考虑每条非树边 $(x, y, z)$ ，采用倍增 LCA 的框架，$x$、$y$ 每向上移动一段路径，就将该路径对应的最大边权和严格次大边权按照与求 $G$ 数组类似的方法合并到答案中。</p><p>$O(M log N)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, o, minn = inf;</span><br><span class="line"><span class="keyword">int</span> to[M &lt;&lt; <span class="number">1</span>], nxt[M &lt;&lt; <span class="number">1</span>], val[M &lt;&lt; <span class="number">1</span>], lnk[N], cnt;</span><br><span class="line"><span class="keyword">int</span> fa[N], d[N], f[N][<span class="number">20</span>], G[N][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = y, val[cnt] = z, nxt[cnt] = lnk[x], lnk[x] = cnt;</span><br><span class="line">    to[++cnt] = x, val[cnt] = z, nxt[cnt] = lnk[y], lnk[y] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;<span class="keyword">return</span> fa[w] == w ? w : fa[w] = getfa(fa[w]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;<span class="keyword">return</span> a.z &lt; b.z;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(e[i].x), fy = getfa(e[i].y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        sum += e[i].z;</span><br><span class="line">        add(e[i].x, e[i].y, e[i].z);</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">            G[y][<span class="number">0</span>][<span class="number">0</span>] = val[i];</span><br><span class="line">            G[y][<span class="number">0</span>][<span class="number">1</span>] = -inf;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beizeng</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            G[j][i][<span class="number">0</span>] = max(G[j][i - <span class="number">1</span>][<span class="number">0</span>], G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            G[j][i][<span class="number">1</span>] = max(G[j][i - <span class="number">1</span>][<span class="number">1</span>], G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (G[j][i - <span class="number">1</span>][<span class="number">0</span>] != G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                G[j][i][<span class="number">1</span>] = max(G[j][i][<span class="number">1</span>], min(G[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>][<span class="number">0</span>], G[j][i - <span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> t = d[x] - d[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; t) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> xy, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx1 = <span class="number">0</span>, mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dis = d[x] - d[xy];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[x][i][<span class="number">0</span>] &gt; mx1) mx2 = mx1, mx1 = G[x][i][<span class="number">0</span>];</span><br><span class="line">            mx2 = max(mx2, G[x][i][<span class="number">1</span>]);</span><br><span class="line">            x = f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx1 != v) minn = min(minn, v - mx1);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        minn = min(minn, v - mx2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    kruskal();</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    beizeng();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].x, y = e[i].y, xy = lca(x, y);</span><br><span class="line">        calc(x, xy, e[i].z), calc(y, xy, e[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum + minn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唉，话说这篇代码真让我调得够呛。。。WA了六发不止。。。最后发现大概是计算 F 数组和 G 数组还有 beizeng() 预处理函数的问题，另外 lca 刚开头深度的比较与调换也错了。。。</p><p>不过！趁机学习了一发对拍～～～还是很有收获滴～～～</p><p>调试变难了不仅是错误百出的原因，还有最近图论不是很熟悉，因为图论本就是抽象的概念，但多做题一定会有所改善的！已经感觉到了= =</p>]]></content>
      
      
      
        <tags>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2007]-树网的核</title>
      <link href="2018/07/10/%5BNOIP2007%5D-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/"/>
      <url>2018/07/10/%5BNOIP2007%5D-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1999" target="_blank" rel="noopener">传送门</a></p><p>题意：说不清。。。看原题吧?</p><p>NOIP 数据可以直接上朴素算法，$O(n^3)$ 。首先通过两次 BFS 或 DFS 求出树的直径，然后在直径上枚举距离不超过 $s$ 的两个点 $p$ 和 $q$ ，$p$、$q$ 之间的路径就是树网的核。先将核上的每个节点标记为“已访问”，然后从核上的每个节点出发，执行深搜，求出偏心距最大值即为偏心距。</p><p>稍加观察，$p$、$q$ 之间的距离肯定是越大越好，所以只要枚举 $p$ 就行了，$q = p + s$。 $O(n^2)$ 。</p><p>然鹅这样还是过不了 BZ 的数据。。</p><p>发现，本题的答案具有单调性，可以二分答案，把问题转化为“验证是否存在一个核，其偏心距不超过二分的值 $mid$” 。</p><p>设直径的两个端点为 $u$ 和 $v$ ，在直径上找到与 $u$ 的距离不超过 $mid$ 的前提下，距离最远的节点，作为节点 $p$。类似地找到与 $v$ 的距离不超过 $mid$ 的前提下，距离最远的节点，作为节点 $q$。</p><p>根据直径的最长性（标黑加粗！），任何从 $u$、$p$ 之间分叉离开直径的子树，其最远点与 $p$ 的距离都不会比 $u$ 更远。所以 $p$、$q$ 就是满足直径两侧的那部分节点偏心距不超过 $mid$ 的前提下、尽量靠近树网中心的节点。</p><p>接下来就是检查 $p$、$q$ 的距离是否不超过 $$s ，同时用深搜检查离核最远的点的距离是否也不超过 $s$。如果两个条件都满足，$p$、$q$ 之间的路径就是偏心距不超过 $mid$ 的一个合法的核。</p><p>该算法 $O(n log SUM)$ ，其中 $SUM$ 表示树网所有边的长度之和。</p><p>据说还有一个 $O(n)$ 的算法。算出 $d[u_i]$ ，表示从每一个直径上的节点 $u1$ ~ $ut$ ，不经过直径上的其他节点，能够到达的最远点的距离。</p><p>所以实际上答案是：</p><script type="math/tex; mode=display">max(max_{i \leq k \leq j}\{d[u_k]\}, dist(u_1, u_i), dist(u_j, u_t))</script><p>由于直径的最长性（标黑加粗！），上式其实可简化为：</p><script type="math/tex; mode=display">max(max_{1 \leq k \leq t}\{d[u_k]\}, dist(u_1, u_i), dist(u_j, u_t))</script><p>$max_{1 \leq k \leq t}\{d[u_k]\}$ 是定值，可以直接算出。</p><p>所以最后只要用指针计算后两项，单调递增，$O(n)$ ！！</p><p>所以说，算法从某种程度上，设计、优化是永无止境的啊，一定要多动脑，不要满足于AC。</p><p>$O(n log SUM)$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, cnt, fa[N], fc[N], dep[N], idx[N], sum[N];</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, val;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; nxt[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nxt[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[nxt[u][i].to] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dep[nxt[u][i].to] = dep[u] + nxt[u][i].val;</span><br><span class="line">                fa[nxt[u][i].to] = u, fc[nxt[u][i].to] = nxt[u][i].val;</span><br><span class="line">                q.push(nxt[u][i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_dia</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">    q.push(x), dep[x] = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &lt; dep[i]) x = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = x; l &lt; cnt &amp;&amp; y &gt;= sum[l + <span class="number">1</span>] - sum[l]; l++)</span><br><span class="line">        y -= sum[l + <span class="number">1</span>] - sum[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = x; r &gt; <span class="number">1</span> &amp;&amp; y &gt;= sum[r] - sum[r - <span class="number">1</span>]; r--)</span><br><span class="line">        y -= sum[r] - sum[r - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum[r] - sum[l] &lt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        nxt[u].push_back((edge)&#123;v, w&#125;), nxt[v].push_back((edge)&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = find_dia(<span class="number">1</span>), t = find_dia(s), k = t;</span><br><span class="line">    <span class="keyword">for</span> (idx[++cnt] = k; k != s; k = fa[k]) &#123;</span><br><span class="line">        idx[++cnt] = fa[k], sum[cnt] = sum[cnt - <span class="number">1</span>] + fc[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = dep[t];</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) q.push(idx[i]), dep[idx[i]] = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l = max(l, dep[i]);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2010]-巡逻</title>
      <link href="2018/07/10/%5BAPIO2010%5D-%E5%B7%A1%E9%80%BB/"/>
      <url>2018/07/10/%5BAPIO2010%5D-%E5%B7%A1%E9%80%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/HYSBZ-1912" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1912</a></p><p>题意：有 n 个村庄编号 1 ～ n ，有 n - 1 条双向道路连接它们，长度均为 1 个单位。编号为 1 的村庄里设立了警察局，巡警车每天从警察局出发，到所有的路上巡逻，最后回到警察局。每条道路都需要经过两次。现在为了减少总的巡逻距离，该地区准备在这些村庄之间建立 K 条新的道路，一条新道路甚至可以是一个环。由于资金有限，K 只能是 1 或 2。巡警车必须经过新建的道路正好一次。</p><p>不建立新的道路时，路线总长度为 2(n - 1) 。建立一条新道路后，因为新道路必须经过刚好一次，所以在沿着新道路 (x, y) 巡逻后，就必须沿着树上从 y 到 x 的路径巡逻一遍，最终形成一个环。相当于树上 x 与 y 之间的两条路径都只需经过一次了。</p><p>因此，当 K = 1 时，我们找到树的最长链（$L_1$），在两个端点之间加一条新道路，就是答案。若树的直径为 L ，答案就是 2(n - 1) - (L - 1) 。</p><p>当 K = 2 时，我们要再找一条最长链（$L_2$）。但这时如果两条新道路形成的环重叠，重叠部分就不会被巡逻到。但由于题目说每条道路必须被巡逻，所以在恰当的时刻重叠部分会被巡逻两遍，对答案没有贡献。</p><p>综上所述，我们得到如下算法：</p><ol><li>再最初的树上求直径，记为 $L_1$ ，然后把直径上的标记取反（从 1 改为 -1）；</li><li>再最长链标记取反的树上再次求直径，记为 $L_2$ 。</li></ol><p>答案就是 $2(n - 1) - (L_1 - 1) - (L_2 - 1)$ 。</p><p>为什么取反能正确处理重叠部分呢？</p><p>因为如果 $L_2$ 包含 $L_1$ 取反的部分，就相当于两个环重叠，最初重叠的部分需要经过两次；减掉 $L_1 - 1$ 后，重叠的部分变成了只需经过一次；减掉 $L_2 - 1$ 后，负负得正，相当于把重叠的部分加回来，变回了“需要经过两次”。</p><p>$O(n)$</p><p>这题主要是注意 dfs 取树直径部分的代码，还有记录直径的方法，思维上注意取反抵消的方法。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, tot, cnt = <span class="number">1</span>, dia, mx;</span><br><span class="line"><span class="keyword">int</span> lnk[N];</span><br><span class="line"><span class="keyword">int</span> s1[N], s2[N];  <span class="comment">// 存第一次树直径的路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v;</span><br><span class="line">&#125;e[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = v, e[cnt].next = lnk[u], lnk[u] = cnt, e[cnt].v = <span class="number">1</span>;</span><br><span class="line">    e[++cnt].to = u, e[cnt].next = lnk[v], lnk[v] = cnt, e[cnt].v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx1 = <span class="number">0</span>, mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[x]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v + dfs(e[i].to, x);</span><br><span class="line">            <span class="keyword">if</span> (v &gt; mx1) mx2 = mx1, mx1 = v, s2[x] = s1[x], s1[x] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; mx2) mx2 = v, s2[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx1 + mx2 &gt; dia) dia = mx1 + mx2, mx = x;</span><br><span class="line">    <span class="keyword">return</span> mx1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    tot = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    tot = tot - dia + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">2</span>) &#123;</span><br><span class="line">        dia = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1[mx]; i; i = s1[e[i].to]) e[i].v = e[i ^ <span class="number">1</span>].v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s2[mx]; i; i = s1[e[i].to]) e[i].v = e[i ^ <span class="number">1</span>].v = <span class="number">-1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tot = tot - dia + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018 Training 2</title>
      <link href="2018/07/02/NOIP%202018%20Training%202/"/>
      <url>2018/07/02/NOIP%202018%20Training%202/</url>
      
        <content type="html"><![CDATA[<h3 id="A-ksum"><a href="#A-ksum" class="headerlink" title="A. ksum"></a>A. ksum</h3><hr><p>题意：有一个大小为 n 的正整数数组，算出这个数组的所有字段和，并将这 n(n + 1) / 2 个数降序排列，输出前 k 个数。</p><p>优先队列存储子段和，因为是正整数，所以用缩减的方法，每次取队首，前缀和算出 (L + 1, R) 和 (L, R - 1)，再次入队。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, k, tot, a[N];</span><br><span class="line">ll sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll l, r;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> val &lt; x.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(node x)</span> </span>&#123;</span><br><span class="line">    ll num = <span class="number">1l</span>l * x.l + <span class="number">1l</span>l * x.r * <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mp.count(num)) &#123;</span><br><span class="line">        mp[num] = <span class="number">1</span>;</span><br><span class="line">        pq.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;= x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("ksum.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("ksum.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    node x;</span><br><span class="line">    x.l = <span class="number">1</span>, x.r = n, x.val = sum[n];</span><br><span class="line">    push_heap(x);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        node u = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        ans[++tot] = u.val;</span><br><span class="line">        <span class="keyword">if</span> (tot == k) <span class="keyword">break</span>;</span><br><span class="line">        ll l = u.l, r = u.r;</span><br><span class="line">        node x, y;</span><br><span class="line">        x.l = l + <span class="number">1</span>, x.r = r, x.val = sum[x.r] - sum[x.l - <span class="number">1</span>];</span><br><span class="line">        y.l = l, y.r = r - <span class="number">1</span>, y.val = sum[y.r] - sum[y.l - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r &amp;&amp; in(l + <span class="number">1</span>, r)) push_heap(x);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r - <span class="number">1</span> &amp;&amp; in(l, r - <span class="number">1</span>)) push_heap(y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans + <span class="number">1</span>, ans + tot + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-label"><a href="#B-label" class="headerlink" title="B. label"></a>B. label</h3><hr><p>题意：有一棵大小为 n 的树，节点编号为 1 ～ n，我们给树上的每一个节点赋一个 [1, m] 之间的权值，并使得有边直接相连的两个节点的权值之差的绝对值 &gt;= K。求有多少种不同的赋值方法，答案对 $10^9 + 7$ 取模。</p><p>先考虑第一档部分分，很明显的树形DP，$F_{i, j}$ 表示第 i 个节点赋值为 j 的方案数。可得：</p><script type="math/tex; mode=display">F_{i, j} = \prod (\sum F_{Son(i), k})</script><p>其中 $|j - k| \geq K$</p><p>第二档也很好办，前缀和优化，每次减去 (j - K) ~ (j + K) 的不符合区间。</p><p>然而 $m \leq 10^9$ 实在太大了。<br>我们发现，对于叶节点，$F_{i, j}$ 均为 1；对于叶节点的父亲节点，F 的值在下标为 [K, m - K] 范围内相同，而在两边对称。进而发现，每一个节点的 F 值都是这样分布的。两边对称值的个数与它到距离最远的后代叶子节点有关。假设这个距离是 x ，那么对称值的个数不超过 xK。</p><p>于是我们得到了一个优化的方法，j 的范围只要取到 $min(m, (n - 1) * k)$</p><p>$O(n^2*k)$ </p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> T, n, m, k, x, y, l, ans, f[<span class="number">105</span>][<span class="number">10005</span>], u[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * b % mo;</span><br><span class="line">        b = b * b % mo;</span><br><span class="line">    &#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">// 计算f[x][y],f[x][y + 1]...f[x][m]</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= l; i++) sum = (sum + f[x][i]) % mo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= m - l + <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= l || i &lt; y) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum = (sum + f[x][m - i + <span class="number">1</span>]) % mo;  <span class="comment">// 对称计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = max(y, l + <span class="number">1</span>), R = m - l;</span><br><span class="line">    <span class="keyword">if</span> (R &gt;= L) sum = (sum + <span class="number">1l</span>l * (R - L + <span class="number">1</span>) * f[x][l]) % mo;  <span class="comment">// 中间部分</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) f[x][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(nxt[x][i], x);</span><br><span class="line">        y = calc(nxt[x][i], k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k) y += f[nxt[x][i]][j - k], y %= mo;</span><br><span class="line">            f[x][j] = <span class="number">1l</span>l * f[x][j] * y % mo;</span><br><span class="line">            <span class="keyword">if</span> (j + k &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + k &lt;= l) y -= f[nxt[x][i]][j + k];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + k &gt; m - l) y -= f[nxt[x][i]][m - j - k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    y -= f[nxt[x][i]][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("label.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen("label.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            nxt[x].push_back(y), nxt[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        l = min(m, (n - <span class="number">1</span>) * k);</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!k) ans = quick_pow(m, n);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//  将1作为根</span></span><br><span class="line">            ans = calc(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-square"><a href="#C-square" class="headerlink" title="C. square"></a>C. square</h3><hr><p>题意：有一个大小为 $n * m$ 的方格图，有的方格为 1，有的方格为 0。T次询问一个区间，区间左上角(x1, y1) ，右下角(x2, y2) 。求给出区间中最大的全为 1 的正方形的边长。</p><p>分情况讨论，1.正方形四边不靠给定区间 2.正方形两边靠给定区间。用DP，或者二分判定边长，好像是这样。。</p><p>没有写，有想法再回来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018 Training 1</title>
      <link href="2018/06/23/NOIP%202018%20Training%201/"/>
      <url>2018/06/23/NOIP%202018%20Training%201/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Count-Good-Prefixes"><a href="#A-Count-Good-Prefixes" class="headerlink" title="A. Count Good Prefixes"></a>A. Count Good Prefixes</h3><p><a href="https://vjudge.net/problem/CodeChef-GOODPREF" target="_blank" rel="noopener">https://vjudge.net/problem/CodeChef-GOODPREF</a></p><p>给定整数 n 和字符串 s，字符串仅包含‘a’和‘b’两种字符。考虑字符串 t = s + s + · · · + s，即将 s 重复 n 遍得到的字符串。<br>请求出 t 有多少非空前缀满足其中‘a’的出现次数严格多余‘b’的出现次数。$1 \leq n \leq 10^9$ 。</p><p>可以证明代码中的做法是不会超时的：可以发现字符串长度很小，$10^3$ ，如果一遍下来 a 字符数已经大于 b 字符数了，那么长度遍过后 b 字符数无论在字符的哪一个位置都不能赶上 a 了，跳出循环；若 b 字符数大于 a 字符数了，一样操作；若相等，那么只要将字符所有位置中 a 字符数大于 b 字符数的情况数乘上剩下的遍数即可，跳出循环。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, freq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (freq--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            ret *= freq + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a - b &gt; n) &#123;</span><br><span class="line">            ret += <span class="number">1l</span>l * n * freq;  <span class="comment">// freq 在 while 循环中是递减的！</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b - a &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s + <span class="number">1</span>, &amp;freq);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Andryusha-and-Colored-Balloons"><a href="#B-Andryusha-and-Colored-Balloons" class="headerlink" title="B. Andryusha and Colored Balloons"></a>B. Andryusha and Colored Balloons</h3><p><a href="https://vjudge.net/problem/CodeForces-781A" target="_blank" rel="noopener">https://vjudge.net/problem/CodeForces-781A</a></p><p>大概就是用尽量少的颜色给一棵树染色，相邻三个节点颜色不能相同。记录一下父节点和祖父节点的颜色就好了。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt[N];</span><br><span class="line"><span class="keyword">int</span> color[N], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] != fa) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt == color[x] || cnt == color[fa]) cnt++;</span><br><span class="line">            color[nxt[x][i]] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nxt[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (nxt[x][i] != fa) dfs(nxt[x][i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        nxt[u].push_back(v);</span><br><span class="line">        nxt[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    color[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = max(ans, color[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, color[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Median-Sum"><a href="#C-Median-Sum" class="headerlink" title="C. Median Sum"></a>C. Median Sum</h3><p><a href="https://vjudge.net/problem/AtCoder-3857" target="_blank" rel="noopener">https://vjudge.net/problem/AtCoder-3857</a></p><p>有 n 个数，那么考虑每一个数取或不取，共有 $2^n - 1$ 种和，求其中的中值。</p><p>用 bitset 来表示每一个数能否被表示成 n 个数中任意个数的和的形式，能，1；不能，0。<br>例如 n = 2 ，两个数分别为 3 和 5，那么这个 bitset 中第 3 位和第 5 位为 1，第 8 位也为 1，而第 8 位赋值方法是 3 &lt;&lt; 5。</p><p>中位数在 $\lceil \frac{\sum\limits_{i=1}^nA_i}{2} \rceil$ 后面一点点的证明：<a href="https://blog.csdn.net/zzzzone/article/details/79115522" target="_blank" rel="noopener">传送门</a></p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, tot, ans;</span><br><span class="line"><span class="built_in">bitset</span>&lt;4000005&gt; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    bit.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        bit = bit | (bit &lt;&lt; x);</span><br><span class="line">        tot += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ans = (tot + <span class="number">1</span>) / <span class="number">2</span>; !bit[ans]; ans++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Salvage-Robots"><a href="#D-Salvage-Robots" class="headerlink" title="D. Salvage Robots"></a>D. Salvage Robots</h3><p><a href="https://vjudge.net/problem/AtCoder-2045" target="_blank" rel="noopener">https://vjudge.net/problem/AtCoder-2045</a></p><p>有一张 $h <em> w$ 的地图，上面有 $h </em> w$ 个格子，格子里为 o 的表示有机器人，为 E 的表示是出口。每次你可以将所有机器人向上下左右任意一个方向移动一步（注意是所有机器人），碰到出口的机器人获救，碰到墙壁的或在墙壁外面的机器人死亡。求最多可以救多少个机器人，无步数限制。</p><p>因为运动是相互的，所以移动机器人就相当于移动墙壁和出口。</p><p>file:///Users/imily/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-23%20%E4%B8%8B%E5%8D%882.29.45.png</p><p>由此图得：</p><p>file:///Users/imily/Desktop/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-23%20%E4%B8%8B%E5%8D%882.35.03.png</p><p>红色部分表示已经死亡的区域。最终我们用 $f_{a, b, c, d}$ 表示坐标(a, b) 到坐标(c, d) 得矩阵已经走完获得的机器人，每次转移时向上下左右某个方向扩展一行即可。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> r[N][N], c[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N * N &gt;&gt; <span class="number">2</span>][N * N &gt;&gt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h, w, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> M)</span> </span>&#123;<span class="keyword">return</span> r * M + l;&#125;  <span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    x = max(x, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> lX, <span class="keyword">int</span> rX, <span class="keyword">int</span> lY, <span class="keyword">int</span> rY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cX = encode(lX, rX, X), cY = encode(lY, rY, Y);</span><br><span class="line">    <span class="keyword">if</span> (f[cX][cY] &gt;= <span class="number">0</span>) <span class="keyword">return</span> f[cX][cY];</span><br><span class="line">    f[cX][cY] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lX &lt; X - <span class="number">1</span>)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX + <span class="number">1</span>, rX, lY, rY) + (rX + <span class="number">1</span> &lt;= X - lX - <span class="number">1</span> ? max(<span class="number">0</span>, r[X - lX - <span class="number">1</span>][min(Y + rY, w - lY)] - r[X - lX - <span class="number">1</span>][max(Y - lY, rY + <span class="number">1</span>) - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rX &lt; h - X)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX + <span class="number">1</span>, lY, rY) + (X + rX + <span class="number">1</span> &lt;= h - lX ? max(<span class="number">0</span>, r[X + rX + <span class="number">1</span>][min(Y + rY, w - lY)] - r[X + rX + <span class="number">1</span>][max(Y - lY, rY + <span class="number">1</span>) - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (lY &lt; Y - <span class="number">1</span>)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX, lY + <span class="number">1</span>, rY) + (rY + <span class="number">1</span> &lt;= Y - lY - <span class="number">1</span> ? max(<span class="number">0</span>, c[min(X + rX, h - lX)][Y - lY - <span class="number">1</span>] - c[max(X - lX, rX + <span class="number">1</span>) - <span class="number">1</span>][Y - lY - <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rY &lt; w - Y)</span><br><span class="line">        chkmax(f[cX][cY], dfs(lX, rX, lY, rY + <span class="number">1</span>) + (Y + rY + <span class="number">1</span> &lt;= w - lY ? max(<span class="number">0</span>, c[min(X + rX, h - lX)][Y + rY + <span class="number">1</span>] - c[max(X - lX, rX + <span class="number">1</span>) - <span class="number">1</span>][Y + rY + <span class="number">1</span>]) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> f[cX][cY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'E'</span>) X = i, Y = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">            r[i][j] = r[i][j - <span class="number">1</span>] + (s[i][j] == <span class="string">'o'</span>);</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j] + (s[i][j] == <span class="string">'o'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF-Gym-101775B]-Scapegoat</title>
      <link href="2018/06/17/%5BCF-Gym-101775B%5D-Scapegoat/"/>
      <url>2018/06/17/%5BCF-Gym-101775B%5D-Scapegoat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/Gym-101775B" target="_blank" rel="noopener">传送门</a></p><p>题意：有 $N$ 个大点，$M$ 个小点，每个大点可以连多个小点，且至少得连一个小点，每个小点必须被一个大点连。每个大点有一个权值 $c_i$，被这个大点连的小点的权值之和即为大点权值。需要求出怎么连，在满足题意的情况下小点权值方差最小？<br>Hint：方差公式：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{n}\sum(x_i - \frac{1}{n}\sum x_j)^2</script><p>真是惭愧 ◑﹏◐ 当时题意都没读懂…<br>可以发现，小点这么求：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{m}\sum(x_i - \frac{1}{m}\sum x_j)^2</script><p>可以发现，小点的总权值之和即为大点总权值之和，是一个已知的常数，我们用 $S$ 表示。<br>完全平方公式得：</p><script type="math/tex; mode=display">\sigma^2 = \frac{1}{m}\sum({x_i}^2 - \frac{2}{m}Sx_i + \frac{1}{m^2}S^2)</script><p>拆开来化简得：</p><script type="math/tex; mode=display">\frac{1}{m}\sum{x_i}^2 - \frac{S^2}{m^2}</script><p>由于 $\frac{1}{m}$ 、 $\frac{S^2}{m^2}$ 全是常数，可以直接得到，我们就不去考虑，现在要解决 $\sum{x_i}^2$ 的问题。</p><p>实在是太难考虑了 ◑﹏◐ 那换一个角度吧</p><p>我们发现，一个大点连着小点，每个小点获得的大点分出的权值肯定是越均匀越好（均分咯），设大点权值为 $C$ ，小点个数为 $M$ ，则 $x_i$ 为 $\frac{C}{M}$ 。</p><p>$\sum{x_i}^2$ 则为 $M(\frac{C}{M})^2$ 即为 $\frac{C^2}{M}$ 。</p><p>$C^2$ 我们也知道了，现在我们考虑的局部问题就是不同大点的小点数。对于每个大点来说，$M$ 肯定是越大越好咯，但为了让对答案的减少量更多，我们要考虑的是哪一个大点的 $M$ 变大对答案的贡献越多。</p><p>仔细观察发现，$\frac{C^2}{1}$ 变为 $\frac{C^2}{2}$ 的减少量是 $\frac{C^2}{2}$ ，$\frac{C^2}{2}$ 变为 $\frac{C^2}{3}$ 的减少量是 $\frac{C^2}{2} - \frac{C^2}{3}$ ，也就是说减少量在递减，而我们却要选减少量将会最多的一个，这是一个很优的性质。</p><p>最终做法，每个大点的 $M$ 初始是 $1$，循环 $m - n$ 次，用优先队列给准减少量降序排列，每次取队首，给它的 $M$ 加 $1$。</p><p>最后别忘了加上之前为了方便思考减去的一堆常数。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">double</span> a[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>, S = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">            S += a[i];</span><br><span class="line">            pq.push(make_pair(a[i] * a[i] / <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            pdi x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">double</span> square = x.first * (x.second * (x.second + <span class="number">1</span>));</span><br><span class="line">            x.second += <span class="number">1</span>;</span><br><span class="line">            x.first = (square / x.second) - (square / (x.second + <span class="number">1</span>));</span><br><span class="line">            pq.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            pdi x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans += x.first * x.second * (x.second + <span class="number">1</span>) / x.second;</span><br><span class="line">        &#125;</span><br><span class="line">        ans /= m;</span><br><span class="line">        ans -= S * S / m / m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.12lf\n"</span>, cas, max(<span class="number">0.0</span>, ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结，本题在于展开，然后省略易求的常数，还有一个减少量的规律，也就是逐渐减小，逐渐不符合我们的要求。此外最可借鉴的就是思考策略——局部问题解法推广到整体，比如这道题中很难考虑时我们跳出去，先去发现减少量这个有趣的性质。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CODEVS1172]-Hankson的趣味题</title>
      <link href="2018/06/16/%5BCODEVS1172%5D-Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/"/>
      <url>2018/06/16/%5BCODEVS1172%5D-Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1172/" target="_blank" rel="noopener">传送门</a></p><p>题意：有 n 个询问，每个询问中有四个自然数 a, b, c, d, 然后求有多少个 x 满足 $gcd(a, x) = c$ 且 $lcm(b, x) = d$ 。<br>$n \leq 2000$ , $1 \leq a, b, c, d \leq 2 * 10^9$ 。</p><p>解法一：</p><p>d 的约数个数上界是 $\sqrt{d}$ ，但 1 ~ d 中每个数约数个数大概只有 $log d$ ，所以我们可以预处理出 1～$\sqrt{2 * 10^5}$ 的所有质数，然后用搜索算法组成 d 的所有约数，再判断是否满足题目条件，即可得到100分。<br>——lyd</p><p>而我写的是这个：</p><p>解法二：</p><p>因为 x 是 d 的约数，所以 x 的质因子 p 一定也是 d 的质因子。我们可以对 d 的每个质因子 p 分别计算 x 可能包含多少个 p 。</p><p>设 a, b, c, d, x 分别包含 $m_a$ , $m_b$ , $m_c$ , $m_d$ , $m_x$ 个质因子 p ，其中 $m_x$ 是未知量。</p><p>如果 $m_a == m_c$ 且 $m_b == m_d$ 且 $m_c \leq m_d$ 那么 $m_x$ 只要满足 $m_c \leq m_x \leq m_d$ 就可以了，方案数为 $m_d - m_c + 1$；<br>若 $m_c &gt; m_d$ 那本次询问答案无解，为0。</p><p>若 $m_a \neq m_c$ 且 $m_b \neq m_d$ ，那么 $m_x$ 必须等于 $m_c$ 和 $m_d$ ，若 $m_c \neq m_d$ 则无解。</p><p>我们把 $m_x$ 的取法数记为 $cnt_p$ ，也就是 x 包含质因子 p 的方案有 $cnt_p$ 种。根据乘法原理，满足题意的 x 数量即为连乘积：</p><script type="math/tex; mode=display">\prod_{p | d} cnt_p</script><p>同样我们预处理出 1～$\sqrt{2 * 10^5}$ 的所有质数，因为 d 至多包含 10 个质因子，所以计算量很小，深搜解决，时间复杂度 $O(n\sqrt{d} / logd)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line">ll n, a0, a1, b0, b1, tot, ans;</span><br><span class="line"><span class="keyword">int</span> prime[N];</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            mark[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m0, m1, m2, m3;</span><br><span class="line">    m0 = m1 = m2 = m3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a0 % x == <span class="number">0</span>) &#123;a0 /= x, m0++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (a1 % x == <span class="number">0</span>) &#123;a1 /= x, m1++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (b0 % x == <span class="number">0</span>) &#123;b0 /= x, m2++;&#125;</span><br><span class="line">    <span class="keyword">while</span> (b1 % x == <span class="number">0</span>) &#123;b1 /= x, m3++;&#125;</span><br><span class="line">    <span class="keyword">if</span> (m0 == m1 &amp;&amp; m2 == m3) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m1 &lt;= m3) ans *= (m3 - m1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m0 != m1 &amp;&amp; m2 != m3 &amp;&amp; m1 != m3) ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Euler_prime();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;a0, &amp;a1, &amp;b0, &amp;b1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) solve(prime[i]);</span><br><span class="line">        <span class="keyword">if</span> (b1 != <span class="number">1</span>) solve(b1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最大公约数与最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举子集的飘逸写法</title>
      <link href="2018/05/28/%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86%E7%9A%84%E9%A3%98%E9%80%B8%E5%86%99%E6%B3%95/"/>
      <url>2018/05/28/%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86%E7%9A%84%E9%A3%98%E9%80%B8%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>要二进制枚举子集啦（准确地说是先枚举集合 S 再枚举 S 的子集 T），其中 S 最多有 n 个元素。</p><p>很容易想到，每个物体有取（1）和不取（0）两种情况，那么总共有 $2^n$ 种情况。<br>要一次概括所有物体的选择情况，二进制就是很好的选择。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;  <span class="comment">// i 枚举所有物体的选择情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么第二层循环中是 j = (j - 1) &amp; i 呢？<br>这样起到了将 j 中有效位（为1）逐渐删除的效果。<br>例如，当 i = 101000 时，j 初始为 101000，第一轮变为 100111，&amp; i 后变为 100000，成功将最后一个1删除。</p><p>时间复杂度计算很玄学，可以发现 S 有 $\binom{n}{i}$ 种选法，i 个中还有 $2^i$ 种选取情况。<br>所以就是：</p><script type="math/tex; mode=display">\sum_{i=0}^n{\binom{n}{i} * 2^i}</script><p>再通过某种玄学证明可得该式 = $3^n$。(20.02.07upd: 就是二项式定理啦！！！即 (1 + 2) ^ n) </p><p>同样的，若枚举 S 的子集 T，再枚举 T 的子集 T1，时间复杂度就是 $4^n$。</p><p>需要注意的是，O($3^n$) 表示 &lt;= $3^n$，而 $3^n$ 就是 $3^n$，是一个准确值。</p><p>顺带的，若要枚举集合 U 中的子集 S 和 T，其中 S 与 T 无重复元素，只需枚举 S，再在 U 中除 S 的元素中枚举 T。</p><p>这是一种很好的二进制思想，利用位运算，巧妙地将冗余降到了最低，因此是最优的该类算法。尽管最优，因为是指数级算法，n 也只能最多取到15左右。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeJam2018-R1c</title>
      <link href="2018/05/07/CodeJam2018-R1c/"/>
      <url>2018/05/07/CodeJam2018-R1c/</url>
      
        <content type="html"><![CDATA[<h3 id="A-A-Whole-New-Word"><a href="#A-A-Whole-New-Word" class="headerlink" title="A. A Whole New Word"></a>A. A Whole New Word</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard</a></p><p>set记题目给定的字符串出现过，然后dfs枚举字符串，26^L，在找到第一个合法的字符串后立刻返回。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; h;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">int</span> n, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.count(ret)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">if</span> (c[x][i]) &#123;</span><br><span class="line">        ret[x] = <span class="string">'A'</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L;</span><br><span class="line">    h.clear();</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; ++j) c[j][s[j] - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        h.insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; ++j) ret += <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dfs(<span class="number">0</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="B-Lollipop-Shop"><a href="#B-Lollipop-Shop" class="headerlink" title="B. Lollipop Shop"></a>B. Lollipop Shop</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard</a></p><p>这是一道交互题，给出每种棒棒糖被喜欢的概率，要求最后答案是正解的90%以上。<br>乍一看很不可做。不知道大家喜欢的糖，怎么做呢？<br>贪心思想，将概率最小的糖给他。/不是概率大的：概率大就有很多人喜欢了，怎么给呢？<br>cnt[]记录概率，若概率相同，怎么办呢？<br>概率性的，当然少不了随机啦！/随机大法好<br>在这种各为50%的情况下，我们随一个数，通过奇偶性来决定分给两者中哪一位。<br>最后 fflush(stdout) 刷新输入。<br>这个算法的概率性体现在“随一个数，判断奇偶性”中，如果不是交互题，就不存在概率的问题，就是正确的算法。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">205</span>], mk[<span class="number">205</span>], biu[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(mk, <span class="number">0</span>, <span class="keyword">sizeof</span>(mk));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> K;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; K;</span><br><span class="line">        <span class="built_in">memset</span>(biu, <span class="number">0</span>, <span class="keyword">sizeof</span>(biu));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            ++cnt[x + <span class="number">1</span>], biu[x + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (biu[j] &amp;&amp; !mk[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[j] &lt; cnt[p]) p = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt[j] == cnt[p] &amp;&amp; (rand() &amp; <span class="number">1</span>)) p = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; p - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>, mk[p] = <span class="number">1</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>) * clock());</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Ant-Stack"><a href="#C-Ant-Stack" class="headerlink" title="C. Ant Stack"></a>C. Ant Stack</h3><hr><p><a href="https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard/000000000003e0a8" target="_blank" rel="noopener">https://codejam.withgoogle.com/2018/challenges/0000000000007765/dashboard/000000000003e0a8</a></p><p>很显然哇，是LIS的改编，朴素的LIS，Task1可以过。<br>Task2呢？<br>之前我们想到的是表示长度，但重量那一维太大了，我们将长度与重量换一换。<br>f[i][j] 表示，前 i 个中，<br>可以发现，a = 6b 时，a + b = 7b / 6。又因保证 wi &lt;= 10 ^ 9，可以发现 (7 / 6) ^ 150 &gt; 10 ^ 9，因此最多150人。那么我们1～150循环枚举长度。发现每一次循环，DP只需要上一次DP的消息，所以我们使用滚动数组。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)(<span class="number">1e5</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = (LL)(<span class="number">1e18</span>) + <span class="number">100</span>;</span><br><span class="line">LL f[<span class="number">2</span>][maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, lst = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) f[<span class="number">0</span>][j] = f[<span class="number">1</span>][j] = inf;</span><br><span class="line">    f[now][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">150</span>; ++j) &#123;</span><br><span class="line">        now = lst ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)  f[now][i] = inf;</span><br><span class="line">        LL ww = f[lst][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ww &lt;= a[i] * <span class="number">6</span>) f[now][i] = ww + a[i];</span><br><span class="line">            ww = min(ww, f[lst][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (f[now][i] &lt; inf) mx = j;</span><br><span class="line">        lst = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF-Gym-100340A]-Cookies</title>
      <link href="2018/05/01/%5BCF-Gym-100340A%5D-Cookies/"/>
      <url>2018/05/01/%5BCF-Gym-100340A%5D-Cookies/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/problem/Gym-100340A" target="_blank" rel="noopener">传送门</a></p><p>题意：圣诞老人要将 $m$ 个饼干全部分给 $n$ 个孩子，每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g[i]$。如果有 $a[i]$ 个孩子拿到的饼干树比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $a[i]g[i]$ 的怨气。$1 \leq n \leq 30$, $n \leq m \leq 5000$.</p><p>如果要计算第 $i$ 个孩子的怨气值，就必须要知道 $a[i]$。一个孩子的怨气大小与其他孩子获得的饼干数有关。</p><p>仔细思考可以发现，贪婪度大的孩子应该获得更多的饼干。正如「国王游戏」与「皇后游戏」一般，我们可以用邻项交换的方式来证明。因此，可以将孩子按贪婪度降序排列。</p><p>设 $f[i][j]$ 为前 $i$ 个孩子分配 $j$ 块饼干时，怨气总和的最小值。有两种情况：</p><ol><li>第 $i + 1$ 个孩子获得的饼干数比第 $i$ 个孩子少，此时 $a[i + 1] = i$</li><li>第 $i + 1$ 个孩子获得的饼干数与第 $i$ 个孩子相同，此时还需要知道 $i$ 前面有几个孩子与i获得的饼干数相同，才能算出 $a[i + 1]$。</li></ol><p>既要知道第 $i$ 个孩子获得的饼干数，又要知道 $i$ 前面有几个孩子与 $i$ 获得的饼干数相同，很难高效地维护 dp。</p><p>观察 dp，可发现“每个孩子至少分到一块饼干”。</p><ol><li>若第 $i$ 个孩子的饼干数大于$1$，$f[i][j] = f[i][j - i]$（即每个孩子少拿一块饼干）。</li><li>若第 $i$ 个孩子的饼干数等于$1$，则枚举i前面有多少个孩子也获得了一块饼干。</li></ol><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]=min(f[i][j-i], min(f[k, j - (i - k)] + k * {\sum_{p = k + 1}^{i} g[p]}))</script><p>初始：$f[0][0] = 0$， 目标：$f[n][m]$。</p><p>方案转移，就像「I-country」一样，开两个数组记录“转移来源”，一次递归回去，找到最优路径。</p><p>CODE:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>, M = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, pre[N], f[N][M], res[N];</span><br><span class="line"><span class="keyword">int</span> lstN[N][M], lstM[N][M];  <span class="comment">// 记录方案</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum, id;</span><br><span class="line">&#125;g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="keyword">return</span> a.sum &gt; b.sum;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> L = lstN[x][y], R = lstM[x][y];</span><br><span class="line">    <span class="keyword">if</span> (x == L) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) res[g[i].id]++;</span><br><span class="line">        record(L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= x; i++) res[g[i].id]++;</span><br><span class="line">        record(L, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cookies.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"cookies.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i].sum);</span><br><span class="line">        g[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g + <span class="number">1</span>, g + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = pre[i - <span class="number">1</span>] + g[i].sum;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = min(f[i][j], f[i][j - i]);</span><br><span class="line">            lstN[i][j] = i, lstM[i][j] = j - i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = f[k][j - (i - k)] + k * (pre[i] - pre[k]);</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &gt; sum) &#123;</span><br><span class="line">                    f[i][j] = sum;</span><br><span class="line">                    lstN[i][j] = k, lstM[i][j] = (j - (i - k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][m]);</span><br><span class="line">    record(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真是一道好题。在数据无序的情况下，我们不知道怎么DP，但可以通过额外的算法（本题中是邻项交换）来确定DP状态的计算顺序，还可以在状态空间中运用等效手法来对状态进行缩放。<br>本题中，我们利用贪心策略，利用相对大小的不变性，将第i + 1个孩子的饼干数先缩放到1，使问题得到简化，容易维护、转移。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP-字符串匹配</title>
      <link href="2018/04/22/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>2018/04/22/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>今天来学KMP算法啦！<br>KMP是用来做字符串匹配的，比如，给定S序列：abababa， T序列：ba，<br>问T序列在S序列里出现的位置，如题则为3、5、7。</p><p>那么，有一种暴力算法，枚举结尾，O(nm)，当然仅限于暴力。。<br>KMP是改进版，简洁好打，O(n + m)!!<br>朴素算法中有许多不必要的枚举，如果失配了，会回归原点，从下一位再次开始；<br>而KMP充分利用匹配失败的信息，尽量减少匹配次数。</p><p>算法中涉及到一个next数组，这也是KMP中最重要的部分。<br>next[i]表示前i位中，前缀与后缀相同的最长部分，<br>比如，序列abcab，next[5] = 2(‘ab’), next[4] = 1(‘a’)。<br>这样，利用next[]，一个序列中后缀匹配不上，就用前缀去匹配。</p><p>CODE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> next[N];  <span class="comment">// 前缀与后缀相同的最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; t[i] != t[k + <span class="number">1</span>]) k = next[k];  <span class="comment">// 跳回去，往前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[k + <span class="number">1</span>]) k++;  <span class="comment">// 相同的情况下</span></span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;  <span class="comment">// 先处理next[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; s[i] != t[k + <span class="number">1</span>]) k = next[k];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[k + <span class="number">1</span>]) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉KMP充分将时间用在刀刃上了。。好妙的KMP。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】欧几里得与扩展欧几里得</title>
      <link href="2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Gcd"><a href="#Gcd" class="headerlink" title="Gcd"></a>Gcd</h2><hr><p>欧几里得算法又称辗转相除法，用于计算两个整数的最大公约数.</p><p>引理：<br>    求整数 a、b 的最大公约数，表示成 gcd(a,b)，设 r = a % b，则 gcd(a, b) = gcd(b, a % b).</p><p>证明:<br>    a = kb + r, r = a % b.<br>    假设 c 是 a、b 的公约数，则 c | a, c | b, r = a - kb，因此 c | r.<br>    因此 c 也是 (b, a % b) 的公约数.<br>    c | b, c | r, a = kb + r.<br>    所以 c 也是 (a, b) 的公约数.<br>    既然 (a, b）与 (b, a % b) 的公约数相等，其最大公约数也必然相等，得证.<br>    (gcd(a, 0) = a)</p><h2 id="exGcd"><a href="#exGcd" class="headerlink" title="exGcd"></a>exGcd</h2><hr><p>扩展欧几里得算法，一般用来求解不定方程、线性同余方程、模的逆元等.</p><p>可以根据裴蜀定理那一课的证明来学一学，这里就不再多说，不过仍有值得一提的：以下程序求出 ax + by = gcd(a, b) 的一组特解 x0, y0，并返回 a，b 的最大公约数 d。对于更为一般的方程 ax + by = c，它有解当且仅当 d | c。我们可以先求出 x0, y0，然后令 x0, y0 同乘以 c / d，就得到了 ax + by = c 的一组特解 (c / d)x0, (c / d)y0。</p><p>事实上，方程 ax + by = c 的通解可以表示为：x = (c / d)x0 + k(b / d), y = (c / d)y0 + k(a / d)，其中 k 取遍整数集合。</p><p>CODE:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d = exGcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x;</span><br><span class="line">    x = y, y = z - y * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 欧几里得与扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bezout(裴蜀)定理</title>
      <link href="2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
      <url>2018/02/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Bezout 定理：对于任意整数 a，b，存在一对整数 x，y，满足 ax + by = gcd(a, b).</p><p>证明：在欧几里得算法的最后一步，即 b = 0 时，显然有一对整数 x = 1, y = 0 ，使得 $a <em> 1 + 0 </em> 0 = gcd(a, 0)$ 。若 b &gt; 0, 则 gcd(a, b) = gcd(b, a mod b)。假设存在一对整数 x，y，满足 $b <em> x + (a mod b) </em> y = gcd(b, a mod b)$ ，因为 $bx + (a mod b)y = bx + (a - b\lfloor{a / b}\rfloor)y = ay - b(x - \lfloor{a / b}\rfloor y)$ ，所以令 $x^{‘} = x$ ，$y^{‘} = x - \lfloor{a / b}\rfloor y$ ，就得到了 $ax^{‘} + by^{‘} = gcd(a, b)$ 。</p><p>证毕。</p><p>Bezout定理是按照欧几里得算法的思路证明的，且上述证明同时给出了整数 x 和 y 的计算方法，即扩展欧几里得算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 欧几里得与扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler线性筛</title>
      <link href="2018/01/21/Euler%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>2018/01/21/Euler%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="欧拉筛法求质数"><a href="#欧拉筛法求质数" class="headerlink" title="欧拉筛法求质数"></a>欧拉筛法求质数</h3><hr><p>当我们知道一个数为质数时，它的倍数肯定不是质数，所以我们可以从 2 开始通过乘积筛掉所有的合数.</p><p>欧拉筛法保证所有合数都是被它的最小质因子筛掉的，时间复杂度 O(N).</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N], prime[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    m = <span class="number">0</span>;  <span class="comment">// 质数数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++m] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// 保证每个数只会被它的最小质因子筛去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="2017/06/06/Hello/"/>
      <url>2017/06/06/Hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><p>数学公式测试</p><script type="math/tex; mode=display">x ^ 2 + 2x + 1 = 0</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
