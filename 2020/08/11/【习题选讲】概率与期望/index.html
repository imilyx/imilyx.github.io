<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">
<meta name="keywords" content="概率与期望">
<meta property="og:type" content="article">
<meta property="og:title" content="【习题选讲】概率与期望">
<meta property="og:url" content="http://yoursite.com/2020/08/11/【习题选讲】概率与期望/index.html">
<meta property="og:site_name" content="imily&#39;s notebook">
<meta property="og:description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-12-13T11:03:10.712Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【习题选讲】概率与期望">
<meta name="twitter:description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>【习题选讲】概率与期望</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

<body>
    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/posts/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/friends/">友人帐</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/08/11/AGC 047 题解/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/08/11/[SHOI2016]-成绩比较/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&text=【习题选讲】概率与期望"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&is_video=false&description=【习题选讲】概率与期望"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【习题选讲】概率与期望&body=Check out this article: http://yoursite.com/2020/08/11/【习题选讲】概率与期望/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&name=【习题选讲】概率与期望&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#套路1-直接递推-dp"><span class="toc-number">1.</span> <span class="toc-text">套路1. 直接递推/dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NOI2005-聪聪与可可"><span class="toc-number">1.1.</span> <span class="toc-text">$[NOI2005]-聪聪与可可$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCOI2008-奖励关"><span class="toc-number">1.2.</span> <span class="toc-text">$[SCOI2008]-奖励关$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清华集训2017-小-Y-和恐怖的奴隶主"><span class="toc-number">1.3.</span> <span class="toc-text">$[清华集训2017]-小 Y 和恐怖的奴隶主$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路2-无限循环转递推"><span class="toc-number">2.</span> <span class="toc-text">套路2. 无限循环转递推</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SHOI2002-百事世界杯之旅"><span class="toc-number">2.1.</span> <span class="toc-text">$[SHOI2002]-百事世界杯之旅$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六省联考2017-分手是祝愿"><span class="toc-number">2.2.</span> <span class="toc-text">$[六省联考2017]-分手是祝愿$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UVA10529-Dumb-Bones"><span class="toc-number">2.3.</span> <span class="toc-text">$[UVA10529]-Dumb Bones$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF908D-New-Year-and-Arbitrary-Arrangement"><span class="toc-number">2.4.</span> <span class="toc-text">$[CF908D]-New Year and Arbitrary Arrangement$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#「PKUWC2018」猎人杀"><span class="toc-number">2.5.</span> <span class="toc-text">$「PKUWC2018」猎人杀$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路3-高斯消元"><span class="toc-number">3.</span> <span class="toc-text">套路3. 高斯消元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USACO10HOL-Driving-Out-the-Piggies-G"><span class="toc-number">3.1.</span> <span class="toc-text">$[USACO10HOL]-Driving Out the Piggies G$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2013-游走"><span class="toc-number">3.2.</span> <span class="toc-text">$[HNOI2013]-游走$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2011-XOR和路径"><span class="toc-number">3.3.</span> <span class="toc-text">$[HNOI2011]-XOR和路径$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路4-分开考虑贡献"><span class="toc-number">4.</span> <span class="toc-text">套路4. 分开考虑贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#仓鼠找sugar-II"><span class="toc-number">4.1.</span> <span class="toc-text">$仓鼠找sugar II$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小魔女帕琪"><span class="toc-number">4.2.</span> <span class="toc-text">$小魔女帕琪$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2015-亚瑟王"><span class="toc-number">4.3.</span> <span class="toc-text">$[HNOI2015]-亚瑟王$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路5-整数概率公式"><span class="toc-number">5.</span> <span class="toc-text">套路5. 整数概率公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数生成器"><span class="toc-number">5.1.</span> <span class="toc-text">$随机数生成器$</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        【习题选讲】概率与期望
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">imily's notebook</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-08-11T03:31:40.000Z" itemprop="datePublished">2020-08-11</time>
    </div>


      
    <div class="article-tags">
        <i class="fa fa-tags"></i>
        <a class="tag-link" href="/tags/概率与期望/">概率与期望</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快乐期望 ~</span><br></pre></td></tr></table></figure>
<p>期望题往往应用到了期望的线性性质，可以说是解题的基础。</p>
<p>在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp</p>
<h2 id="套路1-直接递推-dp"><a href="#套路1-直接递推-dp" class="headerlink" title="套路1. 直接递推/dp"></a><strong>套路1. 直接递推/dp</strong></h2><hr>
<h3 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="$[NOI2005]-聪聪与可可$"></a><a href="https://www.luogu.com.cn/problem/P4206" target="_blank" rel="noopener">$[NOI2005]-聪聪与可可$</a></h3><p>简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能到达的。<strong>猫和鼠的距离不断减少</strong>，所以状态不会形成环，记忆化搜索就好了。</p>
<h3 id="SCOI2008-奖励关"><a href="#SCOI2008-奖励关" class="headerlink" title="$[SCOI2008]-奖励关$"></a><a href="https://www.luogu.com.cn/problem/P2473" target="_blank" rel="noopener">$[SCOI2008]-奖励关$</a></h3><p>n 这么小一定是状压啦。首先要明确的是，抛出什么宝物是随机的，但选择与否是我们决定的，也就是说我们要求<strong>最优策略下的最大期望得分</strong></p>
<p>$f[i, S]$ 表示前 $i - 1$ 轮取到的状态为 $S$，$i$ ~ $K$ 轮的最大期望得分。那么就有 </p>
<script type="math/tex; mode=display">f[i, S] = \frac{1}{n}(\sum\limits_{k\ is\ valid} max(f[i + 1, S], f[i + 1, S | (1 << (k - 1))] + p_k) + \sum\limits_{k\ isn't\ valid} f[i + 1, S])</script><h3 id="清华集训2017-小-Y-和恐怖的奴隶主"><a href="#清华集训2017-小-Y-和恐怖的奴隶主" class="headerlink" title="$[清华集训2017]-小 Y 和恐怖的奴隶主$"></a><a href="https://www.luogu.com.cn/problem/P4007" target="_blank" rel="noopener">$[清华集训2017]-小 Y 和恐怖的奴隶主$</a></h3><p>n 这么大一定是矩阵快速幂优化 dp 啦（雾）。以 $m = 3$ 为例，设 $f[i, a, b, c]$ 表示 $i$ 轮攻击后有 $a$ 个 1 血随从、$b$ 个 2 血随从、$c$ 个 3 血随从的概率，转移方程就很好想。。然后发现这个东西状态数是 166, 复杂度 $O(T166^3logn)$，考虑把 $2^i$ 的矩阵预处理出来，每次询问就只需用一个行向量去乘 logn 次矩阵，复杂度就变成了 $O(T166^2logn)$，然后还要卡很多常。。。所以这是道毒题</p>
<h2 id="套路2-无限循环转递推"><a href="#套路2-无限循环转递推" class="headerlink" title="套路2. 无限循环转递推"></a><strong>套路2. 无限循环转递推</strong></h2><hr>
<p>（这部分好神仙的！要巧妙设计状态，或者错位相减法（等比数列求和必备技能）等方法化柿子 qvq）</p>
<h3 id="SHOI2002-百事世界杯之旅"><a href="#SHOI2002-百事世界杯之旅" class="headerlink" title="$[SHOI2002]-百事世界杯之旅$"></a><a href="https://www.luogu.com.cn/problem/P1291" target="_blank" rel="noopener">$[SHOI2002]-百事世界杯之旅$</a></h3><p>应用极限的思想 <a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p1291" target="_blank" rel="noopener">题解</a></p>
<h3 id="六省联考2017-分手是祝愿"><a href="#六省联考2017-分手是祝愿" class="headerlink" title="$[六省联考2017]-分手是祝愿$"></a><a href="https://www.luogu.com.cn/problem/P3750" target="_blank" rel="noopener">$[六省联考2017]-分手是祝愿$</a></h3><p>看起来很神的期望题</p>
<p>首先 50 分从后往前取，好拿吧</p>
<p>考虑正解！从后往前取会确定一些<strong>必须要取</strong>的键，那么就相当于除开这些键 按了其他的键 <strong>就得按同一个键按回来</strong>，相当于多了一个必须要按的键（所以 f 的预处理得从 n，不能从 cnt 开始！）。所以 dp 的状态就是 f[i] 表示从 i 个必选的键转移到 i - 1 个必选的键的期望操作次数</p>
<script type="math/tex; mode=display">f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])</script><p>第一项表示选了一个必选的，一次就到 i - 1 去了；</p>
<p>第二项表示选了一个其他的，就得 f[i + 1] 次按回来，再 f[i] 次按到 i - 1 去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100003</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, cnt, res;</span><br><span class="line">ll col[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    col[j] ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j * j != i) col[i / j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)  <span class="comment">// !!! 从 n 开始</span></span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] * (ll)(n - i) % mod + n) % mod * quick_pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= K) res = cnt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt; K; --i) res = (res + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) res = res * (ll)i % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UVA10529-Dumb-Bones"><a href="#UVA10529-Dumb-Bones" class="headerlink" title="$[UVA10529]-Dumb Bones$"></a><a href="https://www.luogu.com.cn/problem/UVA10529" target="_blank" rel="noopener">$[UVA10529]-Dumb Bones$</a></h3><p>太神仙了吧woc</p>
<p>考虑<strong>单独</strong>一张骨牌摆放成功的期望次数 E</p>
<p>玄学化柿子（感性理解）</p>
<script type="math/tex; mode=display">E = 1 + pl(1 + pl(...) + pr(...)) + pr(1 + pl(...) + pr(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr)(1 + (pl + pr)(...))</script><script type="math/tex; mode=display">= 1 + (pl + pr) + (pl + pr)^2 + (pl + pr)^3 ... + (pl + pr)^{\infty}</script><script type="math/tex; mode=display">= \frac{1}{1 - pl - pr}</script><p>（别化晕了</p>
<p>考虑连续的 x 张骨牌成功的期望。<strong>注意采取最优策略</strong></p>
<p>放第 x 张骨牌时，如果向左/右，就要花费一些步数去扶起左/右边的骨牌。后面那坨东西，根据<strong>期望的线性性质</strong></p>
<script type="math/tex; mode=display">f[x] = \min\limits_{i = 1}^x\{f[i - 1] \times \frac{1 - pr}{1 - pl - pr} + f[x - i] \times \frac{1 - pl}{1 - pl - pr} + \frac{1}{1 - pl - pr}\}</script><p>以往左倒为例解释一下：左边要重搭 $f[i - 1] \times [往左倒的期望次数] = f[i - 1] \times (E - 1) \times \frac{pl}{pl + pr}$，注意这是重搭的，初始还有一次，所以是 $f[i - 1] \times \frac{1 - pr}{1 - pl - pr}$</p>
<p>就做完了。uva 数据只有一组，非常的水，我怕了，题解柿子都不一样。</p>
<p>感想就是，<strong>期望的线性性质真的太重要了！</strong> 不然这种互相影响的问题就没法做了。</p>
<h3 id="CF908D-New-Year-and-Arbitrary-Arrangement"><a href="#CF908D-New-Year-and-Arbitrary-Arrangement" class="headerlink" title="$[CF908D]-New Year and Arbitrary Arrangement$"></a><a href="https://www.luogu.com.cn/problem/CF908D" target="_blank" rel="noopener">$[CF908D]-New Year and Arbitrary Arrangement$</a></h3><p>这题的关键在处理边界啦。</p>
<p>容易发现我们需要记录的是当前 a 和 ab 的数量。设 f[i, j] 表示 i 个 a，j 个 ab，那么 $f[i, j] = \frac{pa}{pa + pb}f[i + 1, j] + \frac{pb}{pa + pb}f[i, i + j]$</p>
<p>开头无限多个 b 怎么办？忽略掉，因为对 ab 的数量没有影响。</p>
<p>结尾无限多个 a 怎么办？这个就要搞一搞了。如果 i + j &gt;= k，那么只要加一个 b 就能结束。设 $P_a = \frac{pa}{pa + pb}$, $P_b = \frac{pb}{pa + pb}$</p>
<script type="math/tex; mode=display">f[i, j] = P_b \sum\limits_{k = 0}^{\infty} P_a^k (i + j + k)</script><script type="math/tex; mode=display">= P_b\sum\limits_{k = 0}^{\infty} P_a^k \times k + P_b(i + j)\sum\limits_{k = 0}^{\infty}P_a^k</script><script type="math/tex; mode=display">= i + j + \frac{P_a}{P_b}</script><h3 id="「PKUWC2018」猎人杀"><a href="#「PKUWC2018」猎人杀" class="headerlink" title="$「PKUWC2018」猎人杀$"></a><a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">$「PKUWC2018」猎人杀$</a></h3><p>很妙的概率题。</p>
<p>分母是变化的，很不好求。</p>
<p>问题可以转化一波，变成：死掉的猎人依旧算在概率里面，每一轮一直开枪直到射死一个没死过的猎人。这样每次能选的就是全集了。</p>
<p>设 $W = \sum w_i$, $T = \{w_i\ |\ (i\ has\ died)\}$, $sum(T) = \sum\limits_{i\ has\ died} w_i$</p>
<p>转化前射死 $i$ 的概率 $P = \frac{wi}{(W - T)}$</p>
<p>转化后射死 $i$ 的概率 $P = \frac{T}{W}P + \frac{wi}{W} = \frac{wi}{W - T}$</p>
<p>两者相等。</p>
<p>。</p>
<p>。</p>
<p>然后考虑容斥，钦定一个不包含 1 的猎人集合 T 在 1 之后死去。除了集合 T 和猎人 1 以外的剩余的猎人不用考虑，因为他们可以任意摆放在 1 的前面后面（也就是说概率是 1）</p>
<p>集合为 T 的人在 1 后面死的概率：</p>
<script type="math/tex; mode=display">P = \frac{w_1}{W}\sum\limits_{i = 0}^{\infty} (1 - \frac{sum(T) + w_1}{W})^i = \frac{w_1}{sum(T) + w_1}</script><p>容斥</p>
<script type="math/tex; mode=display">ans = \sum\limits_{T} (-1)^{|T|} \frac{w_1}{sum(T) + w_1}</script><p>枚举 $T$ 再背包预处理容斥系数可以做到 $n^2$，50 pts：</p>
<script type="math/tex; mode=display">ans = \sum\limits_{num = 0}^{W} \frac{w_1}{num + w_1} (\sum\limits_T (-1)^{|T|} [sum(T) == num])</script><p>好妙【吐血而亡</p>
<p>100 pts 的话就是后面那坨容斥系数用分治的 NTT 卷一下了（下标是 T），注意不是 cdq 分治，就是普通的分治。或者也可以堆优化，即每次选两个长度最小的卷。nlog^2n</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, w[N], lim, sum[N], stk[<span class="number">32</span>], top, g[<span class="number">32</span>][N], ans, f[N], L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll f[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>, f[w[l]] = mod - <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ls, rs;</span><br><span class="line">    ls = stk[top--], solve(g[ls], l, mid);</span><br><span class="line">    rs = stk[top--], solve(g[rs], mid + <span class="number">1</span>, r);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= sum[r] - sum[l - <span class="number">1</span>]) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    get_rev();</span><br><span class="line">    NTT(g[ls], <span class="number">1</span>), NTT(g[rs], <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) f[i] = g[ls][i] * g[rs][i] % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) g[ls][i] = g[rs][i] = <span class="number">0</span>;</span><br><span class="line">    stk[++top] = ls, stk[++top] = rs;  <span class="comment">// 垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]), sum[i] = sum[i - <span class="number">1</span>] + w[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) stk[++top] = i;</span><br><span class="line">    solve(f, <span class="number">2</span>, n);</span><br><span class="line">    rep(i, <span class="number">0</span>, sum[n] - w[<span class="number">1</span>])</span><br><span class="line">        ans = (ans + w[<span class="number">1</span>] * quick_pow(i + w[<span class="number">1</span>], mod - <span class="number">2</span>) % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="套路3-高斯消元"><a href="#套路3-高斯消元" class="headerlink" title="套路3. 高斯消元"></a><strong>套路3. 高斯消元</strong></h2><hr>
<p>终于到了我最喜欢的部分 ~ 高消！</p>
<p>我纠结了很久的问题：图上游走问题 是以出发点度数作为分母还是终点度数作为分母，但这其实应题而异，主要跟你设计的 dp 状态有关。</p>
<h3 id="USACO10HOL-Driving-Out-the-Piggies-G"><a href="#USACO10HOL-Driving-Out-the-Piggies-G" class="headerlink" title="$[USACO10HOL]-Driving Out the Piggies G$"></a><a href="https://www.luogu.com.cn/problem/P2973" target="_blank" rel="noopener">$[USACO10HOL]-Driving Out the Piggies G$</a></h3><p>$f[x]$ 表示走到 x 不爆炸的概率（爆炸只要乘上 $\frac{p}{q}$ 就好了）</p>
<p>对于非起始点的 x，$f[x] = \sum \frac{(1 - \frac{p}{q})f[y]}{deg_y}$</p>
<h3 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="$[HNOI2013]-游走$"></a><a href="https://www.luogu.com.cn/problem/P3232" target="_blank" rel="noopener">$[HNOI2013]-游走$</a></h3><p>几个月前做的，现在来看却有了新的体会。</p>
<p>根据期望的线性性质，$E[分数之和] = \sum_{(u, v) \in G} E[(u, v)分数] = \sum_{(u, v) \in G} E[经过(u, v)的次数] \times val(u, v)$，那么算出每条边被经过次数后从小到大排序，贪心的从大到小赋边权就可以了。</p>
<p>边经过的期望次数可以转化成点经过的期望次数。$E[u, v] = \frac{E[u]}{deg_u} + \frac{E[v]}{deg_v}$, $E[u] = \sum \frac{E[v]}{deg_v} + [u == 1]$</p>
<h3 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="$[HNOI2011]-XOR和路径$"></a><a href="https://www.luogu.com.cn/problem/P3211" target="_blank" rel="noopener">$[HNOI2011]-XOR和路径$</a></h3><p>整个做不好做。根据期望的线性性质，按位考虑，计算出每一位为 1 的概率直接相加。$f[x]$ 表示从 x 到 n 当前位为 1 的概率。</p>
<script type="math/tex; mode=display">f[x] = \sum\limits_{(x, y) = 0} \frac{f[y]}{deg_y} + \sum\limits_{(x, y) = 1} \frac{1 - f[y]}{deg_y}</script><p>移项以后高消。注意边界，$f[n] = 0$</p>
<h2 id="套路4-分开考虑贡献"><a href="#套路4-分开考虑贡献" class="headerlink" title="套路4. 分开考虑贡献"></a><strong>套路4. 分开考虑贡献</strong></h2><hr>
<p>这部分主要是期望的线性性质的应用。其实前面的题目也有体现。</p>
<h3 id="仓鼠找sugar-II"><a href="#仓鼠找sugar-II" class="headerlink" title="$仓鼠找sugar II$"></a><a href="https://www.luogu.com.cn/problem/P3412" target="_blank" rel="noopener">$仓鼠找sugar II$</a></h3><p>数据范围这么大 不能高消 =&gt; 我不会做了！</p>
<p>把目标节点看作根，这样答案就成了到达根的期望步数和</p>
<p>设 $f[x]$ 表示从 x 向上走一步的期望步数，那么 $f[x] = \frac{1}{deg_x} + \frac{deg_x - 1}{deg_x}(1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x - 1} + f[x]) = 1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x} + f[x] = deg_x + \sum\limits_{y \in Son(x)}f[y]$, 叶子 $x$ 的 $f[x] = 1$</p>
<p>树形dp $n$ 次能获得 50 分的好成绩，考虑再优化——换根法。</p>
<p>设 $g[x]$ 表示在 $fa[x]$ 的儿子中除了 $x$ 以外的 $f$ 值之和。根从 $u$ 变成 $v$ 实际上只会影响 $u$ 和 $v$ 的 $f$ 值和子树大小，即 $f[u] = deg_u + g[v], f[v] = 0$，子树和随便搞一下。$ans = \frac{\sum\limits_{rt = 1}^n\sum\limits_{x = 1}^n f[x] \times sz[x]}{n^2}$</p>
<h3 id="小魔女帕琪"><a href="#小魔女帕琪" class="headerlink" title="$小魔女帕琪$"></a><a href="https://www.luogu.com.cn/problem/P3802" target="_blank" rel="noopener">$小魔女帕琪$</a></h3><p>根据期望的线性性质，$E[总数] = \sum\limits_i E[从 i 开始的七个魔法都不相同]$，每个位置 i 的连续七个不相同的概率都是相同的。答案就是 $7! \times \prod\limits_{i = 1}^7 \frac{a_i}{N - i + 1} \times (N - 6)$</p>
<h3 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="$[HNOI2015]-亚瑟王$"></a><a href="https://www.luogu.com.cn/problem/P3239" target="_blank" rel="noopener">$[HNOI2015]-亚瑟王$</a></h3><p>根据期望的线性性质，考虑每张牌对答案的贡献。发现第 $i$ 张牌被考虑到的次数<strong>只</strong>和前 $i - 1$ 张牌产生贡献的<strong>数量</strong>有关（设其为 $j$），因为这 $j$ 张牌产生贡献的时间和顺序不论怎样变换，第 $i$ 张牌都能被考虑到 $r - j$ 次。</p>
<p>于是想到 dp。$f[i, j]$ 表示在 $r$ 轮中前 $i$ 张牌有 $j$ 张产生贡献的概率，$g[i]$ 表示第 $i$ 张牌产生贡献的概率。那么</p>
<script type="math/tex; mode=display">f[i, j] = [j <= i - 1] \times f[i - 1, j] \times (1 - p[i])^{r - j} + [j > 0] \times f[i - 1, j - 1] \times (1 - (1 - p[i])^{r - j + 1})</script><script type="math/tex; mode=display">g[i] = \sum\limits_{j = 0}^{min(i - 1, r)}f[i - 1, j] \times (1 - (1 - p[i])^{r - j})</script><p>最终 $ans = \sum\limits_{i = 1}^n g[i] \times d[i]$</p>
<p>最终答案就是 $f[1, 0]$</p>
<h2 id="套路5-整数概率公式"><a href="#套路5-整数概率公式" class="headerlink" title="套路5. 整数概率公式"></a><strong>套路5. 整数概率公式</strong></h2><hr>
<p>这部分是真的没怎么练过。。</p>
<p>反正要知道公式：对于随机变量 $k &gt;= 0$, $E(k) = \sum\limits_{i = 0}^{\infty} P(k \ge i)$</p>
<h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="$随机数生成器$"></a><a href="https://www.luogu.com.cn/problem/P3600" target="_blank" rel="noopener">$随机数生成器$</a></h3><p>根据上面那个公式，我们就是要计算出 $P(ans \ge i)$。发现 $\ge$ 不好求，$\leq$ 挺好求，因为每个区间里至少有一个 $\leq i$ 的就算满足条件了，所以考虑将 $P(ans \ge i)$ 转化为 $1 - P(ans &lt; i)$。</p>
<p>我们发现两个区间是包含关系的话，大的区间对答案没有贡献，于是操作一波使得区间们的左右端点不减。考虑某个位置的数，如果它 $\leq i - 1$ 就能对覆盖自己的区间产生贡献，而且覆盖自己的区间编号连续。考虑将点和区间互换，问题等价于每个点能覆盖一些区间，且覆盖的概率为 $p = \frac{i - 1}{x}$，用一些点去覆盖所有区间的概率。</p>
<p>容易想到 dp，设 $l[i]$ 表示点 i 覆盖的最左边的区间，$r[i]$ 是最右边的，$f[i]$ 表示强制选第 i 个点，然后覆盖了 $1$ ~ $r[i]$ 所有区间的概率，那么</p>
<script type="math/tex; mode=display">f[i] = p \times (\sum\limits_{r[j] \ge l[i] - 1} f[j] \times (1 - p)^{i - 1 - j} + [l[i] = 1](1 - p)^{i - 1})</script><p>最终答案就是 $\sum\limits_{r[i] = Q}f[i] \times (1 - p)^{n - i}$</p>
<p>直接做是 $n^3$ 的，前缀和维护一下就好了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">666623333</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, Q, top, L, R;</span><br><span class="line"><span class="keyword">int</span> stk[N], l[N], r[N];</span><br><span class="line">ll f[N], ans, pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &gt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; q[stk[top]].r &gt;= q[i].r) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = top;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) q[i] = q[stk[i]];</span><br><span class="line">    L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; Q &amp;&amp; q[R + <span class="number">1</span>].l &lt;= i) ++R;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R &amp;&amp; q[L].r &lt; i) ++L;</span><br><span class="line">        l[i] = L, r[i] = R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    prework();</span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        ll p = (i - <span class="number">1</span>) * qpow(x, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        ll pp = mod + <span class="number">1</span> - p;</span><br><span class="line">        ll invp = qpow(pp, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lst &lt; j &amp;&amp; r[lst] &lt; l[j] - <span class="number">1</span>)</span><br><span class="line">                tot = (tot - f[lst] * qpow(invp, lst) % mod + mod) % mod, ++lst;</span><br><span class="line">            f[j] = p * tot % mod * qpow(pp, j - <span class="number">1</span>) % mod;</span><br><span class="line">            tot = (tot + f[j] * qpow(invp, j) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &amp;&amp; r[j] == Q; --j) sum = (sum + f[j] * qpow(pp, n - j) % mod) % mod;</span><br><span class="line">        ans = (ans + <span class="number">1</span> - sum + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/posts/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/friends/">友人帐</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#套路1-直接递推-dp"><span class="toc-number">1.</span> <span class="toc-text">套路1. 直接递推/dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NOI2005-聪聪与可可"><span class="toc-number">1.1.</span> <span class="toc-text">$[NOI2005]-聪聪与可可$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCOI2008-奖励关"><span class="toc-number">1.2.</span> <span class="toc-text">$[SCOI2008]-奖励关$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清华集训2017-小-Y-和恐怖的奴隶主"><span class="toc-number">1.3.</span> <span class="toc-text">$[清华集训2017]-小 Y 和恐怖的奴隶主$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路2-无限循环转递推"><span class="toc-number">2.</span> <span class="toc-text">套路2. 无限循环转递推</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SHOI2002-百事世界杯之旅"><span class="toc-number">2.1.</span> <span class="toc-text">$[SHOI2002]-百事世界杯之旅$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六省联考2017-分手是祝愿"><span class="toc-number">2.2.</span> <span class="toc-text">$[六省联考2017]-分手是祝愿$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UVA10529-Dumb-Bones"><span class="toc-number">2.3.</span> <span class="toc-text">$[UVA10529]-Dumb Bones$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF908D-New-Year-and-Arbitrary-Arrangement"><span class="toc-number">2.4.</span> <span class="toc-text">$[CF908D]-New Year and Arbitrary Arrangement$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#「PKUWC2018」猎人杀"><span class="toc-number">2.5.</span> <span class="toc-text">$「PKUWC2018」猎人杀$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路3-高斯消元"><span class="toc-number">3.</span> <span class="toc-text">套路3. 高斯消元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USACO10HOL-Driving-Out-the-Piggies-G"><span class="toc-number">3.1.</span> <span class="toc-text">$[USACO10HOL]-Driving Out the Piggies G$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2013-游走"><span class="toc-number">3.2.</span> <span class="toc-text">$[HNOI2013]-游走$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2011-XOR和路径"><span class="toc-number">3.3.</span> <span class="toc-text">$[HNOI2011]-XOR和路径$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路4-分开考虑贡献"><span class="toc-number">4.</span> <span class="toc-text">套路4. 分开考虑贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#仓鼠找sugar-II"><span class="toc-number">4.1.</span> <span class="toc-text">$仓鼠找sugar II$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小魔女帕琪"><span class="toc-number">4.2.</span> <span class="toc-text">$小魔女帕琪$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2015-亚瑟王"><span class="toc-number">4.3.</span> <span class="toc-text">$[HNOI2015]-亚瑟王$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套路5-整数概率公式"><span class="toc-number">5.</span> <span class="toc-text">套路5. 整数概率公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数生成器"><span class="toc-number">5.1.</span> <span class="toc-text">$随机数生成器$</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&text=【习题选讲】概率与期望"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&is_video=false&description=【习题选讲】概率与期望"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【习题选讲】概率与期望&body=Check out this article: http://yoursite.com/2020/08/11/【习题选讲】概率与期望/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&title=【习题选讲】概率与期望"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/08/11/【习题选讲】概率与期望/&name=【习题选讲】概率与期望&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 imily
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/posts/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/friends/">友人帐</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



