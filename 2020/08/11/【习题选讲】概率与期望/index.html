<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="概率与期望," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">
<meta name="keywords" content="概率与期望">
<meta property="og:type" content="article">
<meta property="og:title" content="【习题选讲】概率与期望">
<meta property="og:url" content="http://yoursite.com/2020/08/11/【习题选讲】概率与期望/index.html">
<meta property="og:site_name" content="imily&#39;s notes">
<meta property="og:description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-12-13T11:03:10.712Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【习题选讲】概率与期望">
<meta name="twitter:description" content="1快乐期望 ~ 期望题往往应用到了期望的线性性质，可以说是解题的基础。 在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp 套路1. 直接递推/dp $[NOI2005]-聪聪与可可$简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/11/【习题选讲】概率与期望/"/>





  <title> 【习题选讲】概率与期望 | imily's notes </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">imily's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/【习题选讲】概率与期望/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="imily">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="imily's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【习题选讲】概率与期望
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-11T11:31:40+08:00">
                2020-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快乐期望 ~</span><br></pre></td></tr></table></figure>
<p>期望题往往应用到了期望的线性性质，可以说是解题的基础。</p>
<p>在图上的解题方式一般就是：树上dp，基环树dp，DAG dp，缩点后 dp，分层图解同一层方程 dp</p>
<h2 id="套路1-直接递推-dp"><a href="#套路1-直接递推-dp" class="headerlink" title="套路1. 直接递推/dp"></a><strong>套路1. 直接递推/dp</strong></h2><hr>
<h3 id="NOI2005-聪聪与可可"><a href="#NOI2005-聪聪与可可" class="headerlink" title="$[NOI2005]-聪聪与可可$"></a><a href="https://www.luogu.com.cn/problem/P4206" target="_blank" rel="noopener">$[NOI2005]-聪聪与可可$</a></h3><p>简单题的样子，$f[i, j] = \frac{\sum f[nxt, k]}{deg_j + 1} + 1$，其中 nxt 是 i 两步能到达的，k 是 j 一步能到达的。<strong>猫和鼠的距离不断减少</strong>，所以状态不会形成环，记忆化搜索就好了。</p>
<h3 id="SCOI2008-奖励关"><a href="#SCOI2008-奖励关" class="headerlink" title="$[SCOI2008]-奖励关$"></a><a href="https://www.luogu.com.cn/problem/P2473" target="_blank" rel="noopener">$[SCOI2008]-奖励关$</a></h3><p>n 这么小一定是状压啦。首先要明确的是，抛出什么宝物是随机的，但选择与否是我们决定的，也就是说我们要求<strong>最优策略下的最大期望得分</strong></p>
<p>$f[i, S]$ 表示前 $i - 1$ 轮取到的状态为 $S$，$i$ ~ $K$ 轮的最大期望得分。那么就有 </p>
<p>$$f[i, S] = \frac{1}{n}(\sum\limits_{k\ is\ valid} max(f[i + 1, S], f[i + 1, S | (1 &lt;&lt; (k - 1))] + p_k) + \sum\limits_{k\ isn’t\ valid} f[i + 1, S])$$</p>
<h3 id="清华集训2017-小-Y-和恐怖的奴隶主"><a href="#清华集训2017-小-Y-和恐怖的奴隶主" class="headerlink" title="$[清华集训2017]-小 Y 和恐怖的奴隶主$"></a><a href="https://www.luogu.com.cn/problem/P4007" target="_blank" rel="noopener">$[清华集训2017]-小 Y 和恐怖的奴隶主$</a></h3><p>n 这么大一定是矩阵快速幂优化 dp 啦（雾）。以 $m = 3$ 为例，设 $f[i, a, b, c]$ 表示 $i$ 轮攻击后有 $a$ 个 1 血随从、$b$ 个 2 血随从、$c$ 个 3 血随从的概率，转移方程就很好想。。然后发现这个东西状态数是 166, 复杂度 $O(T166^3logn)$，考虑把 $2^i$ 的矩阵预处理出来，每次询问就只需用一个行向量去乘 logn 次矩阵，复杂度就变成了 $O(T166^2logn)$，然后还要卡很多常。。。所以这是道毒题</p>
<h2 id="套路2-无限循环转递推"><a href="#套路2-无限循环转递推" class="headerlink" title="套路2. 无限循环转递推"></a><strong>套路2. 无限循环转递推</strong></h2><hr>
<p>（这部分好神仙的！要巧妙设计状态，或者错位相减法（等比数列求和必备技能）等方法化柿子 qvq）</p>
<h3 id="SHOI2002-百事世界杯之旅"><a href="#SHOI2002-百事世界杯之旅" class="headerlink" title="$[SHOI2002]-百事世界杯之旅$"></a><a href="https://www.luogu.com.cn/problem/P1291" target="_blank" rel="noopener">$[SHOI2002]-百事世界杯之旅$</a></h3><p>应用极限的思想 <a href="https://www.luogu.com.cn/blog/ButterflyDew/solution-p1291" target="_blank" rel="noopener">题解</a></p>
<h3 id="六省联考2017-分手是祝愿"><a href="#六省联考2017-分手是祝愿" class="headerlink" title="$[六省联考2017]-分手是祝愿$"></a><a href="https://www.luogu.com.cn/problem/P3750" target="_blank" rel="noopener">$[六省联考2017]-分手是祝愿$</a></h3><p>看起来很神的期望题</p>
<p>首先 50 分从后往前取，好拿吧</p>
<p>考虑正解！从后往前取会确定一些<strong>必须要取</strong>的键，那么就相当于除开这些键 按了其他的键 <strong>就得按同一个键按回来</strong>，相当于多了一个必须要按的键（所以 f 的预处理得从 n，不能从 cnt 开始！）。所以 dp 的状态就是 f[i] 表示从 i 个必选的键转移到 i - 1 个必选的键的期望操作次数</p>
<p>$$f[i] = \frac{i}{n} + \frac{n - i}{n}(1 + f[i] + f[i + 1])$$</p>
<p>第一项表示选了一个必选的，一次就到 i - 1 去了；</p>
<p>第二项表示选了一个其他的，就得 f[i + 1] 次按回来，再 f[i] 次按到 i - 1 去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100003</span>, N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, K, cnt, res;</span><br><span class="line">ll col[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    col[j] ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j * j != i) col[i / j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)  <span class="comment">// !!! 从 n 开始</span></span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] * (ll)(n - i) % mod + n) % mod * quick_pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= K) res = cnt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt; K; --i) res = (res + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) res = res * (ll)i % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UVA10529-Dumb-Bones"><a href="#UVA10529-Dumb-Bones" class="headerlink" title="$[UVA10529]-Dumb Bones$"></a><a href="https://www.luogu.com.cn/problem/UVA10529" target="_blank" rel="noopener">$[UVA10529]-Dumb Bones$</a></h3><p>太神仙了吧woc</p>
<p>考虑<strong>单独</strong>一张骨牌摆放成功的期望次数 E</p>
<p>玄学化柿子（感性理解）<br>$$E = 1 + pl(1 + pl(…) + pr(…)) + pr(1 + pl(…) + pr(…))$$<br>$$= 1 + (pl + pr)(1 + (pl + pr)(…))$$<br>$$= 1 + (pl + pr) + (pl + pr)^2 + (pl + pr)^3 … + (pl + pr)^{\infty}$$<br>$$= \frac{1}{1 - pl - pr}$$<br>（别化晕了</p>
<p>考虑连续的 x 张骨牌成功的期望。<strong>注意采取最优策略</strong></p>
<p>放第 x 张骨牌时，如果向左/右，就要花费一些步数去扶起左/右边的骨牌。后面那坨东西，根据<strong>期望的线性性质</strong></p>
<p>$$f[x] = \min\limits_{i = 1}^x{f[i - 1] \times \frac{1 - pr}{1 - pl - pr} + f[x - i] \times \frac{1 - pl}{1 - pl - pr} + \frac{1}{1 - pl - pr}}$$</p>
<p>以往左倒为例解释一下：左边要重搭 $f[i - 1] \times [往左倒的期望次数] = f[i - 1] \times (E - 1) \times \frac{pl}{pl + pr}$，注意这是重搭的，初始还有一次，所以是 $f[i - 1] \times \frac{1 - pr}{1 - pl - pr}$</p>
<p>就做完了。uva 数据只有一组，非常的水，我怕了，题解柿子都不一样。</p>
<p>感想就是，<strong>期望的线性性质真的太重要了！</strong> 不然这种互相影响的问题就没法做了。</p>
<h3 id="CF908D-New-Year-and-Arbitrary-Arrangement"><a href="#CF908D-New-Year-and-Arbitrary-Arrangement" class="headerlink" title="$[CF908D]-New Year and Arbitrary Arrangement$"></a><a href="https://www.luogu.com.cn/problem/CF908D" target="_blank" rel="noopener">$[CF908D]-New Year and Arbitrary Arrangement$</a></h3><p>这题的关键在处理边界啦。</p>
<p>容易发现我们需要记录的是当前 a 和 ab 的数量。设 f[i, j] 表示 i 个 a，j 个 ab，那么 $f[i, j] = \frac{pa}{pa + pb}f[i + 1, j] + \frac{pb}{pa + pb}f[i, i + j]$</p>
<p>开头无限多个 b 怎么办？忽略掉，因为对 ab 的数量没有影响。</p>
<p>结尾无限多个 a 怎么办？这个就要搞一搞了。如果 i + j &gt;= k，那么只要加一个 b 就能结束。设 $P_a = \frac{pa}{pa + pb}$, $P_b = \frac{pb}{pa + pb}$</p>
<p>$$f[i, j] = P_b \sum\limits_{k = 0}^{\infty} P_a^k (i + j + k)$$</p>
<p>$$= P_b\sum\limits_{k = 0}^{\infty} P_a^k \times k + P_b(i + j)\sum\limits_{k = 0}^{\infty}P_a^k$$</p>
<p>$$= i + j + \frac{P_a}{P_b}$$</p>
<h3 id="「PKUWC2018」猎人杀"><a href="#「PKUWC2018」猎人杀" class="headerlink" title="$「PKUWC2018」猎人杀$"></a><a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">$「PKUWC2018」猎人杀$</a></h3><p>很妙的概率题。</p>
<p>分母是变化的，很不好求。</p>
<p>问题可以转化一波，变成：死掉的猎人依旧算在概率里面，每一轮一直开枪直到射死一个没死过的猎人。这样每次能选的就是全集了。</p>
<p>设 $W = \sum w_i$, $T = {w_i\ |\ (i\ has\ died)}$, $sum(T) = \sum\limits_{i\ has\ died} w_i$</p>
<p>转化前射死 $i$ 的概率 $P = \frac{wi}{(W - T)}$</p>
<p>转化后射死 $i$ 的概率 $P = \frac{T}{W}P + \frac{wi}{W} = \frac{wi}{W - T}$</p>
<p>两者相等。</p>
<p>。</p>
<p>。</p>
<p>然后考虑容斥，钦定一个不包含 1 的猎人集合 T 在 1 之后死去。除了集合 T 和猎人 1 以外的剩余的猎人不用考虑，因为他们可以任意摆放在 1 的前面后面（也就是说概率是 1）</p>
<p>集合为 T 的人在 1 后面死的概率：</p>
<p>$$P = \frac{w_1}{W}\sum\limits_{i = 0}^{\infty} (1 - \frac{sum(T) + w_1}{W})^i = \frac{w_1}{sum(T) + w_1}$$</p>
<p>容斥</p>
<p>$$ans = \sum\limits_{T} (-1)^{|T|} \frac{w_1}{sum(T) + w_1}$$</p>
<p>枚举 $T$ 再背包预处理容斥系数可以做到 $n^2$，50 pts：</p>
<p>$$ans = \sum\limits_{num = 0}^{W} \frac{w_1}{num + w_1} (\sum\limits_T (-1)^{|T|} [sum(T) == num])$$</p>
<p>好妙【吐血而亡</p>
<p>100 pts 的话就是后面那坨容斥系数用分治的 NTT 卷一下了（下标是 T），注意不是 cdq 分治，就是普通的分治。或者也可以堆优化，即每次选两个长度最小的卷。nlog^2n</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">3e5</span> + <span class="number">10</span>, G1 = <span class="number">3</span>, G2 = (mod + <span class="number">1</span>) / G1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, w[N], lim, sum[N], stk[<span class="number">32</span>], top, g[<span class="number">32</span>][N], ans, f[N], L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll a[], <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">1</span>, lim - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll W = quick_pow(op == <span class="number">1</span> ? G1 : G2, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * W % mod) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        ll Inv = quick_pow(lim, mod - <span class="number">2</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) a[i] = a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll f[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>, f[w[l]] = mod - <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ls, rs;</span><br><span class="line">    ls = stk[top--], solve(g[ls], l, mid);</span><br><span class="line">    rs = stk[top--], solve(g[rs], mid + <span class="number">1</span>, r);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= sum[r] - sum[l - <span class="number">1</span>]) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    get_rev();</span><br><span class="line">    NTT(g[ls], <span class="number">1</span>), NTT(g[rs], <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) f[i] = g[ls][i] * g[rs][i] % mod;</span><br><span class="line">    NTT(f, <span class="number">-1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, lim - <span class="number">1</span>) g[ls][i] = g[rs][i] = <span class="number">0</span>;</span><br><span class="line">    stk[++top] = ls, stk[++top] = rs;  <span class="comment">// 垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]), sum[i] = sum[i - <span class="number">1</span>] + w[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">30</span>) stk[++top] = i;</span><br><span class="line">    solve(f, <span class="number">2</span>, n);</span><br><span class="line">    rep(i, <span class="number">0</span>, sum[n] - w[<span class="number">1</span>])</span><br><span class="line">        ans = (ans + w[<span class="number">1</span>] * quick_pow(i + w[<span class="number">1</span>], mod - <span class="number">2</span>) % mod * f[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="套路3-高斯消元"><a href="#套路3-高斯消元" class="headerlink" title="套路3. 高斯消元"></a><strong>套路3. 高斯消元</strong></h2><hr>
<p>终于到了我最喜欢的部分 ~ 高消！</p>
<p>我纠结了很久的问题：图上游走问题 是以出发点度数作为分母还是终点度数作为分母，但这其实应题而异，主要跟你设计的 dp 状态有关。</p>
<h3 id="USACO10HOL-Driving-Out-the-Piggies-G"><a href="#USACO10HOL-Driving-Out-the-Piggies-G" class="headerlink" title="$[USACO10HOL]-Driving Out the Piggies G$"></a><a href="https://www.luogu.com.cn/problem/P2973" target="_blank" rel="noopener">$[USACO10HOL]-Driving Out the Piggies G$</a></h3><p>$f[x]$ 表示走到 x 不爆炸的概率（爆炸只要乘上 $\frac{p}{q}$ 就好了）</p>
<p>对于非起始点的 x，$f[x] = \sum \frac{(1 - \frac{p}{q})f[y]}{deg_y}$</p>
<h3 id="HNOI2013-游走"><a href="#HNOI2013-游走" class="headerlink" title="$[HNOI2013]-游走$"></a><a href="https://www.luogu.com.cn/problem/P3232" target="_blank" rel="noopener">$[HNOI2013]-游走$</a></h3><p>几个月前做的，现在来看却有了新的体会。</p>
<p>根据期望的线性性质，$E[分数之和] = \sum_{(u, v) \in G} E[(u, v)分数] = \sum_{(u, v) \in G} E[经过(u, v)的次数] \times val(u, v)$，那么算出每条边被经过次数后从小到大排序，贪心的从大到小赋边权就可以了。</p>
<p>边经过的期望次数可以转化成点经过的期望次数。$E[u, v] = \frac{E[u]}{deg_u} + \frac{E[v]}{deg_v}$, $E[u] = \sum \frac{E[v]}{deg_v} + [u == 1]$</p>
<h3 id="HNOI2011-XOR和路径"><a href="#HNOI2011-XOR和路径" class="headerlink" title="$[HNOI2011]-XOR和路径$"></a><a href="https://www.luogu.com.cn/problem/P3211" target="_blank" rel="noopener">$[HNOI2011]-XOR和路径$</a></h3><p>整个做不好做。根据期望的线性性质，按位考虑，计算出每一位为 1 的概率直接相加。$f[x]$ 表示从 x 到 n 当前位为 1 的概率。</p>
<p>$$f[x] = \sum\limits_{(x, y) = 0} \frac{f[y]}{deg_y} + \sum\limits_{(x, y) = 1} \frac{1 - f[y]}{deg_y}$$</p>
<p>移项以后高消。注意边界，$f[n] = 0$</p>
<h2 id="套路4-分开考虑贡献"><a href="#套路4-分开考虑贡献" class="headerlink" title="套路4. 分开考虑贡献"></a><strong>套路4. 分开考虑贡献</strong></h2><hr>
<p>这部分主要是期望的线性性质的应用。其实前面的题目也有体现。</p>
<h3 id="仓鼠找sugar-II"><a href="#仓鼠找sugar-II" class="headerlink" title="$仓鼠找sugar II$"></a><a href="https://www.luogu.com.cn/problem/P3412" target="_blank" rel="noopener">$仓鼠找sugar II$</a></h3><p>数据范围这么大 不能高消 =&gt; 我不会做了！</p>
<p>把目标节点看作根，这样答案就成了到达根的期望步数和</p>
<p>设 $f[x]$ 表示从 x 向上走一步的期望步数，那么 $f[x] = \frac{1}{deg_x} + \frac{deg_x - 1}{deg_x}(1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x - 1} + f[x]) = 1 + \frac{\sum\limits_{y \in Son(x)} f[y]}{deg_x} + f[x] = deg_x + \sum\limits_{y \in Son(x)}f[y]$, 叶子 $x$ 的 $f[x] = 1$</p>
<p>树形dp $n$ 次能获得 50 分的好成绩，考虑再优化——换根法。</p>
<p>设 $g[x]$ 表示在 $fa[x]$ 的儿子中除了 $x$ 以外的 $f$ 值之和。根从 $u$ 变成 $v$ 实际上只会影响 $u$ 和 $v$ 的 $f$ 值和子树大小，即 $f[u] = deg_u + g[v], f[v] = 0$，子树和随便搞一下。$ans = \frac{\sum\limits_{rt = 1}^n\sum\limits_{x = 1}^n f[x] \times sz[x]}{n^2}$</p>
<h3 id="小魔女帕琪"><a href="#小魔女帕琪" class="headerlink" title="$小魔女帕琪$"></a><a href="https://www.luogu.com.cn/problem/P3802" target="_blank" rel="noopener">$小魔女帕琪$</a></h3><p>根据期望的线性性质，$E[总数] = \sum\limits_i E[从 i 开始的七个魔法都不相同]$，每个位置 i 的连续七个不相同的概率都是相同的。答案就是 $7! \times \prod\limits_{i = 1}^7 \frac{a_i}{N - i + 1} \times (N - 6)$</p>
<h3 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="$[HNOI2015]-亚瑟王$"></a><a href="https://www.luogu.com.cn/problem/P3239" target="_blank" rel="noopener">$[HNOI2015]-亚瑟王$</a></h3><p>根据期望的线性性质，考虑每张牌对答案的贡献。发现第 $i$ 张牌被考虑到的次数<strong>只</strong>和前 $i - 1$ 张牌产生贡献的<strong>数量</strong>有关（设其为 $j$），因为这 $j$ 张牌产生贡献的时间和顺序不论怎样变换，第 $i$ 张牌都能被考虑到 $r - j$ 次。</p>
<p>于是想到 dp。$f[i, j]$ 表示在 $r$ 轮中前 $i$ 张牌有 $j$ 张产生贡献的概率，$g[i]$ 表示第 $i$ 张牌产生贡献的概率。那么</p>
<p>$$f[i, j] = [j &lt;= i - 1] \times f[i - 1, j] \times (1 - p[i])^{r - j} + [j &gt; 0] \times f[i - 1, j - 1] \times (1 - (1 - p[i])^{r - j + 1})$$</p>
<p>$$g[i] = \sum\limits_{j = 0}^{min(i - 1, r)}f[i - 1, j] \times (1 - (1 - p[i])^{r - j})$$</p>
<p>最终 $ans = \sum\limits_{i = 1}^n g[i] \times d[i]$</p>
<p>最终答案就是 $f[1, 0]$</p>
<h2 id="套路5-整数概率公式"><a href="#套路5-整数概率公式" class="headerlink" title="套路5. 整数概率公式"></a><strong>套路5. 整数概率公式</strong></h2><hr>
<p>这部分是真的没怎么练过。。</p>
<p>反正要知道公式：对于随机变量 $k &gt;= 0$, $E(k) = \sum\limits_{i = 0}^{\infty} P(k \ge i)$</p>
<h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="$随机数生成器$"></a><a href="https://www.luogu.com.cn/problem/P3600" target="_blank" rel="noopener">$随机数生成器$</a></h3><p>根据上面那个公式，我们就是要计算出 $P(ans \ge i)$。发现 $\ge$ 不好求，$\leq$ 挺好求，因为每个区间里至少有一个 $\leq i$ 的就算满足条件了，所以考虑将 $P(ans \ge i)$ 转化为 $1 - P(ans &lt; i)$。</p>
<p>我们发现两个区间是包含关系的话，大的区间对答案没有贡献，于是操作一波使得区间们的左右端点不减。考虑某个位置的数，如果它 $\leq i - 1$ 就能对覆盖自己的区间产生贡献，而且覆盖自己的区间编号连续。考虑将点和区间互换，问题等价于每个点能覆盖一些区间，且覆盖的概率为 $p = \frac{i - 1}{x}$，用一些点去覆盖所有区间的概率。</p>
<p>容易想到 dp，设 $l[i]$ 表示点 i 覆盖的最左边的区间，$r[i]$ 是最右边的，$f[i]$ 表示强制选第 i 个点，然后覆盖了 $1$ ~ $r[i]$ 所有区间的概率，那么</p>
<p>$$f[i] = p \times (\sum\limits_{r[j] \ge l[i] - 1} f[j] \times (1 - p)^{i - 1 - j} + <a href="1 - p">l[i] = 1</a>^{i - 1})$$</p>
<p>最终答案就是 $\sum\limits_{r[i] = Q}f[i] \times (1 - p)^{n - i}$</p>
<p>直接做是 $n^3$ 的，前缀和维护一下就好了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, x, y) for (int i = x; i &lt;= y; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">666623333</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, Q, top, L, R;</span><br><span class="line"><span class="keyword">int</span> stk[N], l[N], r[N];</span><br><span class="line">ll f[N], ans, pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l, r; &#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l == b.l ? a.r &gt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, cmp);</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; q[stk[top]].r &gt;= q[i].r) --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = top;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) q[i] = q[stk[i]];</span><br><span class="line">    L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; Q &amp;&amp; q[R + <span class="number">1</span>].l &lt;= i) ++R;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R &amp;&amp; q[L].r &lt; i) ++L;</span><br><span class="line">        l[i] = L, r[i] = R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; Q;</span><br><span class="line">    rep(i, <span class="number">1</span>, Q) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    prework();</span><br><span class="line">    rep(i, <span class="number">1</span>, x) &#123;</span><br><span class="line">        ll sum = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">        ll p = (i - <span class="number">1</span>) * qpow(x, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        ll pp = mod + <span class="number">1</span> - p;</span><br><span class="line">        ll invp = qpow(pp, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lst &lt; j &amp;&amp; r[lst] &lt; l[j] - <span class="number">1</span>)</span><br><span class="line">                tot = (tot - f[lst] * qpow(invp, lst) % mod + mod) % mod, ++lst;</span><br><span class="line">            f[j] = p * tot % mod * qpow(pp, j - <span class="number">1</span>) % mod;</span><br><span class="line">            tot = (tot + f[j] * qpow(invp, j) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &amp;&amp; r[j] == Q; --j) sum = (sum + f[j] * qpow(pp, n - j) % mod) % mod;</span><br><span class="line">        ans = (ans + <span class="number">1</span> - sum + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/概率与期望/" rel="tag"># 概率与期望</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/11/[SHOI2016]-成绩比较/" rel="next" title="[SHOI2016]-成绩比较">
                <i class="fa fa-chevron-left"></i> [SHOI2016]-成绩比较
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/11/AGC 047 题解/" rel="prev" title="AGC 047 题解">
                AGC 047 题解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="imily" />
          <p class="site-author-name" itemprop="name">imily</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">312</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">110</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#套路1-直接递推-dp"><span class="nav-number">1.</span> <span class="nav-text">套路1. 直接递推/dp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NOI2005-聪聪与可可"><span class="nav-number">1.1.</span> <span class="nav-text">$[NOI2005]-聪聪与可可$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCOI2008-奖励关"><span class="nav-number">1.2.</span> <span class="nav-text">$[SCOI2008]-奖励关$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清华集训2017-小-Y-和恐怖的奴隶主"><span class="nav-number">1.3.</span> <span class="nav-text">$[清华集训2017]-小 Y 和恐怖的奴隶主$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套路2-无限循环转递推"><span class="nav-number">2.</span> <span class="nav-text">套路2. 无限循环转递推</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SHOI2002-百事世界杯之旅"><span class="nav-number">2.1.</span> <span class="nav-text">$[SHOI2002]-百事世界杯之旅$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六省联考2017-分手是祝愿"><span class="nav-number">2.2.</span> <span class="nav-text">$[六省联考2017]-分手是祝愿$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UVA10529-Dumb-Bones"><span class="nav-number">2.3.</span> <span class="nav-text">$[UVA10529]-Dumb Bones$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF908D-New-Year-and-Arbitrary-Arrangement"><span class="nav-number">2.4.</span> <span class="nav-text">$[CF908D]-New Year and Arbitrary Arrangement$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#「PKUWC2018」猎人杀"><span class="nav-number">2.5.</span> <span class="nav-text">$「PKUWC2018」猎人杀$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套路3-高斯消元"><span class="nav-number">3.</span> <span class="nav-text">套路3. 高斯消元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#USACO10HOL-Driving-Out-the-Piggies-G"><span class="nav-number">3.1.</span> <span class="nav-text">$[USACO10HOL]-Driving Out the Piggies G$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HNOI2013-游走"><span class="nav-number">3.2.</span> <span class="nav-text">$[HNOI2013]-游走$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HNOI2011-XOR和路径"><span class="nav-number">3.3.</span> <span class="nav-text">$[HNOI2011]-XOR和路径$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套路4-分开考虑贡献"><span class="nav-number">4.</span> <span class="nav-text">套路4. 分开考虑贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#仓鼠找sugar-II"><span class="nav-number">4.1.</span> <span class="nav-text">$仓鼠找sugar II$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小魔女帕琪"><span class="nav-number">4.2.</span> <span class="nav-text">$小魔女帕琪$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HNOI2015-亚瑟王"><span class="nav-number">4.3.</span> <span class="nav-text">$[HNOI2015]-亚瑟王$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套路5-整数概率公式"><span class="nav-number">5.</span> <span class="nav-text">套路5. 整数概率公式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机数生成器"><span class="nav-number">5.1.</span> <span class="nav-text">$随机数生成器$</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">imily</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

</body>
</html>
